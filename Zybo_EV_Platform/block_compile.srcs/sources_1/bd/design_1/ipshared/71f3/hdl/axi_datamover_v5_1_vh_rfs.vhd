  -------------------------------------------------------------------------------
  -- axi_datamover_reset.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_reset.vhd
  --
  -- Description:     
  --   This file implements the DataMover Reset module.               
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library lib_cdc_v1_0_2;  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_reset is
    generic (
      
      C_STSCMD_IS_ASYNC    : Integer range  0 to  1 :=  0
        -- 0 = Use Synchronous Command/Statys User Interface
        -- 1 = Use Asynchronous Command/Statys User Interface
      );
    port (
      
      -- Primary Clock and Reset Inputs -----------------
                                                       --
      primary_aclk         : in  std_logic;            --
      primary_aresetn      : in  std_logic;            --
      ---------------------------------------------------
      
                                                       
      -- Async operation clock and reset from User ------
      -- Used for Command/Status User interface        --
      -- synchronization when C_STSCMD_IS_ASYNC = 1    --
                                                       --
      secondary_awclk      : in  std_logic;            --
      secondary_aresetn    : in  std_logic;            --
      ---------------------------------------------------
  
                                           
     
      -- Halt request input control -------------------------------
      halt_req             : in  std_logic;                      --
         -- Active high soft shutdown request (can be a pulse)   --
                                                                 --
      -- Halt Complete status flag                               --
      halt_cmplt           : Out std_logic;                      --
         -- Active high soft shutdown complete status            --
      -------------------------------------------------------------
      
       
                                                 
      -- Soft Shutdown internal interface ------------------------------------------------
                                                                                        --
      flush_stop_request   : Out std_logic;                                             --
         -- Active high soft stop request to modules                                    --
                                                                                        --
      data_cntlr_stopped   : in  std_logic;                                             --
         -- Active high flag indicating the data controller is flushed and stopped      --
                                                                                        --
      addr_cntlr_stopped   : in  std_logic;                                             --
         -- Active high flag indicating the address controller is flushed and stopped   --
                                                                                        --
      aux1_stopped         : in  std_logic;                                             --
         -- Active high flag flush complete for auxillary 1 module                      --
         -- Tie high if unused                                                          --
                                                                                        --
      aux2_stopped         : in  std_logic;                                             --
         -- Active high flag flush complete for auxillary 2 module                      --
         -- Tie high if unused                                                          --
      ------------------------------------------------------------------------------------
      
       
          
      -- HW Reset outputs to reset groups  -------------------------------------     
                                                                              --
      cmd_stat_rst_user    : Out std_logic;                                   --
         -- The reset to the Command/Status Module User interface side        --
                                                                              --
      cmd_stat_rst_int     : Out std_logic;                                   --
         -- The reset to the Command/Status Module internal interface side    --
                                                                              --
      mmap_rst             : Out std_logic;                                   --
         -- The reset to the Memory Map interface side                        --
                                                                              --
      stream_rst           : Out std_logic                                    --
         -- The reset to the Stream interface side                            --
      --------------------------------------------------------------------------
      
      );
  
  end entity axi_datamover_reset;
  
  
  architecture implementation of axi_datamover_reset is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

    constant MTBF_STAGES : integer := 4;
  
      --  ATTRIBUTE async_reg                      : STRING;
    -- Signals
    
    signal sig_cmd_stat_rst_user_n     : std_logic := '0';
    signal sig_cmd_stat_rst_user_reg_n_cdc_from : std_logic := '0';
    signal sig_cmd_stat_rst_int_reg_n  : std_logic := '0';
    signal sig_mmap_rst_reg_n          : std_logic := '0';
    signal sig_stream_rst_reg_n        : std_logic := '0';
    signal sig_syncd_sec_rst           : std_logic := '0';
    
    -- soft shutdown support
    signal sig_internal_reset          : std_logic := '0';
    signal sig_s_h_halt_reg            : std_logic := '0';
    signal sig_halt_cmplt              : std_logic := '0';
                               
    -- additional CDC synchronization signals
    signal sig_sec_neg_edge_plus_delay : std_logic := '0';
    signal sig_secondary_aresetn_reg   : std_logic := '0';
    signal sig_prim2sec_rst_reg1_n_cdc_to     : std_logic := '0';
    signal sig_prim2sec_rst_reg2_n     : std_logic := '0';
    
--  ATTRIBUTE async_reg OF sig_prim2sec_rst_reg1_n_cdc_to  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF sig_prim2sec_rst_reg2_n  : SIGNAL IS "true";
                               
                               
  begin --(architecture implementation)
  
  
    -- Assign outputs
   
    cmd_stat_rst_user <=   not(sig_cmd_stat_rst_user_n);
    
    cmd_stat_rst_int  <=   not(sig_cmd_stat_rst_int_reg_n) or
                           sig_syncd_sec_rst;
    
    mmap_rst          <=   not(sig_mmap_rst_reg_n) or
                           sig_syncd_sec_rst;
    
    stream_rst        <=   not(sig_stream_rst_reg_n) or
                           sig_syncd_sec_rst;
    
    
    
    
    
    
    
    -- Internal logic Implmentation
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_SYNC_CMDSTAT_RESET
    --
    -- If Generate Description:
    --  This IfGen assigns the reset for the 
    -- Synchronous Command/Status User interface case
    --
    ------------------------------------------------------------
    GEN_SYNC_CMDSTAT_RESET : if (C_STSCMD_IS_ASYNC = 0) generate
       
       begin
    
          sig_syncd_sec_rst       <= '0';
          
          sig_cmd_stat_rst_user_n <=  not(sig_cmd_stat_rst_user_reg_n_cdc_from);
                    
       end generate GEN_SYNC_CMDSTAT_RESET;
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ASYNC_CMDSTAT_RESET
    --
    -- If Generate Description:
    --  This IfGen assigns the reset for the 
    -- Asynchronous Command/Status User interface case
    --
    ------------------------------------------------------------
    GEN_ASYNC_CMDSTAT_RESET : if (C_STSCMD_IS_ASYNC = 1) generate
     --   ATTRIBUTE async_reg                      : STRING;
 
      signal sig_sec_reset_in_reg_n      : std_logic := '0';
      signal sig_secondary_aresetn_reg_tmp : std_logic := '0';
      
      -- Secondary reset pulse stretcher
      signal sig_secondary_dly1          : std_logic := '0';
      signal sig_secondary_dly2          : std_logic := '0';
      signal sig_neg_edge_detect         : std_logic := '0';
      signal sig_sec2prim_reset          : std_logic := '0';
      signal sig_sec2prim_reset_reg_cdc_tig      : std_logic := '0';
      signal sig_sec2prim_reset_reg2     : std_logic := '0';
      signal sig_sec2prim_rst_syncro1_cdc_tig    : std_logic := '0';
      signal sig_sec2prim_rst_syncro2    : std_logic := '0';
--  ATTRIBUTE async_reg OF sig_sec2prim_reset_reg_cdc_tig  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF sig_sec2prim_reset_reg2  : SIGNAL IS "true";
      
--  ATTRIBUTE async_reg OF sig_sec2prim_rst_syncro1_cdc_tig  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF sig_sec2prim_rst_syncro2  : SIGNAL IS "true";
                                 
      begin
         
        -- Generate the reset in the primary clock domain. Use the longer
        -- of the pulse stretched reset or the actual reset.
        sig_syncd_sec_rst <= sig_sec2prim_reset_reg2 or
                             sig_sec2prim_rst_syncro2;
  
        
        -- Check for falling edge of secondary_aresetn input
        sig_neg_edge_detect <=  '1'
          when (sig_sec_reset_in_reg_n = '1' and 
                secondary_aresetn      = '0')
          else '0';
          

        
         
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_PUSE_STRETCH_FLOPS
        --
        -- Process Description:
        -- This process implements a 3 clock wide pulse whenever the 
        -- secondary reset is asserted
        --
        -------------------------------------------------------------
        IMP_PUSE_STRETCH_FLOPS : process (secondary_awclk)
          begin
            if (secondary_awclk'event and secondary_awclk = '1') then
            
              If (sig_secondary_dly2 = '1') Then
                
                sig_secondary_dly1 <= '0' ;
                sig_secondary_dly2 <= '0' ;
            
              Elsif (sig_neg_edge_detect = '1') Then
                
                sig_secondary_dly1 <= '1';
            
              else

                sig_secondary_dly2 <= sig_secondary_dly1 ;
              
              End if;
            
            
            
            
            end if;       
          end process IMP_PUSE_STRETCH_FLOPS; 
        
        
        
   --  CDC add     
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: SYNC_NEG_EDGE
        --
        -- Process Description:
        --  First (source clock) stage synchronizer for CDC of 
        -- negative edge detection,
        --
        -------------------------------------------------------------
        SYNC_NEG_EDGE : process (secondary_awclk)
          begin
            if (secondary_awclk'event and secondary_awclk = '1') then
            
              sig_sec_neg_edge_plus_delay <= sig_neg_edge_detect or
                                             sig_secondary_dly1  or
                                             sig_secondary_dly2;
            
            end if;       
          end process SYNC_NEG_EDGE; 
        
  --      
         
         
         
          
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: SEC2PRIM_RST_SYNCRO
        --
        -- Process Description:
        --    This process registers the secondary reset input to 
        -- the primary clock domain.
        --
        -------------------------------------------------------------
SEC2PRIM_RST_SYNCRO : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => sig_sec_neg_edge_plus_delay,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => primary_aclk,
        scndry_resetn              => '0',
        scndry_out                 => sig_sec2prim_reset_reg2,
        scndry_vect_out            => open
    );


--        SEC2PRIM_RST_SYNCRO : process (primary_aclk)
--           begin
--             if (primary_aclk'event and primary_aclk = '1') then
--             
--               
--               sig_sec2prim_reset_reg_cdc_tig   <=  sig_sec_neg_edge_plus_delay ;
--               
--               sig_sec2prim_reset_reg2  <=  sig_sec2prim_reset_reg_cdc_tig;
--                            
--             end if;       
--           end process SEC2PRIM_RST_SYNCRO; 
        
       
       
 
 
 
 
 
 
   --  CDC add     
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: REG_SEC_RST
        --
        -- Process Description:
        --  First (source clock) stage synchronizer for CDC of 
        -- secondary reset input,
        --
        -------------------------------------------------------------
        REG_SEC_RST : process (secondary_awclk)
          begin
            if (secondary_awclk'event and secondary_awclk = '1') then
            
              sig_secondary_aresetn_reg <= secondary_aresetn;
            
            end if;       
          end process REG_SEC_RST; 
        
  --      
         
         
         
         
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: SEC2PRIM_RST_SYNCRO_2
        --
        -- Process Description:
        --    Second stage (destination) synchronizers for the secondary
        -- reset CDC to the primary clock.
        --
        -------------------------------------------------------------

         sig_secondary_aresetn_reg_tmp <= not(sig_secondary_aresetn_reg);

SEC2PRIM_RST_SYNCRO_2 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => sig_secondary_aresetn_reg_tmp,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => primary_aclk,
        scndry_resetn              => '0',
        scndry_out                 => sig_sec2prim_rst_syncro2,
        scndry_vect_out            => open
    );


--        SEC2PRIM_RST_SYNCRO_2 : process (primary_aclk)
--           begin
--             if (primary_aclk'event and primary_aclk = '1') then
--             
--               
--      -- CDC   sig_sec2prim_rst_syncro1_cdc_tig  <= not(secondary_aresetn);
--               sig_sec2prim_rst_syncro1_cdc_tig  <= not(sig_secondary_aresetn_reg);
--               sig_sec2prim_rst_syncro2  <= sig_sec2prim_rst_syncro1_cdc_tig;
-- 
-- 
--             end if;       
--           end process SEC2PRIM_RST_SYNCRO_2; 
        
       
         
         
         -- Generate the Command and Status side reset
         sig_cmd_stat_rst_user_n <= sig_sec_reset_in_reg_n and
                                    sig_prim2sec_rst_reg2_n;
    -- CDC                          sig_cmd_stat_rst_user_reg_n_cdc_from;
   
   
    
    
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_RESET_ASYNC
         --
         -- Process Description:
         --    This process registers the secondary reset input to 
         -- generate the Command/Status User interface reset.
         --
         -------------------------------------------------------------
         REG_RESET_ASYNC : process (secondary_awclk)
            begin
              if (secondary_awclk'event and secondary_awclk = '1') then
              
                 sig_sec_reset_in_reg_n <= secondary_aresetn;
              
              end if;       
            end process REG_RESET_ASYNC; 
         
   
   
   
   
   --  CDC add     
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: SYNC_PRIM2SEC_RST
        --
        -- Process Description:
        --  Second (destination clock) stage synchronizers for CDC of 
        -- primary reset input,
        --
        -------------------------------------------------------------

SYNC_PRIM2SEC_RST : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => sig_cmd_stat_rst_user_reg_n_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => secondary_awclk,
        scndry_resetn              => '0',
        scndry_out                 => sig_prim2sec_rst_reg2_n,
        scndry_vect_out            => open
    );


--        SYNC_PRIM2SEC_RST : process (secondary_awclk)
--          begin
--            if (secondary_awclk'event and secondary_awclk = '1') then
--            
--              sig_prim2sec_rst_reg1_n_cdc_to <= sig_cmd_stat_rst_user_reg_n_cdc_from;
--              sig_prim2sec_rst_reg2_n <= sig_prim2sec_rst_reg1_n_cdc_to;
--            
--            end if;       
--          end process SYNC_PRIM2SEC_RST; 
        
  --      
         
         
        
        
      end generate GEN_ASYNC_CMDSTAT_RESET;
 
 
 
  
  
  
  
  
  
  
  
 
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_CMDSTAT_PRIM_RESET
    --
    -- Process Description:
    --    This process registers the primary reset input to 
    -- generate the Command/Status User interface reset.
    --
    -------------------------------------------------------------
    REG_CMDSTAT_PRIM_RESET : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
         
            sig_cmd_stat_rst_user_reg_n_cdc_from <= primary_aresetn;
         
         end if;       
       end process REG_CMDSTAT_PRIM_RESET; 
    
   
   
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_CMDSTAT_INT_RESET
    --
    -- Process Description:
    --    This process registers the primary reset input to 
    -- generate the Command/Status internal interface reset.
    --
    -------------------------------------------------------------
    REG_CMDSTAT_INT_RESET : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
         
            sig_cmd_stat_rst_int_reg_n <= primary_aresetn;
         
         end if;       
       end process REG_CMDSTAT_INT_RESET; 
    
   
   
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_MMAP_RESET
    --
    -- Process Description:
    --    This process registers the primary reset input to 
    -- generate the Memory Map interface reset.
    --
    -------------------------------------------------------------
    REG_MMAP_RESET : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
         
            sig_mmap_rst_reg_n <= primary_aresetn;
         
         end if;       
       end process REG_MMAP_RESET; 
    
   
   
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_STREAM_RESET
    --
    -- Process Description:
    --    This process registers the primary reset input to 
    -- generate the Stream interface reset.
    --
    -------------------------------------------------------------
    REG_STREAM_RESET : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
         
            sig_stream_rst_reg_n <= primary_aresetn;
         
         end if;       
       end process REG_STREAM_RESET; 
    
  
  
  
  
  
  
  
  
  -- Soft Shutdown logic ------------------------------------------------------
  
    
    
    sig_internal_reset  <= not(sig_cmd_stat_rst_int_reg_n) or
                           sig_syncd_sec_rst;
    
    
    flush_stop_request  <= sig_s_h_halt_reg;
    
    
    halt_cmplt          <= sig_halt_cmplt;
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_HALT_REQ
    --
    -- Process Description:
    --  Implements a sample and hold flop for the halt request 
    -- input. Can only be cleared on a HW reset.
    --
    -------------------------------------------------------------
    REG_HALT_REQ : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_internal_reset = '1') then
              
              sig_s_h_halt_reg <= '0';
            
            elsif (halt_req = '1') then
              
              sig_s_h_halt_reg <= '1';
            
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process REG_HALT_REQ; 
     
     
  
  
  
  
  
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_CMPLT
    --
    -- Process Description:
    --  Implements a the flop for the halt complete status 
    -- output. Can only be cleared on a HW reset.
    --
    -------------------------------------------------------------
    IMP_HALT_CMPLT : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_internal_reset = '1') then
              
              sig_halt_cmplt <= '0';
            
            elsif (data_cntlr_stopped = '1' and
                   addr_cntlr_stopped = '1' and
                   aux1_stopped       = '1' and
                   aux2_stopped       = '1') then
              
              sig_halt_cmplt <= '1';
            
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process IMP_HALT_CMPLT; 
     
     
  
          
          
  
    
  end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_afifo_autord.vhd - entity/architecture pair

-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_afifo_autord.vhd
-- Version:         initial
-- Description:     
--    This file contains the logic to generate a CoreGen call to create a
-- asynchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs. 
-- 
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library lib_fifo_v1_0_10;
use lib_fifo_v1_0_10.async_fifo_fg;

-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------

entity axi_datamover_afifo_autord is
  generic (
     C_DWIDTH        : integer := 32;
       -- Sets the width of the FIFO Data
       
     C_DEPTH         : integer := 16;
       -- Sets the depth of the FIFO
       
     C_CNT_WIDTH     : Integer := 5;
       -- Sets the width of the FIFO Data Count output
       
     C_USE_BLKMEM    : Integer := 1 ;
       -- Sets the type of memory to use for the FIFO
       -- 0 = Distributed Logic
       -- 1 = Block Ram
       
     C_FAMILY        : String  := "virtex7"
       -- Specifies the target FPGA Family
       
    );
  port (
    -- FIFO Inputs --------------------------------------------------------------
     AFIFO_Ainit                : In  std_logic;                               --
     AFIFO_Ainit_Rd_clk         : In  std_logic;                               --
     AFIFO_Wr_clk               : In  std_logic;                               --
     AFIFO_Wr_en                : In  std_logic;                               --
     AFIFO_Din                  : In  std_logic_vector(C_DWIDTH-1 downto 0);   --
     AFIFO_Rd_clk               : In  std_logic;                               --
     AFIFO_Rd_en                : In  std_logic;                               --
     AFIFO_Clr_Rd_Data_Valid    : In  std_logic;                               --
     ----------------------------------------------------------------------------
     
    -- FIFO Outputs --------------------------------------------------------------
     AFIFO_DValid               : Out std_logic;                                --
     AFIFO_Dout                 : Out std_logic_vector(C_DWIDTH-1 downto 0);    --
     AFIFO_Full                 : Out std_logic;                                --
     AFIFO_Empty                : Out std_logic;                                --
     AFIFO_Almost_full          : Out std_logic;                                --
     AFIFO_Almost_empty         : Out std_logic;                                --
     AFIFO_Wr_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Rd_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Corr_Rd_count        : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Corr_Rd_count_minus1 : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Rd_ack               : Out std_logic                                 --
     -----------------------------------------------------------------------------
     
    );
end entity axi_datamover_afifo_autord;

 
-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_datamover_afifo_autord is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";

   constant MTBF_STAGES : integer := 4;
   constant C_FIFO_MTBF : integer := 4;
-- Constant declarations
  -- none 
  ATTRIBUTE async_reg                      : STRING;
-- Signal declarations
   signal write_data_lil_end       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end        : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');

   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal rd_count_int             : natural   :=  0;
   signal rd_count_int_corr        : natural   :=  0;
   signal rd_count_int_corr_minus1 : natural   :=  0;
   Signal corrected_empty          : std_logic := '0';
   Signal corrected_almost_empty   : std_logic := '0';
   Signal sig_afifo_empty          : std_logic := '0';
   Signal sig_afifo_almost_empty   : std_logic := '0';
  
 -- backend fifo read ack sample and hold
   Signal sig_rddata_valid         : std_logic := '0';
   Signal hold_ff_q                : std_logic := '0';
   Signal ored_ack_ff_reset        : std_logic := '0';
   Signal autoread                 : std_logic := '0';
   Signal sig_wrfifo_rdack         : std_logic := '0';
   Signal fifo_read_enable         : std_logic := '0';

   signal AFIFO_Ainit_d2_cdc_tig : std_logic;
   signal AFIFO_Ainit_d2 : std_logic;
--     ATTRIBUTE async_reg OF AFIFO_Ainit_d2_cdc_tig  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF AFIFO_Ainit_d2  : SIGNAL IS "true";
   
 
-----------------------------------------------------------------------------
-- Begin architecture
-----------------------------------------------------------------------------
begin  

 -- Bit ordering translations
       
    write_data_lil_end   <=  AFIFO_Din;  -- translate from Big Endian to little
                                         -- endian.
    AFIFO_Rd_ack         <= sig_wrfifo_rdack; 
       
    AFIFO_Dout           <= read_data_lil_end;  -- translate from Little Endian to 
                                                -- Big endian.                            
 
    AFIFO_Almost_empty   <= corrected_almost_empty;
 
    AFIFO_Empty          <= sig_afifo_empty; --corrected_empty;
 
    AFIFO_Wr_count       <= wr_count_lil_end;   
   
    AFIFO_Rd_count       <= rd_count_lil_end;                       
   
    AFIFO_Corr_Rd_count  <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr, 
                                                  C_CNT_WIDTH+1);                       
   
    AFIFO_Corr_Rd_count_minus1 <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr_minus1, 
                                                        C_CNT_WIDTH+1);                                          
                                                                        
    AFIFO_DValid         <= sig_wrfifo_rdack; --sig_rddata_valid; -- Output data valid indicator
   
   
    fifo_read_enable     <= AFIFO_Rd_en; -- or autoread;
       

                     
   -------------------------------------------------------------------------------
   -- Instantiate the CoreGen FIFO
   --
   -- NOTE:
   -- This instance refers to a wrapper file that interm will use the 
   -- CoreGen FIFO Generator Async FIFO utility.
   --
   -------------------------------------------------------------------------------
    I_ASYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_10.async_fifo_fg 
       generic map (
          C_ALLOW_2N_DEPTH      =>  1 , 
          C_FAMILY              =>  C_FAMILY,
          C_DATA_WIDTH          =>  C_DWIDTH, 
          C_ENABLE_RLOCS        =>  0, 
          C_FIFO_DEPTH          =>  C_DEPTH, 
          C_HAS_ALMOST_EMPTY    =>  1, 
          C_HAS_ALMOST_FULL     =>  1, 
          C_HAS_RD_ACK          =>  1, 
          C_HAS_RD_COUNT        =>  1, 
          C_HAS_RD_ERR          =>  0, 
          C_HAS_WR_ACK          =>  0, 
          C_HAS_WR_COUNT        =>  1, 
          C_EN_SAFETY_CKT       =>  1, 
          C_HAS_WR_ERR          =>  0, 
          C_RD_ACK_LOW          =>  0, 
          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH, 
          C_RD_ERR_LOW          =>  0, 
          C_USE_BLOCKMEM        =>  C_USE_BLKMEM, 
          C_WR_ACK_LOW          =>  0, 
          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH, 
          C_WR_ERR_LOW          =>  0,
          C_SYNCHRONIZER_STAGE  =>  C_FIFO_MTBF,
          C_USE_EMBEDDED_REG    =>  0, -- 0 ;
          C_PRELOAD_REGS        =>  1, -- 0 ;
          C_PRELOAD_LATENCY     =>  0,  -- 1 ;
          C_XPM_FIFO            =>  1
         )
      port Map (
         Din                 =>  write_data_lil_end,     
         Wr_en               =>  AFIFO_Wr_en,            
         Wr_clk              =>  AFIFO_Wr_clk,           
         Rd_en               =>  fifo_read_enable,       
         Rd_clk              =>  AFIFO_Rd_clk,           
         Ainit               =>  AFIFO_Ainit,            
         Dout                =>  read_data_lil_end,      
         Full                =>  AFIFO_Full,             
         Empty               =>  sig_afifo_empty,        
         Almost_full         =>  AFIFO_Almost_full,      
         Almost_empty        =>  sig_afifo_almost_empty, 
         Wr_count            =>  wr_count_lil_end,       
         Rd_count            =>  rd_count_lil_end,       
         Rd_ack              =>  sig_wrfifo_rdack,       
         Rd_err              =>  open,                   
         Wr_ack              =>  open,                   
         Wr_err              =>  open                    
        );                


   ----------------------------------------------------------------------------                              
   -- Read Ack assert & hold logic (needed because:
   --     1) The Async FIFO has to be read once to get valid
   --        data to the read data port (data is discarded). 
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been read. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.
      
    
--    ored_ack_ff_reset  <=  fifo_read_enable or 
--                           AFIFO_Ainit_Rd_clk or
--                           AFIFO_Clr_Rd_Data_Valid;
--    
--    sig_rddata_valid   <=  hold_ff_q or 
--                           sig_wrfifo_rdack;
-- 
 
   
     ored_ack_ff_reset <= '1'                     
      when (fifo_read_enable = '1' or  
            AFIFO_Ainit_Rd_clk = '1' or  
            AFIFO_Clr_Rd_Data_Valid = '1')      
      Else '0';
      
    sig_rddata_valid <= '1'                     
      when (hold_ff_q = '1' or  
            sig_wrfifo_rdack = '1')      
      Else '0';
      
           
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
--IMP_SYNC_FLOP : entity  proc_common_v4_0_2.cdc_sync
--    generic map (
--        C_CDC_TYPE                 => 1,
--        C_RESET_STATE              => 0,
--        C_SINGLE_BIT               => 1,
--        C_VECTOR_WIDTH             => 32,
--        C_MTBF_STAGES              => MTBF_STAGES
--    )
--    port map (
--        prmry_aclk                 => '0',
--        prmry_resetn               => '0',
--        prmry_in                   => AFIFO_Ainit,
--        prmry_vect_in              => (others => '0'),

--        scndry_aclk                => AFIFO_Rd_clk,
--        scndry_resetn              => '0',
--        scndry_out                 => AFIFO_Ainit_d2,
--        scndry_vect_out            => open
--    );



--    IMP_SYNC_FLOP : process (AFIFO_Rd_clk)
--       begin
--         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
--            AFIFO_Ainit_d2_cdc_tig <= AFIFO_Ainit; 
--            AFIFO_Ainit_d2 <= AFIFO_Ainit_d2_cdc_tig; 
--         end if;       
--       end process IMP_SYNC_FLOP; 

    IMP_ACK_HOLD_FLOP : process (AFIFO_Rd_clk)
       begin
         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if; 
         end if;       
       end process IMP_ACK_HOLD_FLOP; 
    
    
    
  -- generate auto-read enable. This keeps fresh data at the output
  -- of the FIFO whenever it is available.
    autoread <= '1'                     -- create a read strobe when the 
      when (sig_rddata_valid = '0' and  -- output data is NOT valid
            sig_afifo_empty = '0')      -- and the FIFO is not empty
      Else '0';
      
    
    rd_count_int <=  CONV_INTEGER(rd_count_lil_end);
    
    
    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CORRECT_RD_CNT
    --
    -- Process Description:
    --  This process corrects the FIFO Read Count output for the
    -- auto read function.
    --
    -------------------------------------------------------------
    CORRECT_RD_CNT : process (sig_rddata_valid,
                              sig_afifo_empty ,
                              sig_afifo_almost_empty,
                              rd_count_int)
       begin
    
          if (sig_rddata_valid = '0') then

             rd_count_int_corr        <= 0;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '1';
             corrected_almost_empty   <= '0';
             
          elsif (sig_afifo_empty = '1') then         -- rddata valid and fifo empty
             
             rd_count_int_corr        <= 1;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '1';
          
          Elsif (sig_afifo_almost_empty = '1') Then  -- rddata valid and fifo almost empty
             
             rd_count_int_corr        <= 2;
             rd_count_int_corr_minus1 <= 1;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';
          
          else                                       -- rddata valid and modify rd count from FIFO 
             
             rd_count_int_corr        <= rd_count_int+1;
             rd_count_int_corr_minus1 <= rd_count_int;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';
          
          end if;
    
       end process CORRECT_RD_CNT; 
    


end imp;


-------------------------------------------------------------------------------
-- axi_datamover_sfifo_autord.vhd - entity/architecture pair

-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_sfifo_autord.vhd
-- Version:         initial
-- Description:     
--    This file contains the logic to generate a CoreGen call to create a
-- synchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs. 
-- 
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library lib_fifo_v1_0_10;
use lib_fifo_v1_0_10.sync_fifo_fg;


-------------------------------------------------------------------------------

entity axi_datamover_sfifo_autord is
  generic (
     C_DWIDTH                : integer := 32;
       -- Sets the width of the FIFO Data
       
     C_DEPTH                 : integer := 128;
       -- Sets the depth of the FIFO
       
     C_DATA_CNT_WIDTH        : integer := 8;
       -- Sets the width of the FIFO Data Count output
       
     C_NEED_ALMOST_EMPTY     : Integer range 0 to 1 := 0;
       -- Indicates the need for an almost empty flag from the internal FIFO
     
     C_NEED_ALMOST_FULL      : Integer range 0 to 1 := 0;
       -- Indicates the need for an almost full flag from the internal FIFO
     
     C_USE_BLKMEM            : Integer range 0 to 1 := 1;
       -- Sets the type of memory to use for the FIFO
       -- 0 = Distributed Logic
       -- 1 = Block Ram
       
     C_FAMILY                : String  := "virtex7"
       -- Specifies the target FPGA Family
       
    );
  port (
    
    -- FIFO Inputs ------------------------------------------------------------------
     SFIFO_Sinit             : In  std_logic;                                      --
     SFIFO_Clk               : In  std_logic;                                      --
     SFIFO_Wr_en             : In  std_logic;                                      --
     SFIFO_Din               : In  std_logic_vector(C_DWIDTH-1 downto 0);          --
     SFIFO_Rd_en             : In  std_logic;                                      --
     SFIFO_Clr_Rd_Data_Valid : In  std_logic;                                      --
     --------------------------------------------------------------------------------
     
    -- FIFO Outputs -----------------------------------------------------------------
     SFIFO_DValid            : Out std_logic;                                      --
     SFIFO_Dout              : Out std_logic_vector(C_DWIDTH-1 downto 0);          --
     SFIFO_Full              : Out std_logic;                                      --
     SFIFO_Empty             : Out std_logic;                                      --
     SFIFO_Almost_full       : Out std_logic;                                      --
     SFIFO_Almost_empty      : Out std_logic;                                      --
     SFIFO_Rd_count          : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Rd_count_minus1   : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Wr_count          : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Rd_ack            : Out std_logic                                       --
     --------------------------------------------------------------------------------
     
    );
end entity axi_datamover_sfifo_autord;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_datamover_sfifo_autord is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";


-- Constant declarations

   -- none
 
-- Signal declarations

   signal write_data_lil_end         : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end          : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal raw_data_cnt_lil_end       : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   signal raw_data_count_int         : natural := 0;
   signal raw_data_count_corr        : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   signal raw_data_count_corr_minus1 : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   Signal corrected_empty            : std_logic := '0';
   Signal corrected_almost_empty     : std_logic := '0';
   Signal sig_SFIFO_empty            : std_logic := '0';
  
   -- backend fifo read ack sample and hold
   Signal sig_rddata_valid           : std_logic := '0';
   Signal hold_ff_q                  : std_logic := '0';
   Signal ored_ack_ff_reset          : std_logic := '0';
   Signal autoread                   : std_logic := '0';
   Signal sig_sfifo_rdack            : std_logic := '0';
   Signal fifo_read_enable           : std_logic := '0';
   

 
begin  

 -- Bit ordering translations
       
    write_data_lil_end    <=  SFIFO_Din;  -- translate from Big Endian to little
                                          -- endian.
       
    SFIFO_Dout            <= read_data_lil_end;  -- translate from Little Endian to 
                                                 -- Big endian.                            
 
 
 -- Other port usages and assignments
    SFIFO_Rd_ack          <= sig_sfifo_rdack; 
 
    SFIFO_Almost_empty    <= corrected_almost_empty;
 
    SFIFO_Empty           <= sig_SFIFO_empty; --corrected_empty;
 
    SFIFO_Wr_count        <= raw_data_cnt_lil_end;   
                                                    
    
    SFIFO_Rd_count        <= raw_data_count_corr;    
                                                                    
   
    SFIFO_Rd_count_minus1 <= raw_data_count_corr_minus1;    
        
        
        
    SFIFO_DValid          <= sig_rddata_valid; -- Output data valid indicator
   
NON_BLK_MEM : if (C_USE_BLKMEM = 0)
  generate   
    fifo_read_enable      <= SFIFO_Rd_en or autoread;
       
    ------------------------------------------------------------
    -- Instance: I_SYNC_FIFOGEN_FIFO 
    --
    -- Description:
    --  Instance for the synchronous fifo from proc common.   
    --
    ------------------------------------------------------------
    I_SYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_10.sync_fifo_fg 
      generic map(
         C_FAMILY             =>  C_FAMILY,        -- requred for FIFO Gen       
         C_DCOUNT_WIDTH       =>  C_DATA_CNT_WIDTH,     
         C_ENABLE_RLOCS       =>  0,                    
         C_HAS_DCOUNT         =>  1,                    
         C_HAS_RD_ACK         =>  1,                    
         C_HAS_RD_ERR         =>  0,                    
         C_HAS_WR_ACK         =>  1,                    
         C_HAS_WR_ERR         =>  0,                    
         C_MEMORY_TYPE        =>  C_USE_BLKMEM,         
         C_PORTS_DIFFER       =>  0,                    
         C_RD_ACK_LOW         =>  0,                    
         C_READ_DATA_WIDTH    =>  C_DWIDTH,             
         C_READ_DEPTH         =>  C_DEPTH,              
         C_RD_ERR_LOW         =>  0,                    
         C_WR_ACK_LOW         =>  0,                    
         C_WR_ERR_LOW         =>  0,                    
         C_WRITE_DATA_WIDTH   =>  C_DWIDTH,             
         C_WRITE_DEPTH        =>  C_DEPTH,
         C_PRELOAD_REGS       =>  1, -- 1 = first word fall through
         C_PRELOAD_LATENCY    =>  0, -- 0 = first word fall through
     --    C_USE_EMBEDDED_REG   =>  1  -- 0 ;
         C_XPM_FIFO           => 1
         )
      port map(  
         Clk                  =>  SFIFO_Clk,            
         Sinit                =>  SFIFO_Sinit,          
         Din                  =>  write_data_lil_end,   
         Wr_en                =>  SFIFO_Wr_en,          
         Rd_en                =>  fifo_read_enable,     
         Dout                 =>  read_data_lil_end,    
         Almost_full          =>  open,
         Full                 =>  SFIFO_Full,           
         Empty                =>  sig_SFIFO_empty,      
         Rd_ack               =>  sig_sfifo_rdack,      
         Wr_ack               =>  open,                 
         Rd_err               =>  open,                 
         Wr_err               =>  open,                 
         Data_count           =>  raw_data_cnt_lil_end  
        );  
end generate NON_BLK_MEM;                     

      
BLK_MEM : if (C_USE_BLKMEM = 1)
  generate   
    fifo_read_enable      <= SFIFO_Rd_en; -- or autoread;
       
    ------------------------------------------------------------
    -- Instance: I_SYNC_FIFOGEN_FIFO 
    --
    -- Description:
    --  Instance for the synchronous fifo from proc common.   
    --
    ------------------------------------------------------------
    I_SYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_10.sync_fifo_fg 
      generic map(
         C_FAMILY             =>  C_FAMILY,        -- requred for FIFO Gen       
         C_DCOUNT_WIDTH       =>  C_DATA_CNT_WIDTH,     
         C_ENABLE_RLOCS       =>  0,                    
         C_HAS_DCOUNT         =>  1,                    
         C_HAS_RD_ACK         =>  1,                    
         C_HAS_RD_ERR         =>  0,                    
         C_HAS_WR_ACK         =>  1,                    
         C_HAS_WR_ERR         =>  0,                    
         C_MEMORY_TYPE        =>  C_USE_BLKMEM,         
         C_PORTS_DIFFER       =>  0,                    
         C_RD_ACK_LOW         =>  0,                    
         C_READ_DATA_WIDTH    =>  C_DWIDTH,             
         C_READ_DEPTH         =>  C_DEPTH,              
         C_RD_ERR_LOW         =>  0,                    
         C_WR_ACK_LOW         =>  0,                    
         C_WR_ERR_LOW         =>  0,                    
         C_WRITE_DATA_WIDTH   =>  C_DWIDTH,             
         C_WRITE_DEPTH        =>  C_DEPTH,
         C_PRELOAD_REGS       =>  1, -- 1 = first word fall through
         C_PRELOAD_LATENCY    =>  0, -- 0 = first word fall through
         C_USE_EMBEDDED_REG   =>  1,  -- 0 ;
         C_XPM_FIFO           =>  1
         )
      port map(  
         Clk                  =>  SFIFO_Clk,            
         Sinit                =>  SFIFO_Sinit,          
         Din                  =>  write_data_lil_end,   
         Wr_en                =>  SFIFO_Wr_en,          
         Rd_en                =>  fifo_read_enable,     
         Dout                 =>  read_data_lil_end,    
         Almost_full          =>  open,
         Full                 =>  SFIFO_Full,           
         Empty                =>  sig_SFIFO_empty,      
         Rd_ack               =>  sig_sfifo_rdack,      
         Wr_ack               =>  open,                 
         Rd_err               =>  open,                 
         Wr_err               =>  open,                 
         Data_count           =>  raw_data_cnt_lil_end  
        );  
end generate BLK_MEM;                     
    
    
    
         
    
   -------------------------------------------------------------------------------




    
                                 
   -------------------------------------------------------------------------------
   -- Read Ack assert & hold logic Needed because....
   -------------------------------------------------------------------------------
   --     1) The CoreGen Sync FIFO has to be read once to get valid
   --        data to the read data port. 
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been used. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.
      
    
    ored_ack_ff_reset  <=  fifo_read_enable or 
                           SFIFO_Sinit or
                           SFIFO_Clr_Rd_Data_Valid;
    
    sig_rddata_valid   <=  not sig_SFIFO_empty; 

                           --hold_ff_q or 
                           --sig_sfifo_rdack;
 
 
   
            
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
    IMP_ACK_HOLD_FLOP : process (SFIFO_Clk)
       begin
         if (SFIFO_Clk'event and SFIFO_Clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if; 
         end if;       
       end process IMP_ACK_HOLD_FLOP; 
    
    
    
    -- generate auto-read enable. This keeps fresh data at the output
    -- of the FIFO whenever it is available.
--    autoread <= '1'                     -- create a read strobe when the 
--      when (sig_rddata_valid = '0' and  -- output data is NOT valid
-- -           sig_SFIFO_empty = '0')      -- and the FIFO is not empty
--      Else '0';
      
    autoread <= '0';   
    raw_data_count_int <=  CONV_INTEGER(raw_data_cnt_lil_end);
    
    
 
 
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_ALMOST_EMPTY
    --
    -- If Generate Description:
    --  This IFGen corrects the FIFO Read Count output for the
    --  auto read function and includes the generation of the
    --  Almost_Empty flag.
    --
    ------------------------------------------------------------
    INCLUDE_ALMOST_EMPTY : if (C_NEED_ALMOST_EMPTY = 1) generate
    
       -- local signals
       
          Signal raw_data_count_int_corr        : integer := 0;
          Signal raw_data_count_int_corr_minus1 : integer := 0;
       
       begin
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: CORRECT_RD_CNT_IAE
         --
         -- Process Description:
         --  This process corrects the FIFO Read Count output for the
         --  auto read function and includes the generation of the
         --  Almost_Empty flag.
         --
         -------------------------------------------------------------
         CORRECT_RD_CNT_IAE : process (sig_rddata_valid,
                                       sig_SFIFO_empty,
                                       raw_data_count_int)
            begin
         
               
               if (sig_rddata_valid = '0') then

                  raw_data_count_int_corr        <= 0;
                  raw_data_count_int_corr_minus1 <= 0;
                  corrected_empty                <= '1';
                  corrected_almost_empty         <= '0';
                  
               elsif (sig_SFIFO_empty = '1') then   -- rddata valid and fifo empty
                  
                  raw_data_count_int_corr        <= 1;
                  raw_data_count_int_corr_minus1 <= 0;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '1';
               
               Elsif (raw_data_count_int = 1) Then  -- rddata valid and fifo almost empty
                  
                  raw_data_count_int_corr        <= 2;
                  raw_data_count_int_corr_minus1 <= 1;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '0';
               
               else                                 -- rddata valid and modify rd count from FIFO 
                  
                  raw_data_count_int_corr        <= raw_data_count_int+1;
                  raw_data_count_int_corr_minus1 <= raw_data_count_int;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '0';
               
               end if;
         
            end process CORRECT_RD_CNT_IAE; 
      
    
            raw_data_count_corr <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr,
                                                         C_DATA_CNT_WIDTH);
        
            raw_data_count_corr_minus1 <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr_minus1,
                                                                 C_DATA_CNT_WIDTH);      
             
       end generate INCLUDE_ALMOST_EMPTY;
 
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_ALMOST_EMPTY
    --
    -- If Generate Description:
    --    This process corrects the FIFO Read Count output for the
    -- auto read function and omits the generation of the
    -- Almost_Empty flag.
    --
    ------------------------------------------------------------
    OMIT_ALMOST_EMPTY : if (C_NEED_ALMOST_EMPTY = 0) generate
    
       -- local signals
       
          Signal raw_data_count_int_corr : integer := 0;
       
       begin
    
          corrected_almost_empty  <= '0'; -- always low
         
         
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: CORRECT_RD_CNT
          --
          -- Process Description:
          --    This process corrects the FIFO Read Count output for the
          -- auto read function and omits the generation of the
          -- Almost_Empty flag.
          --
          -------------------------------------------------------------
          CORRECT_RD_CNT : process (sig_rddata_valid,
                                    sig_SFIFO_empty,
                                    raw_data_count_int)
             begin
          
              
                if (sig_rddata_valid = '0') then

                   raw_data_count_int_corr <= 0;
                   corrected_empty         <= '1';
                   
                elsif (sig_SFIFO_empty = '1') then   -- rddata valid and fifo empty
                   
                   raw_data_count_int_corr <= 1;
                   corrected_empty         <= '0';
                
                Elsif (raw_data_count_int = 1) Then  -- rddata valid and fifo almost empty
                   
                   raw_data_count_int_corr <= 2;
                   corrected_empty         <= '0';
                
                else                                 -- rddata valid and modify rd count from FIFO 
                   
                   raw_data_count_int_corr <= raw_data_count_int+1;
                   corrected_empty         <= '0';
                
                end if;
          
             end process CORRECT_RD_CNT; 
       
            
             raw_data_count_corr <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr,
                                                          C_DATA_CNT_WIDTH);
        
 
         
       end generate OMIT_ALMOST_EMPTY;
  
  
  
       
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_ALMOST_FULL
    --
    -- If Generate Description:
    --  This IfGen Includes the generation of the Amost_Full flag.
    --
    --
    ------------------------------------------------------------
    INCLUDE_ALMOST_FULL : if (C_NEED_ALMOST_FULL = 1) generate
    
       -- Local Constants
          
         Constant ALMOST_FULL_VALUE : integer := 2**(C_DATA_CNT_WIDTH-1)-1;
       
       begin
    
          SFIFO_Almost_full <= '1'
             When raw_data_count_int = ALMOST_FULL_VALUE
             Else '0';
                
                
       end generate INCLUDE_ALMOST_FULL;

   
   
   
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_ALMOST_FULL
    --
    -- If Generate Description:
    --  This IfGen Omits the generation of the Amost_Full flag.
    --
    --
    ------------------------------------------------------------
    OMIT_ALMOST_FULL : if (C_NEED_ALMOST_FULL = 0) generate
    
       begin
    
           SFIFO_Almost_full <= '0';  -- always low   
                
       end generate OMIT_ALMOST_FULL;



end imp;


-------------------------------------------------------------------------------
-- axi_datamover_fifo.vhd - entity/architecture pair

-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_fifo.vhd
-- Version:         initial
-- Description:     
--    This file is a wrapper file for the Synchronous FIFO used by the DataMover. 
-- 
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
---------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;



library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;
use lib_pkg_v1_0_2.lib_pkg.clog2;

library lib_srl_fifo_v1_0_2;
use lib_srl_fifo_v1_0_2.srl_fifo_f;


library axi_datamover_v5_1_17;
use axi_datamover_v5_1_17.axi_datamover_sfifo_autord;
use axi_datamover_v5_1_17.axi_datamover_afifo_autord;


-------------------------------------------------------------------------------

entity axi_datamover_fifo is
  generic (
     C_DWIDTH            : integer := 32  ;
       -- Bit width of the FIFO
       
     C_DEPTH             : integer := 4   ;
       -- Depth of the fifo in fifo width words
     
     C_IS_ASYNC          : Integer range 0 to 1 := 0 ;
       -- 0 = Syncronous FIFO
       -- 1 = Asynchronous (2 clock) FIFO
     
     C_PRIM_TYPE         : Integer range 0 to 2 := 2 ;
       -- 0 = Register
       -- 1 = Block Memory
       -- 2 = SRL
     
     C_FAMILY            : String  := "virtex7"
       -- Specifies the Target FPGA device family
     
    );
  port (
     
     
     
     -- Write Clock and reset -----------------
     fifo_wr_reset        : In  std_logic;   --
     fifo_wr_clk          : In  std_logic;   --
     ------------------------------------------
     
     -- Write Side ------------------------------------------------------
     fifo_wr_tvalid       : In  std_logic;                             --
     fifo_wr_tready       : Out std_logic;                             --
     fifo_wr_tdata        : In  std_logic_vector(C_DWIDTH-1 downto 0); --
     fifo_wr_full         : Out std_logic;                             --
     --------------------------------------------------------------------
    
    
     -- Read Clock and reset -----------------------------------------------
     fifo_async_rd_reset  : In  std_logic; -- only used if C_IS_ASYNC = 1 --  
     fifo_async_rd_clk    : In  std_logic; -- only used if C_IS_ASYNC = 1 --
     -----------------------------------------------------------------------
     
     -- Read Side --------------------------------------------------------
     fifo_rd_tvalid       : Out std_logic;                              --
     fifo_rd_tready       : In  std_logic;                              --
     fifo_rd_tdata        : Out std_logic_vector(C_DWIDTH-1 downto 0);  --
     fifo_rd_empty        : Out std_logic                               --
     ---------------------------------------------------------------------
    
    );
end entity axi_datamover_fifo;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_datamover_fifo is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";

 -- function Declarations
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: funct_get_prim_type
  --
  -- Function Description:
  --  Sorts out the FIFO Primitive type selection based on fifo
  -- depth and original primitive choice.
  --
  -------------------------------------------------------------------
  function funct_get_prim_type (depth            : integer;
                                input_prim_type  : integer) return integer is
  
    Variable temp_prim_type : Integer := 0;
  
  begin
  
    If (depth > 64) Then
    
      temp_prim_type := 1;  -- use BRAM
   
    Elsif (depth <= 64 and 
           input_prim_type = 0) Then
    
      temp_prim_type := 0;  -- use regiaters
    
    else

      temp_prim_type := 1;  -- use BRAM
    
    End if;
    
    
    Return (temp_prim_type);
    
  end function funct_get_prim_type;
  
 
  
  
-- Signal declarations
  
  Signal sig_init_reg          : std_logic := '0';
  Signal sig_init_reg2         : std_logic := '0';
  Signal sig_init_done         : std_logic := '0';
  signal sig_inhibit_rdy_n     : std_logic := '0';
 
   
   
 
-----------------------------------------------------------------------------
-- Begin architecture
-----------------------------------------------------------------------------
begin  


  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_INIT_REG
  --
  -- Process Description:
  --  Registers the reset signal input.
  --
  -------------------------------------------------------------
  IMP_INIT_REG : process (fifo_wr_clk)
     begin
       if (fifo_wr_clk'event and fifo_wr_clk = '1') then
          if (fifo_wr_reset = '1') then
            sig_init_reg  <= '1';
            sig_init_reg2 <= '1';
          else
            sig_init_reg <= '0';
            sig_init_reg2 <= sig_init_reg;
          end if; 
       end if;       
     end process IMP_INIT_REG; 
  
  
  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_INIT_DONE_REG
  --
  -- Process Description:
  -- Create a 1 clock wide init done pulse. 
  --
  -------------------------------------------------------------
  IMP_INIT_DONE_REG : process (fifo_wr_clk)
     begin
       if (fifo_wr_clk'event and fifo_wr_clk = '1') then
          if (fifo_wr_reset = '1' or
              sig_init_done = '1') then
            
            sig_init_done <= '0';
          
          Elsif (sig_init_reg  = '1' and
                 sig_init_reg2 = '1') Then
          
            sig_init_done <= '1';
          
          else
            null;  -- hold current state
          end if; 
       end if;       
     end process IMP_INIT_DONE_REG; 
  
  
  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_RDY_INHIBIT_REG
  --
  -- Process Description:
  --  Implements a ready inhibit flop.
  --
  -------------------------------------------------------------
  IMP_RDY_INHIBIT_REG : process (fifo_wr_clk)
     begin
       if (fifo_wr_clk'event and fifo_wr_clk = '1') then
          if (fifo_wr_reset = '1') then
            
            sig_inhibit_rdy_n  <= '0';
          
          Elsif (sig_init_done = '1') Then
          
            sig_inhibit_rdy_n <= '1';
          
          else
            null;  -- hold current state
          end if; 
       end if;       
     end process IMP_RDY_INHIBIT_REG; 
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: USE_SINGLE_REG
  --
  -- If Generate Description:
  --  Implements a 1 deep register FIFO (synchronous mode only)
  --
  --
  ------------------------------------------------------------
  USE_SINGLE_REG : if (C_IS_ASYNC  = 0 and 
                       C_DEPTH    <= 1) generate
  
     -- Local Constants
     
     -- local signals
     signal sig_data_in           : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
     signal sig_regfifo_dout_reg  : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
     signal sig_regfifo_full_reg  : std_logic := '0';
     signal sig_regfifo_empty_reg : std_logic := '0';
     signal sig_push_regfifo      : std_logic := '0';
     signal sig_pop_regfifo       : std_logic := '0';
     
     
  
     begin

       -- Internal signals
       
       -- Write signals
       fifo_wr_tready    <=  sig_regfifo_empty_reg;
       
       fifo_wr_full      <=  sig_regfifo_full_reg ;
       
       sig_push_regfifo  <=  fifo_wr_tvalid and
                             sig_regfifo_empty_reg;
       
       sig_data_in       <=  fifo_wr_tdata ; 

       
       -- Read signals
       fifo_rd_tdata     <=  sig_regfifo_dout_reg ;
       
       fifo_rd_tvalid    <=  sig_regfifo_full_reg ;
       
       fifo_rd_empty     <=  sig_regfifo_empty_reg;
       
       sig_pop_regfifo   <=  sig_regfifo_full_reg and
                             fifo_rd_tready;
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_REG_FIFO
       --
       -- Process Description:
       --    This process implements the data and full flag for the 
       -- register fifo.
       --
       -------------------------------------------------------------
       IMP_REG_FIFO : process (fifo_wr_clk)
          begin
            if (fifo_wr_clk'event and fifo_wr_clk = '1') then
               if (fifo_wr_reset    = '1' or
                   sig_pop_regfifo  = '1') then
                 
                 sig_regfifo_full_reg  <= '0';
                 
               elsif (sig_push_regfifo = '1') then
                 
                 sig_regfifo_full_reg  <= '1';
                 
               else
                 null;  -- don't change state
               end if; 
            end if;       
          end process IMP_REG_FIFO; 
       
      
       IMP_REG_FIFO1 : process (fifo_wr_clk)
          begin
            if (fifo_wr_clk'event and fifo_wr_clk = '1') then
               if (fifo_wr_reset    = '1') then
                
                 
                 sig_regfifo_dout_reg  <= (others => '0');
                 
               elsif (sig_push_regfifo = '1') then
                 
                 sig_regfifo_dout_reg  <= sig_data_in;
                 
               else
                 null;  -- don't change state
               end if; 
            end if;       
          end process IMP_REG_FIFO1; 
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_REG_EMPTY_FLOP
       --
       -- Process Description:
       --    This process implements the empty flag for the 
       -- register fifo.
       --
       -------------------------------------------------------------
       IMP_REG_EMPTY_FLOP : process (fifo_wr_clk)
          begin
            if (fifo_wr_clk'event and fifo_wr_clk = '1') then
               if (fifo_wr_reset    = '1') then
                 
                 sig_regfifo_empty_reg <= '0'; -- since this is used for the ready (invertd)
                                               -- it can't be asserted during reset
                 
               elsif (sig_pop_regfifo  = '1' or
                      sig_init_done    = '1') then
                 
                 sig_regfifo_empty_reg <= '1';
                 
               elsif (sig_push_regfifo = '1') then
                 
                 sig_regfifo_empty_reg <= '0';
                 
               else
                 null;  -- don't change state
               end if; 
            end if;       
          end process IMP_REG_EMPTY_FLOP; 
       

  
     end generate USE_SINGLE_REG;
 
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: USE_SRL_FIFO
  --
  -- If Generate Description:
  --  Generates a fifo implementation usinf SRL based FIFOa
  --
  --
  ------------------------------------------------------------
  USE_SRL_FIFO : if (C_IS_ASYNC  =  0 and
                     C_DEPTH    <= 64 and
                     C_DEPTH     >  1 and
                     C_PRIM_TYPE =  2 ) generate
                     
  
  
    -- Local Constants
    Constant  LOGIC_LOW         : std_logic := '0';
    Constant  NEED_ALMOST_EMPTY : Integer := 0;
    Constant  NEED_ALMOST_FULL  : Integer := 0;
    
    
    -- local signals

    signal sig_wr_full          : std_logic := '0';
    signal sig_wr_fifo          : std_logic := '0';
    signal sig_wr_ready         : std_logic := '0';
    signal sig_rd_fifo          : std_logic := '0';
    signal sig_rd_empty         : std_logic := '0';
    signal sig_rd_valid         : std_logic := '0';
    signal sig_fifo_rd_data     : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_wr_data     : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
      
    begin
  
       

      -- Write side signals
      fifo_wr_tready    <=  sig_wr_ready;
      
      fifo_wr_full      <=  sig_wr_full;
      
      sig_wr_ready      <=  not(sig_wr_full) and 
                            sig_inhibit_rdy_n;
 
      sig_wr_fifo       <=  fifo_wr_tvalid and 
                            sig_wr_ready;
      
      sig_fifo_wr_data  <=  fifo_wr_tdata;
      
      
      
      
      -- Read Side Signals
      fifo_rd_tvalid    <=  sig_rd_valid;
      
      sig_rd_valid      <=  not(sig_rd_empty);
      
      fifo_rd_tdata     <=  sig_fifo_rd_data ;
      
      fifo_rd_empty     <=  not(sig_rd_valid);
      
      sig_rd_fifo       <=  sig_rd_valid and
                            fifo_rd_tready;
       
      
       
      ------------------------------------------------------------
      -- Instance: I_SYNC_FIFO 
      --
      -- Description:
      -- Implement the synchronous FIFO using SRL FIFO elements    
      --
      ------------------------------------------------------------
       I_SYNC_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
       generic map (

         C_DWIDTH            =>  C_DWIDTH   ,  
         C_DEPTH             =>  C_DEPTH    ,  
         C_FAMILY            =>  C_FAMILY      

         )
       port map (

         Clk           =>  fifo_wr_clk      ,  
         Reset         =>  fifo_wr_reset    ,  
         FIFO_Write    =>  sig_wr_fifo      ,  
         Data_In       =>  sig_fifo_wr_data ,  
         FIFO_Read     =>  sig_rd_fifo      ,  
         Data_Out      =>  sig_fifo_rd_data ,  
         FIFO_Empty    =>  sig_rd_empty     ,  
         FIFO_Full     =>  sig_wr_full      ,  
         Addr          =>  open                
     
         );

       
       
     end generate USE_SRL_FIFO;




 
 
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: USE_SYNC_FIFO
  --
  -- If Generate Description:
  --  Instantiates a synchronous FIFO design for use in the 
  -- synchronous operating mode.
  --
  ------------------------------------------------------------
  USE_SYNC_FIFO : if (C_IS_ASYNC  =  0 and
                     (C_DEPTH     > 64  or
                     (C_DEPTH     >  1 and C_PRIM_TYPE < 2 ))) 
                     or 
                     (C_IS_ASYNC  =  0 and
                     C_DEPTH    <= 64 and
                     C_DEPTH     >  1 and
                     C_PRIM_TYPE =  0 ) 
generate
  
    -- Local Constants
    Constant  LOGIC_LOW         : std_logic := '0';
    Constant  NEED_ALMOST_EMPTY : Integer   := 0;
    Constant  NEED_ALMOST_FULL  : Integer   := 0;
    Constant  DATA_CNT_WIDTH    : Integer   := clog2(C_DEPTH)+1;
    Constant  PRIM_TYPE         : Integer   := funct_get_prim_type(C_DEPTH, C_PRIM_TYPE);
    
    
    -- local signals
    signal sig_wr_full          : std_logic := '0';
    signal sig_wr_fifo          : std_logic := '0';
    signal sig_wr_ready         : std_logic := '0';
    signal sig_rd_fifo          : std_logic := '0';
    signal sig_rd_valid         : std_logic := '0';
    signal sig_fifo_rd_data     : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_wr_data     : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
    
    begin

      -- Write side signals
      fifo_wr_tready    <=  sig_wr_ready;
      
      fifo_wr_full      <=  sig_wr_full;
      
      sig_wr_ready      <=  not(sig_wr_full) and 
                            sig_inhibit_rdy_n;
 
      sig_wr_fifo       <=  fifo_wr_tvalid and 
                            sig_wr_ready;
      
      sig_fifo_wr_data  <=  fifo_wr_tdata;
      
      
      
      
      -- Read Side Signals
      fifo_rd_tvalid    <=  sig_rd_valid;
      
      fifo_rd_tdata     <=  sig_fifo_rd_data ;
      
      fifo_rd_empty     <=  not(sig_rd_valid);
      
      sig_rd_fifo       <=  sig_rd_valid and
                            fifo_rd_tready;
       
      
      
      
      ------------------------------------------------------------
      -- Instance: I_SYNC_FIFO 
      --
      -- Description:
      -- Implement the synchronous FIFO    
      --
      ------------------------------------------------------------
       I_SYNC_FIFO : entity axi_datamover_v5_1_17.axi_datamover_sfifo_autord
       generic map (

         C_DWIDTH                =>  C_DWIDTH          ,  
         C_DEPTH                 =>  C_DEPTH           ,  
         C_DATA_CNT_WIDTH        =>  DATA_CNT_WIDTH    ,  
         C_NEED_ALMOST_EMPTY     =>  NEED_ALMOST_EMPTY ,  
         C_NEED_ALMOST_FULL      =>  NEED_ALMOST_FULL  ,  
         C_USE_BLKMEM            =>  PRIM_TYPE         ,  
         C_FAMILY                =>  C_FAMILY             

         )
       port map (

        -- Inputs 
         SFIFO_Sinit             =>  fifo_wr_reset     ,  
         SFIFO_Clk               =>  fifo_wr_clk       ,  
         SFIFO_Wr_en             =>  sig_wr_fifo       ,  
         SFIFO_Din               =>  fifo_wr_tdata     ,  
         SFIFO_Rd_en             =>  sig_rd_fifo       ,  
         SFIFO_Clr_Rd_Data_Valid =>  LOGIC_LOW         ,  
         
        -- Outputs
         SFIFO_DValid            =>  sig_rd_valid      ,  
         SFIFO_Dout              =>  sig_fifo_rd_data  ,  
         SFIFO_Full              =>  sig_wr_full       ,  
         SFIFO_Empty             =>  open              ,  
         SFIFO_Almost_full       =>  open              ,  
         SFIFO_Almost_empty      =>  open              ,  
         SFIFO_Rd_count          =>  open              ,  
         SFIFO_Rd_count_minus1   =>  open              ,  
         SFIFO_Wr_count          =>  open              ,  
         SFIFO_Rd_ack            =>  open                 

         );


      
 
     end generate USE_SYNC_FIFO;
 
 
 
 
 
 
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: USE_ASYNC_FIFO
  --
  -- If Generate Description:
  --  Instantiates an asynchronous FIFO design for use in the 
  -- asynchronous operating mode.
  --
  ------------------------------------------------------------
  USE_ASYNC_FIFO : if (C_IS_ASYNC = 1) generate
  
    -- Local Constants
    Constant  LOGIC_LOW         : std_logic := '0';
    Constant  CNT_WIDTH         : Integer := clog2(C_DEPTH);
    
    
    -- local signals

    signal sig_async_wr_full       : std_logic := '0';
    signal sig_async_wr_fifo       : std_logic := '0';
    signal sig_async_wr_ready      : std_logic := '0';
    signal sig_async_rd_fifo       : std_logic := '0';
    signal sig_async_rd_valid      : std_logic := '0';
    signal sig_afifo_rd_data       : std_logic_vector(C_DWIDTH-1 downto 0);
    signal sig_afifo_wr_data       : std_logic_vector(C_DWIDTH-1 downto 0);
    signal sig_fifo_ainit          : std_logic := '0';
    Signal sig_init_reg            : std_logic := '0';
    
    
    begin

      sig_fifo_ainit  <= fifo_wr_reset; --fifo_async_rd_reset or fifo_wr_reset;
      
      

      -- Write side signals
      fifo_wr_tready      <=  sig_async_wr_ready;
      
      fifo_wr_full        <=  sig_async_wr_full;
      
      sig_async_wr_ready  <=  not(sig_async_wr_full) and
                              sig_inhibit_rdy_n;
 
      sig_async_wr_fifo   <=  fifo_wr_tvalid and 
                              sig_async_wr_ready;
      
      sig_afifo_wr_data   <=  fifo_wr_tdata;
      
      
      
      
      -- Read Side Signals
      fifo_rd_tvalid    <=  sig_async_rd_valid;
      
      fifo_rd_tdata     <=  sig_afifo_rd_data ;
      
      fifo_rd_empty     <=  not(sig_async_rd_valid);
      
      sig_async_rd_fifo <=  sig_async_rd_valid and
                            fifo_rd_tready;
       
      
 
       
       
       
      ------------------------------------------------------------
      -- Instance: I_ASYNC_FIFO 
      --
      -- Description:
      -- Implement the asynchronous FIFO    
      --
      ------------------------------------------------------------
       I_ASYNC_FIFO : entity axi_datamover_v5_1_17.axi_datamover_afifo_autord
       generic map (

         C_DWIDTH                   =>  C_DWIDTH          ,  
         C_DEPTH                    =>  C_DEPTH           ,  
         C_CNT_WIDTH                =>  CNT_WIDTH         ,  
         C_USE_BLKMEM               =>  C_PRIM_TYPE       ,  
         C_FAMILY                   =>  C_FAMILY             

         )
       port map (

        -- Inputs 
         AFIFO_Ainit                =>  sig_fifo_ainit    ,  
         AFIFO_Ainit_Rd_clk         =>  fifo_async_rd_reset    ,  
         AFIFO_Wr_clk               =>  fifo_wr_clk       ,  
         AFIFO_Wr_en                =>  sig_async_wr_fifo ,  
         AFIFO_Din                  =>  sig_afifo_wr_data ,  
         AFIFO_Rd_clk               =>  fifo_async_rd_clk ,  
         AFIFO_Rd_en                =>  sig_async_rd_fifo ,  
         AFIFO_Clr_Rd_Data_Valid    =>  LOGIC_LOW         ,  
         
        -- Outputs
         AFIFO_DValid               =>  sig_async_rd_valid,  
         AFIFO_Dout                 =>  sig_afifo_rd_data ,  
         AFIFO_Full                 =>  sig_async_wr_full ,  
         AFIFO_Empty                =>  open              ,  
         AFIFO_Almost_full          =>  open              ,  
         AFIFO_Almost_empty         =>  open              ,  
         AFIFO_Wr_count             =>  open              ,   
         AFIFO_Rd_count             =>  open              ,  
         AFIFO_Corr_Rd_count        =>  open              ,  
         AFIFO_Corr_Rd_count_minus1 =>  open              ,  
         AFIFO_Rd_ack               =>  open                 

         );


      
 
     end generate USE_ASYNC_FIFO;
 
 

end imp;


  -------------------------------------------------------------------------------
  -- axi_datamover_cmd_status.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_cmd_status.vhd
  --
  -- Description:     
  --    This file implements the DataMover Command and Status interfaces.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library axi_datamover_v5_1_17;
  Use axi_datamover_v5_1_17.axi_datamover_fifo;
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_cmd_status is
    generic (
      
      C_ADDR_WIDTH         : Integer range 32 to 64 := 32;
        -- Indictes the width of the DataMover Address bus
       
      C_INCLUDE_STSFIFO    : Integer range  0 to  1 :=  1;
        -- Indicates if a Stus FIFO is to be included or omitted
        -- 0 = Omit
        -- 1 = Include
       
      C_STSCMD_FIFO_DEPTH  : Integer range  1 to 16 :=  4;
        -- Sets the depth of the Command and Status FIFOs
       
      C_STSCMD_IS_ASYNC    : Integer range  0 to  1 :=  0;
        -- Indicates if the Command and Status Stream Channels are clocked with
        -- a different clock than the Main dataMover Clock
        -- 0 = Same Clock
        -- 1 = Different clocks
       
      C_CMD_WIDTH          : Integer                := 68;
        -- Sets the width of the input command
       
      C_STS_WIDTH          : Integer                :=  8;
        -- Sets the width of the output status

      C_ENABLE_CACHE_USER  : Integer range 0 to 1   :=  0;
       
      C_FAMILY             : string                 := "virtex7"
        -- Sets the target FPGA family
      
      );
    port (
      
      -- Clock inputs ----------------------------------------------------
      primary_aclk           : in  std_logic;                           --
         -- Primary synchronization clock for the Master side           --
         -- interface and internal logic. It is also used               --
         -- for the User interface synchronization when                 --
         -- C_STSCMD_IS_ASYNC = 0.                                      --
                                                                        --
      secondary_awclk        : in  std_logic;                           --
         -- Clock used for the Command and Status User Interface        --
         --  when the User Command and Status interface is Async        --
         -- to the MMap interface. Async mode is set by the assigned    --
         -- value to C_STSCMD_IS_ASYNC = 1.                             --
      --------------------------------------------------------------------
     
     
      -- Reset inputs ----------------------------------------------------
      user_reset             : in  std_logic;                           --
        -- Reset used for the User Stream interface logic               --
                                                                        --
      internal_reset         : in  std_logic;                           --
        -- Reset used for the internal master interface logic           --
      --------------------------------------------------------------------
      
      
      -- User Command Stream Ports (AXI Stream) -------------------------------
      cmd_wvalid             : in  std_logic;                                --
      cmd_wready             : out std_logic;                                --
      cmd_wdata              : in  std_logic_vector(C_CMD_WIDTH-1 downto 0); --
      cache_data             : in  std_logic_vector(7 downto 0); --
      -------------------------------------------------------------------------
      
      -- User Status Stream Ports (AXI Stream) ------------------------------------
      sts_wvalid             : out std_logic;                                    --
      sts_wready             : in  std_logic;                                    --
      sts_wdata              : out std_logic_vector(C_STS_WIDTH-1 downto 0);     --
      sts_wstrb              : out std_logic_vector((C_STS_WIDTH/8)-1 downto 0); --
      sts_wlast              : out std_logic;                                    --
      -----------------------------------------------------------------------------
      
      
      -- Internal Command Out Interface -----------------------------------------------
      cmd2mstr_command       : Out std_logic_vector(C_CMD_WIDTH-1 downto 0);         --
         -- The next command value available from the Command FIFO/Register          --

      cache2mstr_command       : Out std_logic_vector(7 downto 0);         --
         -- The cache value available from the FIFO/Register          --

                                                                                     --
      mst2cmd_cmd_valid      : Out std_logic;                                        --
         -- Handshake bit indicating the Command FIFO/Register has at least 1 valid  --
         -- command entry                                                            --
                                                                                     --
      cmd2mstr_cmd_ready     : in  std_logic;                                        --
         -- Handshake bit indicating the Command Calculator is ready to accept       --
         -- another command                                                          --
      ---------------------------------------------------------------------------------
      
      
      -- Internal Status In Interface  -----------------------------------------------------
      mstr2stat_status       : in  std_logic_vector(C_STS_WIDTH-1 downto 0);              --
         -- The input for writing the status value to the Status FIFO/Register            --
                                                                                          --
      stat2mstr_status_ready : Out std_logic;                                             --
         -- Handshake bit indicating that the Status FIFO/Register is ready for transfer  --
                                                                                          --
      mst2stst_status_valid  : In  std_logic                                              --
         -- Handshake bit for writing the Status value into the Status FIFO/Register      --
      --------------------------------------------------------------------------------------
     
      );
  
  end entity axi_datamover_cmd_status;
  
  
  architecture implementation of axi_datamover_cmd_status is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: get_fifo_prim_type
    --
    -- Function Description:
    --  Returns the fifo primitiver type to use for the given input
    -- conditions.
    --
    --  0 = Not used or allowed here
    --  1 = BRAM Primitives (Block Memory)
    --  2 = Distributed memory
    --
    -------------------------------------------------------------------
    function get_fifo_prim_type (is_async : integer;
                                 depth    : integer) return integer is
    
      Variable var_temp_prim_type : Integer := 1;
    
    begin
    
      if (is_async = 1) then   -- Async FIFOs always use Blk Mem (BRAM)
      
        var_temp_prim_type := 1;
      
      elsif (depth <= 64) then -- (use srls or distrubuted)
      
        var_temp_prim_type := 2; 
      
      else  -- depth is too big for SRLs so use Blk Memory (BRAM)
      
        var_temp_prim_type := 1;
      
      end if;
      
     Return (var_temp_prim_type);
      
    end function get_fifo_prim_type;
    
   
   
    
    
    -- Constants 
    
    Constant REGISTER_TYPE  : integer := 0; 
    Constant BRAM_TYPE      : integer := 1; 
    --Constant SRL_TYPE       : integer := 2; 
    --Constant FIFO_PRIM_TYPE : integer := SRL_TYPE;
    Constant FIFO_PRIM_TYPE : integer := get_fifo_prim_type(C_STSCMD_IS_ASYNC, 
                                                            C_STSCMD_FIFO_DEPTH);
    
    
    -- Signals
    
    signal sig_cmd_fifo_wr_clk  : std_logic := '0';
    signal sig_cmd_fifo_wr_rst  : std_logic := '0';
    signal sig_cmd_fifo_rd_clk  : std_logic := '0';
    signal sig_cmd_fifo_rd_rst  : std_logic := '0';
    signal sig_sts_fifo_wr_clk  : std_logic := '0';
    signal sig_sts_fifo_wr_rst  : std_logic := '0';
    signal sig_sts_fifo_rd_clk  : std_logic := '0';
    signal sig_sts_fifo_rd_rst  : std_logic := '0';
    signal sig_reset_mstr       : std_logic := '0';
    signal sig_reset_user       : std_logic := '0';
 
 
  
  
  begin --(architecture implementation)
  
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_SYNC_RESET
    --
    -- If Generate Description:
    --  This IfGen assigns the clock and reset signals for the 
    -- synchronous User interface case
    --
    ------------------------------------------------------------
    GEN_SYNC_RESET : if (C_STSCMD_IS_ASYNC = 0) generate
    
       begin
    
          sig_reset_mstr       <= internal_reset  ;
          sig_reset_user       <= internal_reset  ;
        
          sig_cmd_fifo_wr_clk   <=  primary_aclk  ;  
          sig_cmd_fifo_wr_rst   <=  sig_reset_user; 
          sig_cmd_fifo_rd_clk   <=  primary_aclk  ; 
          sig_cmd_fifo_rd_rst   <=  sig_reset_mstr; 
         
          sig_sts_fifo_wr_clk   <=  primary_aclk  ; 
          sig_sts_fifo_wr_rst   <=  sig_reset_mstr; 
          sig_sts_fifo_rd_clk   <=  primary_aclk  ; 
          sig_sts_fifo_rd_rst   <=  sig_reset_user; 
           
         
        
             
         
       end generate GEN_SYNC_RESET;
  
  
    
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ASYNC_RESET
    --
    -- If Generate Description:
    --  This IfGen assigns the clock and reset signals for the 
    -- Asynchronous User interface case
    --
    ------------------------------------------------------------
    GEN_ASYNC_RESET : if (C_STSCMD_IS_ASYNC = 1) generate
    
       begin
    
         sig_reset_mstr        <= internal_reset  ;
         sig_reset_user        <= user_reset      ;
       
         sig_cmd_fifo_wr_clk   <=  secondary_awclk;  
         sig_cmd_fifo_wr_rst   <=  sig_reset_user ; 
         sig_cmd_fifo_rd_clk   <=  primary_aclk   ; 
         sig_cmd_fifo_rd_rst   <=  sig_reset_mstr ; 
        
         sig_sts_fifo_wr_clk   <=  primary_aclk   ; 
         sig_sts_fifo_wr_rst   <=  sig_reset_mstr ; 
         sig_sts_fifo_rd_clk   <=  secondary_awclk; 
         sig_sts_fifo_rd_rst   <=  sig_reset_user ; 
          
        
            
         
       end generate GEN_ASYNC_RESET;
  
  
  
  
       
    ------------------------------------------------------------
    -- Instance: I_CMD_FIFO 
    --
    -- Description:
    -- Instance for the Command FIFO
    -- The User Interface is the Write Side
    -- The Internal Interface is the Read side    
    --
    ------------------------------------------------------------
     I_CMD_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
     generic map (
   
       C_DWIDTH            =>  C_CMD_WIDTH          ,  
       C_DEPTH             =>  C_STSCMD_FIFO_DEPTH  ,  
       C_IS_ASYNC          =>  C_STSCMD_IS_ASYNC    ,  
       C_PRIM_TYPE         =>  FIFO_PRIM_TYPE       ,  
       C_FAMILY            =>  C_FAMILY                
      
       )
     port map (
       
       -- Write Clock and reset
       fifo_wr_reset        =>  sig_cmd_fifo_wr_rst ,  
       fifo_wr_clk          =>  sig_cmd_fifo_wr_clk ,  
       
       -- Write Side
       fifo_wr_tvalid       =>  cmd_wvalid          ,  
       fifo_wr_tready       =>  cmd_wready          ,  
       fifo_wr_tdata        =>  cmd_wdata           ,  
       fifo_wr_full         =>  open                ,  
      
      
       -- Read Clock and reset
       fifo_async_rd_reset  =>  sig_cmd_fifo_rd_rst ,     
       fifo_async_rd_clk    =>  sig_cmd_fifo_rd_clk ,   
       
       -- Read Side
       fifo_rd_tvalid       =>  mst2cmd_cmd_valid   ,  
       fifo_rd_tready       =>  cmd2mstr_cmd_ready  ,  
       fifo_rd_tdata        =>  cmd2mstr_command    ,  
       fifo_rd_empty        =>  open                   
      
       );

CACHE_ENABLE : if C_ENABLE_CACHE_USER = 1 generate
begin
   
     I_CACHE_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
     generic map (
   
       C_DWIDTH            =>  8          ,  
       C_DEPTH             =>  C_STSCMD_FIFO_DEPTH  ,  
       C_IS_ASYNC          =>  C_STSCMD_IS_ASYNC    ,  
       C_PRIM_TYPE         =>  FIFO_PRIM_TYPE       ,  
       C_FAMILY            =>  C_FAMILY                
      
       )
     port map (
       
       -- Write Clock and reset
       fifo_wr_reset        =>  sig_cmd_fifo_wr_rst ,  
       fifo_wr_clk          =>  sig_cmd_fifo_wr_clk ,  
       
       -- Write Side
       fifo_wr_tvalid       =>  cmd_wvalid          ,  
       fifo_wr_tready       =>  open ,--cmd_wready          ,  
       fifo_wr_tdata        =>  cache_data           ,  
       fifo_wr_full         =>  open                ,  
      
      
       -- Read Clock and reset
       fifo_async_rd_reset  =>  sig_cmd_fifo_rd_rst ,     
       fifo_async_rd_clk    =>  sig_cmd_fifo_rd_clk ,   
       
       -- Read Side
       fifo_rd_tvalid       =>  open ,--mst2cmd_cmd_valid   ,  
       fifo_rd_tready       =>  cmd2mstr_cmd_ready  ,  
       fifo_rd_tdata        =>  cache2mstr_command  ,  
       fifo_rd_empty        =>  open                   
      
       );
   
end generate;    
    
    
CACHE_DISABLE : if C_ENABLE_CACHE_USER = 0 generate
begin
   
 cache2mstr_command <= (others => '0'); 
    
end generate CACHE_DISABLE;    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_STATUS_FIFO
    --
    -- If Generate Description:
    --  Instantiates a Status FIFO
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_STATUS_FIFO : if (C_INCLUDE_STSFIFO = 1) generate
    
       begin
 
  
         -- Set constant outputs for Status Interface
         sts_wstrb             <=  (others => '1');    
         sts_wlast             <=  '1';                
         
         
       
         ------------------------------------------------------------
         -- Instance: I_STS_FIFO 
         --
         -- Description:
         -- Instance for the Status FIFO
         -- The Internal Interface is the Write Side
         -- The User Interface is the Read side    
         --
         ------------------------------------------------------------
         I_STS_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
         generic map (
       
           C_DWIDTH            =>  C_STS_WIDTH            ,  
           C_DEPTH             =>  C_STSCMD_FIFO_DEPTH    ,  
           C_IS_ASYNC          =>  C_STSCMD_IS_ASYNC      ,  
           C_PRIM_TYPE         =>  FIFO_PRIM_TYPE         ,  
           C_FAMILY            =>  C_FAMILY                  
          
           )
         port map (
           
           -- Write Clock and reset
           fifo_wr_reset        =>  sig_sts_fifo_wr_rst   ,  
           fifo_wr_clk          =>  sig_sts_fifo_wr_clk   ,  
           
           -- Write Side
           fifo_wr_tvalid       =>  mst2stst_status_valid ,  
           fifo_wr_tready       =>  stat2mstr_status_ready,  
           fifo_wr_tdata        =>  mstr2stat_status      ,  
           fifo_wr_full         =>  open                  ,  
          
          
           -- Read Clock and reset
           fifo_async_rd_reset  =>  sig_sts_fifo_rd_rst   ,     
           fifo_async_rd_clk    =>  sig_sts_fifo_rd_clk   ,   
           
           -- Read Side
           fifo_rd_tvalid       =>  sts_wvalid            ,  
           fifo_rd_tready       =>  sts_wready            ,  
           fifo_rd_tdata        =>  sts_wdata             ,  
           fifo_rd_empty        =>  open                     
          
           );
        
    
       end generate GEN_INCLUDE_STATUS_FIFO;
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_STATUS_FIFO
    --
    -- If Generate Description:
    --  Omits the Status FIFO
    --
    --
    ------------------------------------------------------------
    GEN_OMIT_STATUS_FIFO : if (C_INCLUDE_STSFIFO = 0) generate
    
       begin
  
         -- Status FIFO User interface housekeeping
         sts_wvalid            <=  '0';
         -- sts_wready         -- ignored
         sts_wdata             <=  (others => '0');
         sts_wstrb             <=  (others => '0');    
         sts_wlast             <=  '0';                
 
         
         
         -- Status FIFO Internal interface housekeeping
         stat2mstr_status_ready <= '1';
         -- mstr2stat_status       -- ignored
         -- mst2stst_status_valid  -- ignored
 
    
       end generate GEN_OMIT_STATUS_FIFO;
    
    
 
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_scc.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_scc.vhd
  --
  -- Description:     
  --    This file implements the DataMover Lite Master Simple Command Calculator (SCC).                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_scc is
    generic (
      
      C_SEL_ADDR_WIDTH     : Integer range  1 to  8 :=  5;
        -- Sets the width of the LS address bus used for 
        -- Muxing/Demuxing data to/from a wider AXI4 data bus
      
      C_ADDR_WIDTH         : Integer range 32 to 64 := 32;
        -- Sets the width of the AXi Address Channel 
      
      C_STREAM_DWIDTH      : Integer range  8 to 64 := 32;
        -- Sets the width of the Native Data width that
        -- is being supported by the PCC
      
      C_MAX_BURST_LEN      : Integer range 2 to 64 := 16;
        -- Indicates the max allowed burst length to use for
        -- AXI4 transfer calculations
      
      C_CMD_WIDTH          : Integer                := 68;
        -- Sets the width of the input command port

      C_MICRO_DMA          : integer range 0 to 1   := 0;
      
      C_TAG_WIDTH          : Integer range  1 to  8 := 4
        -- Sets the width of the Tag field in the input command
      
      );
    port (
      
      -- Clock and Reset inputs -------------------------------------
      primary_aclk         : in  std_logic;                        --
         -- Primary synchronization clock for the Master side      --
         -- interface and internal logic. It is also used          --
         -- for the User interface synchronization when            --
         -- C_STSCMD_IS_ASYNC = 0.                                 --
                                                                   --
      -- Reset input                                               --
      mmap_reset           : in  std_logic;                        --
        -- Reset used for the internal master logic                --
      ---------------------------------------------------------------
      
      
     
      -- Command Input Interface ---------------------------------------------------------
                                                                                        --
      cmd2mstr_command      : in std_logic_vector(C_CMD_WIDTH-1 downto 0);              --
         -- The next command value available from the Command FIFO/Register             --
                                                                                        --
      cache2mstr_command      : in std_logic_vector(7 downto 0);              --
         -- The next command value available from the Command FIFO/Register             --
                                                                                        --
      cmd2mstr_cmd_valid    : in std_logic;                                             --
         -- Handshake bit indicating if the Command FIFO/Register has at leasdt 1 entry --
                                                                                        --
      mst2cmd_cmd_ready     : out  std_logic;                                           --
         -- Handshake bit indicating the Command Calculator is ready to accept          --
         -- another command                                                             --
      ------------------------------------------------------------------------------------
      
      
      
      -- Address Channel Controller Interface --------------------------------------------
                                                                                        --
      mstr2addr_tag       : out std_logic_vector(C_TAG_WIDTH-1 downto 0);               --
         -- The next command tag                                                        --
                                                                                        --
      mstr2addr_addr      : out std_logic_vector(C_ADDR_WIDTH-1 downto 0);              --
         -- The next command address to put on the AXI MMap ADDR                        --
                                                                                        --
      mstr2addr_len       : out std_logic_vector(7 downto 0);                           --
         -- The next command length to put on the AXI MMap LEN                          --
                                                                                        --
      mstr2addr_size      : out std_logic_vector(2 downto 0);                           --
         -- The next command size to put on the AXI MMap SIZE                           --
                                                                                        --
      mstr2addr_burst     : out std_logic_vector(1 downto 0);                           --
         -- The next command burst type to put on the AXI MMap BURST                    --
                                                                                        --
      mstr2addr_cache     : out std_logic_vector(3 downto 0);                           --
         -- The next command burst type to put on the AXI MMap BURST                    --
                                                                                        --
      mstr2addr_user      : out std_logic_vector(3 downto 0);                           --
         -- The next command burst type to put on the AXI MMap BURST                    --
                                                                                        --
      mstr2addr_cmd_cmplt : out std_logic;                                              --
         -- The indication to the Address Channel that the current                      --
         -- sub-command output is the last one compiled from the                        --
         -- parent command pulled from the Command FIFO                                 --
                                                                                        --
      mstr2addr_calc_error : out std_logic;                                             --
         -- Indication if the next command in the calculation pipe                      --
         -- has a calcualtion error                                                     --
                                                                                        --
      mstr2addr_cmd_valid : out std_logic;                                              --
         -- The next command valid indication to the Address Channel                    --
         -- Controller for the AXI MMap                                                 --
                                                                                        --
      addr2mstr_cmd_ready : In std_logic;                                               --
         -- Indication from the Address Channel Controller that the                     --
         -- command is being accepted                                                   --
      ------------------------------------------------------------------------------------
      
      
      
      -- Data Channel Controller Interface  ----------------------------------------------
                                                                                        --
      mstr2data_tag        : out std_logic_vector(C_TAG_WIDTH-1 downto 0);              --
         -- The next command tag                                                        --
                                                                                        --
      mstr2data_saddr_lsb  : out std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);         --
         -- The next command start address LSbs to use for the read data                --
         -- mux (only used if Stream data width is 8 or 16 bits).                       --
                                                                                        --
      mstr2data_len        : out std_logic_vector(7 downto 0);                          --
         -- The LEN value output to the Address Channel                                 --
                                                                                        --
      mstr2data_strt_strb  : out std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);      --
         -- The starting strobe value to use for the data transfer                      --
                                                                                        --
      mstr2data_last_strb  : out std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);      --
         -- The endiing (LAST) strobe value to use for the data transfer                --
                                                                                        --
      mstr2data_sof        : out std_logic;                                             --
         -- The starting tranfer of a sequence of transfers                             --
                                                                                        --
      mstr2data_eof        : out std_logic;                                             --
         -- The endiing tranfer of a sequence of parent transfer commands               --
                                                                                        --
      mstr2data_calc_error : out std_logic;                                             --
         -- Indication if the next command in the calculation pipe                      --
         -- has a calculation error                                                     --
                                                                                        --
      mstr2data_cmd_cmplt  : out std_logic;                                             --
         -- The indication to the Data Channel that the current                         --
         -- sub-command output is the last one compiled from the                        --
         -- parent command pulled from the Command FIFO                                 --
                                                                                        --
      mstr2data_cmd_valid  : out std_logic;                                             --
         -- The next command valid indication to the Data Channel                       --
         -- Controller for the AXI MMap                                                 --
                                                                                        --
      data2mstr_cmd_ready  : In std_logic ;                                             --
         -- Indication from the Data Channel Controller that the                        --
         -- command is being accepted on the AXI Address                                --
         -- Channel                                                                     --
                                                                                        --
      calc_error           : Out std_logic                                              --
         -- Indication from the Command Calculator that a calculation                   --
         -- error has occured.                                                          --
      ------------------------------------------------------------------------------------
     
      );
  
  end entity axi_datamover_scc;
  
  
  architecture implementation of axi_datamover_scc is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
  
  
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_slice_width
    --
    -- Function Description:
    -- Calculates the bits to rip from the Command BTT field to calculate
    -- the LEN value output to the AXI Address Channel.
    --
    -------------------------------------------------------------------
    function funct_get_slice_width (max_burst_len : integer) return integer is
                                    
    
      Variable temp_slice_width : Integer := 0;
    
    begin
  
      case max_burst_len is
        
        when 64 =>
          temp_slice_width := 7;
        when 32 =>
          temp_slice_width := 6;
        when 16 =>
          temp_slice_width := 5;
        when 8 =>
          temp_slice_width := 4;
        when 4 =>
          temp_slice_width := 3;
        when others =>   -- assume 16 dbeats is max LEN
          temp_slice_width := 2;
      end case;
      
      Return (temp_slice_width);
     
    end function funct_get_slice_width;
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_residue_width
    --
    -- Function Description:
    --  Calculates the number of Least significant bits of the BTT field
    -- that are unused for the LEN calculation
    --
    -------------------------------------------------------------------
    function funct_get_btt_ls_unused (transfer_width : integer) return integer is
    
      Variable temp_btt_ls_unused : Integer := 0; -- 8-bit stream
      
    begin
    
      case transfer_width is
        when 64 =>
            temp_btt_ls_unused := 3;
        when 32 =>
            temp_btt_ls_unused := 2;
        when 16 =>
            temp_btt_ls_unused := 1;
        when others =>  -- assume 8-bit transfers
            temp_btt_ls_unused := 0;
      end case;
      
      Return (temp_btt_ls_unused);
     
    end function funct_get_btt_ls_unused;
    
    
    
    
    
    
    
    
    
    -- Constant Declarations  ----------------------------------------
    
    Constant BASE_CMD_WIDTH      : integer := 32; -- Bit Width of Command LS (no address)
    Constant CMD_TYPE_INDEX      : integer := 23;
    Constant CMD_ADDR_LS_INDEX   : integer := BASE_CMD_WIDTH;
    Constant CMD_EOF_INDEX     : integer := BASE_CMD_WIDTH-2;
    Constant CMD_ADDR_MS_INDEX   : integer := (C_ADDR_WIDTH+BASE_CMD_WIDTH)-1;
    Constant CMD_TAG_WIDTH       : integer := C_TAG_WIDTH;
    Constant CMD_TAG_LS_INDEX    : integer := C_ADDR_WIDTH+BASE_CMD_WIDTH;
    Constant CMD_TAG_MS_INDEX    : integer := (CMD_TAG_LS_INDEX+CMD_TAG_WIDTH)-1;
    Constant AXI_BURST_FIXED     : std_logic_vector(1 downto 0) := "00";
    Constant AXI_BURST_INCR      : std_logic_vector(1 downto 0) := "01";
    Constant AXI_BURST_WRAP      : std_logic_vector(1 downto 0) := "10";
    Constant AXI_BURST_RESVD     : std_logic_vector(1 downto 0) := "11";
    Constant AXI_SIZE_1BYTE      : std_logic_vector(2 downto 0) := "000"; 
    Constant AXI_SIZE_2BYTE      : std_logic_vector(2 downto 0) := "001"; 
    Constant AXI_SIZE_4BYTE      : std_logic_vector(2 downto 0) := "010"; 
    Constant AXI_SIZE_8BYTE      : std_logic_vector(2 downto 0) := "011"; 
    Constant AXI_SIZE_16BYTE     : std_logic_vector(2 downto 0) := "100"; 
    Constant AXI_SIZE_32BYTE     : std_logic_vector(2 downto 0) := "101"; 
    Constant AXI_SIZE_64BYTE     : std_logic_vector(2 downto 0) := "110"; 
    Constant AXI_SIZE_128BYTE    : std_logic_vector(2 downto 0) := "111"; 
    Constant BTT_SLICE_SIZE      : integer := funct_get_slice_width(C_MAX_BURST_LEN);
    Constant MAX_BURST_LEN_US    : unsigned(BTT_SLICE_SIZE-1 downto 0) := 
                                   TO_UNSIGNED(C_MAX_BURST_LEN-1, BTT_SLICE_SIZE);
    Constant BTT_LS_UNUSED_WIDTH : integer := funct_get_btt_ls_unused(C_STREAM_DWIDTH);
    Constant CMD_BTT_WIDTH       : integer :=  BTT_SLICE_SIZE+BTT_LS_UNUSED_WIDTH;
    Constant CMD_BTT_LS_INDEX    : integer :=  0;
    Constant CMD_BTT_MS_INDEX    : integer :=  CMD_BTT_WIDTH-1;
    Constant BTT_ZEROS           : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0'); 
    Constant BTT_RESIDUE_ZEROS   : unsigned(BTT_LS_UNUSED_WIDTH-1 downto 0) := (others => '0'); 
    Constant BTT_SLICE_ONE       : unsigned(BTT_SLICE_SIZE-1 downto 0) := TO_UNSIGNED(1, BTT_SLICE_SIZE); 
    Constant STRB_WIDTH          : integer := C_STREAM_DWIDTH/8; -- Number of bytes in the Stream
    Constant LEN_WIDTH           : integer := 8; 
    
               
               
    -- Type Declarations  --------------------------------------------
    
    type SCC_SM_STATE_TYPE is (
                INIT,
                POP_RECOVER,
                GET_NXT_CMD,
                CHK_AND_CALC,
                PUSH_TO_AXI,
                ERROR_TRAP
                );
  
  
    
    
    
    -- Signal Declarations  --------------------------------------------
  
    signal sm_scc_state              : SCC_SM_STATE_TYPE := INIT;
    signal sm_scc_state_ns           : SCC_SM_STATE_TYPE := INIT;
    signal sm_pop_input_cmd          : std_logic := '0';
    signal sm_pop_input_cmd_ns       : std_logic := '0';
    signal sm_set_push2axi           : std_logic := '0';
    signal sm_set_push2axi_ns        : std_logic := '0';
    signal sm_set_error              : std_logic := '0';
    signal sm_set_error_ns           : std_logic := '0';
    Signal sm_scc_sm_ready           : std_logic := '0';
    Signal sm_scc_sm_ready_ns        : std_logic := '0';
    signal sig_cmd2data_valid        : std_logic := '0';
    signal sig_clr_cmd2data_valid    : std_logic := '0';
    signal sig_cmd2addr_valid        : std_logic := '0';
    signal sig_clr_cmd2addr_valid    : std_logic := '0';
    signal sig_addr_data_rdy_pending : std_logic := '0';
    signal sig_cmd_btt_slice         : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_load_input_cmd        : std_logic := '0';
    signal sig_cmd_reg_empty         : std_logic := '0';
    signal sig_cmd_reg_full          : std_logic := '0';
    signal sig_cmd_addr_reg          : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_btt_reg           : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_type_reg          : std_logic := '0';
    signal sig_cmd_burst_reg         : std_logic_vector (1 downto 0) := "00";
    signal sig_cmd_tag_reg           : std_logic_vector(CMD_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_data_rdy4cmd     : std_logic := '0';
    signal sig_btt_raw               : std_logic := '0';
    signal sig_btt_is_zero           : std_logic := '0';
    signal sig_btt_is_zero_reg       : std_logic := '0';
    signal sig_next_tag              : std_logic_vector(CMD_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_addr             : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_len              : std_logic_vector(LEN_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_size             : std_logic_vector(2 downto 0) := (others => '0');
    signal sig_next_burst            : std_logic_vector(1 downto 0) := (others => '0');
    signal sig_next_cache            : std_logic_vector(3 downto 0) := (others => '0');
    signal sig_next_user             : std_logic_vector(3 downto 0) := (others => '0');
    signal sig_next_strt_strb        : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_next_end_strb         : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_input_eof_reg         : std_logic;
    
  
    
    
  begin --(architecture implementation)
     
    -- Assign calculation error output 
    calc_error            <= sm_set_error;
   
    -- Assign the ready output to the Command FIFO 
    mst2cmd_cmd_ready     <= sig_cmd_reg_empty and sm_scc_sm_ready;
    
    -- Assign the Address Channel Controller Qualifiers
    mstr2addr_tag         <= sig_next_tag  ; 
    mstr2addr_addr        <= sig_next_addr ; 
    mstr2addr_len         <= sig_next_len  ; 
    mstr2addr_size        <= sig_next_size ;
    mstr2addr_burst       <= sig_cmd_burst_reg; 
    mstr2addr_cache       <= sig_next_cache; 
    mstr2addr_user        <= sig_next_user; 
    mstr2addr_cmd_valid   <= sig_cmd2addr_valid;
    mstr2addr_calc_error  <= sm_set_error  ; 
    mstr2addr_cmd_cmplt   <= '1'           ;   -- Lite mode is always 1 
    
    -- Assign the Data Channel Controller Qualifiers
    mstr2data_tag         <= sig_next_tag ; 
    mstr2data_saddr_lsb   <= sig_cmd_addr_reg(C_SEL_ADDR_WIDTH-1 downto 0);
    
    mstr2data_len         <= sig_next_len ;
    
    mstr2data_strt_strb   <= sig_next_strt_strb;
    mstr2data_last_strb   <= sig_next_end_strb;
    mstr2data_sof         <= '1';  -- Lite mode is always 1 cmd
    mstr2data_eof         <= sig_input_eof_reg;  -- Lite mode is always 1 cmd
    mstr2data_cmd_cmplt   <= '1';  -- Lite mode is always 1 cmd
    mstr2data_cmd_valid   <= sig_cmd2data_valid;
    mstr2data_calc_error  <= sm_set_error;   
    
    
    -- Internal logic ------------------------------
    sig_addr_data_rdy_pending  <=  sig_cmd2addr_valid or 
                                   sig_cmd2data_valid;
   
    sig_clr_cmd2data_valid     <=  sig_cmd2data_valid and data2mstr_cmd_ready;
    
    sig_clr_cmd2addr_valid     <=  sig_cmd2addr_valid and addr2mstr_cmd_ready;
    
    
    sig_load_input_cmd         <=  cmd2mstr_cmd_valid and 
                                   sig_cmd_reg_empty  and
                                   sm_scc_sm_ready;
    
    sig_next_tag               <=  sig_cmd_tag_reg;
    
    sig_next_addr              <=  sig_cmd_addr_reg;
    
    sig_addr_data_rdy4cmd      <=  addr2mstr_cmd_ready and data2mstr_cmd_ready;
    
    sig_cmd_btt_slice          <=  cmd2mstr_command(CMD_BTT_MS_INDEX downto CMD_BTT_LS_INDEX);
    
    sig_btt_is_zero  <= '1'
      when  (sig_cmd_btt_slice = BTT_ZEROS)
      Else '0';
    
  
  
    
 
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_RESIDUE_BITS
    --
    -- If Generate Description:
    --
    --
    --
    ------------------------------------------------------------
    GEN_NO_RESIDUE_BITS : if (BTT_LS_UNUSED_WIDTH = 0) generate
    
    
       -- signals 
       signal sig_len_btt_slice         : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       signal sig_len_btt_slice_minus_1 : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       signal sig_len2use               : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       
     
       begin
    
       -- LEN Calculation logic ------------------------------------------ 
        
         sig_next_len         <= STD_LOGIC_VECTOR(RESIZE(sig_len2use, LEN_WIDTH));
        
         sig_len_btt_slice    <= UNSIGNED(sig_cmd_btt_reg(CMD_BTT_MS_INDEX downto 0));
         
         sig_len_btt_slice_minus_1 <= sig_len_btt_slice-BTT_SLICE_ONE
          when sig_btt_is_zero_reg = '0'
          else (others => '0');    -- clip at zero
         
         
         -- If most significant bit of BTT set then limit to 
         -- Max Burst Len, else rip it from the BTT value,
         -- otheriwse subtract 1 from the BTT ripped value
         -- 1 from the BTT ripped value
         sig_len2use <= MAX_BURST_LEN_US 
           When (sig_cmd_btt_reg(CMD_BTT_MS_INDEX) = '1')
           Else sig_len_btt_slice_minus_1;
           
        
       end generate GEN_NO_RESIDUE_BITS;
        
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_HAS_RESIDUE_BITS
    --
    -- If Generate Description:
    --
    --
    --
    ------------------------------------------------------------
    GEN_HAS_RESIDUE_BITS : if (BTT_LS_UNUSED_WIDTH > 0) generate
    
       -- signals 
       signal sig_btt_len_residue       : unsigned(BTT_LS_UNUSED_WIDTH-1 downto 0) := (others => '0');
       signal sig_len_btt_slice         : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       signal sig_len_btt_slice_minus_1 : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       signal sig_len2use               : unsigned(BTT_SLICE_SIZE-1 downto 0) := (others => '0');
       
     
       begin
    
       -- LEN Calculation logic ------------------------------------------ 
        
         sig_next_len         <= STD_LOGIC_VECTOR(RESIZE(sig_len2use, LEN_WIDTH));
        
         sig_len_btt_slice    <= UNSIGNED(sig_cmd_btt_reg(CMD_BTT_MS_INDEX downto BTT_LS_UNUSED_WIDTH));
         
         sig_len_btt_slice_minus_1 <= sig_len_btt_slice-BTT_SLICE_ONE
          when sig_btt_is_zero_reg = '0'
          else (others => '0');    -- clip at zero
         
         sig_btt_len_residue  <= UNSIGNED(sig_cmd_btt_reg(BTT_LS_UNUSED_WIDTH-1 downto 0));
            
         
         -- If most significant bit of BTT set then limit to 
         -- Max Burst Len, else rip it from the BTT value
         -- However if residue bits are zeroes then subtract
         -- 1 from the BTT ripped value
         sig_len2use <= MAX_BURST_LEN_US 
           When (sig_cmd_btt_reg(CMD_BTT_MS_INDEX) = '1')
           Else sig_len_btt_slice_minus_1
           when (sig_btt_len_residue = BTT_RESIDUE_ZEROS)
           Else sig_len_btt_slice;

        
       end generate GEN_HAS_RESIDUE_BITS;
        
        
        
        
        
        
        
     
     
     
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_INPUT_CMD
    --
    -- Process Description:
    --  Implements the input command holding registers
    --
    -------------------------------------------------------------
    REG_INPUT_CMD : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset       = '1' or
                sm_pop_input_cmd = '1') then
            
              sig_cmd_btt_reg      <=  (others => '0');
              sig_cmd_type_reg     <=  '0';
              sig_cmd_addr_reg     <=  (others => '0');
              sig_cmd_tag_reg      <=  (others => '0');
              sig_btt_is_zero_reg  <=  '0';
              
              sig_cmd_reg_empty    <=  '1';
              sig_cmd_reg_full     <=  '0';
              sig_input_eof_reg    <= '0'; 
              sig_cmd_burst_reg    <=  "00";
            
            elsif (sig_load_input_cmd = '1') then
              
              sig_cmd_btt_reg      <= sig_cmd_btt_slice;
              sig_cmd_type_reg     <= cmd2mstr_command(CMD_TYPE_INDEX);
              sig_cmd_addr_reg     <= cmd2mstr_command(CMD_ADDR_MS_INDEX downto CMD_ADDR_LS_INDEX);  
              sig_cmd_tag_reg      <=  cmd2mstr_command(CMD_TAG_MS_INDEX downto CMD_TAG_LS_INDEX);
              sig_btt_is_zero_reg  <= sig_btt_is_zero;
              
              sig_cmd_reg_empty    <=  '0';
              sig_cmd_reg_full     <=  '1';

              sig_cmd_burst_reg    <= sig_next_burst;
              if (C_MICRO_DMA = 1) then  
                sig_input_eof_reg    <= cmd2mstr_command(CMD_EOF_INDEX);
              else
                sig_input_eof_reg    <= '1';
              end if;
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process REG_INPUT_CMD; 
   
   
    
    
    -- Only Incrementing Burst type supported (per Interface_X guidelines)
    sig_next_burst <= AXI_BURST_INCR when (cmd2mstr_command(CMD_TYPE_INDEX) = '1') else
                      AXI_BURST_FIXED;
    sig_next_user <= cache2mstr_command (7 downto 4);   
    sig_next_cache  <= cache2mstr_command (3 downto 0);   
 
 
  
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_LEN_SDWIDTH_64
    --
    -- If Generate Description:
    --  This IfGen implements the AXI LEN qualifier calculation
    -- and the Stream data channel start/end STRB value.  
    --
    -- This IfGen is for the 64-bit Stream data Width case.
    --
    ------------------------------------------------------------
    GEN_LEN_SDWIDTH_64 : if (C_STREAM_DWIDTH = 64) generate
    
       -- Local Constants
       Constant AXI_SIZE2USE      : std_logic_vector(2 downto 0) := AXI_SIZE_8BYTE;
       Constant RESIDUE_BIT_WIDTH : integer := 3;
       
       
       
       -- local signals
       signal sig_last_strb2use              : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       signal sig_last_strb                  : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       Signal sig_btt_ms_bit_value           : std_logic := '0';
       signal lsig_btt_len_residue           : std_logic_vector(BTT_LS_UNUSED_WIDTH-1 downto 0) := (others => '0');
       signal sig_btt_len_residue_composite  : std_logic_vector(RESIDUE_BIT_WIDTH downto 0) := (others => '0');
                                                                -- note 1 extra bit implied
                                                                
       
       begin
           
         -- Assign the Address Channel Controller Size Qualifier Value
         sig_next_size        <= AXI_SIZE2USE;
         
         -- Assign the Strobe Values
         sig_next_strt_strb   <= (others => '1'); -- always aligned on first databeat for LITE DataMover
         sig_next_end_strb    <= sig_last_strb;
        
        
         -- Local calculations ------------------------------
         
         lsig_btt_len_residue  <= sig_cmd_btt_reg(BTT_LS_UNUSED_WIDTH-1 downto 0);
         
         sig_btt_ms_bit_value  <= sig_cmd_btt_reg(CMD_BTT_MS_INDEX);
         
         sig_btt_len_residue_composite <= sig_btt_ms_bit_value &
                                          lsig_btt_len_residue;
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_LAST_STRB_8bit
         --
         -- Process Description:
         -- Generates the Strobe values for the LAST databeat of the
         -- Burst to MMap when the Stream is 64 bits wide and 8 strobe
         -- bits are required.
         --
         -------------------------------------------------------------
         IMP_LAST_STRB_8bit : process (sig_btt_len_residue_composite)
            begin
         
             case sig_btt_len_residue_composite is
               when "0001" =>
                 sig_last_strb <= "00000001";
               when "0010" =>
                 sig_last_strb <= "00000011";
               when "0011" =>
                 sig_last_strb <= "00000111";
               when "0100" =>
                 sig_last_strb <= "00001111";
               when "0101" =>
                 sig_last_strb <= "00011111";
               when "0110" =>
                 sig_last_strb <= "00111111";
               when "0111" =>
                 sig_last_strb <= "01111111";
               when others =>
                 sig_last_strb <= "11111111";
             end case;
             
             
            end process IMP_LAST_STRB_8bit; 
         
         
       end generate GEN_LEN_SDWIDTH_64;
  
  
  
  
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_LEN_SDWIDTH_32
    --
    -- If Generate Description:
    --  This IfGen implements the AXI LEN qualifier calculation
    -- and the Stream data channel start/end STRB value.  
    --
    -- This IfGen is for the 32-bit Stream data Width case.
    --
    ------------------------------------------------------------
    GEN_LEN_SDWIDTH_32 : if (C_STREAM_DWIDTH = 32) generate
    
       -- Local Constants
       Constant AXI_SIZE2USE                 : std_logic_vector(2 downto 0) := AXI_SIZE_4BYTE;
       Constant RESIDUE_BIT_WIDTH            : integer := 2;
       
       -- local signals
       signal sig_last_strb2use              : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       signal sig_last_strb                  : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       Signal sig_btt_ms_bit_value           : std_logic := '0';
       signal sig_btt_len_residue_composite  : std_logic_vector(RESIDUE_BIT_WIDTH downto 0) := (others => '0'); -- 1 extra bit
       signal lsig_btt_len_residue           : std_logic_vector(BTT_LS_UNUSED_WIDTH-1 downto 0) := (others => '0');
       
       
       begin
           
         -- Assign the Address Channel Controller Size Qualifier Value
         sig_next_size        <= AXI_SIZE2USE;
         
         -- Assign the Strobe Values
         sig_next_strt_strb   <= (others => '1'); -- always aligned on first databeat for LITE DataMover
         sig_next_end_strb    <= sig_last_strb;
        
        
         -- Local calculations ------------------------------
         
         lsig_btt_len_residue  <= sig_cmd_btt_reg(BTT_LS_UNUSED_WIDTH-1 downto 0);
         
         sig_btt_ms_bit_value <= sig_cmd_btt_reg(CMD_BTT_MS_INDEX);
         
         sig_btt_len_residue_composite <= sig_btt_ms_bit_value &
                                          lsig_btt_len_residue;
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_LAST_STRB_4bit
         --
         -- Process Description:
         -- Generates the Strobe values for the LAST databeat of the
         -- Burst to MMap when the Stream is 32 bits wide and 4 strobe
         -- bits are required.
         --
         -------------------------------------------------------------
         IMP_LAST_STRB_4bit : process (sig_btt_len_residue_composite)
            begin
         
             case sig_btt_len_residue_composite is
               when "001" =>
                 sig_last_strb <= "0001";
               when "010" =>
                 sig_last_strb <= "0011";
               when "011" =>
                 sig_last_strb <= "0111";
               when others =>
                 sig_last_strb <= "1111";
             end case;
             
             
            end process IMP_LAST_STRB_4bit; 
          
       end generate GEN_LEN_SDWIDTH_32;
  
  
  
  
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_LEN_SDWIDTH_16
    --
    -- If Generate Description:
    --  This IfGen implements the AXI LEN qualifier calculation
    -- and the Stream data channel start/end STRB value.  
    --
    -- This IfGen is for the 16-bit Stream data Width case.
    --
    ------------------------------------------------------------
    GEN_LEN_SDWIDTH_16 : if (C_STREAM_DWIDTH = 16) generate
    
       -- Local Constants
       Constant AXI_SIZE2USE      : std_logic_vector(2 downto 0) := AXI_SIZE_2BYTE;
       Constant RESIDUE_BIT_WIDTH : integer := 1;
       
       
       -- local signals
       signal sig_last_strb2use              : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       signal sig_last_strb                  : std_logic_vector(STRB_WIDTH-1 downto 0) := (others => '0');
       Signal sig_btt_ms_bit_value           : std_logic := '0';
       signal sig_btt_len_residue_composite  : std_logic_vector(RESIDUE_BIT_WIDTH downto 0) := (others => '0'); -- 1 extra bit
       signal lsig_btt_len_residue           : std_logic_vector(BTT_LS_UNUSED_WIDTH-1 downto 0) := (others => '0');
       
       
       begin
           
         -- Assign the Address Channel Controller Size Qualifier Value
         sig_next_size        <= AXI_SIZE2USE;
         
         -- Assign the Strobe Values
         sig_next_strt_strb   <= (others => '1'); -- always aligned on first databeat for LITE DataMover
         sig_next_end_strb    <= sig_last_strb;
        
        
         -- Local calculations ------------------------------
         
         lsig_btt_len_residue  <= sig_cmd_btt_reg(BTT_LS_UNUSED_WIDTH-1 downto 0);
         
         sig_btt_ms_bit_value  <= sig_cmd_btt_reg(CMD_BTT_MS_INDEX);
         
         sig_btt_len_residue_composite <= sig_btt_ms_bit_value &
                                          lsig_btt_len_residue;
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_LAST_STRB_2bit
         --
         -- Process Description:
         -- Generates the Strobe values for the LAST databeat of the
         -- Burst to MMap when the Stream is 16 bits wide and 2 strobe
         -- bits are required.
         --
         -------------------------------------------------------------
         IMP_LAST_STRB_2bit : process (sig_btt_len_residue_composite)
            begin
         
             case sig_btt_len_residue_composite is
               when "01" =>
                 sig_last_strb <= "01";
               when others =>
                 sig_last_strb <= "11";
             end case;
             
             
            end process IMP_LAST_STRB_2bit; 
         
         
       end generate GEN_LEN_SDWIDTH_16;
  
  
  
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_LEN_SDWIDTH_8
    --
    -- If Generate Description:
    --  This IfGen implements the AXI LEN qualifier calculation
    -- and the Stream data channel start/end STRB value.  
    --
    -- This IfGen is for the 8-bit Stream data Width case.
    --
    ------------------------------------------------------------
    GEN_LEN_SDWIDTH_8 : if (C_STREAM_DWIDTH = 8) generate
       
       -- Local Constants
       Constant AXI_SIZE2USE : std_logic_vector(2 downto 0) := AXI_SIZE_1BYTE;
       
       begin
    
           -- Assign the Address Channel Controller Qualifiers
         sig_next_size        <= AXI_SIZE2USE;
           
         -- Assign the Data Channel Controller Qualifiers
         sig_next_strt_strb   <= (others => '1');
         sig_next_end_strb    <= (others => '1');
          
          
       end generate GEN_LEN_SDWIDTH_8;
  
  
  
  
  
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CMD2DATA_VALID_FLOP
    --
    -- Process Description:
    --  Implements the set/reset flop for the Command Ready control
    -- to the Data Controller Module.
    --
    -------------------------------------------------------------
    CMD2DATA_VALID_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset             = '1' or
                sig_clr_cmd2data_valid = '1') then
    
              sig_cmd2data_valid <= '0';
              
            elsif (sm_set_push2axi_ns = '1') then
    
              sig_cmd2data_valid <= '1';
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process CMD2DATA_VALID_FLOP; 
      
      
      
      
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CMD2ADDR_VALID_FLOP
    --
    -- Process Description:
    --  Implements the set/reset flop for the Command Ready control
    -- to the Address Controller Module.
    --
    -------------------------------------------------------------
    CMD2ADDR_VALID_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset             = '1' or
                sig_clr_cmd2addr_valid = '1') then
    
              sig_cmd2addr_valid <= '0';
              
            elsif (sm_set_push2axi_ns = '1') then
    
              sig_cmd2addr_valid <= '1';
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process CMD2ADDR_VALID_FLOP; 
      
      
      
      
    
    
    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: SCC_SM_COMB
    --
    -- Process Description:
    -- Implements combinational portion of state machine
    --
    -------------------------------------------------------------
    SCC_SM_COMB : process (sm_scc_state,
                           cmd2mstr_cmd_valid,
                           sig_addr_data_rdy_pending, 
                           sig_cmd_reg_full,
                           sig_btt_is_zero_reg
                          )
       begin
    
         -- Set default State machine outputs
         sm_pop_input_cmd_ns  <= '0';
         sm_set_push2axi_ns   <= '0';
         sm_scc_state_ns      <= sm_scc_state;
         sm_set_error_ns      <= '0';
         sm_scc_sm_ready_ns   <= '1';
          
          
         case sm_scc_state is
           
           ----------------------------------------------------
           when INIT =>
             
             -- if (sig_addr_data_rdy4cmd = '1') then
             if (cmd2mstr_cmd_valid = '1') then  -- wait for first cmd valid after reset
             
               sm_scc_state_ns   <= GET_NXT_CMD;  -- jump to get command
       
              else
               
               sm_scc_sm_ready_ns <= '0';
               sm_scc_state_ns    <= INIT;  -- Stay in Init
              
              End if;
             
               
           ----------------------------------------------------
           when POP_RECOVER =>
           
               sm_scc_state_ns    <= GET_NXT_CMD;  -- jump to next state
           
             
           ----------------------------------------------------
           when GET_NXT_CMD =>
             
             if (sig_cmd_reg_full = '1') then
             
               sm_scc_state_ns    <= CHK_AND_CALC;  -- jump to next state
               
             else
             
               sm_scc_state_ns    <= GET_NXT_CMD;  -- stay in this state
             
             end if;
             
           
           ----------------------------------------------------
           when CHK_AND_CALC =>
             
             sm_set_push2axi_ns <= '1';  -- Push the command to ADDR and DATA
             
             if (sig_btt_is_zero_reg = '1') then
             
               sm_scc_state_ns    <= ERROR_TRAP;  -- jump to error trap
               sm_set_error_ns    <= '1';         -- Set internal error flag
               
             else
             
               sm_scc_state_ns    <= PUSH_TO_AXI;  
             
             end if;
             
           
           ----------------------------------------------------
           when PUSH_TO_AXI =>
           
             if (sig_addr_data_rdy_pending = '1') then
             
               sm_scc_state_ns    <= PUSH_TO_AXI;  -- stay in this state
                                                   -- until both Addr and Data have taken commands
             else
             
               sm_pop_input_cmd_ns  <= '1';
               sm_scc_state_ns      <= POP_RECOVER; -- jump back to fetch new cmd input 
             
             end if;
             
           
           
           ----------------------------------------------------
           when ERROR_TRAP =>
           
             sm_scc_state_ns    <= ERROR_TRAP;  -- stay in this state
             sm_set_error_ns    <= '1';
           
             
           ----------------------------------------------------
           when others =>
               
             sm_scc_state_ns    <= INIT; -- error so always jump to init state
               
         end case;
         
    
       end process SCC_SM_COMB; 
    
  
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: SCC_SM_REG
    --
    -- Process Description:
    -- Implements registered portion of state machine
    --
    -------------------------------------------------------------
    SCC_SM_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sm_scc_state      <= INIT;
              sm_pop_input_cmd  <= '0' ;           
              sm_set_push2axi   <= '0' ;           
              sm_set_error      <= '0' ;
              sm_scc_sm_ready   <= '0' ;
              
            else
              
              sm_scc_state      <= sm_scc_state_ns     ;
              sm_pop_input_cmd  <= sm_pop_input_cmd_ns ;           
              sm_set_push2axi   <= sm_set_push2axi_ns  ;           
              sm_set_error      <= sm_set_error_ns     ;
              sm_scc_sm_ready   <= sm_scc_sm_ready_ns  ;
              
            end if; 
         end if;       
       end process SCC_SM_REG; 
    
    
  
  
  
  end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_strb_gen2.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_strb_gen2.vhd
--
-- Description:     
--   Second generation AXI Strobe Generator module. This design leverages
-- look up table approach vs real-time calculation. This design method is 
-- used to reduce logic levels and improve final Fmax timing.               
--                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;




-------------------------------------------------------------------------------

entity axi_datamover_strb_gen2 is
  generic (
    C_OP_MODE            : Integer range 0 to 1 := 0; 
      -- 0 = offset/length mode 
      -- 1 = offset/offset mode,
      
    C_STRB_WIDTH         : Integer := 8; 
    -- number of addr bits needed
    
    C_OFFSET_WIDTH       : Integer := 3; 
    -- log2(C_STRB_WIDTH)
    
    C_NUM_BYTES_WIDTH    : Integer := 4 
      -- log2(C_STRB_WIDTH)+1 in offset/length mode (C_OP_MODE = 0)
      -- log2(C_STRB_WIDTH) in offset/offset mode   (C_OP_MODE = 1)
    );
  port (
    
    -- Starting offset input -----------------------------------------------------
                                                                                --
    start_addr_offset    : In  std_logic_vector(C_OFFSET_WIDTH-1 downto 0);     --
      -- Specifies the starting address offset of the strobe value              --
    ------------------------------------------------------------------------------
      -- used in both offset/offset and offset/length modes
      
    
    
    -- Endig Offset Input --------------------------------------------------------
                                                                                --
    end_addr_offset      : In  std_logic_vector(C_OFFSET_WIDTH-1 downto 0);     --
      -- Specifies the ending address offset of the strobe value                --
      -- used in only offset/offset mode (C_OP_MODE = 1)                        --
    ------------------------------------------------------------------------------
    
      
    -- Number of valid Bytes input (from starting offset) ------------------------
                                                                                --
    num_valid_bytes      : In  std_logic_vector(C_NUM_BYTES_WIDTH-1 downto 0);  --
      -- Specifies the number of valid bytes from starting offset               --
      -- used in only offset/length mode (C_OP_MODE = 0)                        --
    ------------------------------------------------------------------------------  
      
    
    -- Generated Strobe output ---------------------------------------------------  
                                                                                --
    strb_out             : out std_logic_vector(C_STRB_WIDTH-1 downto 0)        --
    ------------------------------------------------------------------------------
    
    
    );

end entity axi_datamover_strb_gen2;


architecture implementation of axi_datamover_strb_gen2 is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_2
  --
  -- Function Description:
  --   returns the 2-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_2 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(1 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "11";
      when others =>
        var_start_vector := "10";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_2;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_2
  --
  -- Function Description:
  --   Returns the 2-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_2 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(1 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "01";
      when others =>
        var_end_vector := "11";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_2; 
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_4
  --
  -- Function Description:
  --   returns the 4-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_4 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(3 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "1111";
      when 1 =>
        var_start_vector := "1110";
      when 2 =>
        var_start_vector := "1100";
      when others =>
        var_start_vector := "1000";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_4;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_4
  --
  -- Function Description:
  --   Returns the 4-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_4 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(3 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "0001";
      when 1 =>
        var_end_vector := "0011";
      when 2 =>
        var_end_vector := "0111";
      when others =>
        var_end_vector := "1111";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_4; 
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_8
  --
  -- Function Description:
  --   returns the 8-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_8 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(7 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "11111111";
      when 1 =>
        var_start_vector := "11111110";
      when 2 =>
        var_start_vector := "11111100";
      when 3 =>
        var_start_vector := "11111000";
      when 4 =>
        var_start_vector := "11110000";
      when 5 =>
        var_start_vector := "11100000";
      when 6 =>
        var_start_vector := "11000000";
      when others =>
        var_start_vector := "10000000";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_8;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_8
  --
  -- Function Description:
  --   Returns the 8-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_8 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(7 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "00000001";
      when 1 =>
        var_end_vector := "00000011";
      when 2 =>
        var_end_vector := "00000111";
      when 3 =>
        var_end_vector := "00001111";
      when 4 =>
        var_end_vector := "00011111";
      when 5 =>
        var_end_vector := "00111111";
      when 6 =>
        var_end_vector := "01111111";
      when others =>
        var_end_vector := "11111111";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_8; 
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_16
  --
  -- Function Description:
  --   returns the 16-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_16 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(15 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "1111111111111111";
      when 1 =>
        var_start_vector := "1111111111111110";
      when 2 =>
        var_start_vector := "1111111111111100";
      when 3 =>
        var_start_vector := "1111111111111000";
      when 4 =>
        var_start_vector := "1111111111110000";
      when 5 =>
        var_start_vector := "1111111111100000";
      when 6 =>
        var_start_vector := "1111111111000000";
      when 7 =>
        var_start_vector := "1111111110000000";
      when 8 =>
        var_start_vector := "1111111100000000";
      when 9 =>
        var_start_vector := "1111111000000000";
      when 10 =>
        var_start_vector := "1111110000000000";
      when 11 =>
        var_start_vector := "1111100000000000";
      when 12 =>
        var_start_vector := "1111000000000000";
      when 13 =>
        var_start_vector := "1110000000000000";
      when 14 =>
        var_start_vector := "1100000000000000";
      when others =>
        var_start_vector := "1000000000000000";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_16;
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_16
  --
  -- Function Description:
  --   Returns the 16-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_16 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(15 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "0000000000000001";
      when 1 =>
        var_end_vector := "0000000000000011";
      when 2 =>
        var_end_vector := "0000000000000111";
      when 3 =>
        var_end_vector := "0000000000001111";
      when 4 =>
        var_end_vector := "0000000000011111";
      when 5 =>
        var_end_vector := "0000000000111111";
      when 6 =>
        var_end_vector := "0000000001111111";
      when 7 =>
        var_end_vector := "0000000011111111";
      when 8 =>
        var_end_vector := "0000000111111111";
      when 9 =>
        var_end_vector := "0000001111111111";
      when 10 =>
        var_end_vector := "0000011111111111";
      when 11 =>
        var_end_vector := "0000111111111111";
      when 12 =>
        var_end_vector := "0001111111111111";
      when 13 =>
        var_end_vector := "0011111111111111";
      when 14 =>
        var_end_vector := "0111111111111111";
      when others =>
        var_end_vector := "1111111111111111";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_16;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_32
  --
  -- Function Description:
  --   returns the 32-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_32 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(31 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "11111111111111111111111111111111";
      when 1 =>
        var_start_vector := "11111111111111111111111111111110";
      when 2 =>
        var_start_vector := "11111111111111111111111111111100";
      when 3 =>
        var_start_vector := "11111111111111111111111111111000";
      when 4 =>
        var_start_vector := "11111111111111111111111111110000";
      when 5 =>
        var_start_vector := "11111111111111111111111111100000";
      when 6 =>
        var_start_vector := "11111111111111111111111111000000";
      when 7 =>
        var_start_vector := "11111111111111111111111110000000";
      when 8 =>
        var_start_vector := "11111111111111111111111100000000";
      when 9 =>
        var_start_vector := "11111111111111111111111000000000";
      when 10 =>
        var_start_vector := "11111111111111111111110000000000";
      when 11 =>
        var_start_vector := "11111111111111111111100000000000";
      when 12 =>
        var_start_vector := "11111111111111111111000000000000";
      when 13 =>
        var_start_vector := "11111111111111111110000000000000";
      when 14 =>
        var_start_vector := "11111111111111111100000000000000";
      when 15 =>
        var_start_vector := "11111111111111111000000000000000";
      when 16 =>
        var_start_vector := "11111111111111110000000000000000";
      when 17 =>
        var_start_vector := "11111111111111100000000000000000";
      when 18 =>
        var_start_vector := "11111111111111000000000000000000";
      when 19 =>
        var_start_vector := "11111111111110000000000000000000";
      when 20 =>
        var_start_vector := "11111111111100000000000000000000";
      when 21 =>
        var_start_vector := "11111111111000000000000000000000";
      when 22 =>
        var_start_vector := "11111111110000000000000000000000";
      when 23 =>
        var_start_vector := "11111111100000000000000000000000";
      when 24 =>
        var_start_vector := "11111111000000000000000000000000";
      when 25 =>
        var_start_vector := "11111110000000000000000000000000";
      when 26 =>
        var_start_vector := "11111100000000000000000000000000";
      when 27 =>
        var_start_vector := "11111000000000000000000000000000";
      when 28 =>
        var_start_vector := "11110000000000000000000000000000";
      when 29 =>
        var_start_vector := "11100000000000000000000000000000";
      when 30 =>
        var_start_vector := "11000000000000000000000000000000";
      when others =>
        var_start_vector := "10000000000000000000000000000000";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_32;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_32
  --
  -- Function Description:
  --   Returns the 32-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_32 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(31 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "00000000000000000000000000000001";
      when 1 =>
        var_end_vector := "00000000000000000000000000000011";
      when 2 =>
        var_end_vector := "00000000000000000000000000000111";
      when 3 =>
        var_end_vector := "00000000000000000000000000001111";
      when 4 =>
        var_end_vector := "00000000000000000000000000011111";
      when 5 =>
        var_end_vector := "00000000000000000000000000111111";
      when 6 =>
        var_end_vector := "00000000000000000000000001111111";
      when 7 =>
        var_end_vector := "00000000000000000000000011111111";
      when 8 =>
        var_end_vector := "00000000000000000000000111111111";
      when 9 =>
        var_end_vector := "00000000000000000000001111111111";
      when 10 =>
        var_end_vector := "00000000000000000000011111111111";
      when 11 =>
        var_end_vector := "00000000000000000000111111111111";
      when 12 =>
        var_end_vector := "00000000000000000001111111111111";
      when 13 =>
        var_end_vector := "00000000000000000011111111111111";
      when 14 =>
        var_end_vector := "00000000000000000111111111111111";
      when 15 =>
        var_end_vector := "00000000000000001111111111111111";
      when 16 =>
        var_end_vector := "00000000000000011111111111111111";
      when 17 =>
        var_end_vector := "00000000000000111111111111111111";
      when 18 =>
        var_end_vector := "00000000000001111111111111111111";
      when 19 =>
        var_end_vector := "00000000000011111111111111111111";
      when 20 =>
        var_end_vector := "00000000000111111111111111111111";
      when 21 =>
        var_end_vector := "00000000001111111111111111111111";
      when 22 =>
        var_end_vector := "00000000011111111111111111111111";
      when 23 =>
        var_end_vector := "00000000111111111111111111111111";
      when 24 =>
        var_end_vector := "00000001111111111111111111111111";
      when 25 =>
        var_end_vector := "00000011111111111111111111111111";
      when 26 =>
        var_end_vector := "00000111111111111111111111111111";
      when 27 =>
        var_end_vector := "00001111111111111111111111111111";
      when 28 =>
        var_end_vector := "00011111111111111111111111111111";
      when 29 =>
        var_end_vector := "00111111111111111111111111111111";
      when 30 =>
        var_end_vector := "01111111111111111111111111111111";
      when others =>
        var_end_vector := "11111111111111111111111111111111";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_32;
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_64
  --
  -- Function Description:
  --   returns the 64-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_64 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(63 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111111111";
      when 1 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111111110";
      when 2 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111111100";
      when 3 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111111000";
      when 4 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111110000";
      when 5 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111100000";
      when 6 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111111000000";
      when 7 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111110000000";
      when 8 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111100000000";
      when 9 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111111000000000";
      when 10 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111110000000000";
      when 11 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111100000000000";
      when 12 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111111000000000000";
      when 13 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111110000000000000";
      when 14 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111100000000000000";
      when 15 =>
        var_start_vector := "1111111111111111111111111111111111111111111111111000000000000000";
      when 16 =>
        var_start_vector := "1111111111111111111111111111111111111111111111110000000000000000";
      when 17 =>
        var_start_vector := "1111111111111111111111111111111111111111111111100000000000000000";
      when 18 =>
        var_start_vector := "1111111111111111111111111111111111111111111111000000000000000000";
      when 19 =>
        var_start_vector := "1111111111111111111111111111111111111111111110000000000000000000";
      when 20 =>
        var_start_vector := "1111111111111111111111111111111111111111111100000000000000000000";
      when 21 =>
        var_start_vector := "1111111111111111111111111111111111111111111000000000000000000000";
      when 22 =>
        var_start_vector := "1111111111111111111111111111111111111111110000000000000000000000";
      when 23 =>
        var_start_vector := "1111111111111111111111111111111111111111100000000000000000000000";
      when 24 =>
        var_start_vector := "1111111111111111111111111111111111111111000000000000000000000000";
      when 25 =>
        var_start_vector := "1111111111111111111111111111111111111110000000000000000000000000";
      when 26 =>
        var_start_vector := "1111111111111111111111111111111111111100000000000000000000000000";
      when 27 =>
        var_start_vector := "1111111111111111111111111111111111111000000000000000000000000000";
      when 28 =>
        var_start_vector := "1111111111111111111111111111111111110000000000000000000000000000";
      when 29 =>
        var_start_vector := "1111111111111111111111111111111111100000000000000000000000000000";
      when 30 =>
        var_start_vector := "1111111111111111111111111111111111000000000000000000000000000000";
      when 31 =>
        var_start_vector := "1111111111111111111111111111111110000000000000000000000000000000";
      when 32 =>
        var_start_vector := "1111111111111111111111111111111100000000000000000000000000000000";
      when 33 =>
        var_start_vector := "1111111111111111111111111111111000000000000000000000000000000000";
      when 34 =>
        var_start_vector := "1111111111111111111111111111110000000000000000000000000000000000";
      when 35 =>                                                                             
        var_start_vector := "1111111111111111111111111111100000000000000000000000000000000000";
      when 36 =>                                                                             
        var_start_vector := "1111111111111111111111111111000000000000000000000000000000000000";
      when 37 =>                                                                             
        var_start_vector := "1111111111111111111111111110000000000000000000000000000000000000";
      when 38 =>                                                                             
        var_start_vector := "1111111111111111111111111100000000000000000000000000000000000000";
      when 39 =>                                                                             
        var_start_vector := "1111111111111111111111111000000000000000000000000000000000000000";
      when 40 =>                                                                             
        var_start_vector := "1111111111111111111111110000000000000000000000000000000000000000";
      when 41 =>                                                                             
        var_start_vector := "1111111111111111111111100000000000000000000000000000000000000000";
      when 42 =>                                                                             
        var_start_vector := "1111111111111111111111000000000000000000000000000000000000000000";
      when 43 =>                                                                             
        var_start_vector := "1111111111111111111110000000000000000000000000000000000000000000";
      when 44 =>                                                                             
        var_start_vector := "1111111111111111111100000000000000000000000000000000000000000000";
      when 45 =>                                                                             
        var_start_vector := "1111111111111111111000000000000000000000000000000000000000000000";
      when 46 =>                                                                             
        var_start_vector := "1111111111111111110000000000000000000000000000000000000000000000";
      when 47 =>                                                                             
        var_start_vector := "1111111111111111100000000000000000000000000000000000000000000000";
      when 48 =>                                                                             
        var_start_vector := "1111111111111111000000000000000000000000000000000000000000000000";
      when 49 =>                                                                             
        var_start_vector := "1111111111111110000000000000000000000000000000000000000000000000";
      when 50 =>                                                                             
        var_start_vector := "1111111111111100000000000000000000000000000000000000000000000000";
      when 51 =>                                                                             
        var_start_vector := "1111111111111000000000000000000000000000000000000000000000000000";
      when 52 =>                                                                             
        var_start_vector := "1111111111110000000000000000000000000000000000000000000000000000";
      when 53 =>                                                                             
        var_start_vector := "1111111111100000000000000000000000000000000000000000000000000000";
      when 54 =>                                                                             
        var_start_vector := "1111111111000000000000000000000000000000000000000000000000000000";
      when 55 =>                                                                             
        var_start_vector := "1111111110000000000000000000000000000000000000000000000000000000";
      when 56 =>                                                                             
        var_start_vector := "1111111100000000000000000000000000000000000000000000000000000000";
      when 57 =>                                                                             
        var_start_vector := "1111111000000000000000000000000000000000000000000000000000000000";
      when 58 =>                                                                             
        var_start_vector := "1111110000000000000000000000000000000000000000000000000000000000";
      when 59 =>                                                                             
        var_start_vector := "1111100000000000000000000000000000000000000000000000000000000000";
      when 60 =>                                                                             
        var_start_vector := "1111000000000000000000000000000000000000000000000000000000000000";
      when 61 =>                                                                             
        var_start_vector := "1110000000000000000000000000000000000000000000000000000000000000";
      when 62 =>                                                                             
        var_start_vector := "1100000000000000000000000000000000000000000000000000000000000000";
      when others =>                                                                         
        var_start_vector := "1000000000000000000000000000000000000000000000000000000000000000";
    end case;
   
    Return (var_start_vector);
   
  end function get_start_64;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_64
  --
  -- Function Description:
  --   Returns the 64-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_64 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(63 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000000001";
      when 1 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000000011";
      when 2 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000000111";
      when 3 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000001111";                    
      when 4 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000011111";
      when 5 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000000111111";
      when 6 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000001111111";
      when 7 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000011111111";
      when 8 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000000111111111";
      when 9 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000001111111111";
      when 10 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000011111111111";
      when 11 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000000111111111111";
      when 12 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000001111111111111";
      when 13 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000011111111111111";
      when 14 =>
        var_end_vector := "0000000000000000000000000000000000000000000000000111111111111111";
      when 15 =>
        var_end_vector := "0000000000000000000000000000000000000000000000001111111111111111";
      when 16 =>
        var_end_vector := "0000000000000000000000000000000000000000000000011111111111111111";
      when 17 =>
        var_end_vector := "0000000000000000000000000000000000000000000000111111111111111111";
      when 18 =>
        var_end_vector := "0000000000000000000000000000000000000000000001111111111111111111";
      when 19 =>
        var_end_vector := "0000000000000000000000000000000000000000000011111111111111111111";
      when 20 =>
        var_end_vector := "0000000000000000000000000000000000000000000111111111111111111111";
      when 21 =>
        var_end_vector := "0000000000000000000000000000000000000000001111111111111111111111";
      when 22 =>
        var_end_vector := "0000000000000000000000000000000000000000011111111111111111111111";
      when 23 =>
        var_end_vector := "0000000000000000000000000000000000000000111111111111111111111111";
      when 24 =>
        var_end_vector := "0000000000000000000000000000000000000001111111111111111111111111";
      when 25 =>
        var_end_vector := "0000000000000000000000000000000000000011111111111111111111111111";
      when 26 =>
        var_end_vector := "0000000000000000000000000000000000000111111111111111111111111111";
      when 27 =>
        var_end_vector := "0000000000000000000000000000000000001111111111111111111111111111";
      when 28 =>
        var_end_vector := "0000000000000000000000000000000000011111111111111111111111111111";
      when 29 =>
        var_end_vector := "0000000000000000000000000000000000111111111111111111111111111111";
      when 30 =>
        var_end_vector := "0000000000000000000000000000000001111111111111111111111111111111";
      when 31 =>
        var_end_vector := "0000000000000000000000000000000011111111111111111111111111111111";
      
      when 32 =>
        var_end_vector := "0000000000000000000000000000000111111111111111111111111111111111";
      when 33 =>
        var_end_vector := "0000000000000000000000000000001111111111111111111111111111111111";
      when 34 =>
        var_end_vector := "0000000000000000000000000000011111111111111111111111111111111111";
      when 35 =>
        var_end_vector := "0000000000000000000000000000111111111111111111111111111111111111";
      when 36 =>
        var_end_vector := "0000000000000000000000000001111111111111111111111111111111111111";
      when 37 =>
        var_end_vector := "0000000000000000000000000011111111111111111111111111111111111111";
      when 38 =>
        var_end_vector := "0000000000000000000000000111111111111111111111111111111111111111";
      when 39 =>
        var_end_vector := "0000000000000000000000001111111111111111111111111111111111111111";
      when 40 =>
        var_end_vector := "0000000000000000000000011111111111111111111111111111111111111111";
      when 41 =>
        var_end_vector := "0000000000000000000000111111111111111111111111111111111111111111";
      when 42 =>
        var_end_vector := "0000000000000000000001111111111111111111111111111111111111111111";
      when 43 =>
        var_end_vector := "0000000000000000000011111111111111111111111111111111111111111111";
      when 44 =>
        var_end_vector := "0000000000000000000111111111111111111111111111111111111111111111";
      when 45 =>
        var_end_vector := "0000000000000000001111111111111111111111111111111111111111111111";
      when 46 =>
        var_end_vector := "0000000000000000011111111111111111111111111111111111111111111111";
      when 47 =>
        var_end_vector := "0000000000000000111111111111111111111111111111111111111111111111";
      when 48 =>
        var_end_vector := "0000000000000001111111111111111111111111111111111111111111111111";
      when 49 =>
        var_end_vector := "0000000000000011111111111111111111111111111111111111111111111111";
      when 50 =>
        var_end_vector := "0000000000000111111111111111111111111111111111111111111111111111";
      when 51 =>
        var_end_vector := "0000000000001111111111111111111111111111111111111111111111111111";
      when 52 =>
        var_end_vector := "0000000000011111111111111111111111111111111111111111111111111111";
      when 53 =>
        var_end_vector := "0000000000111111111111111111111111111111111111111111111111111111";
      when 54 =>
        var_end_vector := "0000000001111111111111111111111111111111111111111111111111111111";
      when 55 =>
        var_end_vector := "0000000011111111111111111111111111111111111111111111111111111111";
      when 56 =>
        var_end_vector := "0000000111111111111111111111111111111111111111111111111111111111";
      when 57 =>
        var_end_vector := "0000001111111111111111111111111111111111111111111111111111111111";
      when 58 =>
        var_end_vector := "0000011111111111111111111111111111111111111111111111111111111111";
      when 59 =>
        var_end_vector := "0000111111111111111111111111111111111111111111111111111111111111";
      when 60 =>
        var_end_vector := "0001111111111111111111111111111111111111111111111111111111111111";
      when 61 =>
        var_end_vector := "0011111111111111111111111111111111111111111111111111111111111111";
      when 62 =>
        var_end_vector := "0111111111111111111111111111111111111111111111111111111111111111";
      
      when others =>
        var_end_vector := "1111111111111111111111111111111111111111111111111111111111111111";
    end case;
   
    Return (var_end_vector);
   
  end function get_end_64;
 
 
 
 
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_start_128
  --
  -- Function Description:
  --   returns the 128-bit vector filled with '1's from the start
  -- offset to the end of of the vector
  --
  -------------------------------------------------------------------
  function get_start_128 (start_offset : natural) return std_logic_vector is
  
    Variable var_start_vector : std_logic_vector(127 downto 0) := (others => '0');
  
  begin
  
    case start_offset is
      when 0 =>
        
        var_start_vector(127 downto 0) := (others => '1');
      
      when 1 =>
        
        var_start_vector(127 downto 1) := (others => '1');
        var_start_vector(  0 downto 0) := (others => '0');
      
      when 2 =>
        
        var_start_vector(127 downto 2) := (others => '1');
        var_start_vector(  1 downto 0) := (others => '0');
      
      when 3 =>
        
        var_start_vector(127 downto 3) := (others => '1');
        var_start_vector(  2 downto 0) := (others => '0');
      
      when 4 =>
        
        var_start_vector(127 downto 4) := (others => '1');
        var_start_vector(  3 downto 0) := (others => '0');
      
      when 5 =>
        
        var_start_vector(127 downto 5) := (others => '1');
        var_start_vector(  4 downto 0) := (others => '0');
      
      when 6 =>
        
        var_start_vector(127 downto 6) := (others => '1');
        var_start_vector(  5 downto 0) := (others => '0');
      
      when 7 =>
        
        var_start_vector(127 downto 7) := (others => '1');
        var_start_vector(  6 downto 0) := (others => '0');
      
      when 8 =>
        
        var_start_vector(127 downto 8) := (others => '1');
        var_start_vector(  7 downto 0) := (others => '0');
      
      when 9 =>
        
        var_start_vector(127 downto 9) := (others => '1');
        var_start_vector(  8 downto 0) := (others => '0');
      
      when 10 =>
        
        var_start_vector(127 downto 10) := (others => '1');
        var_start_vector(  9 downto 0) := (others => '0');
      
      when 11 =>
        
        var_start_vector(127 downto 11) := (others => '1');
        var_start_vector( 10 downto  0) := (others => '0');
      
      when 12 =>
        
        var_start_vector(127 downto 12) := (others => '1');
        var_start_vector( 11 downto  0) := (others => '0');
      
      when 13 =>
        
        var_start_vector(127 downto 13) := (others => '1');
        var_start_vector( 12 downto  0) := (others => '0');
      
      when 14 =>
        
        var_start_vector(127 downto 14) := (others => '1');
        var_start_vector( 13 downto  0) := (others => '0');
      
      when 15 =>
        
        var_start_vector(127 downto 15) := (others => '1');
        var_start_vector( 14 downto  0) := (others => '0');
      
      when 16 =>
        
        var_start_vector(127 downto 16) := (others => '1');
        var_start_vector( 15 downto  0) := (others => '0');
      
      when 17 =>
        
        var_start_vector(127 downto 17) := (others => '1');
        var_start_vector( 16 downto  0) := (others => '0');
      
      when 18 =>
        
        var_start_vector(127 downto 18) := (others => '1');
        var_start_vector( 17 downto  0) := (others => '0');
      
      when 19 =>
        
        var_start_vector(127 downto 19) := (others => '1');
        var_start_vector( 18 downto  0) := (others => '0');
      
      when 20 =>
        
        var_start_vector(127 downto 20) := (others => '1');
        var_start_vector( 19 downto  0) := (others => '0');
      
      when 21 =>
        
        var_start_vector(127 downto 21) := (others => '1');
        var_start_vector( 20 downto  0) := (others => '0');
      
      when 22 =>
        
        var_start_vector(127 downto 22) := (others => '1');
        var_start_vector( 21 downto  0) := (others => '0');
      
      when 23 =>
        
        var_start_vector(127 downto 23) := (others => '1');
        var_start_vector( 22 downto  0) := (others => '0');
      
      when 24 =>
        
        var_start_vector(127 downto 24) := (others => '1');
        var_start_vector( 23 downto  0) := (others => '0');
      
      when 25 =>
        
        var_start_vector(127 downto 25) := (others => '1');
        var_start_vector( 24 downto  0) := (others => '0');
      
      when 26 =>
        
        var_start_vector(127 downto 26) := (others => '1');
        var_start_vector( 25 downto  0) := (others => '0');
      
      when 27 =>
        
        var_start_vector(127 downto 27) := (others => '1');
        var_start_vector( 26 downto  0) := (others => '0');
      
      when 28 =>
        
        var_start_vector(127 downto 28) := (others => '1');
        var_start_vector( 27 downto  0) := (others => '0');
      
      when 29 =>
        
        var_start_vector(127 downto 29) := (others => '1');
        var_start_vector( 28 downto  0) := (others => '0');
      
      when 30 =>
        
        var_start_vector(127 downto 30) := (others => '1');
        var_start_vector( 29 downto  0) := (others => '0');
      
      when 31 =>
        
        var_start_vector(127 downto 31) := (others => '1');
        var_start_vector( 30 downto  0) := (others => '0');
      
      
      
      when 32 =>
        
        var_start_vector(127 downto 32) := (others => '1');
        var_start_vector( 31 downto  0) := (others => '0');
      
      when 33 =>
        
        var_start_vector(127 downto 33) := (others => '1');
        var_start_vector( 32 downto  0) := (others => '0');
      
      when 34 =>
        
        var_start_vector(127 downto 34) := (others => '1');
        var_start_vector( 33 downto  0) := (others => '0');
      
      when 35 =>
        
        var_start_vector(127 downto 35) := (others => '1');
        var_start_vector( 34 downto  0) := (others => '0');
      
      when 36 =>
        
        var_start_vector(127 downto 36) := (others => '1');
        var_start_vector( 35 downto  0) := (others => '0');
      
      when 37 =>
        
        var_start_vector(127 downto 37) := (others => '1');
        var_start_vector( 36 downto  0) := (others => '0');
      
      when 38 =>
        
        var_start_vector(127 downto 38) := (others => '1');
        var_start_vector( 37 downto  0) := (others => '0');
      
      when 39 =>
        
        var_start_vector(127 downto 39) := (others => '1');
        var_start_vector( 38 downto  0) := (others => '0');
      
      when 40 =>
        
        var_start_vector(127 downto 40) := (others => '1');
        var_start_vector( 39 downto  0) := (others => '0');
      
      when 41 =>
        
        var_start_vector(127 downto 41) := (others => '1');
        var_start_vector( 40 downto  0) := (others => '0');
      
      when 42 =>
        
        var_start_vector(127 downto 42) := (others => '1');
        var_start_vector( 41 downto  0) := (others => '0');
      
      when 43 =>
        
        var_start_vector(127 downto 43) := (others => '1');
        var_start_vector( 42 downto  0) := (others => '0');
      
      when 44 =>
        
        var_start_vector(127 downto 44) := (others => '1');
        var_start_vector( 43 downto  0) := (others => '0');
      
      when 45 =>
        
        var_start_vector(127 downto 45) := (others => '1');
        var_start_vector( 44 downto  0) := (others => '0');
      
      when 46 =>
        
        var_start_vector(127 downto 46) := (others => '1');
        var_start_vector( 45 downto  0) := (others => '0');
      
      when 47 =>
        
        var_start_vector(127 downto 47) := (others => '1');
        var_start_vector( 46 downto  0) := (others => '0');
      
      when 48 =>
        
        var_start_vector(127 downto 48) := (others => '1');
        var_start_vector( 47 downto  0) := (others => '0');
      
      when 49 =>
        
        var_start_vector(127 downto 49) := (others => '1');
        var_start_vector( 48 downto  0) := (others => '0');
      
      when 50 =>
        
        var_start_vector(127 downto 50) := (others => '1');
        var_start_vector( 49 downto  0) := (others => '0');
      
      when 51 =>
        
        var_start_vector(127 downto 51) := (others => '1');
        var_start_vector( 50 downto  0) := (others => '0');
      
      when 52 =>
        
        var_start_vector(127 downto 52) := (others => '1');
        var_start_vector( 51 downto  0) := (others => '0');
      
      when 53 =>
        
        var_start_vector(127 downto 53) := (others => '1');
        var_start_vector( 52 downto  0) := (others => '0');
      
      when 54 =>
        
        var_start_vector(127 downto 54) := (others => '1');
        var_start_vector( 53 downto  0) := (others => '0');
      
      when 55 =>
        
        var_start_vector(127 downto 55) := (others => '1');
        var_start_vector( 54 downto  0) := (others => '0');
      
      when 56 =>
        
        var_start_vector(127 downto 56) := (others => '1');
        var_start_vector( 55 downto  0) := (others => '0');
      
      when 57 =>
        
        var_start_vector(127 downto 57) := (others => '1');
        var_start_vector( 56 downto  0) := (others => '0');
      
      when 58 =>
        
        var_start_vector(127 downto 58) := (others => '1');
        var_start_vector( 57 downto  0) := (others => '0');
      
      when 59 =>
        
        var_start_vector(127 downto 59) := (others => '1');
        var_start_vector( 58 downto  0) := (others => '0');
      
      when 60 =>
        
        var_start_vector(127 downto 60) := (others => '1');
        var_start_vector( 59 downto  0) := (others => '0');
      
      when 61 =>
        
        var_start_vector(127 downto 61) := (others => '1');
        var_start_vector( 60 downto  0) := (others => '0');
      
      when 62 =>
        
        var_start_vector(127 downto 62) := (others => '1');
        var_start_vector( 61 downto  0) := (others => '0');
      
      when 63 =>
        
        var_start_vector(127 downto 63) := (others => '1');
        var_start_vector( 62 downto  0) := (others => '0');
      
      
      
      
      when 64 =>
        
        var_start_vector(127 downto 64) := (others => '1');
        var_start_vector( 63 downto  0) := (others => '0');
 
      when 65 =>
        
        var_start_vector(127 downto 65) := (others => '1');
        var_start_vector( 64 downto  0) := (others => '0');
      
      when 66 =>                                                                           
        
        var_start_vector(127 downto 66) := (others => '1');
        var_start_vector( 65 downto  0) := (others => '0');
      
      when 67 =>                                                                           
        
        var_start_vector(127 downto 67) := (others => '1');
        var_start_vector( 66 downto  0) := (others => '0');
      
      when 68 =>                                                                           
        
        var_start_vector(127 downto 68) := (others => '1');
        var_start_vector( 67 downto  0) := (others => '0');
      
      when 69 =>                                                                           
        
        var_start_vector(127 downto 69) := (others => '1');
        var_start_vector( 68 downto  0) := (others => '0');
      
      when 70 =>                                                                           
        
        var_start_vector(127 downto 70) := (others => '1');
        var_start_vector( 69 downto  0) := (others => '0');
      
      when 71 =>                                                                           
        
        var_start_vector(127 downto 71) := (others => '1');
        var_start_vector( 70 downto  0) := (others => '0');
      
      when 72 =>                                                                           
        
        var_start_vector(127 downto 72) := (others => '1');
        var_start_vector( 71 downto  0) := (others => '0');
      
      when 73 =>                                                                           
        
        var_start_vector(127 downto 73) := (others => '1');
        var_start_vector( 72 downto  0) := (others => '0');
      
      when 74 =>                                                                           
        
        var_start_vector(127 downto 74) := (others => '1');
        var_start_vector( 73 downto  0) := (others => '0');
      
      when 75 =>                                                                           
        
        var_start_vector(127 downto 75) := (others => '1');
        var_start_vector( 74 downto  0) := (others => '0');
      
      when 76 =>                                                                           
        
        var_start_vector(127 downto 76) := (others => '1');
        var_start_vector( 75 downto  0) := (others => '0');
      
      when 77 =>                                                                           
        
        var_start_vector(127 downto 77) := (others => '1');
        var_start_vector( 76 downto  0) := (others => '0');
      
      when 78 =>                                                                           
        
        var_start_vector(127 downto 78) := (others => '1');
        var_start_vector( 77 downto  0) := (others => '0');
      
      when 79 =>                                                                           
        
        var_start_vector(127 downto 79) := (others => '1');
        var_start_vector( 78 downto  0) := (others => '0');
      
      when 80 =>                                                                           
        
        var_start_vector(127 downto 80) := (others => '1');
        var_start_vector( 79 downto  0) := (others => '0');
      
      when 81 =>                                                                           
        
        var_start_vector(127 downto 81) := (others => '1');
        var_start_vector( 80 downto  0) := (others => '0');
      
      when 82 =>                                                                           
        
        var_start_vector(127 downto 82) := (others => '1');
        var_start_vector( 81 downto  0) := (others => '0');
      
      when 83 =>                                                                           
        
        var_start_vector(127 downto 83) := (others => '1');
        var_start_vector( 82 downto  0) := (others => '0');
      
      when 84 =>                                                                           
        
        var_start_vector(127 downto 84) := (others => '1');
        var_start_vector( 83 downto  0) := (others => '0');
      
      when 85 =>                                                                           
        
        var_start_vector(127 downto 85) := (others => '1');
        var_start_vector( 84 downto  0) := (others => '0');
      
      when 86 =>                                                                           
        
        var_start_vector(127 downto 86) := (others => '1');
        var_start_vector( 85 downto  0) := (others => '0');
      
      when 87 =>                                                                           
        
        var_start_vector(127 downto 87) := (others => '1');
        var_start_vector( 86 downto  0) := (others => '0');
      
      when 88 =>                                                                           
        
        var_start_vector(127 downto 88) := (others => '1');
        var_start_vector( 87 downto  0) := (others => '0');
      
      when 89 =>                                                                           
        
        var_start_vector(127 downto 89) := (others => '1');
        var_start_vector( 88 downto  0) := (others => '0');
      
      when 90 =>                                                                           
        
        var_start_vector(127 downto 90) := (others => '1');
        var_start_vector( 89 downto  0) := (others => '0');
      
      when 91 =>                                                                           
        
        var_start_vector(127 downto 91) := (others => '1');
        var_start_vector( 90 downto  0) := (others => '0');
      
      when 92 =>                                                                           
        
        var_start_vector(127 downto 92) := (others => '1');
        var_start_vector( 91 downto  0) := (others => '0');
      
      when 93 =>                                                                           
        
        var_start_vector(127 downto 93) := (others => '1');
        var_start_vector( 92 downto  0) := (others => '0');
      
      when 94 =>                                                                           
        
        var_start_vector(127 downto 94) := (others => '1');
        var_start_vector( 93 downto  0) := (others => '0');
      
      when 95 =>                                                                           
        
        var_start_vector(127 downto 95) := (others => '1');
        var_start_vector( 94 downto  0) := (others => '0');
      
      when 96 =>                                                                           
        
        var_start_vector(127 downto 96) := (others => '1');
        var_start_vector( 95 downto  0) := (others => '0');
      
      when 97 =>                                                                           
        
        var_start_vector(127 downto 97) := (others => '1');
        var_start_vector( 96 downto  0) := (others => '0');
      
      when 98 =>                                                                           
        
        var_start_vector(127 downto 98) := (others => '1');
        var_start_vector( 97 downto  0) := (others => '0');
      
      when 99 =>                                                                           
        
        var_start_vector(127 downto 99) := (others => '1');
        var_start_vector( 98 downto  0) := (others => '0');
      
      when 100 =>                                                                          
        
        var_start_vector(127 downto 100) := (others => '1');
        var_start_vector( 99 downto   0) := (others => '0');
      
      when 101 =>                                                                          
        
        var_start_vector(127 downto 101) := (others => '1');
        var_start_vector(100 downto   0) := (others => '0');
      
      when 102 =>                                                                          
        
        var_start_vector(127 downto 102) := (others => '1');
        var_start_vector(101 downto   0) := (others => '0');
      
      when 103 =>                                                                          
        
        var_start_vector(127 downto 103) := (others => '1');
        var_start_vector(102 downto   0) := (others => '0');
      
      when 104 =>                                                                          
        
        var_start_vector(127 downto 104) := (others => '1');
        var_start_vector(103 downto   0) := (others => '0');
      
      when 105 =>                                                                          
        
        var_start_vector(127 downto 105) := (others => '1');
        var_start_vector(104 downto   0) := (others => '0');
      
      when 106 =>                                                                          
        
        var_start_vector(127 downto 106) := (others => '1');
        var_start_vector(105 downto   0) := (others => '0');
      
      when 107 =>                                                                          
        
        var_start_vector(127 downto 107) := (others => '1');
        var_start_vector(106 downto   0) := (others => '0');
      
      when 108 =>                                                                          
        
        var_start_vector(127 downto 108) := (others => '1');
        var_start_vector(107 downto   0) := (others => '0');
      
      when 109 =>                                                                          
        
        var_start_vector(127 downto 109) := (others => '1');
        var_start_vector(108 downto   0) := (others => '0');
      
      when 110 =>                                                                          
        
        var_start_vector(127 downto 110) := (others => '1');
        var_start_vector(109 downto   0) := (others => '0');
      
      when 111 =>                                                                          
        
        var_start_vector(127 downto 111) := (others => '1');
        var_start_vector(110 downto   0) := (others => '0');
      
      when 112 =>                                                                          
        
        var_start_vector(127 downto 112) := (others => '1');
        var_start_vector(111 downto   0) := (others => '0');
      
      when 113 =>                                                                          
        
        var_start_vector(127 downto 113) := (others => '1');
        var_start_vector(112 downto   0) := (others => '0');
      
      when 114 =>                                                                          
        
        var_start_vector(127 downto 114) := (others => '1');
        var_start_vector(113 downto   0) := (others => '0');
      
      when 115 =>                                                                          
        
        var_start_vector(127 downto 115) := (others => '1');
        var_start_vector(114 downto   0) := (others => '0');
      
      when 116 =>                                                                          
        
        var_start_vector(127 downto 116) := (others => '1');
        var_start_vector(115 downto   0) := (others => '0');
      
      when 117 =>                                                                          
        
        var_start_vector(127 downto 117) := (others => '1');
        var_start_vector(116 downto   0) := (others => '0');
      
      when 118 =>                                                                          
        
        var_start_vector(127 downto 118) := (others => '1');
        var_start_vector(117 downto   0) := (others => '0');
      
      when 119 =>                                                                          
        
        var_start_vector(127 downto 119) := (others => '1');
        var_start_vector(118 downto   0) := (others => '0');
      
      when 120 =>                                                                          
        
        var_start_vector(127 downto 120) := (others => '1');
        var_start_vector(119 downto   0) := (others => '0');
      
      when 121 =>                                                                          
        
        var_start_vector(127 downto 121) := (others => '1');
        var_start_vector(120 downto   0) := (others => '0');
      
      when 122 =>                                                                          
        
        var_start_vector(127 downto 122) := (others => '1');
        var_start_vector(121 downto   0) := (others => '0');
      
      when 123 =>                                                                          
        
        var_start_vector(127 downto 123) := (others => '1');
        var_start_vector(122 downto   0) := (others => '0');
      
      when 124 =>                                                                          
        
        var_start_vector(127 downto 124) := (others => '1');
        var_start_vector(123 downto   0) := (others => '0');
      
      when 125 =>                                                                          
        
        var_start_vector(127 downto 125) := (others => '1');
        var_start_vector(124 downto   0) := (others => '0');
      
      when 126 =>                                                                          
        
        var_start_vector(127 downto 126) := (others => '1');
        var_start_vector(125 downto   0) := (others => '0');
      
      when others =>
        
        var_start_vector(127 downto 127) := (others => '1');
        var_start_vector(126 downto   0) := (others => '0');
      
    end case;
   
    Return (var_start_vector);
   
  end function get_start_128;
  
  
 
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_end_128
  --
  -- Function Description:
  --   Returns the 128-bit vector filled with '1's from the lsbit
  -- of the vector to the end offset.
  --
  -------------------------------------------------------------------
  function get_end_128 (end_offset : natural) return std_logic_vector is
  
    Variable var_end_vector : std_logic_vector(127 downto 0) := (others => '0');
  
  begin
  
    case end_offset is
      when 0 =>
        
        var_end_vector(127 downto 1) := (others => '0');
        var_end_vector(  0 downto 0) := (others => '1');
      
      when 1 =>
        
        var_end_vector(127 downto 2) := (others => '0');
        var_end_vector(  1 downto 0) := (others => '1');
      
      when 2 =>
        
        var_end_vector(127 downto 3) := (others => '0');
        var_end_vector(  2 downto 0) := (others => '1');
      
      when 3 =>
        
        var_end_vector(127 downto 4) := (others => '0');
        var_end_vector(  3 downto 0) := (others => '1');
      
      when 4 =>
        
        var_end_vector(127 downto 5) := (others => '0');
        var_end_vector(  4 downto 0) := (others => '1');
      
      when 5 =>
        
        var_end_vector(127 downto 6) := (others => '0');
        var_end_vector(  5 downto 0) := (others => '1');
      
      when 6 =>
        
        var_end_vector(127 downto 7) := (others => '0');
        var_end_vector(  6 downto 0) := (others => '1');
      
      when 7 =>
        
        var_end_vector(127 downto 8) := (others => '0');
        var_end_vector(  7 downto 0) := (others => '1');
      
      when 8 =>
        
        var_end_vector(127 downto 9) := (others => '0');
        var_end_vector(  8 downto 0) := (others => '1');
      
      when 9 =>
        
        var_end_vector(127 downto 10) := (others => '0');
        var_end_vector(  9 downto 0) := (others => '1');
      
      when 10 =>
        
        var_end_vector(127 downto 11) := (others => '0');
        var_end_vector( 10 downto  0) := (others => '1');
      
      when 11 =>
        
        var_end_vector(127 downto 12) := (others => '0');
        var_end_vector( 11 downto  0) := (others => '1');
      
      when 12 =>
        
        var_end_vector(127 downto 13) := (others => '0');
        var_end_vector( 12 downto  0) := (others => '1');
      
      when 13 =>
        
        var_end_vector(127 downto 14) := (others => '0');
        var_end_vector( 13 downto  0) := (others => '1');
      
      when 14 =>
        
        var_end_vector(127 downto 15) := (others => '0');
        var_end_vector( 14 downto  0) := (others => '1');
      
      when 15 =>
        
        var_end_vector(127 downto 16) := (others => '0');
        var_end_vector( 15 downto  0) := (others => '1');
      
      when 16 =>
        
        var_end_vector(127 downto 17) := (others => '0');
        var_end_vector( 16 downto  0) := (others => '1');
      
      when 17 =>
        
        var_end_vector(127 downto 18) := (others => '0');
        var_end_vector( 17 downto  0) := (others => '1');
      
      when 18 =>
        
        var_end_vector(127 downto 19) := (others => '0');
        var_end_vector( 18 downto  0) := (others => '1');
      
      when 19 =>
        
        var_end_vector(127 downto 20) := (others => '0');
        var_end_vector( 19 downto  0) := (others => '1');
      
      when 20 =>
        
        var_end_vector(127 downto 21) := (others => '0');
        var_end_vector( 20 downto  0) := (others => '1');
      
      when 21 =>
        
        var_end_vector(127 downto 22) := (others => '0');
        var_end_vector( 21 downto  0) := (others => '1');
      
      when 22 =>
        
        var_end_vector(127 downto 23) := (others => '0');
        var_end_vector( 22 downto  0) := (others => '1');
      
      when 23 =>
        
        var_end_vector(127 downto 24) := (others => '0');
        var_end_vector( 23 downto  0) := (others => '1');
      
      when 24 =>
        
        var_end_vector(127 downto 25) := (others => '0');
        var_end_vector( 24 downto  0) := (others => '1');
      
      when 25 =>
        
        var_end_vector(127 downto 26) := (others => '0');
        var_end_vector( 25 downto  0) := (others => '1');
      
      when 26 =>
        
        var_end_vector(127 downto 27) := (others => '0');
        var_end_vector( 26 downto  0) := (others => '1');
      
      when 27 =>
        
        var_end_vector(127 downto 28) := (others => '0');
        var_end_vector( 27 downto  0) := (others => '1');
      
      when 28 =>
        
        var_end_vector(127 downto 29) := (others => '0');
        var_end_vector( 28 downto  0) := (others => '1');
      
      when 29 =>
        
        var_end_vector(127 downto 30) := (others => '0');
        var_end_vector( 29 downto  0) := (others => '1');
      
      when 30 =>
        
        var_end_vector(127 downto 31) := (others => '0');
        var_end_vector( 30 downto  0) := (others => '1');
      
      when 31 =>
        
        var_end_vector(127 downto 32) := (others => '0');
        var_end_vector( 31 downto  0) := (others => '1');
      
      
      when 32 =>
        
        var_end_vector(127 downto 33) := (others => '0');
        var_end_vector( 32 downto  0) := (others => '1');
      
      when 33 =>
        
        var_end_vector(127 downto 34) := (others => '0');
        var_end_vector( 33 downto  0) := (others => '1');
      
      when 34 =>
        
        var_end_vector(127 downto 35) := (others => '0');
        var_end_vector( 34 downto  0) := (others => '1');
      
      when 35 =>
        
        var_end_vector(127 downto 36) := (others => '0');
        var_end_vector( 35 downto  0) := (others => '1');
      
      when 36 =>
        
        var_end_vector(127 downto 37) := (others => '0');
        var_end_vector( 36 downto  0) := (others => '1');
      
      when 37 =>
        
        var_end_vector(127 downto 38) := (others => '0');
        var_end_vector( 37 downto  0) := (others => '1');
      
      when 38 =>
        
        var_end_vector(127 downto 39) := (others => '0');
        var_end_vector( 38 downto  0) := (others => '1');
      
      when 39 =>
        
        var_end_vector(127 downto 40) := (others => '0');
        var_end_vector( 39 downto  0) := (others => '1');
      
      when 40 =>
        
        var_end_vector(127 downto 41) := (others => '0');
        var_end_vector( 40 downto  0) := (others => '1');
      
      when 41 =>
        
        var_end_vector(127 downto 42) := (others => '0');
        var_end_vector( 41 downto  0) := (others => '1');
      
      when 42 =>
        
        var_end_vector(127 downto 43) := (others => '0');
        var_end_vector( 42 downto  0) := (others => '1');
      
      when 43 =>
        
        var_end_vector(127 downto 44) := (others => '0');
        var_end_vector( 43 downto  0) := (others => '1');
      
      when 44 =>
        
        var_end_vector(127 downto 45) := (others => '0');
        var_end_vector( 44 downto  0) := (others => '1');
      
      when 45 =>
        
        var_end_vector(127 downto 46) := (others => '0');
        var_end_vector( 45 downto  0) := (others => '1');
      
      when 46 =>
        
        var_end_vector(127 downto 47) := (others => '0');
        var_end_vector( 46 downto  0) := (others => '1');
      
      when 47 =>
        
        var_end_vector(127 downto 48) := (others => '0');
        var_end_vector( 47 downto  0) := (others => '1');
      
      when 48 =>
        
        var_end_vector(127 downto 49) := (others => '0');
        var_end_vector( 48 downto  0) := (others => '1');
      
      when 49 =>
        
        var_end_vector(127 downto 50) := (others => '0');
        var_end_vector( 49 downto  0) := (others => '1');
      
      when 50 =>
        
        var_end_vector(127 downto 51) := (others => '0');
        var_end_vector( 50 downto  0) := (others => '1');
      
      when 51 =>
        
        var_end_vector(127 downto 52) := (others => '0');
        var_end_vector( 51 downto  0) := (others => '1');
      
      when 52 =>
        
        var_end_vector(127 downto 53) := (others => '0');
        var_end_vector( 52 downto  0) := (others => '1');
      
      when 53 =>
        
        var_end_vector(127 downto 54) := (others => '0');
        var_end_vector( 53 downto  0) := (others => '1');
      
      when 54 =>
        
        var_end_vector(127 downto 55) := (others => '0');
        var_end_vector( 54 downto  0) := (others => '1');
      
      when 55 =>
        
        var_end_vector(127 downto 56) := (others => '0');
        var_end_vector( 55 downto  0) := (others => '1');
      
      when 56 =>
        
        var_end_vector(127 downto 57) := (others => '0');
        var_end_vector( 56 downto  0) := (others => '1');
      
      when 57 =>
        
        var_end_vector(127 downto 58) := (others => '0');
        var_end_vector( 57 downto  0) := (others => '1');
      
      when 58 =>
        
        var_end_vector(127 downto 59) := (others => '0');
        var_end_vector( 58 downto  0) := (others => '1');
      
      when 59 =>
        
        var_end_vector(127 downto 60) := (others => '0');
        var_end_vector( 59 downto  0) := (others => '1');
      
      when 60 =>
        
        var_end_vector(127 downto 61) := (others => '0');
        var_end_vector( 60 downto  0) := (others => '1');
      
      when 61 =>
        
        var_end_vector(127 downto 62) := (others => '0');
        var_end_vector( 61 downto  0) := (others => '1');
      
      when 62 =>
        
        var_end_vector(127 downto 63) := (others => '0');
        var_end_vector( 62 downto  0) := (others => '1');
      
      when 63 =>
        
        var_end_vector(127 downto 64) := (others => '0');
        var_end_vector( 63 downto  0) := (others => '1');
      
 
 
 
 
      when 64 =>
        
        var_end_vector(127 downto 65) := (others => '0');
        var_end_vector( 64 downto  0) := (others => '1');
      
      when 65 =>
        
        var_end_vector(127 downto 66) := (others => '0');
        var_end_vector( 65 downto  0) := (others => '1');
      
      when 66 =>                                                                           
        
        var_end_vector(127 downto 67) := (others => '0');
        var_end_vector( 66 downto  0) := (others => '1');
      
      when 67 =>                                                                           
        
        var_end_vector(127 downto 68) := (others => '0');
        var_end_vector( 67 downto  0) := (others => '1');
      
      when 68 =>                                                                           
        
        var_end_vector(127 downto 69) := (others => '0');
        var_end_vector( 68 downto  0) := (others => '1');
      
      when 69 =>                                                                           
        
        var_end_vector(127 downto 70) := (others => '0');
        var_end_vector( 69 downto  0) := (others => '1');
      
      when 70 =>                                                                           
        
        var_end_vector(127 downto 71) := (others => '0');
        var_end_vector( 70 downto  0) := (others => '1');
      
      when 71 =>                                                                           
        
        var_end_vector(127 downto 72) := (others => '0');
        var_end_vector( 71 downto  0) := (others => '1');
      
      when 72 =>                                                                           
        
        var_end_vector(127 downto 73) := (others => '0');
        var_end_vector( 72 downto  0) := (others => '1');
      
      when 73 =>                                                                           
        
        var_end_vector(127 downto 74) := (others => '0');
        var_end_vector( 73 downto  0) := (others => '1');
      
      when 74 =>                                                                           
        
        var_end_vector(127 downto 75) := (others => '0');
        var_end_vector( 74 downto  0) := (others => '1');
      
      when 75 =>                                                                           
        
        var_end_vector(127 downto 76) := (others => '0');
        var_end_vector( 75 downto  0) := (others => '1');
      
      when 76 =>                                                                           
        
        var_end_vector(127 downto 77) := (others => '0');
        var_end_vector( 76 downto  0) := (others => '1');
      
      when 77 =>                                                                           
        
        var_end_vector(127 downto 78) := (others => '0');
        var_end_vector( 77 downto  0) := (others => '1');
      
      when 78 =>                                                                           
        
        var_end_vector(127 downto 79) := (others => '0');
        var_end_vector( 78 downto  0) := (others => '1');
      
      when 79 =>                                                                           
        
        var_end_vector(127 downto 80) := (others => '0');
        var_end_vector( 79 downto  0) := (others => '1');
      
      when 80 =>                                                                           
        
        var_end_vector(127 downto 81) := (others => '0');
        var_end_vector( 80 downto  0) := (others => '1');
      
      when 81 =>                                                                           
        
        var_end_vector(127 downto 82) := (others => '0');
        var_end_vector( 81 downto  0) := (others => '1');
      
      when 82 =>                                                                           
        
        var_end_vector(127 downto 83) := (others => '0');
        var_end_vector( 82 downto  0) := (others => '1');
      
      when 83 =>                                                                           
        
        var_end_vector(127 downto 84) := (others => '0');
        var_end_vector( 83 downto  0) := (others => '1');
      
      when 84 =>                                                                           
        
        var_end_vector(127 downto 85) := (others => '0');
        var_end_vector( 84 downto  0) := (others => '1');
      
      when 85 =>                                                                           
        
        var_end_vector(127 downto 86) := (others => '0');
        var_end_vector( 85 downto  0) := (others => '1');
      
      when 86 =>                                                                           
        
        var_end_vector(127 downto 87) := (others => '0');
        var_end_vector( 86 downto  0) := (others => '1');
      
      when 87 =>                                                                           
        
        var_end_vector(127 downto 88) := (others => '0');
        var_end_vector( 87 downto  0) := (others => '1');
      
      when 88 =>                                                                           
        
        var_end_vector(127 downto 89) := (others => '0');
        var_end_vector( 88 downto  0) := (others => '1');
      
      when 89 =>                                                                           
        
        var_end_vector(127 downto 90) := (others => '0');
        var_end_vector( 89 downto  0) := (others => '1');
      
      when 90 =>                                                                           
        
        var_end_vector(127 downto 91) := (others => '0');
        var_end_vector( 90 downto  0) := (others => '1');
      
      when 91 =>                                                                           
        
        var_end_vector(127 downto 92) := (others => '0');
        var_end_vector( 91 downto  0) := (others => '1');
      
      when 92 =>                                                                           
        
        var_end_vector(127 downto 93) := (others => '0');
        var_end_vector( 92 downto  0) := (others => '1');
      
      when 93 =>                                                                           
        
        var_end_vector(127 downto 94) := (others => '0');
        var_end_vector( 93 downto  0) := (others => '1');
      
      when 94 =>                                                                           
        
        var_end_vector(127 downto 95) := (others => '0');
        var_end_vector( 94 downto  0) := (others => '1');
      
      when 95 =>                                                                           
        
        var_end_vector(127 downto 96) := (others => '0');
        var_end_vector( 95 downto  0) := (others => '1');
      
      when 96 =>                                                                           
        
        var_end_vector(127 downto 97) := (others => '0');
        var_end_vector( 96 downto  0) := (others => '1');
      
      when 97 =>                                                                           
        
        var_end_vector(127 downto 98) := (others => '0');
        var_end_vector( 97 downto  0) := (others => '1');
      
      when 98 =>                                                                           
        
        var_end_vector(127 downto 99) := (others => '0');
        var_end_vector( 98 downto  0) := (others => '1');
      
      when 99 =>                                                                           
        
        var_end_vector(127 downto 100) := (others => '0');
        var_end_vector( 99 downto   0) := (others => '1');
      
      when 100 =>                                                                          
        
        var_end_vector(127 downto 101) := (others => '0');
        var_end_vector(100 downto   0) := (others => '1');
      
      when 101 =>                                                                          
        
        var_end_vector(127 downto 102) := (others => '0');
        var_end_vector(101 downto   0) := (others => '1');
      
      when 102 =>                                                                          
        
        var_end_vector(127 downto 103) := (others => '0');
        var_end_vector(102 downto   0) := (others => '1');
      
      when 103 =>                                                                          
        
        var_end_vector(127 downto 104) := (others => '0');
        var_end_vector(103 downto   0) := (others => '1');
      
      when 104 =>                                                                          
        
        var_end_vector(127 downto 105) := (others => '0');
        var_end_vector(104 downto   0) := (others => '1');
      
      when 105 =>                                                                          
        
        var_end_vector(127 downto 106) := (others => '0');
        var_end_vector(105 downto   0) := (others => '1');
      
      when 106 =>                                                                          
        
        var_end_vector(127 downto 107) := (others => '0');
        var_end_vector(106 downto   0) := (others => '1');
      
      when 107 =>                                                                          
        
        var_end_vector(127 downto 108) := (others => '0');
        var_end_vector(107 downto   0) := (others => '1');
      
      when 108 =>                                                                          
        
        var_end_vector(127 downto 109) := (others => '0');
        var_end_vector(108 downto   0) := (others => '1');
      
      when 109 =>                                                                          
        
        var_end_vector(127 downto 110) := (others => '0');
        var_end_vector(109 downto   0) := (others => '1');
      
      when 110 =>                                                                          
        
        var_end_vector(127 downto 111) := (others => '0');
        var_end_vector(110 downto   0) := (others => '1');
      
      when 111 =>                                                                          
        
        var_end_vector(127 downto 112) := (others => '0');
        var_end_vector(111 downto   0) := (others => '1');
      
      when 112 =>                                                                          
        
        var_end_vector(127 downto 113) := (others => '0');
        var_end_vector(112 downto   0) := (others => '1');
      
      when 113 =>                                                                          
        
        var_end_vector(127 downto 114) := (others => '0');
        var_end_vector(113 downto   0) := (others => '1');
      
      when 114 =>                                                                          
        
        var_end_vector(127 downto 115) := (others => '0');
        var_end_vector(114 downto   0) := (others => '1');
      
      when 115 =>                                                                          
        
        var_end_vector(127 downto 116) := (others => '0');
        var_end_vector(115 downto   0) := (others => '1');
      
      when 116 =>                                                                          
        
        var_end_vector(127 downto 117) := (others => '0');
        var_end_vector(116 downto   0) := (others => '1');
      
      when 117 =>                                                                          
        
        var_end_vector(127 downto 118) := (others => '0');
        var_end_vector(117 downto   0) := (others => '1');
      
      when 118 =>                                                                          
        
        var_end_vector(127 downto 119) := (others => '0');
        var_end_vector(118 downto   0) := (others => '1');
      
      when 119 =>                                                                          
        
        var_end_vector(127 downto 120) := (others => '0');
        var_end_vector(119 downto   0) := (others => '1');
      
      when 120 =>                                                                          
        
        var_end_vector(127 downto 121) := (others => '0');
        var_end_vector(120 downto   0) := (others => '1');
      
      when 121 =>                                                                          
        
        var_end_vector(127 downto 122) := (others => '0');
        var_end_vector(121 downto   0) := (others => '1');
      
      when 122 =>                                                                          
        
        var_end_vector(127 downto 123) := (others => '0');
        var_end_vector(122 downto   0) := (others => '1');
      
      when 123 =>                                                                          
        
        var_end_vector(127 downto 124) := (others => '0');
        var_end_vector(123 downto   0) := (others => '1');
      
      when 124 =>                                                                          
        
        var_end_vector(127 downto 125) := (others => '0');
        var_end_vector(124 downto   0) := (others => '1');
      
      when 125 =>                                                                          
        
        var_end_vector(127 downto 126) := (others => '0');
        var_end_vector(125 downto   0) := (others => '1');
      
      when 126 =>                                                                          
        
        var_end_vector(127 downto 127) := (others => '0');
        var_end_vector(126 downto   0) := (others => '1');
      
      when others =>
        
        var_end_vector(127 downto   0) := (others => '1');
      
    end case;
   
    Return (var_end_vector);
   
  end function get_end_128;
  
  
 
  
  
  
  
  
  
  
  
  
  
 
   
   
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: funct_clip_value
  --
  -- Function Description:
  --   Returns a value that cannot exceed a clip value.
  --
  -------------------------------------------------------------------
  function funct_clip_value (input_value : natural;
                             max_value   : natural) return natural is
  
    Variable temp_value : Natural := 0;
  
  begin
  
    If (input_value <= max_value) Then
    
      temp_value := input_value;
    
    Else 
    
      temp_value := max_value;
    
    End if;
   
    Return (temp_value);
   
   
  end function funct_clip_value;
  
   
   
  -- Constants
  Constant INTERNAL_CALC_WIDTH   : integer  := C_NUM_BYTES_WIDTH+(C_OP_MODE*2); -- Add 2 bits of math headroom
                                                                                -- if op Mode = 1
  
  
  -- Signals
  signal sig_ouput_stbs       : std_logic_vector(C_STRB_WIDTH-1 downto 0) := (others => '0');
  signal sig_start_offset_un  : unsigned(INTERNAL_CALC_WIDTH-1 downto 0)  := (others => '0');
  signal sig_end_offset_un    : unsigned(INTERNAL_CALC_WIDTH-1 downto 0)  := (others => '0');
 
  

begin --(architecture implementation)

 
  -- Assign the output strobe value
  strb_out <= sig_ouput_stbs ;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_OFF_OFF_CASE
  --
  -- If Generate Description:
  --  Calculates the internal start and end offsets for the 
  -- case when start and end offsets are being provided.
  --
  --
  ------------------------------------------------------------
  GEN_OFF_OFF_CASE : if (C_OP_MODE = 1) generate
 
 
    begin
     
      sig_start_offset_un <= RESIZE(UNSIGNED(start_addr_offset), INTERNAL_CALC_WIDTH);
     
      sig_end_offset_un   <= RESIZE(UNSIGNED(end_addr_offset), INTERNAL_CALC_WIDTH);
     
     
   
    end generate GEN_OFF_OFF_CASE;
  
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_OFF_LEN_CASE
  --
  -- If Generate Description:
  --  Calculates the internal start and end offsets for the 
  -- case when start offset and length are being provided.
  --
  ------------------------------------------------------------
  GEN_OFF_LEN_CASE : if (C_OP_MODE = 0) generate

   -- Local Constants Declarations
    Constant L_INTERNAL_CALC_WIDTH   : integer  := INTERNAL_CALC_WIDTH;
    Constant L_ONE                   : unsigned := TO_UNSIGNED(1, L_INTERNAL_CALC_WIDTH);
    Constant L_ZERO                  : unsigned := TO_UNSIGNED(0, L_INTERNAL_CALC_WIDTH);
    Constant MAX_VALUE               : natural  := C_STRB_WIDTH-1;
    
    
    
   -- local signals
    signal lsig_addr_offset_us       : unsigned(L_INTERNAL_CALC_WIDTH-1 downto 0) := (others => '0');
    signal lsig_num_valid_bytes_us   : unsigned(L_INTERNAL_CALC_WIDTH-1 downto 0) := (others => '0');
    signal lsig_length_adjust_us     : unsigned(L_INTERNAL_CALC_WIDTH-1 downto 0) := (others => '0');
    signal lsig_incr_offset_bytes_us : unsigned(L_INTERNAL_CALC_WIDTH-1 downto 0) := (others => '0');
    signal lsig_end_addr_us          : unsigned(L_INTERNAL_CALC_WIDTH-1 downto 0) := (others => '0');
    signal lsig_end_addr_int         : integer := 0;
    signal lsig_strt_addr_int        : integer := 0;
   
    

    begin
  
      lsig_addr_offset_us       <= RESIZE(UNSIGNED(start_addr_offset), L_INTERNAL_CALC_WIDTH); 
                                                                                            
      lsig_num_valid_bytes_us   <= RESIZE(UNSIGNED(num_valid_bytes)  , L_INTERNAL_CALC_WIDTH); 
      
      lsig_length_adjust_us     <= L_ZERO
        When (lsig_num_valid_bytes_us = L_ZERO)
        Else L_ONE;
      
      lsig_incr_offset_bytes_us <= lsig_num_valid_bytes_us - lsig_length_adjust_us;                             
                                                                                            
      lsig_end_addr_us          <= lsig_addr_offset_us + lsig_incr_offset_bytes_us;            
                                                                                            
      lsig_strt_addr_int        <= TO_INTEGER(lsig_addr_offset_us);                           
                                                                                            
      lsig_end_addr_int         <= TO_INTEGER(lsig_end_addr_us);                              
      
   
   
   
      
      sig_start_offset_un       <= TO_UNSIGNED(funct_clip_value(lsig_strt_addr_int, MAX_VALUE), INTERNAL_CALC_WIDTH);
                                  
      sig_end_offset_un         <= TO_UNSIGNED(funct_clip_value(lsig_end_addr_int, MAX_VALUE), INTERNAL_CALC_WIDTH) ;
      
    
    
    
    
                                                                                            
   
    end generate GEN_OFF_LEN_CASE;
  
  
  
  
  
  
  
 
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_1BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 1-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_1BIT_CASE : if (C_STRB_WIDTH = 1) generate
 
 
    begin
  
      sig_ouput_stbs    <=  (others => '1') ;
      
   
    end generate GEN_1BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_2BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 2-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_2BIT_CASE : if (C_STRB_WIDTH = 2) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural :=  1;
    
    Signal lsig_start_vect   : std_logic_vector(1 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(1 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(1 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_2(lsig_start_offset);
      lsig_end_vect     <=  get_end_2(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_2BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_4BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 4-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_4BIT_CASE : if (C_STRB_WIDTH = 4) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural :=  3;
    
    Signal lsig_start_vect   : std_logic_vector(3 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(3 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(3 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_4(lsig_start_offset);
      lsig_end_vect     <=  get_end_4(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_4BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_8BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 8-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_8BIT_CASE : if (C_STRB_WIDTH = 8) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural :=  7;
    
    Signal lsig_start_vect   : std_logic_vector(7 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(7 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(7 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_8(lsig_start_offset);
      lsig_end_vect     <=  get_end_8(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_8BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_16BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 16-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_16BIT_CASE : if (C_STRB_WIDTH = 16) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural := 15;
    
    Signal lsig_start_vect   : std_logic_vector(15 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(15 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(15 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_16(lsig_start_offset);
      lsig_end_vect     <=  get_end_16(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_16BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_32BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 32-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_32BIT_CASE : if (C_STRB_WIDTH = 32) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural := 31;
    
    Signal lsig_start_vect   : std_logic_vector(31 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(31 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(31 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_32(lsig_start_offset);
      lsig_end_vect     <=  get_end_32(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_32BIT_CASE;
  
  
  
  
  
 
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_64BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 64-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_64BIT_CASE : if (C_STRB_WIDTH = 64) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=  0;
    Signal lsig_end_offset   : Natural := 63;
    
    Signal lsig_start_vect   : std_logic_vector(63 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(63 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(63 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_64(lsig_start_offset);
      lsig_end_vect     <=  get_end_64(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_64BIT_CASE;
  
  
  
 
 
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_128BIT_CASE
  --
  -- If Generate Description:
  --  Generates the strobes for the 64-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_128BIT_CASE : if (C_STRB_WIDTH = 128) generate
 
    -- local signals
    Signal lsig_start_offset : Natural :=   0;
    Signal lsig_end_offset   : Natural := 127;
    
    Signal lsig_start_vect   : std_logic_vector(127 downto 0) := (others => '0');
    Signal lsig_end_vect     : std_logic_vector(127 downto 0) := (others => '0');
    Signal lsig_cmplt_vect   : std_logic_vector(127 downto 0) := (others => '0');
    
 
    begin
 
  
      lsig_start_offset <=  TO_INTEGER(sig_start_offset_un) ;
      lsig_end_offset   <=  TO_INTEGER(sig_end_offset_un  ) ;
      
  
      lsig_start_vect   <=  get_start_128(lsig_start_offset);
      lsig_end_vect     <=  get_end_128(lsig_end_offset)    ;
  
  
      lsig_cmplt_vect   <=  lsig_start_vect and
                            lsig_end_vect; 
  
      sig_ouput_stbs    <=  lsig_cmplt_vect ;
      
   
    end generate GEN_128BIT_CASE;
  
  
  
  
  
 
 
 
 
 

end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_pcc.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_pcc.vhd
  --
  -- Description:
  --    This file implements the DataMover Predictive Command Calculator (PCC).
  --
  --
  --
  --
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_strb_gen2;

  -------------------------------------------------------------------------------

  entity axi_datamover_pcc is
    generic (

      C_IS_MM2S              : Integer range  0 to   1 :=  0;
        -- This parameter tells the PCC module if it is a MM2S
        -- instance or a S2MM instance.
        -- 0 = S2MM Instance
        -- 1 = MM2S Instance
      
      C_DRE_ALIGN_WIDTH      : Integer range  1 to   6 :=  2;
        -- Sets the width of the DRE Aligment output ports
        
      C_SEL_ADDR_WIDTH       : Integer range  1 to   8 :=  5;
        -- Sets the width of the LS address bus used for 
        -- Muxing/Demuxing data to/from a wider AXI4 data bus
      
      C_ADDR_WIDTH           : Integer range 32 to  64 := 32;
        -- Sets the width of the AXi Address Channel 
      
      C_STREAM_DWIDTH        : Integer range  8 to 1024 := 32;
        -- Sets the width of the Stream Data width that
        -- is being supported by the PCC
      
      C_MAX_BURST_LEN        : Integer range 2 to 256 := 16;
        -- Indicates the max allowed burst length to use for
        -- AXI4 transfer calculations
      
      C_CMD_WIDTH            : Integer                 := 68;
        -- Sets the width of the input command port
      
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        -- Sets the width of the Tag field in the input command
      
      C_BTT_USED             : Integer range  8 to  26 := 16;
        -- Sets the width of the used portion of the BTT field
        -- of the input command
      
      C_SUPPORT_INDET_BTT    : Integer range  0 to   1 :=  0;
        -- Indicates if the Indeterminate BTT mode is enabled
      
      C_NATIVE_XFER_WIDTH    : Integer range  8 to 1024 :=  32;
        -- Indicates the Native transfer width to use for all
        -- transfer calculations. This will either be the DataMover
        -- input Stream width or the AXI4 MMap data width depending
        -- on DataMover parameterization.
      
      C_STRT_SF_OFFSET_WIDTH : Integer range  1 to   7 :=  1;
        -- Indicates the width of the starting address offset
        -- bus passed to Store and Forward functions                                                    
      C_MCDMA                : integer range 0 to 1 := 0
      );
    port (

      -- Clock and Reset input ----------------------------------------
      primary_aclk           : in  std_logic;                        --
         -- Primary synchronization clock for the Master side        --
         -- interface and internal logic. It is also used            --
         -- for the User interface synchronization when              --
         -- C_STSCMD_IS_ASYNC = 0.                                   --
                                                                     --
      -- Reset input                                                 --
      mmap_reset             : in  std_logic;                        --
        -- Reset used for the internal master logic                  --
      -----------------------------------------------------------------




      -- Master Command FIFO/Register Interface --------------------------------------------
                                                                                          --
      cmd2mstr_command      : in std_logic_vector(C_CMD_WIDTH-1 downto 0);                --
         -- The next command value available from the Command FIFO/Register               --
                                                                                          --
      cache2mstr_command      : in std_logic_vector(7 downto 0);                --
         -- The next command value available from the Command FIFO/Register               --
      cmd2mstr_cmd_valid    : in std_logic;                                               --
         -- Handshake bit indicating if the Command FIFO/Register has at leasdt 1 entry   --
                                                                                          --
      mst2cmd_cmd_ready     : out  std_logic;                                             --
         -- Handshake bit indicating the Command Calculator is ready to accept            --
         -- another command                                                               --
      --------------------------------------------------------------------------------------



      -- Address Channel Controller Interface -----------------------------------
                                                                               --
      mstr2addr_tag       : out std_logic_vector(C_TAG_WIDTH-1 downto 0);      --
         -- The next command tag                                               --
                                                                               --
      mstr2addr_addr      : out std_logic_vector(C_ADDR_WIDTH-1 downto 0);     --
         -- The next command address to put on the AXI MMap ADDR               --
                                                                               --
      mstr2addr_len       : out std_logic_vector(7 downto 0);                  --
         -- The next command length to put on the AXI MMap LEN                 --
                                                                               --
      mstr2addr_size      : out std_logic_vector(2 downto 0);                  --
         -- The next command size to put on the AXI MMap SIZE                  --
                                                                               --
      mstr2addr_burst     : out std_logic_vector(1 downto 0);                  --
         -- The next command burst type to put on the AXI MMap BURST           --
                                                                               --
      mstr2addr_cache     : out std_logic_vector(3 downto 0);                  --
         -- The next command burst type to put on the AXI MMap BURST           --

      mstr2addr_user     : out std_logic_vector(3 downto 0);                  --
         -- The next command burst type to put on the AXI MMap BURST           --

      mstr2addr_cmd_cmplt : out std_logic;                                     --
         -- The indication to the Address Channel that the current             --
         -- sub-command output is the last one compiled from the               --
         -- parent command pulled from the Command FIFO                        --
                                                                               --
      mstr2addr_calc_error : out std_logic;                                    --
         -- Indication if the next command in the calculation pipe             --
         -- has a calcualtion error                                            --
                                                                               --
      mstr2addr_cmd_valid : out std_logic;                                     --
         -- The next command valid indication to the Address Channel           --
         -- Controller for the AXI MMap                                        --
                                                                               --
      addr2mstr_cmd_ready : In std_logic;                                      --
         -- Indication from the Address Channel Controller that the            --
         -- command is being accepted                                          --
      ---------------------------------------------------------------------------
      



      -- Data Channel Controller Interface ------------------------------------------------
                                                                                         --
      mstr2data_tag        : out std_logic_vector(C_TAG_WIDTH-1 downto 0);               --
         -- The next command tag                                                         --
                                                                                         --
      mstr2data_saddr_lsb  : out std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);          --
         -- The next command start address LSbs to use for the read data                 --
         -- mux (only used if Stream data width is less than the MMap data               --
         -- width).                                                                      --
                                                                                         --
      mstr2data_len        : out std_logic_vector(7 downto 0);                           --
         -- The LEN value output to the Address Channel                                  --
                                                                                         --
      mstr2data_strt_strb  : out std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0);   --
         -- The starting strobe value to use for the data transfer                       --
                                                                                         --
      mstr2data_last_strb  : out std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0);   --
         -- The endiing (LAST) strobe value to use for the data transfer                 --
                                                                                         --
      mstr2data_drr        : out std_logic;                                              --
         -- The starting tranfer of a sequence of transfers                              --
                                                                                         --
      mstr2data_eof        : out std_logic;                                              --
         -- The endiing tranfer of a sequence of parent transfer commands                --
                                                                                         --
      mstr2data_sequential : Out std_logic;                                              --
         -- The next sequential tranfer of a sequence of transfers                       --
         -- spawned from a single parent command                                         --
                                                                                         --
      mstr2data_calc_error : out std_logic;                                              --
         -- Indication if the next command in the calculation pipe                       --
         -- has a calculation error                                                      --
                                                                                         --
      mstr2data_cmd_cmplt  : out std_logic;                                              --
         -- The indication to the Data Channel that the current                          --
         -- sub-command output is the last one compiled from the                         --
         -- parent command pulled from the Command FIFO                                  --
                                                                                         --
      mstr2data_cmd_valid  : out std_logic;                                              --
         -- The next command valid indication to the Data Channel                        --
         -- Controller for the AXI MMap                                                  --
                                                                                         --
      data2mstr_cmd_ready  : In std_logic ;                                              --
         -- Indication from the Data Channel Controller that the                         --
         -- command is being accepted on the AXI Address                                 --
         -- Channel                                                                      --
                                                                                         --
      mstr2data_dre_src_align  : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
         -- The source (input) alignment for the MM2S DRE                                --
                                                                                         --
      mstr2data_dre_dest_align : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
         -- The destinstion (output) alignment for the MM2S DRE                          --
      -------------------------------------------------------------------------------------
                                                                                         
                                                                                         
                                                                                         
                                                                                         
      -- Output flag indicating that a calculation error has occured ----------------------
                                                                                         --
      calc_error               : Out std_logic;                                          --
         -- Indication from the Command Calculator that a calculation                    --
         -- error has occured.                                                           --
      -------------------------------------------------------------------------------------





      -- Special DRE Controller Interface      --------------------------------------------
                                                                                         --
      dre2mstr_cmd_ready        : In std_logic ;                                         --
         -- Indication from the S2MM DRE Controller that it can                          --
         -- accept another command.                                                      --
                                                                                         --
      mstr2dre_cmd_valid        : out std_logic ;                                        --
         -- The next command valid indication to the S2MM DRE                            --
         -- Controller.                                                                  --
                                                                                         --
      mstr2dre_tag              : out std_logic_vector(C_TAG_WIDTH-1 downto 0);          --
         -- The next command tag                                                         --
                                                                                         --
      mstr2dre_dre_src_align    : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) ;   --
         -- The source (S2MM Stream) alignment for the S2MM DRE                          --
                                                                                         --
      mstr2dre_dre_dest_align   : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) ;   --
         -- The destinstion (S2MM MMap) alignment for the S2MM DRE                       --
                                                                                         --
      mstr2dre_btt              : out std_logic_vector(C_BTT_USED-1 downto 0) ;          --
         -- The BTT value output to the S2MM DRE. This is needed for                     --
         -- Scatter operations.                                                          --
                                                                                         --
      mstr2dre_drr              : out std_logic ;                                        --
         -- The starting tranfer of a sequence of transfers                              --
                                                                                         --
      mstr2dre_eof              : out std_logic ;                                        --
         -- The endiing tranfer of a sequence of parent transfer commands                --
                                                                                         --
      mstr2dre_cmd_cmplt        : Out std_logic ;                                        --
         -- The last child tranfer of a sequence of transfers                            --
         -- spawned from a single parent command                                         --
                                                                                         --
      mstr2dre_calc_error       : out std_logic ;                                        --
         -- Indication if the next command in the calculation pipe                       --
         -- has a calculation error                                                      --
      -------------------------------------------------------------------------------------

     
     
     -- Store and Forward Support Start Offset --------------------------------------------- 
                                                                                          -- 
     mstr2dre_strt_offset       : out std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0) -- 
       -- Relays the starting address offset for a transfer to the Store and Forward      -- 
       -- functions incorporating upsizer/downsizer logic                                 -- 
     ---------------------------------------------------------------------------------------    


      );

  end entity axi_datamover_pcc;


  architecture implementation of axi_datamover_pcc is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  -- Function declarations  -------------------

    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_dbeat_residue_width
    --
    -- Function Description:
    --  Calculates the number of Least significant bits of the BTT field
    -- that are unused for the LEN calculation
    --
    -------------------------------------------------------------------
    function funct_get_dbeat_residue_width (bytes_per_beat : integer) return integer is

      Variable temp_dbeat_residue_width : Integer := 0; -- 8-bit stream

    begin

      case bytes_per_beat is
        when 1 =>  
            temp_dbeat_residue_width := 0;
        when 2 =>
            temp_dbeat_residue_width := 1;
        when 4 =>
            temp_dbeat_residue_width := 2;
        when 8 =>
            temp_dbeat_residue_width := 3;
        when 16 =>
            temp_dbeat_residue_width := 4;
        when 32 =>
            temp_dbeat_residue_width := 5;
        when 64 =>
            temp_dbeat_residue_width := 6;
        
        when others =>  -- 128-byte transfers
            temp_dbeat_residue_width := 7;
      end case;

      Return (temp_dbeat_residue_width);

    end function funct_get_dbeat_residue_width;




    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_burstcnt_offset
    --
    -- Function Description:
    -- Calculates the bit offset from the residue bits needed to detirmine
    -- the load value for the burst counter.
    --
    -------------------------------------------------------------------
    function funct_get_burst_residue_width (max_burst_len : integer) return integer is


      Variable temp_burst_residue_width : Integer := 0;

    begin

      case max_burst_len is

        when 256 =>
          temp_burst_residue_width := 8;
        when 128 =>
          temp_burst_residue_width := 7;
        when 64 =>
          temp_burst_residue_width := 6;
        when 32 =>
          temp_burst_residue_width := 5;
        when 16 =>
          temp_burst_residue_width := 4;
        when 8 =>
          temp_burst_residue_width := 3;
        when 4 =>
          temp_burst_residue_width := 2;
        when others =>   -- assume 2 dbeats
          temp_burst_residue_width := 1;
      end case;

      Return (temp_burst_residue_width);

    end function funct_get_burst_residue_width;


    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_get_axi_size
    --
    -- Function Description:
    -- Calculates the AXI SIZE Qualifier based on the data width.
    --
    -------------------------------------------------------------------
    function func_get_axi_size (native_dwidth : integer) return std_logic_vector is

      Constant AXI_SIZE_1BYTE    : std_logic_vector(2 downto 0) := "000";
      Constant AXI_SIZE_2BYTE    : std_logic_vector(2 downto 0) := "001";
      Constant AXI_SIZE_4BYTE    : std_logic_vector(2 downto 0) := "010";
      Constant AXI_SIZE_8BYTE    : std_logic_vector(2 downto 0) := "011";
      Constant AXI_SIZE_16BYTE   : std_logic_vector(2 downto 0) := "100";
      Constant AXI_SIZE_32BYTE   : std_logic_vector(2 downto 0) := "101";
      Constant AXI_SIZE_64BYTE   : std_logic_vector(2 downto 0) := "110";
      Constant AXI_SIZE_128BYTE  : std_logic_vector(2 downto 0) := "111";

      Variable temp_size : std_logic_vector(2 downto 0) := (others => '0');

    begin

       case native_dwidth is
         when 8 =>
           temp_size := AXI_SIZE_1BYTE;
         when 16 =>
           temp_size := AXI_SIZE_2BYTE;
         when 32 =>
           temp_size := AXI_SIZE_4BYTE;
         when 64 =>
           temp_size := AXI_SIZE_8BYTE;
         when 128 =>
           temp_size := AXI_SIZE_16BYTE;
         when 256 =>
           temp_size := AXI_SIZE_32BYTE;
         when 512 =>
           temp_size := AXI_SIZE_64BYTE;
         
         when others => -- 1024 bit dwidth
           temp_size := AXI_SIZE_128BYTE;
       end case;

       Return (temp_size);


    end function func_get_axi_size;



    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_sf_offset_ls_index
    --
    -- Function Description:
    --   Calculates the Ls index of the Store and Forward
    --  starting offset bus based on the User Stream Width.
    --
    -------------------------------------------------------------------
    function funct_get_sf_offset_ls_index (stream_width : integer) return integer is
    
      Variable lvar_temp_ls_index : Integer := 0;
    
    begin
    
      case stream_width is
        when 8 =>
          lvar_temp_ls_index := 0;
        when 16 =>
          lvar_temp_ls_index := 1;
        when 32 =>
          lvar_temp_ls_index := 2;
        when 64 =>
          lvar_temp_ls_index := 3;
        when 128 =>
          lvar_temp_ls_index := 4;
        when 256 =>
          lvar_temp_ls_index := 5;
        when 512 =>
          lvar_temp_ls_index := 6;
        when others => -- 1024
          lvar_temp_ls_index := 7;
      end case;
      
      Return (lvar_temp_ls_index);
    
    
    end function funct_get_sf_offset_ls_index;
    


    -- Constant Declarations  ----------------------------------------

    Constant BASE_CMD_WIDTH    : integer := 32+C_MCDMA*3; -- Bit Width of Command LS (no address)
    Constant CMD_BTT_WIDTH     : integer := C_BTT_USED;
    Constant CMD_BTT_LS_INDEX  : integer := 0;
    Constant CMD_BTT_MS_INDEX  : integer := CMD_BTT_WIDTH-1;
    Constant CMD_TYPE_INDEX    : integer := 23+(C_MCDMA*3);
    Constant CMD_DRR_INDEX     : integer := BASE_CMD_WIDTH-1;
    Constant CMD_EOF_INDEX     : integer := BASE_CMD_WIDTH-2;
    Constant CMD_DSA_WIDTH     : integer := 6;
    Constant CMD_DSA_LS_INDEX  : integer := CMD_TYPE_INDEX+1;
    Constant CMD_DSA_MS_INDEX  : integer := (CMD_DSA_LS_INDEX+CMD_DSA_WIDTH)-1;
    Constant CMD_ADDR_LS_INDEX : integer := BASE_CMD_WIDTH;
    Constant CMD_ADDR_MS_INDEX : integer := (C_ADDR_WIDTH+BASE_CMD_WIDTH)-1;
    Constant CMD_TAG_WIDTH     : integer := C_TAG_WIDTH;
    Constant CMD_TAG_LS_INDEX  : integer := C_ADDR_WIDTH+BASE_CMD_WIDTH;
    Constant CMD_TAG_MS_INDEX  : integer := (CMD_TAG_LS_INDEX+CMD_TAG_WIDTH)-1;


    ----------------------------------------------------------------------------------------
    -- Command calculation constants

    Constant SIZE_TO_USE               : std_logic_vector(2 downto 0) := func_get_axi_size(C_NATIVE_XFER_WIDTH);
    Constant BYTES_PER_DBEAT           : integer := C_NATIVE_XFER_WIDTH/8;
    Constant DBEATS_PER_BURST          : integer := C_MAX_BURST_LEN;
    Constant BYTES_PER_MAX_BURST       : integer := DBEATS_PER_BURST*BYTES_PER_DBEAT;
    Constant LEN_WIDTH                 : integer  := 8;  -- 8 bits fixed
    Constant MAX_LEN_VALUE             : integer  := DBEATS_PER_BURST-1;
    Constant XFER_LEN_ZERO             : std_logic_vector(LEN_WIDTH-1 downto 0) := (others => '0');
    Constant DBEAT_RESIDUE_WIDTH       : integer  := funct_get_dbeat_residue_width(BYTES_PER_DBEAT);
    Constant BURST_RESIDUE_WIDTH       : integer  := funct_get_burst_residue_width(C_MAX_BURST_LEN);
    Constant BURST_RESIDUE_LS_INDEX    : integer  := DBEAT_RESIDUE_WIDTH;
    Constant BTT_RESIDUE_WIDTH         : integer  := DBEAT_RESIDUE_WIDTH+BURST_RESIDUE_WIDTH;
    Constant BTT_ZEROS                 : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    Constant BTT_RESIDUE_1             : unsigned := TO_UNSIGNED( 1, BTT_RESIDUE_WIDTH);
    Constant BTT_RESIDUE_0             : unsigned := TO_UNSIGNED( 0, BTT_RESIDUE_WIDTH);
    Constant BURST_CNT_LS_INDEX        : integer  := DBEAT_RESIDUE_WIDTH+BURST_RESIDUE_WIDTH;
    Constant BURST_CNTR_WIDTH          : integer  := CMD_BTT_WIDTH - (DBEAT_RESIDUE_WIDTH+BURST_RESIDUE_WIDTH); 
    Constant BRST_CNT_1                : unsigned := TO_UNSIGNED( 1, BURST_CNTR_WIDTH);
    Constant BRST_CNT_0                : unsigned := TO_UNSIGNED( 0, BURST_CNTR_WIDTH);
    Constant BRST_RESIDUE_0            : std_logic_vector(BURST_RESIDUE_WIDTH-1 downto 0) := (others => '0');
    Constant DBEAT_RESIDUE_0           : std_logic_vector(DBEAT_RESIDUE_WIDTH-1 downto 0) := (others => '0');
    Constant ADDR_CNTR_WIDTH           : integer  := 16;  -- Addres Counter slice
    Constant ADDR_MS_SLICE_WIDTH       : integer  := C_ADDR_WIDTH-ADDR_CNTR_WIDTH;
    Constant ADDR_CNTR_MAX_VALUE       : unsigned := TO_UNSIGNED((2**ADDR_CNTR_WIDTH)-1, ADDR_CNTR_WIDTH);
    Constant ADDR_CNTR_ONE             : unsigned := TO_UNSIGNED(1, ADDR_CNTR_WIDTH);
    Constant MBAA_ADDR_SLICE_WIDTH     : integer := BTT_RESIDUE_WIDTH;
    Constant STRBGEN_ADDR_SLICE_WIDTH  : integer := DBEAT_RESIDUE_WIDTH;
    Constant STRBGEN_ADDR_0            : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    Constant STRBGEN_ADDR_SLICE_1      : unsigned := TO_UNSIGNED( 1, STRBGEN_ADDR_SLICE_WIDTH);

    Constant SF_OFFSET_LS_INDEX        : integer := funct_get_sf_offset_ls_index(C_STREAM_DWIDTH);
    Constant SF_OFFSET_MS_INDEX        : integer := (SF_OFFSET_LS_INDEX + C_STRT_SF_OFFSET_WIDTH)-1;
    
    

    -- Type Declarations  --------------------------------------------

    type PCC_SM_STATE_TYPE is (
                INIT,
                WAIT_FOR_CMD,
                CALC_1,
                CALC_2,
                CALC_3,
                WAIT_ON_XFER_PUSH,
                CHK_IF_DONE,
                ERROR_TRAP
                );





    -- Signal Declarations  --------------------------------------------
    Signal sig_pcc_sm_state                 : PCC_SM_STATE_TYPE := INIT;
    Signal sig_pcc_sm_state_ns              : PCC_SM_STATE_TYPE := INIT;
    signal sig_sm_halt_ns                   : std_logic := '0';
    signal sig_sm_halt_reg                  : std_logic := '0';
    signal sig_sm_ld_xfer_reg_ns            : std_logic := '0';
    signal sig_sm_ld_xfer_reg_ns_tmp            : std_logic := '0';
    signal sig_sm_pop_input_reg_ns          : std_logic := '0';
    signal sig_sm_pop_input_reg             : std_logic := '0';
    signal sig_sm_ld_calc1_reg_ns           : std_logic := '0';
    signal sig_sm_ld_calc1_reg              : std_logic := '0';
    signal sig_sm_ld_calc2_reg_ns           : std_logic := '0';
    signal sig_sm_ld_calc2_reg              : std_logic := '0';
    
    signal sig_sm_ld_calc3_reg_ns           : std_logic := '0';
    signal sig_sm_ld_calc3_reg              : std_logic := '0';
    
    
    signal sig_parent_done                  : std_logic := '0';
    signal sig_ld_xfer_reg                  : std_logic := '0';
    signal sig_ld_xfer_reg_tmp                  : std_logic := '0';
    signal sig_btt_raw                      : std_logic := '0';
    signal sig_btt_is_zero                  : std_logic := '0';
    signal sig_btt_is_zero_reg              : std_logic := '0';
    
    -- unused signal sig_next_tag                     : std_logic_vector(CMD_TAG_WIDTH-1 downto 0) := (others => '0');
    -- unused signal sig_next_addr                    : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    -- unused signal sig_next_len                     : std_logic_vector(LEN_WIDTH-1 downto 0) := (others => '0');
    -- unused signal sig_next_size                    : std_logic_vector(2 downto 0) := (others => '0');
    -- unused signal sig_next_burst                   : std_logic_vector(1 downto 0) := (others => '0');
    -- unused signal sig_next_strt_strb               : std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0) := (others => '0');
    -- unused signal sig_next_end_strb                : std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0) := (others => '0');

    ----------------------------------------------------------------------------------------
    -- Burst Buster signals
    signal sig_burst_cnt_slice_im0          : unsigned(BURST_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_last_xfer_valid_im1          : std_logic := '0';
    signal sig_brst_cnt_eq_zero_im0         : std_logic := '0';
    signal sig_brst_cnt_eq_zero_ireg1       : std_logic := '0';
    signal sig_brst_cnt_eq_one_im0          : std_logic := '0';
    signal sig_brst_cnt_eq_one_ireg1        : std_logic := '0';
    signal sig_brst_residue_eq_zero         : std_logic := '0';
    signal sig_brst_residue_eq_zero_reg     : std_logic := '0';
    signal sig_no_btt_residue_im0           : std_logic := '0';
    signal sig_no_btt_residue_ireg1         : std_logic := '0';
    signal sig_btt_residue_slice_im0        : Unsigned(BTT_RESIDUE_WIDTH-1 downto 0) := (others => '0');

    -- Input command register
    signal sig_push_input_reg               : std_logic := '0';
    signal sig_pop_input_reg                : std_logic := '0';
    signal sig_input_burst_type_reg         : std_logic := '0';
    signal sig_input_cache_type_reg         : std_logic_vector (3 downto 0) := "0000";
    signal sig_input_user_type_reg          : std_logic_vector (3 downto 0) := "0000";
    signal sig_input_btt_residue_minus1_reg : std_logic_vector(BTT_RESIDUE_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_dsa_reg                : std_logic_vector(CMD_DSA_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_drr_reg                : std_logic := '0';
    signal sig_input_eof_reg                : std_logic := '0';
    signal sig_input_tag_reg                : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_reg_empty              : std_logic := '0';
    signal sig_input_reg_full               : std_logic := '0';

    -- Output qualifier Register
    --  signal sig_ld_output                    : std_logic := '0';
    signal sig_push_xfer_reg                : std_logic := '0';
    signal sig_pop_xfer_reg                 : std_logic := '0';
    signal sig_xfer_addr_reg                : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_type_reg                : std_logic := '0';
    signal sig_xfer_cache_reg               : std_logic_vector (3 downto 0) := "0000";
    signal sig_xfer_user_reg                : std_logic_vector (3 downto 0) := "0000";
    signal sig_xfer_len_reg                 : std_logic_vector(LEN_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_tag_reg                 : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_dsa_reg                 : std_logic_vector(CMD_DSA_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_drr_reg                 : std_logic := '0';
    signal sig_xfer_eof_reg                 : std_logic := '0';
    signal sig_xfer_strt_strb_reg           : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb_reg            : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_is_seq_reg              : std_logic := '0';
    signal sig_xfer_cmd_cmplt_reg           : std_logic := '0';
    signal sig_xfer_calc_err_reg            : std_logic := '0';
    signal sig_xfer_reg_empty               : std_logic := '0';
    signal sig_xfer_reg_full                : std_logic := '0';
                                            
    -- Address Counter                      
    signal sig_ld_addr_cntr                 : std_logic := '0';
    signal sig_incr_addr_cntr               : std_logic := '0';
    signal sig_addr_cntr_incr_im1           : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_byte_change_minus1_im2       : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');

    -- misc
    signal sig_xfer_len_im2                 : std_logic_vector(LEN_WIDTH-1 downto 0);
    signal sig_xfer_strt_strb_im2           : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_strt_strb2use_im3       : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb_im2            : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb2use_im3        : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_address_im0             : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_size                    : std_logic_vector(2 downto 0) := (others => '0');
    signal sig_cmd_addr_slice               : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_btt_slice                : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_type_slice               : std_logic := '0';
    signal sig_cmd_cache_slice              : std_logic_vector (3 downto 0) := "0000";
    signal sig_cmd_user_slice               : std_logic_vector (3 downto 0) := "0000";
    signal sig_cmd_tag_slice                : std_logic_vector(CMD_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_dsa_slice                : std_logic_vector(CMD_DSA_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_drr_slice                : std_logic := '0';
    signal sig_cmd_eof_slice                : std_logic := '0';
    signal sig_calc_error_reg               : std_logic := '0';
    signal sig_calc_error_pushed            : std_logic := '0';

   -- PCC2 stuff
    signal sig_finish_addr_offset_im1       : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_len_eq_0_im2            : std_logic := '0';
    signal sig_first_xfer_im0               : std_logic := '0';
    signal sig_bytes_to_mbaa_im0            : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_bytes_to_mbaa_ireg1          : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_lsh_rollover            : std_logic := '0';
    signal sig_predict_addr_lsh_slv         : std_logic_vector(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_predict_addr_lsh_im1         : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_cntr_lsh_im0            : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_cntr_lsh_kh            : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_cntr_lsh_im0_slv        : std_logic_vector(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_cntr_im0_msh            : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_strbgen_addr_im0             : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_strbgen_bytes_im1            : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH   downto 0) := (others => '0');
    signal sig_ld_btt_cntr                  : std_logic := '0';
    signal sig_decr_btt_cntr                : std_logic := '0';
    signal sig_btt_cntr_im0                 : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd2data_valid               : std_logic := '0';
    signal sig_clr_cmd2data_valid           : std_logic := '0';
    signal sig_cmd2addr_valid               : std_logic := '0';
    signal sig_clr_cmd2addr_valid           : std_logic := '0';
    signal sig_btt_lt_b2mbaa_im0            : std_logic := '0';
    signal sig_btt_lt_b2mbaa_ireg1          : std_logic := '0';
    signal sig_btt_eq_b2mbaa_im0            : std_logic := '0';
    signal sig_btt_eq_b2mbaa_ireg1          : std_logic := '0';
    signal sig_addr_incr_ge_bpdb_im1        : std_logic := '0';

    -- Unaligned start address support
    signal sig_adjusted_addr_incr_im1       : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_adjusted_addr_incr_ireg2     : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_start_addr_offset_slice_im0  : Unsigned(DBEAT_RESIDUE_WIDTH-1 downto 0) := (others => '0');
    signal sig_mbaa_addr_cntr_slice_im0     : Unsigned(MBAA_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_aligned_im0             : std_logic := '0';
    signal sig_addr_aligned_ireg1           : std_logic := '0';

    -- S2MM DRE Support
    signal sig_cmd2dre_valid                : std_logic := '0';
    signal sig_clr_cmd2dre_valid            : std_logic := '0';
    signal sig_input_xfer_btt_im0           : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_btt_reg                 : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_dre_eof_reg             : std_logic := '0';

    -- Long Timing path breakup intermediate registers
    signal sig_strbgen_addr_ireg2           : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_strbgen_bytes_ireg2          : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH   downto 0) := (others => '0');
    signal sig_finish_addr_offset_ireg2     : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_last_addr_offset_im2         : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_xfer_strt_strb_ireg3         : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb_ireg3          : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_len_eq_0_ireg3          : std_logic := '0';

    signal sig_addr_cntr_incr_ireg2         : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_predict_addr_lsh_im3_slv     : std_logic_vector(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_predict_addr_lsh_im2         : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_predict_addr_lsh_ireg3       : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_lsh_rollover_im3        : std_logic := '0';
    
    signal sig_mmap_reset_reg               : std_logic := '0';
    
    ----------------------------------------------------------
 




  begin --(architecture implementation)



     -- Assign calculation error output
     calc_error               <= sig_calc_error_reg;

     -- Assign the ready output to the Command FIFO
     mst2cmd_cmd_ready        <= not(sig_sm_halt_reg) and
                                 sig_input_reg_empty  and
                                 not(sig_calc_error_pushed);

     -- Assign the Address Channel Controller Qualifiers
     mstr2addr_tag            <=  sig_xfer_tag_reg ;
     mstr2addr_addr           <=  sig_xfer_addr_reg;
     mstr2addr_len            <=  sig_xfer_len_reg ;
     mstr2addr_size           <=  sig_xfer_size    ;
     mstr2addr_burst          <=  '0' & sig_xfer_type_reg; -- only fixed or increment supported
     mstr2addr_cache          <=  sig_xfer_cache_reg; -- only fixed or increment supported
     mstr2addr_user           <=  sig_xfer_user_reg; -- only fixed or increment supported
     mstr2addr_cmd_valid      <=  sig_cmd2addr_valid;
     mstr2addr_calc_error     <=  sig_xfer_calc_err_reg;
     mstr2addr_cmd_cmplt      <=  sig_xfer_cmd_cmplt_reg;
     

     -- Assign the Data Channel Controller Qualifiers
     mstr2data_tag            <= sig_xfer_tag_reg      ;
     mstr2data_saddr_lsb      <= sig_xfer_addr_reg(C_SEL_ADDR_WIDTH-1 downto 0);
     mstr2data_len            <= sig_xfer_len_reg      ;
     mstr2data_strt_strb      <= sig_xfer_strt_strb_reg;
     mstr2data_last_strb      <= sig_xfer_end_strb_reg ;
     mstr2data_drr            <= sig_xfer_drr_reg      ;
     mstr2data_eof            <= sig_xfer_eof_reg      ;
     mstr2data_sequential     <= sig_xfer_is_seq_reg   ;
     mstr2data_cmd_cmplt      <= sig_xfer_cmd_cmplt_reg;
     mstr2data_cmd_valid      <= sig_cmd2data_valid    ;

     mstr2data_dre_src_align  <= sig_xfer_addr_reg(C_DRE_ALIGN_WIDTH-1 downto 0);  -- Used by MM2S DRE
     mstr2data_dre_dest_align <= sig_xfer_dsa_reg(C_DRE_ALIGN_WIDTH-1 downto 0);   -- Used by MM2S DRE

     mstr2data_calc_error     <= sig_xfer_calc_err_reg ;


     -- Assign the DRE Controller Qualifiers
     mstr2dre_cmd_valid       <= sig_cmd2dre_valid     ;                            -- Used by DRE
     mstr2dre_tag             <= sig_xfer_tag_reg      ;                            -- Used by DRE
     mstr2dre_btt             <= sig_xfer_btt_reg      ;                            -- Used by DRE
     mstr2dre_drr             <= sig_xfer_drr_reg      ;                            -- Used by DRE
     mstr2dre_eof             <= sig_xfer_dre_eof_reg  ;                            -- Used by DRE
     mstr2dre_cmd_cmplt       <= sig_xfer_cmd_cmplt_reg;                            -- Used by DRE
     mstr2dre_calc_error      <= sig_xfer_calc_err_reg ;                            -- Used by DRE


     
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: DO_MM2S_CASE
     --
     -- If Generate Description:
     --  Assigns the auxillary DRE Control Source and Destination
     -- ports for the MM2S use case.
     --
     ------------------------------------------------------------
     DO_MM2S_CASE : if (C_IS_MM2S = 1) generate
    
       begin
      
         mstr2dre_dre_src_align   <= sig_xfer_addr_reg(C_DRE_ALIGN_WIDTH-1 downto 0);   -- Used by DRE
         mstr2dre_dre_dest_align  <= sig_xfer_dsa_reg(C_DRE_ALIGN_WIDTH-1 downto 0) ;   -- Used by DRE
      
       end generate DO_MM2S_CASE;



     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: DO_S2MM_CASE
     --
     -- If Generate Description:
     --  Assigns the auxillary DRE Control Source and Destination
     -- ports for the S2MM use case.
     --
     ------------------------------------------------------------
     DO_S2MM_CASE : if (C_IS_MM2S = 0) generate
    
       begin
      
         mstr2dre_dre_src_align   <= sig_xfer_dsa_reg(C_DRE_ALIGN_WIDTH-1 downto 0) ;   -- Used by DRE
         mstr2dre_dre_dest_align  <= sig_xfer_addr_reg(C_DRE_ALIGN_WIDTH-1 downto 0);   -- Used by DRE
      
       end generate DO_S2MM_CASE;







     -- Store and Forward Support Start Offset (used by Packer/Unpacker logic)
     mstr2dre_strt_offset     <= sig_xfer_addr_reg(SF_OFFSET_MS_INDEX downto SF_OFFSET_LS_INDEX);  
     
     

   -- Start internal logic.

--    sig_cmd_type_slice        <=  '1';  -- always incrementing (per Interface_X guidelines)
    sig_cmd_user_slice       <= cache2mstr_command(7 downto 4);
    sig_cmd_cache_slice        <= cache2mstr_command(3 downto 0);
 
    sig_cmd_type_slice        <=  cmd2mstr_command(CMD_TYPE_INDEX);
    sig_cmd_addr_slice        <=  cmd2mstr_command(CMD_ADDR_MS_INDEX downto CMD_ADDR_LS_INDEX);
    sig_cmd_tag_slice         <=  cmd2mstr_command(CMD_TAG_MS_INDEX downto CMD_TAG_LS_INDEX);
    sig_cmd_btt_slice         <=  cmd2mstr_command(CMD_BTT_MS_INDEX downto CMD_BTT_LS_INDEX);

    sig_cmd_dsa_slice         <=  cmd2mstr_command(CMD_DSA_MS_INDEX downto CMD_DSA_LS_INDEX);
    sig_cmd_drr_slice         <=  cmd2mstr_command(CMD_DRR_INDEX);
    sig_cmd_eof_slice         <=  cmd2mstr_command(CMD_EOF_INDEX);



    -- Check for a zero length BTT (error condition)
    sig_btt_is_zero  <= '1'
      when  (sig_cmd_btt_slice = BTT_ZEROS)
      Else '0';

    sig_xfer_size <= SIZE_TO_USE;



    -----------------------------------------------------------------
    -- Reset fanout control
    -----------------------------------------------------------------
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_RESET_REG
    --
    -- Process Description:
    --  Registers the input reset to reduce fanout. This module
    --  has a high number of register bits to reset.
    --
    -------------------------------------------------------------
    IMP_RESET_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
        
          sig_mmap_reset_reg <= mmap_reset;
        
        end if;       
      end process IMP_RESET_REG; 

    
    
    
    
    
    
    

    -----------------------------------------------------------------
    -- Input xfer register design

    sig_push_input_reg  <=  not(sig_sm_halt_reg) and
                            cmd2mstr_cmd_valid   and
                            sig_input_reg_empty  and
                            not(sig_calc_error_reg);

    sig_pop_input_reg   <= sig_sm_pop_input_reg;



    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_INPUT_QUAL
    --
    -- Process Description:
    --  Implements the input command qualifier holding register
    --
    -------------------------------------------------------------
    REG_INPUT_QUAL : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg    = '1' or
                sig_pop_input_reg     = '1' or
                sig_calc_error_pushed = '1') then

              sig_input_cache_type_reg          <=  (others => '0');
              sig_input_user_type_reg           <=  (others => '0');
              sig_input_burst_type_reg          <=  '0';
              sig_input_tag_reg                 <=  (others => '0');
              sig_input_dsa_reg                 <=  (others => '0');
              sig_input_drr_reg                 <=  '0';
              sig_input_eof_reg                 <=  '0';

              sig_input_reg_empty               <=  '1';
              sig_input_reg_full                <=  '0';

            elsif (sig_push_input_reg = '1') then
              sig_input_cache_type_reg          <=  sig_cmd_cache_slice;
              sig_input_user_type_reg           <=  sig_cmd_user_slice;
              sig_input_burst_type_reg          <=  sig_cmd_type_slice;
              sig_input_tag_reg                 <=  sig_cmd_tag_slice;
              sig_input_dsa_reg                 <=  sig_cmd_dsa_slice;
              sig_input_drr_reg                 <=  sig_cmd_drr_slice;
              sig_input_eof_reg                 <=  sig_cmd_eof_slice;

              sig_input_reg_empty               <=  '0';
              sig_input_reg_full                <=  '1';

            else
              null; -- Hold current State
            end if;
         end if;
       end process REG_INPUT_QUAL;





  ----------------------------------------------------------------------
  -- Calculation Error Logic


  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_CALC_ERROR_FLOP
  --
  -- Process Description:
  --   Implements the flop for the Calc Error flag, Once set,
  -- the flag cannot be cleared until a reset is issued.
  --
  -------------------------------------------------------------
  IMP_CALC_ERROR_FLOP : process (primary_aclk)
     begin
       if (primary_aclk'event and primary_aclk = '1') then
          if (sig_mmap_reset_reg = '1') then
            sig_calc_error_reg <= '0';
          elsif (sig_push_input_reg = '1' and
                 sig_calc_error_reg = '0') then
            sig_calc_error_reg <= sig_btt_is_zero;
          else
            Null;  -- hold the current state
          end if;
       end if;
     end process IMP_CALC_ERROR_FLOP;



  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_CALC_ERROR_PUSHED
  --
  -- Process Description:
  --   Implements the flop for generating a flag indicating the
  -- calculation error flag has been pushed to the addr and data
  -- controllers.
  --
  -------------------------------------------------------------
  IMP_CALC_ERROR_PUSHED : process (primary_aclk)
     begin
       if (primary_aclk'event and primary_aclk = '1') then
          if (sig_mmap_reset_reg = '1') then
            sig_calc_error_pushed <= '0';
          elsif (sig_push_xfer_reg = '1' and
                 sig_calc_error_pushed = '0') then
            sig_calc_error_pushed <= sig_calc_error_reg;
          else
            Null;  -- hold the current state
          end if;
       end if;
     end process IMP_CALC_ERROR_PUSHED;









  ---------------------------------------------------------------------
  -- Strobe Generator Logic

   sig_xfer_strt_strb2use_im3 <=  sig_xfer_strt_strb_ireg3
     When (sig_first_xfer_im0 = '1')
     Else (others => '1');

   sig_xfer_end_strb2use_im3 <= sig_xfer_strt_strb2use_im3
     When (sig_xfer_len_eq_0_ireg3 = '1' and
           sig_first_xfer_im0      = '1')
     else sig_xfer_end_strb_ireg3
     When (sig_last_xfer_valid_im1 = '1')
     Else (others => '1');


   
   
   
    ----------------------------------------------------------
    -- Intermediate registers for STBGEN Fmax path
   
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_IM_STBGEN_REGS
    --
    -- Process Description:
    --  Intermediate registers for Strobegen inputs to break
    -- long timing paths.
    --
    -------------------------------------------------------------
    IMP_IM_STBGEN_REGS : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then

             sig_strbgen_addr_ireg2       <= (others => '0');
             sig_strbgen_bytes_ireg2      <= (others => '0');
             sig_finish_addr_offset_ireg2 <= (others => '0');
    
           elsif (sig_sm_ld_calc2_reg = '1') then

             sig_strbgen_addr_ireg2       <= sig_strbgen_addr_im0      ;
             sig_strbgen_bytes_ireg2      <= sig_strbgen_bytes_im1     ;
             sig_finish_addr_offset_ireg2 <= sig_finish_addr_offset_im1;
    
           else
    
             null;  -- hold state
    
           end if; 
        end if;       
      end process IMP_IM_STBGEN_REGS; 
   
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_IM_STBGEN_OUT_REGS
    --
    -- Process Description:
    --  Intermediate registers for Strobegen outputs to break
    -- long timing paths.
    --
    -------------------------------------------------------------
    IMP_IM_STBGEN_OUT_REGS : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then

             sig_xfer_strt_strb_ireg3     <= (others => '0');
             sig_xfer_end_strb_ireg3      <= (others => '0');
             sig_xfer_len_eq_0_ireg3      <= '0';
    
           elsif (sig_sm_ld_calc3_reg = '1') then

             sig_xfer_strt_strb_ireg3     <= sig_xfer_strt_strb_im2;
             sig_xfer_end_strb_ireg3      <= sig_xfer_end_strb_im2 ;
             sig_xfer_len_eq_0_ireg3      <= sig_xfer_len_eq_0_im2 ;
    
           else
    
             null;  -- hold state
    
           end if; 
        end if;       
      end process IMP_IM_STBGEN_OUT_REGS; 
   
   
   
   
   
   
   
   
    ------------------------------------------------------------
    -- Instance: I_STRT_STRB_GEN 
    --
    -- Description:
    --  Strobe generator instance. Generates strobe bits for
    -- a designated starting byte lane and the number of bytes
    -- to be transfered (for that data beat).    
    --
    ------------------------------------------------------------
    I_STRT_STRB_GEN : entity axi_datamover_v5_1_17.axi_datamover_strb_gen2
    generic map (
                          
      C_OP_MODE            =>  0                         , -- 0 = Offset/Length mode
      C_STRB_WIDTH         =>  BYTES_PER_DBEAT           ,   
      C_OFFSET_WIDTH       =>  STRBGEN_ADDR_SLICE_WIDTH  ,   
      C_NUM_BYTES_WIDTH    =>  STRBGEN_ADDR_SLICE_WIDTH+1           
  
      )
    port map (
      
      start_addr_offset    =>  sig_strbgen_addr_ireg2  , 
      end_addr_offset      =>  STRBGEN_ADDR_0          , -- not used in op mode 0
      num_valid_bytes      =>  sig_strbgen_bytes_ireg2 , 
      strb_out             =>  sig_xfer_strt_strb_im2   
  
      );
                               
   

    
    
    -- The ending address offset is 1 less than the calculated 
    -- starting address for the next sequential transfer.
    sig_last_addr_offset_im2 <=  STD_LOGIC_VECTOR(UNSIGNED(sig_finish_addr_offset_ireg2) - 
                                 STRBGEN_ADDR_SLICE_1);
   

    ------------------------------------------------------------
    -- Instance: I_END_STRB_GEN 
    --
    -- Description:
    --  End Strobe generator instance. Generates asserted strobe 
    -- bits from byte offset 0 to the ending byte offset.    
    --
    ------------------------------------------------------------
    I_END_STRB_GEN : entity axi_datamover_v5_1_17.axi_datamover_strb_gen2
    generic map (
                          
      C_OP_MODE            =>  1                        , -- 0 = Offset/Length mode
      C_STRB_WIDTH         =>  BYTES_PER_DBEAT          ,   
      C_OFFSET_WIDTH       =>  STRBGEN_ADDR_SLICE_WIDTH ,   
      C_NUM_BYTES_WIDTH    =>  STRBGEN_ADDR_SLICE_WIDTH          
  
      )
    port map (
      
      start_addr_offset    =>  STRBGEN_ADDR_0               , 
      end_addr_offset      =>  sig_last_addr_offset_im2     , 
      num_valid_bytes      =>  STRBGEN_ADDR_0               , -- not used in op mode 1
      strb_out             =>  sig_xfer_end_strb_im2   
  
      );
                               
  


   


    -----------------------------------------------------------------
    -- Output xfer register design

    sig_push_xfer_reg <= (sig_ld_xfer_reg and sig_xfer_reg_empty);

                         -- Data taking xfer after Addr and DRE
    sig_pop_xfer_reg  <= (sig_clr_cmd2data_valid and not(sig_cmd2addr_valid) and not(sig_cmd2dre_valid))  or
                         -- Addr taking xfer after Data and DRE
                         (sig_clr_cmd2addr_valid and not(sig_cmd2data_valid) and not(sig_cmd2dre_valid))  or 
                         -- DRE taking xfer after Data and ADDR
                         (sig_clr_cmd2dre_valid  and not(sig_cmd2data_valid) and not(sig_cmd2addr_valid)) or  
                         
                         -- data and Addr taking xfer after DRE
                         (sig_clr_cmd2data_valid and sig_clr_cmd2addr_valid and not(sig_cmd2dre_valid))   or 
                         -- Addr and DRE taking xfer after Data
                         (sig_clr_cmd2addr_valid and sig_clr_cmd2dre_valid  and not(sig_cmd2data_valid))  or 
                         -- Data and DRE taking xfer after Addr
                         (sig_clr_cmd2data_valid and sig_clr_cmd2dre_valid  and not(sig_cmd2addr_valid))  or  
                         
                         -- Addr, Data,  and DRE all taking xfer
                         (sig_clr_cmd2data_valid and sig_clr_cmd2addr_valid and sig_clr_cmd2dre_valid);       



    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_OUTPUT_QUAL
    --
    -- Process Description:
    --  Implements the output xfer qualifier holding register
    --
    -------------------------------------------------------------
    REG_OUTPUT_QUAL : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
               (sig_pop_xfer_reg   = '1' and
                sig_push_xfer_reg  = '0')) then

--              sig_xfer_cache_reg      <=  (others => '0');
--              sig_xfer_user_reg       <=  (others => '0');
--              sig_xfer_addr_reg       <=  (others => '0');
--              sig_xfer_type_reg       <=  '0';
 --             sig_xfer_len_reg        <=  (others => '0');
 --             sig_xfer_tag_reg        <=  (others => '0');
 --             sig_xfer_dsa_reg        <=  (others => '0');
 --             sig_xfer_drr_reg        <=  '0';
 --             sig_xfer_eof_reg        <=  '0';
 --             sig_xfer_strt_strb_reg  <=  (others => '0');
 --             sig_xfer_end_strb_reg   <=  (others => '0');
 --             sig_xfer_is_seq_reg     <=  '0';
 --             sig_xfer_cmd_cmplt_reg  <=  '0';
 --             sig_xfer_calc_err_reg   <=  '0';
 --             sig_xfer_btt_reg        <=  (others => '0');
 --             sig_xfer_dre_eof_reg    <=  '0';

              sig_xfer_reg_empty      <=  '1';
              sig_xfer_reg_full       <=  '0';

            elsif (sig_push_xfer_reg = '1') then
 --             if (sig_input_burst_type_reg = '0') then
 --                 sig_xfer_addr_reg       <=  sig_addr_cntr_lsh_kh; 
 --             else
 --                 sig_xfer_addr_reg       <=  sig_xfer_address_im0         ;
 --             end if;
 --             sig_xfer_type_reg       <=  sig_input_burst_type_reg     ;
 --             sig_xfer_cache_reg      <=  sig_input_cache_type_reg     ;
 --             sig_xfer_user_reg       <=  sig_input_user_type_reg     ;
 --             sig_xfer_len_reg        <=  sig_xfer_len_im2             ;
 --             sig_xfer_tag_reg        <=  sig_input_tag_reg            ;
 --             sig_xfer_dsa_reg        <=  sig_input_dsa_reg            ;
 --             sig_xfer_drr_reg        <=  sig_input_drr_reg and
 --                                         sig_first_xfer_im0           ;
 --             sig_xfer_eof_reg        <=  sig_input_eof_reg and
 --                                         sig_last_xfer_valid_im1      ;
 --             sig_xfer_strt_strb_reg  <=  sig_xfer_strt_strb2use_im3   ;
 --             sig_xfer_end_strb_reg   <=  sig_xfer_end_strb2use_im3    ;
 --             sig_xfer_is_seq_reg     <=  not(sig_last_xfer_valid_im1) ;
 --             sig_xfer_cmd_cmplt_reg  <=  sig_last_xfer_valid_im1 or
 --                                         sig_calc_error_reg           ;
 --             sig_xfer_calc_err_reg   <=  sig_calc_error_reg           ;
 --             sig_xfer_btt_reg        <=  sig_input_xfer_btt_im0       ;
 --             sig_xfer_dre_eof_reg    <=  sig_input_eof_reg            ;

              sig_xfer_reg_empty      <=  '0';
              sig_xfer_reg_full       <=  '1';

            else
              null; -- Hold current State
            end if;
         end if;
       end process REG_OUTPUT_QUAL;


 --             if (sig_input_burst_type_reg = '0') then
 --                 sig_xfer_addr_reg       <=  sig_addr_cntr_lsh_kh; 
 --             else
                  sig_xfer_addr_reg       <=  sig_xfer_address_im0 when (sig_input_burst_type_reg = '1') else
                                              sig_addr_cntr_lsh_kh      ;
 --             end if;
              sig_xfer_type_reg       <=  sig_input_burst_type_reg     ;
              sig_xfer_cache_reg      <=  sig_input_cache_type_reg     ;
              sig_xfer_user_reg       <=  sig_input_user_type_reg     ;
              sig_xfer_len_reg        <=  sig_xfer_len_im2             ;
              sig_xfer_tag_reg        <=  sig_input_tag_reg            ;
              sig_xfer_dsa_reg        <=  sig_input_dsa_reg            ;
              sig_xfer_drr_reg        <=  sig_input_drr_reg and
                                          sig_first_xfer_im0           ;
              sig_xfer_eof_reg        <=  sig_input_eof_reg and
                                          sig_last_xfer_valid_im1      ;
              sig_xfer_strt_strb_reg  <=  sig_xfer_strt_strb2use_im3   ;
              sig_xfer_end_strb_reg   <=  sig_xfer_end_strb2use_im3    ;
              sig_xfer_is_seq_reg     <=  not(sig_last_xfer_valid_im1) ;
              sig_xfer_cmd_cmplt_reg  <=  sig_last_xfer_valid_im1 or
                                          sig_calc_error_reg           ;
              sig_xfer_calc_err_reg   <=  sig_calc_error_reg           ;
              sig_xfer_btt_reg        <=  sig_input_xfer_btt_im0       ;
              sig_xfer_dre_eof_reg    <=  sig_input_eof_reg            ;



    --------------------------------------------------------------
    -- BTT Counter Logic


    sig_ld_btt_cntr   <= sig_ld_addr_cntr;

--    sig_decr_btt_cntr <= sig_incr_addr_cntr;
--    above signal is using the incr_addr_cntr signal and hence cannot be 
--    used if burst type is Fixed

    sig_decr_btt_cntr <= sig_incr_addr_cntr; --sig_push_xfer_reg;


    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_BTT_CNTR
    --
    -- Process Description:
    -- Bytes to transfer counter implementation.
    --
    -------------------------------------------------------------
    IMP_BTT_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then

              sig_btt_cntr_im0 <= (others => '0');

            elsif (sig_ld_btt_cntr = '1') then

              sig_btt_cntr_im0 <= UNSIGNED(sig_cmd_btt_slice);

            Elsif (sig_decr_btt_cntr = '1') Then

              sig_btt_cntr_im0 <= sig_btt_cntr_im0-RESIZE(sig_addr_cntr_incr_ireg2, CMD_BTT_WIDTH);

            else
              null;  -- hold current state
            end if;
         end if;
       end process IMP_BTT_CNTR;



    -- Convert to logic vector for the S2MM DRE use
    -- The DRE will only use this value prior to the first
    -- decrement of the BTT Counter. Using this saves a separate
    -- BTT register.
    sig_input_xfer_btt_im0 <= STD_LOGIC_VECTOR(sig_btt_cntr_im0);


    -- Rip the Burst Count slice from BTT counter value
    sig_burst_cnt_slice_im0 <= sig_btt_cntr_im0(CMD_BTT_WIDTH-1 downto BURST_CNT_LS_INDEX);



    sig_brst_cnt_eq_zero_im0 <= '1'
      When (sig_burst_cnt_slice_im0 = BRST_CNT_0)
      Else '0';

    sig_brst_cnt_eq_one_im0 <= '1'
      When (sig_burst_cnt_slice_im0 = BRST_CNT_1)
      Else '0';


    -- Rip the BTT residue field from the BTT counter value
    sig_btt_residue_slice_im0   <=  sig_btt_cntr_im0(BTT_RESIDUE_WIDTH-1 downto 0);



    -- Check for transfer length residue of zero prior to subtracting 1
    sig_no_btt_residue_im0 <= '1'
       when (sig_btt_residue_slice_im0 = BTT_RESIDUE_0)
       Else '0';


    -- Unaligned address compensation
    -- Add the number of starting address offset byte positions to the
    -- final byte change value needed to calculate the AXI LEN field

    sig_start_addr_offset_slice_im0 <=  sig_addr_cntr_lsh_im0(DBEAT_RESIDUE_WIDTH-1 downto 0);

    sig_adjusted_addr_incr_im1      <=  sig_addr_cntr_incr_im1 +
                                        RESIZE(sig_start_addr_offset_slice_im0, ADDR_CNTR_WIDTH);







    -- adjust the address increment down by 1 byte to compensate
    -- for the LEN requirement of being N-1 data beats

    sig_byte_change_minus1_im2 <=  sig_adjusted_addr_incr_ireg2-ADDR_CNTR_ONE;



    -- Rip the new transfer length value
    sig_xfer_len_im2 <=  STD_LOGIC_VECTOR(
                         RESIZE(
                            sig_byte_change_minus1_im2(BTT_RESIDUE_WIDTH-1 downto
                                                       DBEAT_RESIDUE_WIDTH),
                         LEN_WIDTH)
                     );


    -- Check to see if the new xfer length is zero (1 data beat)
    sig_xfer_len_eq_0_im2 <= '1'
      when (sig_xfer_len_im2 = XFER_LEN_ZERO)
      Else '0';



    -- Check for Last transfer condition
    --sig_last_xfer_valid_im1  <=  (sig_brst_cnt_eq_one_im0 and
    sig_last_xfer_valid_im1  <=  (sig_brst_cnt_eq_one_ireg1 and
                                  --sig_no_btt_residue_im0  and
                                  sig_no_btt_residue_ireg1  and
                                  -- sig_addr_aligned_im0)   or  -- always the last databeat case
                                  sig_addr_aligned_ireg1)   or  -- always the last databeat case

                                 -- ((sig_btt_lt_b2mbaa_im0 or sig_btt_eq_b2mbaa_im0) and  -- less than a full burst remaining
                                 ((sig_btt_lt_b2mbaa_ireg1 or sig_btt_eq_b2mbaa_ireg1) and  -- less than a full burst remaining
                                 -- (sig_brst_cnt_eq_zero_im0 and not(sig_no_btt_residue_im0)));
                                 (sig_brst_cnt_eq_zero_ireg1 and not(sig_no_btt_residue_ireg1)));



 
    
    
    
    
    
    
    
    
    ----------------------------------------------------------------------------------------------------
    ----------------------------------------------------------------------------------------------------
    --
    -- General Address Counter Logic (applies to any address width of 32 or greater
    -- The address counter is divided into 2 16-bit segements for 32-bit address support. As the
    -- address gets wider, up to 2 more segements will be added via IfGens to provide for 64-bit 
    -- addressing.
    --
    ----------------------------------------------------------------------------------------------------
    


    -- Rip the LS bits of the LS Address Counter for the StrobeGen
    -- starting address offset
    sig_strbgen_addr_im0  <=  STD_LOGIC_VECTOR(sig_addr_cntr_lsh_im0(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0));



    -- Check if the calcualted address increment (in bytes) is greater than the
    -- number of bytes that can be transfered per data beat
    sig_addr_incr_ge_bpdb_im1 <= '1'
      When (sig_addr_cntr_incr_im1 >= TO_UNSIGNED(BYTES_PER_DBEAT, ADDR_CNTR_WIDTH))
      Else '0';


    -- If the calculated address increment (in bytes) is greater than the
    -- number of bytes that can be transfered per data beat, then clip the
    -- strobegen byte value to the number of bytes per data beat, else use the
    -- increment value.
    sig_strbgen_bytes_im1 <=  STD_LOGIC_VECTOR(TO_UNSIGNED(BYTES_PER_DBEAT, STRBGEN_ADDR_SLICE_WIDTH+1))
      when (sig_addr_incr_ge_bpdb_im1 = '1')
      else STD_LOGIC_VECTOR(sig_addr_cntr_incr_im1(STRBGEN_ADDR_SLICE_WIDTH downto 0));




    --------------------------------------------------------------------------
    -- Address Counter logic

    sig_ld_addr_cntr   <= sig_push_input_reg;

    -- don't increment address cntr if type is '0' (non-incrementing)
    sig_incr_addr_cntr <= sig_pop_xfer_reg;-- and
                     --     sig_input_burst_type_reg;



    sig_mbaa_addr_cntr_slice_im0 <= sig_addr_cntr_lsh_im0(MBAA_ADDR_SLICE_WIDTH-1 downto 0);




    sig_bytes_to_mbaa_im0 <=  TO_UNSIGNED(BYTES_PER_MAX_BURST, ADDR_CNTR_WIDTH) -
                              RESIZE(sig_mbaa_addr_cntr_slice_im0,ADDR_CNTR_WIDTH);



    sig_addr_aligned_im0 <= '1'
      when (sig_mbaa_addr_cntr_slice_im0 = BTT_RESIDUE_0)
      Else '0';


    -- Check to see if the jump to the Max Burst Aligned Address (mbaa) is less
    -- than or equal to the remaining bytes to transfer. If it is, then at least
    -- two tranfers have to be scheduled.
    sig_btt_lt_b2mbaa_im0 <= '1'
      when ((RESIZE(sig_btt_residue_slice_im0, ADDR_CNTR_WIDTH) < sig_bytes_to_mbaa_im0) and
            (sig_brst_cnt_eq_zero_im0 = '1'))

      Else '0';


    sig_btt_eq_b2mbaa_im0 <= '1'
      when ((RESIZE(sig_btt_residue_slice_im0, ADDR_CNTR_WIDTH) = sig_bytes_to_mbaa_im0) and
             (sig_brst_cnt_eq_zero_im0 = '1'))
      Else '0';





    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_IM_REG1
    --
    -- Process Description:
    --  Intermediate register stage 1 for Address Counter 
    -- derivative calculations.
    --
    -------------------------------------------------------------
    IMP_IM_REG1 : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then

             sig_bytes_to_mbaa_ireg1      <= (others => '0');
             sig_addr_aligned_ireg1       <= '0'            ;
             sig_btt_lt_b2mbaa_ireg1      <= '0'            ;
             sig_btt_eq_b2mbaa_ireg1      <= '0'            ;
             
             
             sig_brst_cnt_eq_zero_ireg1   <= '0'            ;
             sig_brst_cnt_eq_one_ireg1    <= '0'            ;
             sig_no_btt_residue_ireg1     <= '0'            ;
             
             
           elsif (sig_sm_ld_calc1_reg = '1') then

             sig_bytes_to_mbaa_ireg1      <= sig_bytes_to_mbaa_im0   ;
             sig_addr_aligned_ireg1       <= sig_addr_aligned_im0    ;
             sig_btt_lt_b2mbaa_ireg1      <= sig_btt_lt_b2mbaa_im0   ;
             sig_btt_eq_b2mbaa_ireg1      <= sig_btt_eq_b2mbaa_im0   ;
    
             sig_brst_cnt_eq_zero_ireg1   <= sig_brst_cnt_eq_zero_im0;
             sig_brst_cnt_eq_one_ireg1    <= sig_brst_cnt_eq_one_im0 ;
             sig_no_btt_residue_ireg1     <= sig_no_btt_residue_im0  ;
             
           else
    
             null;  -- hold state
    
           end if; 
        end if;       
      end process IMP_IM_REG1; 
   
   
   


    -- Select the address counter increment value to use
    sig_addr_cntr_incr_im1 <= RESIZE(sig_btt_residue_slice_im0, ADDR_CNTR_WIDTH)
      --When (sig_btt_lt_b2mbaa_im0 = '1')
      When (sig_btt_lt_b2mbaa_ireg1 = '1')
      --else sig_bytes_to_mbaa_im0
      else  sig_bytes_to_mbaa_ireg1
      when (sig_first_xfer_im0 = '1')
      else TO_UNSIGNED(BYTES_PER_MAX_BURST, ADDR_CNTR_WIDTH);



    -- calculate the next starting address after the current
    -- xfer completes
    sig_predict_addr_lsh_im1    <=  sig_addr_cntr_lsh_im0 + sig_addr_cntr_incr_im1;


    -- Predict next transfer's address offset for the Strobe Generator
    sig_finish_addr_offset_im1  <= STD_LOGIC_VECTOR(sig_predict_addr_lsh_im1(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0));


    sig_addr_cntr_lsh_im0_slv   <= STD_LOGIC_VECTOR(sig_addr_cntr_lsh_im0);



    -- Determine if an address count lsh rollover is going to occur when
    -- jumping to the next starting address by comparing the MS bit of the
    -- current address lsh to the MS bit of the predicted address lsh .
    -- A transition of a '1' to a '0' is a rollover.
    sig_addr_lsh_rollover_im3 <= '1'
      when (
            (sig_addr_cntr_lsh_im0_slv(ADDR_CNTR_WIDTH-1)    = '1') and
            (sig_predict_addr_lsh_im3_slv(ADDR_CNTR_WIDTH-1) = '0')
           )
      Else '0';




       
     
          
          
    ----------------------------------------------------------
    -- Intermediate registers for reducing the Address Counter 
    -- Increment timing path
    ----------------------------------------------------------
   

    -- calculate the next starting address after the current
    -- xfer completes using intermediate register values
    sig_predict_addr_lsh_im2      <= sig_addr_cntr_lsh_im0 + sig_addr_cntr_incr_ireg2;
    
    sig_predict_addr_lsh_im3_slv  <= STD_LOGIC_VECTOR(sig_predict_addr_lsh_ireg3);
   
   
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_IM_ADDRINC_REG
    --
    -- Process Description:
    --  Intermediate registers for address counter increment to 
    -- break long timing paths.
    --
    -------------------------------------------------------------
    IMP_IM_ADDRINC_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then

             sig_addr_cntr_incr_ireg2   <= (others => '0');
    
           elsif (sig_sm_ld_calc2_reg = '1') then

             sig_addr_cntr_incr_ireg2   <= sig_addr_cntr_incr_im1;
    
           else
    
             null;  -- hold state
    
           end if; 
        end if;       
      end process IMP_IM_ADDRINC_REG; 
   
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_IM_PREDICT_ADDR_REG
    --
    -- Process Description:
    --  Intermediate register for predicted address to break up
    -- long timing paths.
    --
    -------------------------------------------------------------
    IMP_IM_PREDICT_ADDR_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then

             sig_predict_addr_lsh_ireg3     <= (others => '0');
    
           elsif (sig_sm_ld_calc3_reg = '1') then

             sig_predict_addr_lsh_ireg3     <= sig_predict_addr_lsh_im2;
    
           else
    
             null;  -- hold state
    
           end if; 
        end if;       
      end process IMP_IM_PREDICT_ADDR_REG; 
   
   
   
     
     
     

    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_ADDR_STUFF
    --
    -- Process Description:
    --  Implements a general register for address counter related
    -- things.
    --
    -------------------------------------------------------------
    REG_ADDR_STUFF : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then

              sig_adjusted_addr_incr_ireg2 <= (others => '0');

           elsif (sig_sm_ld_calc2_reg = '1') then
              
              sig_adjusted_addr_incr_ireg2 <= sig_adjusted_addr_incr_im1;

            else
    
             null;  -- hold state
    
            end if;
         end if;
       end process REG_ADDR_STUFF;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_LSH_ADDR_CNTR
    --
    -- Process Description:
    -- Least Significant Half Address counter implementation.
    --
    -------------------------------------------------------------
    IMP_LSH_ADDR_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then

              sig_addr_cntr_lsh_im0 <= (others => '0');
              sig_addr_cntr_lsh_kh <= (others => '0');

            elsif (sig_ld_addr_cntr = '1') then

              sig_addr_cntr_lsh_im0 <= UNSIGNED(sig_cmd_addr_slice(ADDR_CNTR_WIDTH-1 downto 0));
              sig_addr_cntr_lsh_kh <= sig_cmd_addr_slice;

            Elsif (sig_incr_addr_cntr = '1') then -- and sig_input_burst_type_reg = '1') Then

              sig_addr_cntr_lsh_im0 <= sig_predict_addr_lsh_ireg3;

            else
              null;  -- hold current state
            end if;
         end if;
       end process IMP_LSH_ADDR_CNTR;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_MSH_ADDR_CNTR
    --
    -- Process Description:
    -- Least Significant Half Address counter implementation.
    --
    -------------------------------------------------------------
    IMP_MSH_ADDR_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then

              sig_addr_cntr_im0_msh <= (others => '0');

            elsif (sig_ld_addr_cntr = '1') then

              sig_addr_cntr_im0_msh <= UNSIGNED(sig_cmd_addr_slice((2*ADDR_CNTR_WIDTH)-1 downto ADDR_CNTR_WIDTH));

            Elsif (sig_incr_addr_cntr        = '1' and 
                   sig_addr_lsh_rollover_im3 = '1') then

              sig_addr_cntr_im0_msh <= sig_addr_cntr_im0_msh+ADDR_CNTR_ONE;

            else
              null;  -- hold current state
            end if;
         end if;
       end process IMP_MSH_ADDR_CNTR;





   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_FIRST_XFER_FLOP
   --
   -- Process Description:
   --  Implements the register flop for the first transfer flag.
   --
   -------------------------------------------------------------
   IMP_FIRST_XFER_FLOP : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg  = '1' or
               sig_incr_addr_cntr  = '1') then

             sig_first_xfer_im0 <= '0';

           elsif (sig_ld_addr_cntr = '1') then

             sig_first_xfer_im0 <= '1';

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_FIRST_XFER_FLOP;




 
 
 
 
 
 
 
 
 
 
 
 
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_32
    --
    -- If Generate Description:
    -- Implements the Address segment merge logic for the 32-bit
    -- address width case. The address counter segments are split 
    -- into two 16-bit sections to improve Fmax convergence.
    --
    --
    ------------------------------------------------------------
    GEN_ADDR_32 : if (C_ADDR_WIDTH = 32) generate


       begin


         -- Populate the transfer address value by concatonating the
         -- address counter segments
         sig_xfer_address_im0 <= STD_LOGIC_VECTOR(sig_addr_cntr_im0_msh) &
                                 STD_LOGIC_VECTOR(sig_addr_cntr_lsh_im0);


       end generate GEN_ADDR_32;









    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_GT_32_LE_48
    --
    -- If Generate Description:
    -- Implements the additional Address Counter logic for the case 
    -- when the address width is greater than 32 bits and less than
    -- or equal to 48 bits. In this case, an additional counter segment
    -- is implemented (segment 3) that is variable width of 1
    -- to 16 bits.
    --
    ------------------------------------------------------------
    GEN_ADDR_GT_32_LE_48 : if (C_ADDR_WIDTH  > 32 and
                               C_ADDR_WIDTH <= 48) generate


      -- Local constants
      Constant ACNTR_SEG3_WIDTH    : integer  := C_ADDR_WIDTH-32;
      Constant ACNTR_SEG3_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG3_WIDTH);
      Constant ACNTR_MSH_MAX       : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      Constant SEG3_ADDR_RIP_MS_INDEX : integer := C_ADDR_WIDTH-1;
      Constant SEG3_ADDR_RIP_LS_INDEX : integer := 32;
      
      
      -- Local Signals
      signal lsig_seg3_addr_cntr       : unsigned(ACNTR_SEG3_WIDTH-1 downto 0) := (others => '0');
      signal lsig_acntr_msh_eq_max     : std_logic := '0';
      signal lsig_acntr_msh_eq_max_reg : std_logic := '0';
       
       
      begin

      
      
        -- Populate the transfer address value by concatonating the
        -- 3 address counter segments
        sig_xfer_address_im0 <= STD_LOGIC_VECTOR(lsig_seg3_addr_cntr  ) &
                                STD_LOGIC_VECTOR(sig_addr_cntr_im0_msh) &
                                STD_LOGIC_VECTOR(sig_addr_cntr_lsh_im0);


       
        
        -- See if the MSH (Segment 2) of the Adress Counter is at a max value
        lsig_acntr_msh_eq_max <= '1'
          when (sig_addr_cntr_im0_msh = ACNTR_MSH_MAX)
          Else '0';


  
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG2_EQ_MAX_REG
        --
        -- Process Description:
        --  Implements a register for the flag indicating the address
        -- counter MSH (Segment 2) is at max value and will rollover
        -- at the next increment interval for the counter. Registering 
        -- this signal and using it for the Seg 3 increment logic only
        -- works because there is always at least a 1 clock time gap 
        -- between the increment causing the segment 2 counter to go to 
        -- max and the next increment operation that can bump segment 3. 
        --
        -------------------------------------------------------------
        IMP_SEG2_EQ_MAX_REG : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (sig_mmap_reset_reg = '1') then
        
                 lsig_acntr_msh_eq_max_reg <= '0';
        
               else
        
                 lsig_acntr_msh_eq_max_reg <= lsig_acntr_msh_eq_max;
        
               end if; 
            end if;       
          end process IMP_SEG2_EQ_MAX_REG; 
  
        
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG3_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 3 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG3_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg3_addr_cntr <= (others => '0');

                elsif (sig_ld_addr_cntr = '1') then

                  lsig_seg3_addr_cntr <= UNSIGNED(sig_cmd_addr_slice(SEG3_ADDR_RIP_MS_INDEX downto 
                                                                     SEG3_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_addr_cntr        = '1' and --sig_input_burst_type_reg = '1' and 
                       sig_addr_lsh_rollover_im3 = '1' and
                       lsig_acntr_msh_eq_max_reg = '1') then

                  lsig_seg3_addr_cntr <= lsig_seg3_addr_cntr+ACNTR_SEG3_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG3_ADDR_CNTR;



  
  
      end generate GEN_ADDR_GT_32_LE_48;



     
     
     
     
     
     
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_GT_48
    --
    -- If Generate Description:
    -- Implements the additional Address Counter logic for the case 
    -- when the address width is greater than 48 bits and less than
    -- or equal to 64. In this case, an additional 2 counter segments
    -- are implemented (segment 3 and 4). Segment 3 is a fixed 16-bits
    -- and segment 4 is variable width of 1 to 16 bits.
    --
    ------------------------------------------------------------
    GEN_ADDR_GT_48 : if (C_ADDR_WIDTH  > 48) generate


      -- Local constants
      Constant ACNTR_SEG3_WIDTH    : integer  := ADDR_CNTR_WIDTH;
      Constant ACNTR_SEG3_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG3_WIDTH);
      Constant ACNTR_SEG3_MAX      : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      Constant ACNTR_MSH_MAX       : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      
      Constant ACNTR_SEG4_WIDTH    : integer  := C_ADDR_WIDTH-48;
      Constant ACNTR_SEG4_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG4_WIDTH);
      
      
      Constant SEG3_ADDR_RIP_MS_INDEX : integer := 47;
      Constant SEG3_ADDR_RIP_LS_INDEX : integer := 32;
      
      Constant SEG4_ADDR_RIP_MS_INDEX : integer := C_ADDR_WIDTH-1;
      Constant SEG4_ADDR_RIP_LS_INDEX : integer := 48;
      
      
      
      
      -- Local Signals
      signal lsig_seg3_addr_cntr        : unsigned(ACNTR_SEG3_WIDTH-1 downto 0) := (others => '0');
      signal lsig_acntr_msh_eq_max      : std_logic := '0';
      signal lsig_acntr_msh_eq_max_reg  : std_logic := '0';
 
      signal lsig_acntr_seg3_eq_max     : std_logic := '0';
      signal lsig_acntr_seg3_eq_max_reg : std_logic := '0';
      
      
      signal lsig_seg4_addr_cntr        : unsigned(ACNTR_SEG4_WIDTH-1 downto 0) := (others => '0');
 
       
       
      begin

      
      
        -- Populate the transfer address value by concatonating the
        -- 4 address counter segments
        sig_xfer_address_im0 <= STD_LOGIC_VECTOR(lsig_seg4_addr_cntr  ) &
                                STD_LOGIC_VECTOR(lsig_seg3_addr_cntr  ) &
                                STD_LOGIC_VECTOR(sig_addr_cntr_im0_msh) &
                                STD_LOGIC_VECTOR(sig_addr_cntr_lsh_im0);


       
        
        -- See if the MSH (Segment 2) of the Address Counter is at a max value
        lsig_acntr_msh_eq_max <= '1'
          when (sig_addr_cntr_im0_msh = ACNTR_MSH_MAX)
          Else '0';

        -- See if the Segment 3 of the Address Counter is at a max value
        lsig_acntr_seg3_eq_max <= '1'
          when (lsig_seg3_addr_cntr = ACNTR_SEG3_MAX)
          Else '0';


        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG2_3_EQ_MAX_REG
        --
        -- Process Description:
        --  Implements a register for the flag indicating the address
        -- counter segments 2 and 3 are at max value and will rollover
        -- at the next increment interval for the counter. Registering 
        -- these signals and using themt for the Seg 3/4 increment logic 
        -- only works because there is always at least a 1 clock time gap 
        -- between the increment causing the segment 2 or 3 counter to go  
        -- to max and the next increment operation. 
        --
        -------------------------------------------------------------
        IMP_SEG2_3_EQ_MAX_REG : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (sig_mmap_reset_reg = '1') then
        
                 lsig_acntr_msh_eq_max_reg  <= '0';
                 lsig_acntr_seg3_eq_max_reg <= '0';
                 
               else
        
                 lsig_acntr_msh_eq_max_reg  <= lsig_acntr_msh_eq_max;
                 lsig_acntr_seg3_eq_max_reg <= lsig_acntr_seg3_eq_max;
        
               end if; 
            end if;       
          end process IMP_SEG2_3_EQ_MAX_REG; 
  
        
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG3_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 3 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG3_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg3_addr_cntr <= (others => '0');

                elsif (sig_ld_addr_cntr = '1') then

                  lsig_seg3_addr_cntr <= UNSIGNED(sig_cmd_addr_slice(SEG3_ADDR_RIP_MS_INDEX downto 
                                                                     SEG3_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_addr_cntr        = '1' and
                       sig_addr_lsh_rollover_im3 = '1' and
                       lsig_acntr_msh_eq_max_reg = '1') then

                  lsig_seg3_addr_cntr <= lsig_seg3_addr_cntr+ACNTR_SEG3_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG3_ADDR_CNTR;



        
  
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG4_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 4 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG4_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg4_addr_cntr <= (others => '0');

                elsif (sig_ld_addr_cntr = '1') then

                  lsig_seg4_addr_cntr <= UNSIGNED(sig_cmd_addr_slice(SEG4_ADDR_RIP_MS_INDEX downto 
                                                                     SEG4_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_addr_cntr         = '1' and
                       sig_addr_lsh_rollover_im3  = '1' and
                       lsig_acntr_msh_eq_max_reg  = '1' and
                       lsig_acntr_seg3_eq_max_reg = '1') then

                  lsig_seg4_addr_cntr <= lsig_seg4_addr_cntr+ACNTR_SEG4_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG4_ADDR_CNTR;



  
  
  
      end generate GEN_ADDR_GT_48;



     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     




    -- Addr and data Cntlr FIFO interface handshake logic ------------------------------

     sig_clr_cmd2data_valid    <= sig_cmd2data_valid and data2mstr_cmd_ready;

     sig_clr_cmd2addr_valid    <= sig_cmd2addr_valid and addr2mstr_cmd_ready;

     sig_clr_cmd2dre_valid     <= sig_cmd2dre_valid  and dre2mstr_cmd_ready;



     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: CMD2DATA_VALID_FLOP
     --
     -- Process Description:
     --  Implements the set/reset flop for the Command Valid control
     -- to the Data Controller Module.
     --
     -------------------------------------------------------------
     CMD2DATA_VALID_FLOP : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg     = '1' or
                 sig_clr_cmd2data_valid = '1') then

               sig_cmd2data_valid <= '0';

             elsif (sig_sm_ld_xfer_reg_ns = '1') then

               sig_cmd2data_valid <= '1';

             else
               null; -- hold current state
             end if;
          end if;
        end process CMD2DATA_VALID_FLOP;



     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: CMD2ADDR_VALID_FLOP
     --
     -- Process Description:
     --  Implements the set/reset flop for the Command Valid control
     -- to the Address Controller Module.
     --
     -------------------------------------------------------------
     CMD2ADDR_VALID_FLOP : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg     = '1' or
                 sig_clr_cmd2addr_valid = '1') then

               sig_cmd2addr_valid <= '0';

             elsif (sig_sm_ld_xfer_reg_ns = '1') then

               sig_cmd2addr_valid <= '1';

             else
               null; -- hold current state
             end if;
          end if;
        end process CMD2ADDR_VALID_FLOP;







     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: CMD2DRE_VALID_FLOP
     --
     -- Process Description:
     --  Implements the set/reset flop for the Command Valid control
     -- to the DRE Module (S2MM DRE Only).
     --
     -- Note that the S2MM DRE only needs to be loaded with a command
     -- for each parent command, not every child command.
     --
     -------------------------------------------------------------
     CMD2DRE_VALID_FLOP : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg    = '1' or
                 sig_clr_cmd2dre_valid = '1') then

               sig_cmd2dre_valid <= '0';

             elsif (sig_sm_ld_xfer_reg_ns = '1' and
                    sig_first_xfer_im0    = '1') then

               sig_cmd2dre_valid <= '1';

             else
               null; -- hold current state
             end if;
          end if;
        end process CMD2DRE_VALID_FLOP;








    -------------------------------------------------------------------------
    -- PCC State machine Logic





    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: PCC_SM_COMBINATIONAL
    --
    -- Process Description:
    -- PCC State Machine combinational implementation
    --
    -------------------------------------------------------------
    PCC_SM_COMBINATIONAL : process (sig_pcc_sm_state     ,
                                    sig_parent_done      ,
                                    sig_push_input_reg   ,
                                    sig_pop_xfer_reg    ,
                                    sig_calc_error_pushed)
       begin

         -- SM Defaults
         sig_pcc_sm_state_ns     <=  INIT;
         sig_sm_halt_ns          <=  '0';
         sig_sm_ld_xfer_reg_ns   <=  '0';
         sig_sm_pop_input_reg_ns <=  '0';
         sig_sm_ld_calc1_reg_ns  <=  '0';
         sig_sm_ld_calc2_reg_ns  <=  '0';
         sig_sm_ld_calc3_reg_ns  <=  '0';


         case sig_pcc_sm_state is

           --------------------------------------------
           when INIT =>

             sig_pcc_sm_state_ns  <=  WAIT_FOR_CMD;
             sig_sm_halt_ns       <=  '1';

           --------------------------------------------
           when WAIT_FOR_CMD =>

             If (sig_push_input_reg = '1') Then

               sig_pcc_sm_state_ns     <=  CALC_1;
               sig_sm_ld_calc1_reg_ns  <=  '1';


             else

               sig_pcc_sm_state_ns <=  WAIT_FOR_CMD;

             End if;

           --------------------------------------------
           when CALC_1 =>

             sig_pcc_sm_state_ns     <=  CALC_2;
             sig_sm_ld_calc2_reg_ns  <=  '1';
             

           --------------------------------------------
           when CALC_2 =>

             sig_pcc_sm_state_ns    <=  CALC_3;
             sig_sm_ld_calc3_reg_ns <= '1';


           --------------------------------------------
           when CALC_3 =>

             sig_pcc_sm_state_ns    <=  WAIT_ON_XFER_PUSH;
             sig_sm_ld_xfer_reg_ns  <= '1';


           --------------------------------------------
           when WAIT_ON_XFER_PUSH =>

             if (sig_pop_xfer_reg = '1') then

               sig_pcc_sm_state_ns <=  CHK_IF_DONE;

             else  -- wait until output register is loaded

               sig_pcc_sm_state_ns <=  WAIT_ON_XFER_PUSH;


             end if;


           --------------------------------------------
           when CHK_IF_DONE =>

             If (sig_calc_error_pushed = '1') then -- Internal error, go to trap

               sig_pcc_sm_state_ns <=  ERROR_TRAP;
               sig_sm_halt_ns      <=  '1';

             elsif (sig_parent_done = '1') Then  -- done with parent command

               sig_pcc_sm_state_ns     <=  WAIT_FOR_CMD;
               sig_sm_pop_input_reg_ns <= '1';

             else  -- Still breaking up parent command

               sig_pcc_sm_state_ns     <=  CALC_1;
               sig_sm_ld_calc1_reg_ns  <=  '1';

             end if;


           --------------------------------------------
           when ERROR_TRAP =>

             sig_pcc_sm_state_ns <=  ERROR_TRAP;
             sig_sm_halt_ns      <=  '1';

           --------------------------------------------
           when others =>

             sig_pcc_sm_state_ns <=  INIT;

         end case;



       end process PCC_SM_COMBINATIONAL;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: PCC_SM_REGISTERED
    --
    -- Process Description:
    -- PCC State Machine registered implementation
    --
    -------------------------------------------------------------
    PCC_SM_REGISTERED : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then

              sig_pcc_sm_state     <= INIT;
              sig_sm_halt_reg      <= '1' ;
              sig_sm_pop_input_reg <= '0' ;
              sig_sm_ld_calc1_reg  <= '0' ;
              sig_sm_ld_calc2_reg  <= '0' ;
              sig_sm_ld_calc3_reg  <= '0' ;

            else

              sig_pcc_sm_state     <=  sig_pcc_sm_state_ns    ;
              sig_sm_halt_reg      <=  sig_sm_halt_ns         ;
              sig_sm_pop_input_reg <=  sig_sm_pop_input_reg_ns;
              sig_sm_ld_calc1_reg  <=  sig_sm_ld_calc1_reg_ns ;
              sig_sm_ld_calc2_reg  <=  sig_sm_ld_calc2_reg_ns ;
              sig_sm_ld_calc3_reg  <=  sig_sm_ld_calc3_reg_ns ;

            end if;
         end if;
       end process PCC_SM_REGISTERED;









    ------------------------------------------------------------------
    -- Transfer Register Load Enable logic


    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: LD_XFER_REG_FLOP
    --
    -- Process Description:
    -- Sample and Hold FLOP for signaling a load of the output
    -- xfer register.
    --
    -------------------------------------------------------------
    LD_XFER_REG_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
                sig_push_xfer_reg  = '1') then

              sig_ld_xfer_reg <=  '0';

            Elsif (sig_sm_ld_xfer_reg_ns = '1') Then

              sig_ld_xfer_reg <=  '1';

            else

              null;   -- hold current state

            end if;
         end if;
       end process LD_XFER_REG_FLOP;


    LD_XFER_REG_FLOP1 : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
                sig_pop_xfer_reg  = '1') then

              sig_ld_xfer_reg_tmp <=  '0';

            Elsif (sig_sm_ld_xfer_reg_ns = '1') Then

              sig_ld_xfer_reg_tmp <=  '1';

            else

              null;   -- hold current state

            end if;
         end if;
       end process LD_XFER_REG_FLOP1;




    ------------------------------------------------------------------
    -- Parent Done flag logic


    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: PARENT_DONE_FLOP
    --
    -- Process Description:
    -- Sample and Hold FLOP for signaling a load of the output
    -- xfer register.
    --
    -------------------------------------------------------------
    PARENT_DONE_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
                sig_push_input_reg = '1') then

              sig_parent_done <=  '0';

            Elsif (sig_ld_xfer_reg_tmp = '1') Then

              sig_parent_done <=  sig_last_xfer_valid_im1;

            else

              null;   -- hold current state

            end if;
         end if;
       end process PARENT_DONE_FLOP;











  end implementation;


  ----------------------------------------------------------------------------
  -- axi_datamover_addr_cntl.vhd
  ----------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_addr_cntl.vhd
  --
  -- Description:     
  --    This file implements the axi_datamover Master Address Controller.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library axi_datamover_v5_1_17;
  Use axi_datamover_v5_1_17.axi_datamover_fifo;
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_addr_cntl is
    generic (
      C_ADDR_FIFO_DEPTH      : Integer range  1 to  32 :=  4;
        -- sets the depth of the Command Queue FIFO
        
      C_ADDR_WIDTH           : Integer range 32 to  64 := 32;
        -- Sets the address bus width
      
      C_ADDR_ID              : Integer range  0 to 255 :=  0;
        -- Sets the value to be on the AxID output
      
      C_ADDR_ID_WIDTH        : Integer range  1 to   8 :=  4;
        -- Sets the width of the AxID output
      
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        -- Sets the width of the Command Tag field width
      
      C_FAMILY               : String  := "virtex7"
        -- Specifies the target FPGA family
        
      );
    port (
      
      -- Clock input ---------------------------------------------
      primary_aclk         : in  std_logic;                     --
         -- Primary synchronization clock for the Master side   --
         -- interface and internal logic. It is also used       --
         -- for the User interface synchronization when         --
         -- C_STSCMD_IS_ASYNC = 0.                              --
                                                                --
      -- Reset input                                            --
      mmap_reset           : in  std_logic;                     --
         -- Reset used for the internal master logic            --
      ------------------------------------------------------------   
      
     
      -- AXI Address Channel I/O  --------------------------------------------
      addr2axi_aid     : out std_logic_vector(C_ADDR_ID_WIDTH-1 downto 0);  --
         -- AXI Address Channel ID output                                   --
                                                                            --
      addr2axi_aaddr   : out std_logic_vector(C_ADDR_WIDTH-1 downto 0);     --
         -- AXI Address Channel Address output                              --
                                                                            --
      addr2axi_alen    : out std_logic_vector(7 downto 0);                  --
         -- AXI Address Channel LEN output                                  --
         -- Sized to support 256 data beat bursts                           --
                                                                            --
      addr2axi_asize   : out std_logic_vector(2 downto 0);                  --
         -- AXI Address Channel SIZE output                                 --
                                                                            --
      addr2axi_aburst  : out std_logic_vector(1 downto 0);                  --
         -- AXI Address Channel BURST output                                --
                                                                            --
      addr2axi_acache  : out std_logic_vector(3 downto 0);                  --
         -- AXI Address Channel BURST output                                --
                                                                            --
      addr2axi_auser  : out std_logic_vector(3 downto 0);                  --
         -- AXI Address Channel BURST output                                --
                                                                            --
      addr2axi_aprot   : out std_logic_vector(2 downto 0);                  --
         -- AXI Address Channel PROT output                                 --
                                                                            --
      addr2axi_avalid  : out std_logic;                                     --
         -- AXI Address Channel VALID output                                --

                                                                            --
      axi2addr_aready  : in  std_logic;                                     --
         -- AXI Address Channel READY input                                 --
      ------------------------------------------------------------------------   
         
         
        
      -- Currently unsupported AXI Address Channel output signals -------
        -- addr2axi_alock   : out std_logic_vector(2 downto 0);        --
        -- addr2axi_acache  : out std_logic_vector(4 downto 0);        --
        -- addr2axi_aqos    : out std_logic_vector(3 downto 0);        --
        -- addr2axi_aregion : out std_logic_vector(3 downto 0);        --
      -------------------------------------------------------------------
      
      
      
      -- Command Calculation Interface -----------------------------------------
      mstr2addr_tag         : In std_logic_vector(C_TAG_WIDTH-1 downto 0);    --
         -- The next command tag                                              --
                                                                              --
      mstr2addr_addr        : In  std_logic_vector(C_ADDR_WIDTH-1 downto 0);  --
         -- The next command address to put on the AXI MMap ADDR              --
                                                                              --
      mstr2addr_len         : In  std_logic_vector(7 downto 0);               --
         -- The next command length to put on the AXI MMap LEN                --
         -- Sized to support 256 data beat bursts                             --
                                                                              --
      mstr2addr_size        : In  std_logic_vector(2 downto 0);               --
         -- The next command size to put on the AXI MMap SIZE                 --
                                                                              --
      mstr2addr_burst       : In  std_logic_vector(1 downto 0);               --
         -- The next command burst type to put on the AXI MMap BURST          --
                                                                              --
      mstr2addr_cache        : In  std_logic_vector(3 downto 0);               --
         -- The next command burst type to put on the AXI MMap BURST          --
                                                                              --
      mstr2addr_user        : In  std_logic_vector(3 downto 0);               --
         -- The next command burst type to put on the AXI MMap BURST          --
                                                                              --
      mstr2addr_cmd_cmplt   : In std_logic;                                   --
         -- The indication to the Address Channel that the current            --
         -- sub-command output is the last one compiled from the              --
         -- parent command pulled from the Command FIFO                       --
                                                                              --
      mstr2addr_calc_error  : In std_logic;                                   --
         -- Indication if the next command in the calculation pipe            --
         -- has a calculation error                                           --
                                                                              --
      mstr2addr_cmd_valid   : in std_logic;                                   --
         -- The next command valid indication to the Address Channel          --
         -- Controller for the AXI MMap                                       --
  
                                                                              --
      addr2mstr_cmd_ready   : out std_logic;                                  --
         -- Indication to the Command Calculator that the                     --
         -- command is being accepted                                         --
      --------------------------------------------------------------------------
     
     
      
      -- Halted Indication to Reset Module ------------------------------
      addr2rst_stop_cmplt     : out std_logic;                         --
         -- Output flag indicating the address controller has stopped  --
         -- posting commands to the Address Channel due to a stop      --
         -- request vai the data2addr_stop_req input port              --
       ------------------------------------------------------------------
       
      
      
      -- Address Generation Control ---------------------------------------
      allow_addr_req    : in std_logic;                                  --
         -- Input used to enable/stall the posting of address requests.  --
         -- 0 = stall address request generation.                        --
         -- 1 = Enable Address request geneartion                        --
                                                                         --
      addr_req_posted   : out std_logic;                                 --
         -- Indication from the Address Channel Controller to external   --
         -- User logic that an address has been posted to the            --
         -- AXI Address Channel.                                         --
      ---------------------------------------------------------------------
    
      
                                                                        
                                                                        
      -- Data Channel Interface ---------------------------------------------
      addr2data_addr_posted    : Out std_logic;                            --
         -- Indication from the Address Channel Controller to the          --
         -- Data Controller that an address has been posted to the         --
         -- AXI Address Channel.                                           --
                                                                           --
      data2addr_data_rdy       : In std_logic;                             --
         -- Indication that the Data Channel is ready to send the first    --
         -- databeat of the next command on the write data channel.        --
         -- This is used for the "wait for data" feature which keeps the   --
         -- address controller from issuing a transfer requset until the   --
         -- corresponding data is ready. This is expected to be held in    --
         -- the asserted state until the addr2data_addr_posted signal is   --
         -- asserted.                                                      --
                                                                           --
      data2addr_stop_req       : In std_logic;                             --
         -- Indication that the Data Channel has encountered an error      --
         -- or a soft shutdown request and needs the Address Controller    --
         -- to stop posting commands to the AXI Address channel            --
      -----------------------------------------------------------------------

       
      -- Status Module Interface ---------------------------------------
      addr2stat_calc_error     : out std_logic;                       --
         -- Indication to the Status Module that the Addr Cntl FIFO   --
         -- is loaded with a Calc error                               --
                                                                      --
      addr2stat_cmd_fifo_empty : out std_logic                        --
         -- Indication to the Status Module that the Addr Cntl FIFO   --
         -- is empty                                                  --
      ------------------------------------------------------------------   
      
     
     
         
      );
  
  end entity axi_datamover_addr_cntl;
  
  
  architecture implementation of axi_datamover_addr_cntl is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    -- Constant Declarations  --------------------------------------------
    Constant APROT_VALUE      : std_logic_vector(2 downto 0) := (others => '0');
                                --'0' & -- bit 2, Normal Access
                                --'0' & -- bit 1, Nonsecure Access
                                --'0';  -- bit 0, Data Access
    
    Constant LEN_WIDTH        : integer := 8;
    Constant SIZE_WIDTH       : integer := 3;
    Constant BURST_WIDTH      : integer := 2;
    Constant CMD_CMPLT_WIDTH  : integer := 1;
    Constant CALC_ERROR_WIDTH : integer := 1;
    
    Constant ADDR_QUAL_WIDTH  : integer := C_TAG_WIDTH     +  -- Cmd Tag field width
                                           C_ADDR_WIDTH    +  -- Cmd Address field width
                                           LEN_WIDTH       +  -- Cmd Len field width
                                           SIZE_WIDTH      +  -- Cmd Size field width
                                           BURST_WIDTH     +  -- Cmd Burst field width
                                           CMD_CMPLT_WIDTH +  -- Cmd Cmplt filed width
                                           CALC_ERROR_WIDTH +  -- Cmd Calc Error flag
                                           8; -- Cmd Cache, user fields
    
    Constant USE_SYNC_FIFO    : integer := 0;
    Constant REG_FIFO_PRIM    : integer := 0; 
    Constant BRAM_FIFO_PRIM   : integer := 1; 
    Constant SRL_FIFO_PRIM    : integer := 2; 
    Constant FIFO_PRIM_TYPE   : integer := SRL_FIFO_PRIM; 
    
    
    
    
    
    -- Signal Declarations  --------------------------------------------
    signal sig_axi_addr               : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_axi_alen               : std_logic_vector(7 downto 0) := (others => '0');             
    signal sig_axi_asize              : std_logic_vector(2 downto 0) := (others => '0');             
    signal sig_axi_aburst             : std_logic_vector(1 downto 0) := (others => '0');             
    signal sig_axi_acache             : std_logic_vector(3 downto 0) := (others => '0');             
    signal sig_axi_auser              : std_logic_vector(3 downto 0) := (others => '0');             
    signal sig_axi_avalid             : std_logic := '0';
    signal sig_axi_aready             : std_logic := '0';
    signal sig_addr_posted            : std_logic := '0';
    signal sig_calc_error             : std_logic := '0';
    signal sig_cmd_fifo_empty         : std_logic := '0';
    Signal sig_aq_fifo_data_in        : std_logic_vector(ADDR_QUAL_WIDTH-1 downto 0) := (others => '0');
    Signal sig_aq_fifo_data_out       : std_logic_vector(ADDR_QUAL_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_tag          : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_addr         : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_len          : std_logic_vector(7 downto 0) := (others => '0');             
    signal sig_fifo_next_size         : std_logic_vector(2 downto 0) := (others => '0');             
    signal sig_fifo_next_burst        : std_logic_vector(1 downto 0) := (others => '0');
    signal sig_fifo_next_user         : std_logic_vector(3 downto 0) := (others => '0');
    signal sig_fifo_next_cache        : std_logic_vector(3 downto 0) := (others => '0');
    signal sig_fifo_next_cmd_cmplt    : std_logic := '0';
    signal sig_fifo_calc_error        : std_logic := '0';
    signal sig_fifo_wr_cmd_valid      : std_logic := '0';
    signal sig_fifo_wr_cmd_ready      : std_logic := '0';
    signal sig_fifo_rd_cmd_valid      : std_logic := '0';
    signal sig_fifo_rd_cmd_ready      : std_logic := '0';
    signal sig_next_tag_reg           : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_addr_reg          : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_len_reg           : std_logic_vector(7 downto 0) := (others => '0');             
    signal sig_next_size_reg          : std_logic_vector(2 downto 0) := (others => '0');             
    signal sig_next_burst_reg         : std_logic_vector(1 downto 0) := (others => '0');             
    signal sig_next_cache_reg         : std_logic_vector(3 downto 0) := (others => '0');             
    signal sig_next_user_reg          : std_logic_vector(3 downto 0) := (others => '0');             
    signal sig_next_cmd_cmplt_reg     : std_logic := '0';             
    signal sig_addr_valid_reg         : std_logic := '0';
    signal sig_calc_error_reg         : std_logic := '0';
    signal sig_pop_addr_reg           : std_logic := '0';
    signal sig_push_addr_reg          : std_logic := '0';
    signal sig_addr_reg_empty         : std_logic := '0';
    signal sig_addr_reg_full          : std_logic := '0';
    signal sig_posted_to_axi          : std_logic := '0';
    -- obsoleted   signal sig_set_wfd_flop           : std_logic := '0';
    -- obsoleted   signal sig_clr_wfd_flop           : std_logic := '0';
    -- obsoleted   signal sig_wait_for_data          : std_logic := '0';
    -- obsoleted   signal sig_data2addr_data_rdy_reg : std_logic := '0';
    signal sig_allow_addr_req         : std_logic := '0';
    signal sig_posted_to_axi_2        : std_logic := '0';
 
    signal new_cmd_in : std_logic;
    signal first_addr_valid : std_logic;
    signal first_addr_valid_del : std_logic;
    signal first_addr_int : std_logic_vector (C_ADDR_WIDTH-1 downto 0);
    signal last_addr_int : std_logic_vector (C_ADDR_WIDTH-1 downto 0);
    signal addr2axi_cache_int  : std_logic_vector (7 downto 0); 
    signal addr2axi_cache_int1  : std_logic_vector (7 downto 0); 

    signal last_one : std_logic;
    signal latch : std_logic;
    signal first_one : std_logic;
    signal latch_n : std_logic;
    signal latch_n_del : std_logic;
    signal mstr2addr_cache_info_int : std_logic_vector (7 downto 0);
-- Register duplication attribute assignments to control fanout
-- on handshake output signals  
  
  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration
  
  Attribute KEEP of sig_posted_to_axi   : signal is "TRUE"; -- definition
  Attribute KEEP of sig_posted_to_axi_2 : signal is "TRUE"; -- definition
  
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_posted_to_axi   : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_posted_to_axi_2 : signal is "no"; 
  
  
  
 
    
  begin --(architecture implementation)
  
    -- AXI I/O Port assignments
    addr2axi_aid        <= STD_LOGIC_VECTOR(TO_UNSIGNED(C_ADDR_ID, C_ADDR_ID_WIDTH));
    addr2axi_aaddr      <= sig_axi_addr  ;
    addr2axi_alen       <= sig_axi_alen  ;
    addr2axi_asize      <= sig_axi_asize ;
    addr2axi_aburst     <= sig_axi_aburst;
    addr2axi_acache     <= sig_axi_acache;
    addr2axi_auser      <= sig_axi_auser;
    addr2axi_aprot      <= APROT_VALUE   ; 
    addr2axi_avalid     <= sig_axi_avalid;
    sig_axi_aready      <= axi2addr_aready;
    
    
    -- Command Calculator Handshake output
    sig_fifo_wr_cmd_valid <= mstr2addr_cmd_valid  ;
    addr2mstr_cmd_ready   <= sig_fifo_wr_cmd_ready;
    
    -- Data Channel Controller synchro pulse output                  
    addr2data_addr_posted <= sig_addr_posted;
     
     
    -- Status Module Interface outputs
    addr2stat_calc_error     <= sig_calc_error    ;
    addr2stat_cmd_fifo_empty <= sig_addr_reg_empty and
                                sig_cmd_fifo_empty; 
     
    

   
    -- Flag Indicating the Address Controller has completed a Stop
    addr2rst_stop_cmplt   <=  (data2addr_stop_req and  -- normal shutdown case
                               sig_addr_reg_empty) or
                              (data2addr_stop_req and  -- shutdown after error trap
                               sig_calc_error);
   
    -- Assign the address posting control and status
    sig_allow_addr_req    <=  allow_addr_req      ;
    addr_req_posted       <=  sig_posted_to_axi_2 ;
   
   
    
    -- Internal logic ------------------------------





    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_FIFO
    --
    -- If Generate Description:
    --   Implements the case where the cmd qualifier depth is
    -- greater than 1.
    --
    ------------------------------------------------------------
    GEN_ADDR_FIFO : if (C_ADDR_FIFO_DEPTH > 1) generate

      begin

        -- Format the input FIFO data word 
        
        sig_aq_fifo_data_in <= mstr2addr_cache      &
                               mstr2addr_user      &
                               mstr2addr_calc_error &
                               mstr2addr_cmd_cmplt  &
                               mstr2addr_burst      &
                               mstr2addr_size       &
                               mstr2addr_len        &
                               mstr2addr_addr       &
                               mstr2addr_tag ;
        
    
    
        -- Rip fields from FIFO output data word
        sig_fifo_next_cache     <=  sig_aq_fifo_data_out((C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH + 
                                                        CALC_ERROR_WIDTH + 7)
                                                    downto
                                                        (C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH +
                                                        CALC_ERROR_WIDTH + 4)
                                                    ); 

        sig_fifo_next_user     <=  sig_aq_fifo_data_out((C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH + 
                                                        CALC_ERROR_WIDTH + 3)
                                                    downto
                                                        (C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH +
                                                        CALC_ERROR_WIDTH)
                                                    ); 


        sig_fifo_calc_error     <=  sig_aq_fifo_data_out((C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH + 
                                                        CALC_ERROR_WIDTH)-1); 
                                                        
        
        sig_fifo_next_cmd_cmplt <=  sig_aq_fifo_data_out((C_ADDR_WIDTH  +
                                                        C_TAG_WIDTH     +
                                                        LEN_WIDTH       +
                                                        SIZE_WIDTH      +
                                                        BURST_WIDTH     +
                                                        CMD_CMPLT_WIDTH)-1); 
                                                        
        
        sig_fifo_next_burst     <=  sig_aq_fifo_data_out((C_ADDR_WIDTH +
                                                         C_TAG_WIDTH   +
                                                         LEN_WIDTH     +
                                                         SIZE_WIDTH    +
                                                         BURST_WIDTH)-1 
                                                downto 
                                                         C_ADDR_WIDTH  +
                                                         C_TAG_WIDTH   +
                                                         LEN_WIDTH     +
                                                         SIZE_WIDTH) ;
                                                          
        sig_fifo_next_size      <=  sig_aq_fifo_data_out((C_ADDR_WIDTH +
                                                         C_TAG_WIDTH   +
                                                         LEN_WIDTH     +
                                                         SIZE_WIDTH)-1
                                                downto 
                                                         C_ADDR_WIDTH  +
                                                         C_TAG_WIDTH   +
                                                         LEN_WIDTH) ; 
                                                         
        sig_fifo_next_len       <=  sig_aq_fifo_data_out((C_ADDR_WIDTH +
                                                         C_TAG_WIDTH   +
                                                         LEN_WIDTH)-1 
                                                downto 
                                                        C_ADDR_WIDTH   +
                                                        C_TAG_WIDTH) ;
                                                         
        sig_fifo_next_addr      <=  sig_aq_fifo_data_out((C_ADDR_WIDTH +
                                                         C_TAG_WIDTH)-1 
                                                downto 
                                                         C_TAG_WIDTH) ;
         
        sig_fifo_next_tag       <=  sig_aq_fifo_data_out(C_TAG_WIDTH-1 downto 0); 
      
      
      
        ------------------------------------------------------------
        -- Instance: I_ADDR_QUAL_FIFO 
        --
        -- Description:
        -- Instance for the Address/Qualifier FIFO
        --
        ------------------------------------------------------------
         I_ADDR_QUAL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
         generic map (
       
           C_DWIDTH            =>  ADDR_QUAL_WIDTH         ,  
           C_DEPTH             =>  C_ADDR_FIFO_DEPTH       ,  
           C_IS_ASYNC          =>  USE_SYNC_FIFO           ,  
           C_PRIM_TYPE         =>  FIFO_PRIM_TYPE          ,  
           C_FAMILY            =>  C_FAMILY                   
          
           )
         port map (
           
           -- Write Clock and reset
           fifo_wr_reset        =>   mmap_reset            ,  
           fifo_wr_clk          =>   primary_aclk          ,  
           
           -- Write Side
           fifo_wr_tvalid       =>   sig_fifo_wr_cmd_valid ,  
           fifo_wr_tready       =>   sig_fifo_wr_cmd_ready ,  
           fifo_wr_tdata        =>   sig_aq_fifo_data_in   ,  
           fifo_wr_full         =>   open                  ,  
          
          
           -- Read Clock and reset
           fifo_async_rd_reset  =>   mmap_reset            ,     
           fifo_async_rd_clk    =>   primary_aclk          ,   
           
           -- Read Side
           fifo_rd_tvalid       =>   sig_fifo_rd_cmd_valid ,  
           fifo_rd_tready       =>   sig_fifo_rd_cmd_ready ,  
           fifo_rd_tdata        =>   sig_aq_fifo_data_out  ,  
           fifo_rd_empty        =>   sig_cmd_fifo_empty       
          
           );
       
      
      
      end generate GEN_ADDR_FIFO;
       
   

    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_ADDR_FIFO
    --
    -- If Generate Description:
    --   Implements the case where no additional FIFOing is needed
    -- on the input command address/qualifiers.
    --
    ------------------------------------------------------------
    GEN_NO_ADDR_FIFO : if (C_ADDR_FIFO_DEPTH = 1) generate

      begin

        -- Bypass FIFO
        sig_fifo_next_tag       <=  mstr2addr_tag         ; 
        sig_fifo_next_addr      <=  mstr2addr_addr        ; 
        sig_fifo_next_len       <=  mstr2addr_len         ; 
        sig_fifo_next_size      <=  mstr2addr_size        ; 
        sig_fifo_next_burst     <=  mstr2addr_burst       ; 
        sig_fifo_next_cache     <=  mstr2addr_cache       ; 
        sig_fifo_next_user      <=  mstr2addr_user       ; 
        sig_fifo_next_cmd_cmplt <=  mstr2addr_cmd_cmplt   ;
        sig_fifo_calc_error     <=  mstr2addr_calc_error  ; 
        sig_cmd_fifo_empty      <=  sig_addr_reg_empty    ;
        sig_fifo_wr_cmd_ready   <=  sig_fifo_rd_cmd_ready ;
        sig_fifo_rd_cmd_valid   <=  sig_fifo_wr_cmd_valid ;
        
      
      end generate GEN_NO_ADDR_FIFO;
       
    
    
    -- Output Register Logic ------------------------------------------- 
    
    sig_axi_addr           <= sig_next_addr_reg  ;
    sig_axi_alen           <= sig_next_len_reg   ;
    sig_axi_asize          <= sig_next_size_reg  ;
    sig_axi_aburst         <= sig_next_burst_reg ;
    sig_axi_acache         <= sig_next_cache_reg ;
    sig_axi_auser          <= sig_next_user_reg ;
    sig_axi_avalid         <= sig_addr_valid_reg ;
    
    sig_calc_error         <= sig_calc_error_reg ;
    
    sig_fifo_rd_cmd_ready  <= sig_addr_reg_empty  and
                              sig_allow_addr_req  and   
                              -- obsoleted   not(sig_wait_for_data) and
                              not(data2addr_stop_req);
    
    sig_addr_posted        <= sig_posted_to_axi  ;
    
    
    -- Internal signals
    sig_push_addr_reg      <= sig_addr_reg_empty     and 
                              sig_fifo_rd_cmd_valid  and
                              sig_allow_addr_req     and   
                              -- obsoleted   not(sig_wait_for_data) and
                              not(data2addr_stop_req);
    
    sig_pop_addr_reg       <= not(sig_calc_error_reg) and 
                              sig_axi_aready          and 
                              sig_addr_reg_full;
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ADDR_FIFO_REG
    --
    -- Process Description:
    --    This process implements a register for the Address 
    -- Control FIFO that operates like a 1 deep Sync FIFO.
    --
    -------------------------------------------------------------
    IMP_ADDR_FIFO_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset       = '1' or
                sig_pop_addr_reg = '1') then
              
              sig_next_tag_reg        <= (others => '0')         ;
              sig_next_addr_reg       <= (others => '0')         ;
              sig_next_len_reg        <= (others => '0')         ;
              sig_next_size_reg       <= (others => '0')         ;
              sig_next_burst_reg      <= (others => '0')         ;
              sig_next_cache_reg      <= (others => '0')         ;
              sig_next_user_reg      <= (others => '0')         ;
              sig_next_cmd_cmplt_reg  <= '0'                     ;
              sig_addr_valid_reg      <= '0'                     ;
              sig_calc_error_reg      <= '0'                     ;
                                                                 
              sig_addr_reg_empty      <= '1'                     ;
              sig_addr_reg_full       <= '0'                     ;
              
            elsif (sig_push_addr_reg = '1') then
              
              sig_next_tag_reg        <= sig_fifo_next_tag       ;
              sig_next_addr_reg       <= sig_fifo_next_addr      ;
              sig_next_len_reg        <= sig_fifo_next_len       ;
              sig_next_size_reg       <= sig_fifo_next_size      ;
              sig_next_burst_reg      <= sig_fifo_next_burst     ;
              sig_next_cache_reg      <= sig_fifo_next_cache     ;
              sig_next_user_reg      <= sig_fifo_next_user     ;
              sig_next_cmd_cmplt_reg  <= sig_fifo_next_cmd_cmplt ;
              sig_addr_valid_reg      <= not(sig_fifo_calc_error);
              sig_calc_error_reg      <= sig_fifo_calc_error     ;
              
              sig_addr_reg_empty      <= '0'                     ;
              sig_addr_reg_full       <= '1'                     ;
              
            else
              null;  -- don't change state
            end if; 
         end if;       
       end process IMP_ADDR_FIFO_REG; 
     

    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_POSTED_FLAG
    --
    -- Process Description:
    --   This implements a FLOP that creates a 1 clock wide pulse
    -- indicating a new address/qualifier set has been posted to
    -- the AXI Addres Channel outputs. This is used to synchronize 
    -- the Data Channel Controller.
    --
    -------------------------------------------------------------
    IMP_POSTED_FLAG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then

              sig_posted_to_axi   <= '0';
              sig_posted_to_axi_2 <= '0';
              
            elsif (sig_push_addr_reg = '1') then

              sig_posted_to_axi   <= '1';
              sig_posted_to_axi_2 <= '1';
              
            else
              
              sig_posted_to_axi   <= '0';
              sig_posted_to_axi_2 <= '0';
              
            end if; 
         end if;       
       end process IMP_POSTED_FLAG; 
  
--     PROC_CMD_DETECT :  process (primary_aclk)
--                     begin
--                     if (mmap_reset = '1') then
--                        first_addr_valid_del <= '0';
--                     elsif (primary_aclk'event and primary_aclk = '1') then
--                        first_addr_valid_del <= first_addr_valid;
--                     end if;
--     end process PROC_CMD_DETECT;
--
--     PROC_ADDR_DET : process (primary_aclk)
--            begin
--              if (mmap_reset = '1') then
--                 first_addr_valid <= '0';
--                 first_addr_int <= (others => '0');
--                 last_addr_int <= (others => '0');
--              elsif (primary_aclk'event and primary_aclk = '1') then
--                if (mstr2addr_cmd_valid = '1' and first_addr_valid = '0') then
--                   first_addr_valid <= '1';
--                   first_addr_int <= mstr2addr_addr;
--                   last_addr_int <= last_addr_int;
--                elsif (mstr2addr_cmd_cmplt = '1') then
--                   first_addr_valid <= '0';
--                   first_addr_int <= first_addr_int;
--                   last_addr_int <= mstr2addr_addr;
--                end if;
--              end if;
--           end process PROC_ADDR_DET;
--
--     latch <= first_addr_valid and (not first_addr_valid_del);
--     latch_n <= (not first_addr_valid) and first_addr_valid_del;
--
--     PROC_CACHE1 : process (primary_aclk)
--          begin
--              if (mmap_reset = '1') then
--                 mstr2addr_cache_info_int <= (others => '0');
--                 latch_n_del <= '0';
--              elsif (primary_aclk'event and primary_aclk = '1') then
--                 if (latch_n = '1') then 
--                   mstr2addr_cache_info_int <= mstr2addr_cache_info;
--                 end if;
--                 latch_n_del <= latch_n;
--              end if;
--          end process PROC_CACHE1;
--       
--
--     PROC_CACHE : process (primary_aclk)
--          begin
--              if (mmap_reset = '1') then
--                 addr2axi_cache_int1 <= (others => '0');
--                 first_one <= '0'; 
--              elsif (primary_aclk'event and primary_aclk = '1') then
--                 first_one <= '0';
----                 if (latch = '1' and first_one = '0') then  -- first one
--                 if (sig_addr_valid_reg = '0' and first_addr_valid = '0') then
--                    addr2axi_cache_int1 <= mstr2addr_cache_info;
----                    first_one <= '1';
----                 elsif (latch_n_del = '1') then
----                    addr2axi_cache_int <= mstr2addr_cache_info_int;
--                 elsif ((first_addr_int = sig_next_addr_reg) and (sig_addr_valid_reg = '1')) then
--                    addr2axi_cache_int1 <= addr2axi_cache_int1; --mstr2addr_cache_info (7 downto 4);
--                 elsif ((last_addr_int >= sig_next_addr_reg) and (sig_addr_valid_reg = '1')) then 
--                    addr2axi_cache_int1 <= addr2axi_cache_int1; --mstr2addr_cache_info (7 downto 4);
--                 end if; 
--              end if;
--          end process PROC_CACHE;
--
--
--     PROC_CACHE2 : process (primary_aclk)
--          begin
--              if (mmap_reset = '1') then
--                 addr2axi_cache_int <= (others => '0');
--              elsif (primary_aclk'event and primary_aclk = '1') then
--                 addr2axi_cache_int <= addr2axi_cache_int1;
--              end if;
--          end process PROC_CACHE2;
-- 
--addr2axi_cache <= addr2axi_cache_int (3 downto 0);
--addr2axi_user  <= addr2axi_cache_int (7 downto 4);
-- 
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_rdmux.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_rdmux.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Read Data Multiplexer.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_rdmux is
    generic (
      
      C_SEL_ADDR_WIDTH     : Integer range 1  to   8 :=  5;
        -- Sets the width of the select control bus
      
      C_MMAP_DWIDTH        : Integer range 32 to 1024 := 32;
        -- Indicates the width of the AXI4 Data Channel
      
      C_STREAM_DWIDTH      : Integer range  8 to 1024 := 32
        -- Indicates the width of the AXI Stream Data Channel
      
      );
    port (
      
     
      -- AXI MMap Data Channel Input  -----------------------------------------------
                                                                                   --
      mmap_read_data_in         : In  std_logic_vector(C_MMAP_DWIDTH-1 downto 0);  --
        -- AXI Read data input                                                     --
      -------------------------------------------------------------------------------
      
      
      -- AXI Master Stream  ---------------------------------------------------------
                                                                                   --
      mux_data_out    : Out std_logic_vector(C_STREAM_DWIDTH-1 downto 0);          --
        --Mux data output                                                          --
      -------------------------------------------------------------------------------         
                
                
      -- Command Calculator Interface -----------------------------------------------
                                                                                   --
      mstr2data_saddr_lsb : In std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0)       --
         -- The next command start address LSbs to use for the read data           --
         -- mux (only used if Stream data width is less than the MMap Data         --
         -- Width).                                                                --
      -------------------------------------------------------------------------------
         
      );
  
  end entity axi_datamover_rdmux;
  
  
  architecture implementation of axi_datamover_rdmux is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function Decalarations -------------------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_mux_sel_width
    --
    -- Function Description:
    --   Calculates the number of needed bits for the Mux Select control
    -- based on the number of input channels to the mux.
    --
    -- Note that the number of input mux channels are always a 
    -- power of 2.
    --
    -------------------------------------------------------------------
    function func_mux_sel_width (num_channels : integer) return integer is
    
     Variable var_sel_width : integer := 0;
    
    begin
    
       case num_channels is
         when 2 =>
             var_sel_width := 1;
         when 4 =>
             var_sel_width := 2;
         when 8 =>
             var_sel_width := 3;
         when 16 =>
             var_sel_width := 4;
         when 32 =>
             var_sel_width := 5;
         when 64 =>
             var_sel_width := 6;
         when 128 =>
             var_sel_width := 7;
         
         when others => 
             var_sel_width := 0; 
       end case;
       
       Return (var_sel_width);
        
        
    end function func_mux_sel_width;
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_sel_ls_index
    --
    -- Function Description:
    --   Calculates the LS index of the select field to rip from the
    -- input select bus.
    --
    -- Note that the number of input mux channels are always a 
    -- power of 2.
    --
    -------------------------------------------------------------------
    function func_sel_ls_index (channel_width : integer) return integer is
    
     Variable var_sel_ls_index : integer := 0;
    
    begin
    
       case channel_width is
         when 8 => 
             var_sel_ls_index := 0;
         when 16 =>
             var_sel_ls_index := 1;
         when 32 =>
             var_sel_ls_index := 2;
         when 64 =>
             var_sel_ls_index := 3;
         when 128 =>
             var_sel_ls_index := 4;
         when 256 =>
             var_sel_ls_index := 5;
         when 512 =>
             var_sel_ls_index := 6;
         
         when others => -- 1024-bit channel case
             var_sel_ls_index := 7;
       end case;
       
       Return (var_sel_ls_index);
        
        
    end function func_sel_ls_index;
    
    
    
    
    
    -- Constant Decalarations -------------------------------------------------
    
    Constant CHANNEL_DWIDTH   : integer := C_STREAM_DWIDTH;
    Constant NUM_MUX_CHANNELS : integer := C_MMAP_DWIDTH/CHANNEL_DWIDTH;
    Constant MUX_SEL_WIDTH    : integer := func_mux_sel_width(NUM_MUX_CHANNELS);
    Constant MUX_SEL_LS_INDEX : integer := func_sel_ls_index(CHANNEL_DWIDTH);
    
    
    
    
    -- Signal Declarations  --------------------------------------------
 
    signal sig_rdmux_dout     : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');



    
  begin --(architecture implementation)
  
  
  
  
   -- Assign the Output data port 
    mux_data_out        <= sig_rdmux_dout;
  
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_STRM_EQ_MMAP
    --
    -- If Generate Description:
    --   This IfGen implements the case where the Stream Data Width is 
    -- the same as the Memory Map read Data width.
    --
    --
    ------------------------------------------------------------
    GEN_STRM_EQ_MMAP : if (NUM_MUX_CHANNELS = 1) generate
        
       begin
    
          sig_rdmux_dout <= mmap_read_data_in;
        
       end generate GEN_STRM_EQ_MMAP;
   
   
    
    
    
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_2XN
    --
    -- If Generate Description:
    --  2 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_2XN : if (NUM_MUX_CHANNELS = 2) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice   <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd  <=  UNSIGNED(sig_mux_sel_slice);  -- convert to unsigned
        
         sig_mux_sel_int     <=  TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                 -- with locally static subtype error in each of the
                                                                 -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_2XN_NUX
         --
         -- Process Description:
         --  Implement the 2XN Mux
         --
         -------------------------------------------------------------
         DO_2XN_NUX : process (sig_mux_sel_int_local,
                               mmap_read_data_in)
            begin
              
              case sig_mux_sel_int_local is
                when 0 =>
                    sig_mux_dout <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0);
                
                when others => -- 1 case
                    sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1);
              end case;
              
            end process DO_2XN_NUX; 
 
         
       end generate GEN_2XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_4XN
    --
    -- If Generate Description:
    --  4 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_4XN : if (NUM_MUX_CHANNELS = 4) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_4XN_NUX
         --
         -- Process Description:
         --  Implement the 4XN Mux
         --
         -------------------------------------------------------------
         DO_4XN_NUX : process (sig_mux_sel_int_local,
                               mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
               when 0 =>
                   sig_mux_dout <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0);
               when 1 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1);
               when 2 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2);
               
               when others => -- 3 case
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3);
             end case;
             
           end process DO_4XN_NUX; 
  
         
       end generate GEN_4XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_8XN
    --
    -- If Generate Description:
    --  8 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_8XN : if (NUM_MUX_CHANNELS = 8) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_8XN_NUX
         --
         -- Process Description:
         --  Implement the 8XN Mux
         --
         -------------------------------------------------------------
         DO_8XN_NUX : process (sig_mux_sel_int_local,
                               mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
               when 0 =>
                   sig_mux_dout <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0);
               when 1 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1);
               when 2 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2);
               when 3 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3);
               when 4 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*5)-1 downto CHANNEL_DWIDTH*4);
               when 5 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*6)-1 downto CHANNEL_DWIDTH*5);
               when 6 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*7)-1 downto CHANNEL_DWIDTH*6);
               
               when others =>  -- 7 case
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*8)-1 downto CHANNEL_DWIDTH*7);
             end case;
                 
           end process DO_8XN_NUX; 
 
         
       end generate GEN_8XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_16XN
    --
    -- If Generate Description:
    --  16 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_16XN : if (NUM_MUX_CHANNELS = 16) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_16XN_NUX
         --
         -- Process Description:
         --  Implement the 16XN Mux
         --
         -------------------------------------------------------------
         DO_16XN_NUX : process (sig_mux_sel_int_local,
                                mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
               when 0 =>
                   sig_mux_dout <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0);
               when 1 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1);
               when 2 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2);
               when 3 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3);
               when 4 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*5)-1 downto CHANNEL_DWIDTH*4);
               when 5 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*6)-1 downto CHANNEL_DWIDTH*5);
               when 6 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*7)-1 downto CHANNEL_DWIDTH*6);
               when 7 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*8)-1 downto CHANNEL_DWIDTH*7);
               when 8 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*9)-1 downto CHANNEL_DWIDTH*8);
               when 9 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*10)-1 downto CHANNEL_DWIDTH*9);
               when 10 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*11)-1 downto CHANNEL_DWIDTH*10);
               when 11 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*12)-1 downto CHANNEL_DWIDTH*11);
               when 12 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*13)-1 downto CHANNEL_DWIDTH*12);
               when 13 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*14)-1 downto CHANNEL_DWIDTH*13);
               when 14 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*15)-1 downto CHANNEL_DWIDTH*14);
               
               when others => -- 15 case
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*16)-1 downto CHANNEL_DWIDTH*15);
             end case;
          
           end process DO_16XN_NUX; 
 
         
       end generate GEN_16XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_32XN
    --
    -- If Generate Description:
    --  32 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_32XN : if (NUM_MUX_CHANNELS = 32) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_32XN_NUX
         --
         -- Process Description:
         --  Implement the 32XN Mux
         --
         -------------------------------------------------------------
         DO_32XN_NUX : process (sig_mux_sel_int_local,
                                mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
               
               when 0 =>
                   sig_mux_dout <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0);
               when 1 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1);
               when 2 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2);
               when 3 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3);
               when 4 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*5)-1 downto CHANNEL_DWIDTH*4);
               when 5 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*6)-1 downto CHANNEL_DWIDTH*5);
               when 6 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*7)-1 downto CHANNEL_DWIDTH*6);
               when 7 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*8)-1 downto CHANNEL_DWIDTH*7);
               when 8 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*9)-1 downto CHANNEL_DWIDTH*8);
               when 9 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*10)-1 downto CHANNEL_DWIDTH*9);
               when 10 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*11)-1 downto CHANNEL_DWIDTH*10);
               when 11 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*12)-1 downto CHANNEL_DWIDTH*11);
               when 12 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*13)-1 downto CHANNEL_DWIDTH*12);
               when 13 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*14)-1 downto CHANNEL_DWIDTH*13);
               when 14 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*15)-1 downto CHANNEL_DWIDTH*14);
               when 15 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*16)-1 downto CHANNEL_DWIDTH*15);
               when 16 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*17)-1 downto CHANNEL_DWIDTH*16);
               when 17 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*18)-1 downto CHANNEL_DWIDTH*17);
               when 18 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*19)-1 downto CHANNEL_DWIDTH*18);
               when 19 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*20)-1 downto CHANNEL_DWIDTH*19);
               when 20 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*21)-1 downto CHANNEL_DWIDTH*20);
               when 21 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*22)-1 downto CHANNEL_DWIDTH*21);
               when 22 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*23)-1 downto CHANNEL_DWIDTH*22);
               when 23 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*24)-1 downto CHANNEL_DWIDTH*23);
               when 24 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*25)-1 downto CHANNEL_DWIDTH*24);
               when 25 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*26)-1 downto CHANNEL_DWIDTH*25);
               when 26 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*27)-1 downto CHANNEL_DWIDTH*26);
               when 27 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*28)-1 downto CHANNEL_DWIDTH*27);
               when 28 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*29)-1 downto CHANNEL_DWIDTH*28);
               when 29 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*30)-1 downto CHANNEL_DWIDTH*29);
               when 30 =>
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*31)-1 downto CHANNEL_DWIDTH*30);
               
               when others => -- 31 case
                   sig_mux_dout <=  mmap_read_data_in((CHANNEL_DWIDTH*32)-1 downto CHANNEL_DWIDTH*31);
             end case;
          
           end process DO_32XN_NUX; 
 
         
       end generate GEN_32XN;
  
 
 
 
 
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_64XN
    --
    -- If Generate Description:
    --  64 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_64XN : if (NUM_MUX_CHANNELS = 64) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0)          := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_64XN_NUX
         --
         -- Process Description:
         --  Implement the 64XN Mux
         --
         -------------------------------------------------------------
         DO_64XN_NUX : process (sig_mux_sel_int_local,
                                mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
             
               when 0 =>
                   sig_mux_dout  <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0)                     ;
               when 1 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1)  ;
               when 2 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2)  ;
               when 3 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3)  ;
               when 4 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*5)-1 downto CHANNEL_DWIDTH*4)  ;
               when 5 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*6)-1 downto CHANNEL_DWIDTH*5)  ;
               when 6 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*7)-1 downto CHANNEL_DWIDTH*6)  ;
               when 7 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*8)-1 downto CHANNEL_DWIDTH*7)  ;
               when 8 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*9)-1 downto CHANNEL_DWIDTH*8)  ;
               when 9 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*10)-1 downto CHANNEL_DWIDTH*9) ;
               when 10 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*11)-1 downto CHANNEL_DWIDTH*10);
               when 11 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*12)-1 downto CHANNEL_DWIDTH*11);
               when 12 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*13)-1 downto CHANNEL_DWIDTH*12);
               when 13 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*14)-1 downto CHANNEL_DWIDTH*13);
               when 14 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*15)-1 downto CHANNEL_DWIDTH*14);
               when 15 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*16)-1 downto CHANNEL_DWIDTH*15);
               when 16 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*17)-1 downto CHANNEL_DWIDTH*16);
               when 17 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*18)-1 downto CHANNEL_DWIDTH*17);
               when 18 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*19)-1 downto CHANNEL_DWIDTH*18);
               when 19 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*20)-1 downto CHANNEL_DWIDTH*19);
               when 20 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*21)-1 downto CHANNEL_DWIDTH*20);
               when 21 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*22)-1 downto CHANNEL_DWIDTH*21);
               when 22 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*23)-1 downto CHANNEL_DWIDTH*22);
               when 23 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*24)-1 downto CHANNEL_DWIDTH*23);
               when 24 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*25)-1 downto CHANNEL_DWIDTH*24);
               when 25 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*26)-1 downto CHANNEL_DWIDTH*25);
               when 26 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*27)-1 downto CHANNEL_DWIDTH*26);
               when 27 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*28)-1 downto CHANNEL_DWIDTH*27);
               when 28 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*29)-1 downto CHANNEL_DWIDTH*28);
               when 29 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*30)-1 downto CHANNEL_DWIDTH*29);
               when 30 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*31)-1 downto CHANNEL_DWIDTH*30);
               when 31 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*32)-1 downto CHANNEL_DWIDTH*31);
             
             
               when 32 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*33)-1 downto CHANNEL_DWIDTH*32);
               when 33 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*34)-1 downto CHANNEL_DWIDTH*33);
               when 34 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*35)-1 downto CHANNEL_DWIDTH*34);
               when 35 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*36)-1 downto CHANNEL_DWIDTH*35);
               when 36 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*37)-1 downto CHANNEL_DWIDTH*36);
               when 37 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*38)-1 downto CHANNEL_DWIDTH*37);
               when 38 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*39)-1 downto CHANNEL_DWIDTH*38);
               when 39 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*40)-1 downto CHANNEL_DWIDTH*39);
               when 40 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*41)-1 downto CHANNEL_DWIDTH*40);
               when 41 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*42)-1 downto CHANNEL_DWIDTH*41);
               when 42 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*43)-1 downto CHANNEL_DWIDTH*42);
               when 43 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*44)-1 downto CHANNEL_DWIDTH*43);
               when 44 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*45)-1 downto CHANNEL_DWIDTH*44);
               when 45 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*46)-1 downto CHANNEL_DWIDTH*45);
               when 46 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*47)-1 downto CHANNEL_DWIDTH*46);
               when 47 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*48)-1 downto CHANNEL_DWIDTH*47);
               when 48 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*49)-1 downto CHANNEL_DWIDTH*48);
               when 49 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*50)-1 downto CHANNEL_DWIDTH*49);
               when 50 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*51)-1 downto CHANNEL_DWIDTH*50);
               when 51 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*52)-1 downto CHANNEL_DWIDTH*51);
               when 52 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*53)-1 downto CHANNEL_DWIDTH*52);
               when 53 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*54)-1 downto CHANNEL_DWIDTH*53);
               when 54 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*55)-1 downto CHANNEL_DWIDTH*54);
               when 55 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*56)-1 downto CHANNEL_DWIDTH*55);
               when 56 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*57)-1 downto CHANNEL_DWIDTH*56);
               when 57 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*58)-1 downto CHANNEL_DWIDTH*57);
               when 58 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*59)-1 downto CHANNEL_DWIDTH*58);
               when 59 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*60)-1 downto CHANNEL_DWIDTH*59);
               when 60 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*61)-1 downto CHANNEL_DWIDTH*60);
               when 61 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*62)-1 downto CHANNEL_DWIDTH*61);
               when 62 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*63)-1 downto CHANNEL_DWIDTH*62);
               
               when others => -- 63 case
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*64)-1 downto CHANNEL_DWIDTH*63);
             
             end case;
          
           end process DO_64XN_NUX; 
 
         
       end generate GEN_64XN;
  
 
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_128XN
    --
    -- If Generate Description:
    --  128 channel input mux case
    --
    --
    ------------------------------------------------------------
    GEN_128XN : if (NUM_MUX_CHANNELS = 128) generate
    
       -- local signals
       signal sig_mux_sel_slice     : std_logic_vector(MUX_SEL_WIDTH-1 downto 0)  := (others => '0');
       signal sig_mux_sel_unsgnd    : unsigned(MUX_SEL_WIDTH-1 downto 0)          := (others => '0');
       signal sig_mux_sel_int       : integer := 0;
       signal sig_mux_sel_int_local : integer := 0;
       signal sig_mux_dout          : std_logic_vector(CHANNEL_DWIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_mux_sel_slice     <= mstr2data_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_mux_sel_unsgnd    <= UNSIGNED(sig_mux_sel_slice);    -- convert to unsigned
        
         sig_mux_sel_int       <= TO_INTEGER(sig_mux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                  -- with locally static subtype error in each of the
                                                                  -- Mux IfGens
        
         sig_mux_sel_int_local <= sig_mux_sel_int;
         
         sig_rdmux_dout        <= sig_mux_dout;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_128XN_NUX
         --
         -- Process Description:
         --  Implement the 64XN Mux
         --
         -------------------------------------------------------------
         DO_128XN_NUX : process (sig_mux_sel_int_local,
                                 mmap_read_data_in)
           begin
             
             case sig_mux_sel_int_local is
               
               when 0 =>
                   sig_mux_dout  <=  mmap_read_data_in(CHANNEL_DWIDTH-1 downto 0)                     ;
               when 1 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*2)-1 downto CHANNEL_DWIDTH*1)  ;
               when 2 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*3)-1 downto CHANNEL_DWIDTH*2)  ;
               when 3 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*4)-1 downto CHANNEL_DWIDTH*3)  ;
               when 4 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*5)-1 downto CHANNEL_DWIDTH*4)  ;
               when 5 =>                                                              
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*6)-1 downto CHANNEL_DWIDTH*5)  ;
               when 6 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*7)-1 downto CHANNEL_DWIDTH*6)  ;
               when 7 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*8)-1 downto CHANNEL_DWIDTH*7)  ;
               when 8 =>                                                               
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*9)-1 downto CHANNEL_DWIDTH*8)  ;
               when 9 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*10)-1 downto CHANNEL_DWIDTH*9) ;
               when 10 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*11)-1 downto CHANNEL_DWIDTH*10);
               when 11 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*12)-1 downto CHANNEL_DWIDTH*11);
               when 12 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*13)-1 downto CHANNEL_DWIDTH*12);
               when 13 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*14)-1 downto CHANNEL_DWIDTH*13);
               when 14 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*15)-1 downto CHANNEL_DWIDTH*14);
               when 15 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*16)-1 downto CHANNEL_DWIDTH*15);
               when 16 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*17)-1 downto CHANNEL_DWIDTH*16);
               when 17 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*18)-1 downto CHANNEL_DWIDTH*17);
               when 18 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*19)-1 downto CHANNEL_DWIDTH*18);
               when 19 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*20)-1 downto CHANNEL_DWIDTH*19);
               when 20 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*21)-1 downto CHANNEL_DWIDTH*20);
               when 21 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*22)-1 downto CHANNEL_DWIDTH*21);
               when 22 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*23)-1 downto CHANNEL_DWIDTH*22);
               when 23 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*24)-1 downto CHANNEL_DWIDTH*23);
               when 24 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*25)-1 downto CHANNEL_DWIDTH*24);
               when 25 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*26)-1 downto CHANNEL_DWIDTH*25);
               when 26 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*27)-1 downto CHANNEL_DWIDTH*26);
               when 27 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*28)-1 downto CHANNEL_DWIDTH*27);
               when 28 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*29)-1 downto CHANNEL_DWIDTH*28);
               when 29 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*30)-1 downto CHANNEL_DWIDTH*29);
               when 30 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*31)-1 downto CHANNEL_DWIDTH*30);
               when 31 =>                                                           
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*32)-1 downto CHANNEL_DWIDTH*31);
             
             
               when 32 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*33)-1 downto CHANNEL_DWIDTH*32);
               when 33 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*34)-1 downto CHANNEL_DWIDTH*33);
               when 34 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*35)-1 downto CHANNEL_DWIDTH*34);
               when 35 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*36)-1 downto CHANNEL_DWIDTH*35);
               when 36 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*37)-1 downto CHANNEL_DWIDTH*36);
               when 37 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*38)-1 downto CHANNEL_DWIDTH*37);
               when 38 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*39)-1 downto CHANNEL_DWIDTH*38);
               when 39 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*40)-1 downto CHANNEL_DWIDTH*39);
               when 40 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*41)-1 downto CHANNEL_DWIDTH*40);
               when 41 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*42)-1 downto CHANNEL_DWIDTH*41);
               when 42 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*43)-1 downto CHANNEL_DWIDTH*42);
               when 43 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*44)-1 downto CHANNEL_DWIDTH*43);
               when 44 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*45)-1 downto CHANNEL_DWIDTH*44);
               when 45 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*46)-1 downto CHANNEL_DWIDTH*45);
               when 46 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*47)-1 downto CHANNEL_DWIDTH*46);
               when 47 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*48)-1 downto CHANNEL_DWIDTH*47);
               when 48 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*49)-1 downto CHANNEL_DWIDTH*48);
               when 49 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*50)-1 downto CHANNEL_DWIDTH*49);
               when 50 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*51)-1 downto CHANNEL_DWIDTH*50);
               when 51 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*52)-1 downto CHANNEL_DWIDTH*51);
               when 52 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*53)-1 downto CHANNEL_DWIDTH*52);
               when 53 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*54)-1 downto CHANNEL_DWIDTH*53);
               when 54 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*55)-1 downto CHANNEL_DWIDTH*54);
               when 55 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*56)-1 downto CHANNEL_DWIDTH*55);
               when 56 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*57)-1 downto CHANNEL_DWIDTH*56);
               when 57 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*58)-1 downto CHANNEL_DWIDTH*57);
               when 58 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*59)-1 downto CHANNEL_DWIDTH*58);
               when 59 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*60)-1 downto CHANNEL_DWIDTH*59);
               when 60 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*61)-1 downto CHANNEL_DWIDTH*60);
               when 61 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*62)-1 downto CHANNEL_DWIDTH*61);
               when 62 =>                                                            
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*63)-1 downto CHANNEL_DWIDTH*62);
               when 63 => 
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*64)-1 downto CHANNEL_DWIDTH*63);
             
             
               when 64 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*65)-1 downto CHANNEL_DWIDTH*64) ;
               when 65 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*66)-1 downto CHANNEL_DWIDTH*65) ;
               when 66 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*67)-1 downto CHANNEL_DWIDTH*66) ;
               when 67 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*68)-1 downto CHANNEL_DWIDTH*67) ;
               when 68 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*69)-1 downto CHANNEL_DWIDTH*68) ;
               when 69 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*70)-1 downto CHANNEL_DWIDTH*69) ;
               when 70 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*71)-1 downto CHANNEL_DWIDTH*70) ;
               when 71 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*72)-1 downto CHANNEL_DWIDTH*71) ;
               when 72 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*73)-1 downto CHANNEL_DWIDTH*72) ;
               when 73 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*74)-1 downto CHANNEL_DWIDTH*73) ;
               when 74 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*75)-1 downto CHANNEL_DWIDTH*74) ;
               when 75 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*76)-1 downto CHANNEL_DWIDTH*75) ;
               when 76 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*77)-1 downto CHANNEL_DWIDTH*76) ;
               when 77 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*78)-1 downto CHANNEL_DWIDTH*77) ;
               when 78 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*79)-1 downto CHANNEL_DWIDTH*78) ;
               when 79 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*80)-1 downto CHANNEL_DWIDTH*79) ;
               when 80 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*81)-1 downto CHANNEL_DWIDTH*80) ;
               when 81 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*82)-1 downto CHANNEL_DWIDTH*81) ;
               when 82 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*83)-1 downto CHANNEL_DWIDTH*82) ;
               when 83 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*84)-1 downto CHANNEL_DWIDTH*83) ;
               when 84 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*85)-1 downto CHANNEL_DWIDTH*84) ;
               when 85 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*86)-1 downto CHANNEL_DWIDTH*85) ;
               when 86 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*87)-1 downto CHANNEL_DWIDTH*86) ;
               when 87 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*88)-1 downto CHANNEL_DWIDTH*87) ;
               when 88 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*89)-1 downto CHANNEL_DWIDTH*88) ;
               when 89 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*90)-1 downto CHANNEL_DWIDTH*89) ;
               when 90 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*91)-1 downto CHANNEL_DWIDTH*90) ;
               when 91 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*92)-1 downto CHANNEL_DWIDTH*91) ;
               when 92 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*93)-1 downto CHANNEL_DWIDTH*92) ;
               when 93 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*94)-1 downto CHANNEL_DWIDTH*93) ;
               when 94 =>                                                                   
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*95)-1 downto CHANNEL_DWIDTH*94) ;
               when 95 =>                                                                 
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*96)-1 downto CHANNEL_DWIDTH*95) ;
             
             
               when 96 =>
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*97 )-1 downto CHANNEL_DWIDTH*96 ) ;
               when 97 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*98 )-1 downto CHANNEL_DWIDTH*97 ) ;
               when 98 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*99 )-1 downto CHANNEL_DWIDTH*98 ) ;
               when 99 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*100)-1 downto CHANNEL_DWIDTH*99 ) ;
               when 100 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*101)-1 downto CHANNEL_DWIDTH*100) ;
               when 101 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*102)-1 downto CHANNEL_DWIDTH*101) ;
               when 102 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*103)-1 downto CHANNEL_DWIDTH*102) ;
               when 103 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*104)-1 downto CHANNEL_DWIDTH*103) ;
               when 104 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*105)-1 downto CHANNEL_DWIDTH*104) ;
               when 105 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*106)-1 downto CHANNEL_DWIDTH*105) ;
               when 106 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*107)-1 downto CHANNEL_DWIDTH*106) ;
               when 107 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*108)-1 downto CHANNEL_DWIDTH*107) ;
               when 108 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*109)-1 downto CHANNEL_DWIDTH*108) ;
               when 109 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*110)-1 downto CHANNEL_DWIDTH*109) ;
               when 110 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*111)-1 downto CHANNEL_DWIDTH*110) ;
               when 111 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*112)-1 downto CHANNEL_DWIDTH*111) ;
               when 112 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*113)-1 downto CHANNEL_DWIDTH*112) ;
               when 113 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*114)-1 downto CHANNEL_DWIDTH*113) ;
               when 114 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*115)-1 downto CHANNEL_DWIDTH*114) ;
               when 115 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*116)-1 downto CHANNEL_DWIDTH*115) ;
               when 116 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*117)-1 downto CHANNEL_DWIDTH*116) ;
               when 117 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*118)-1 downto CHANNEL_DWIDTH*117) ;
               when 118 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*119)-1 downto CHANNEL_DWIDTH*118) ;
               when 119 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*120)-1 downto CHANNEL_DWIDTH*119) ;
               when 120 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*121)-1 downto CHANNEL_DWIDTH*120) ;
               when 121 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*122)-1 downto CHANNEL_DWIDTH*121) ;
               when 122 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*123)-1 downto CHANNEL_DWIDTH*122) ;
               when 123 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*124)-1 downto CHANNEL_DWIDTH*123) ;
               when 124 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*125)-1 downto CHANNEL_DWIDTH*124) ;
               when 125 =>                                                                    
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*126)-1 downto CHANNEL_DWIDTH*125) ;
               when 126 =>                                                                 
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*127)-1 downto CHANNEL_DWIDTH*126) ;
               
               when others => -- 127 case
                   sig_mux_dout  <=  mmap_read_data_in((CHANNEL_DWIDTH*128)-1 downto CHANNEL_DWIDTH*127) ;
             
             
             end case;
          
           end process DO_128XN_NUX; 
 
         
       end generate GEN_128XN;
  
 
  
  
  
  
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_rddata_cntl.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_rddata_cntl.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Read Data Controller.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  library axi_datamover_v5_1_17; 
  use axi_datamover_v5_1_17.axi_datamover_rdmux;  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_rddata_cntl is
    generic (
      
      C_INCLUDE_DRE          : Integer range  0 to   1 :=  0;
        -- Indicates if the DRE interface is used
        
      C_ALIGN_WIDTH          : Integer range  1 to   6 :=  3;
        -- Sets the width of the DRE Alignment controls
        
      C_SEL_ADDR_WIDTH       : Integer range  1 to   8 :=  5;
        -- Sets the width of the LS bits of the transfer address that
        -- are being used to Mux read data from a wider AXI4 Read
        -- Data Bus
        
      C_DATA_CNTL_FIFO_DEPTH : Integer range  1 to  32 :=  4;
        -- Sets the depth of the internal command fifo used for the
        -- command queue
        
      C_MMAP_DWIDTH          : Integer range 32 to 1024 := 32;
        -- Indicates the native data width of the Read Data port
        
      C_STREAM_DWIDTH        : Integer range  8 to 1024 := 32;
        -- Sets the width of the Stream output data port
        
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        -- Indicates the width of the Tag field of the input command

    C_ENABLE_MM2S_TKEEP             : integer range 0 to 1 := 1; 
        
      C_FAMILY               : String                  := "virtex7"
        -- Indicates the device family of the target FPGA
        
      
      );
    port (
      
      -- Clock and Reset inputs ----------------------------------------
                                                                      --
      primary_aclk          : in  std_logic;                          --
         -- Primary synchronization clock for the Master side         --
         -- interface and internal logic. It is also used             --
         -- for the User interface synchronization when               --
         -- C_STSCMD_IS_ASYNC = 0.                                    --
                                                                      --
      -- Reset input                                                  --
      mmap_reset            : in  std_logic;                          --
         -- Reset used for the internal master logic                  --
      ------------------------------------------------------------------
      
     
      
      -- Soft Shutdown internal interface -----------------------------------
                                                                           --
      rst2data_stop_request : in  std_logic;                               --
         -- Active high soft stop request to modules                       --
                                                                           --
      data2addr_stop_req    : Out std_logic;                               --
        -- Active high signal requesting the Address Controller            --
        -- to stop posting commands to the AXI Read Address Channel        --
                                                                           --
      data2rst_stop_cmplt   : Out std_logic;                               --
        -- Active high indication that the Data Controller has completed   --
        -- any pending transfers committed by the Address Controller       --
        -- after a stop has been requested by the Reset module.            --
      -----------------------------------------------------------------------
   
   
        
      -- External Address Pipelining Contol support -------------------------
                                                                           --
      mm2s_rd_xfer_cmplt    : out std_logic;                               --
        -- Active high indication that the Data Controller has completed   --
        -- a single read data transfer on the AXI4 Read Data Channel.      --
        -- This signal escentially echos the assertion of rlast received   --
        -- from the AXI4.                                                  --
      -----------------------------------------------------------------------
      
      
      
        
     -- AXI Read Data Channel I/O  ---------------------------------------------
                                                                              --
      mm2s_rdata            : In  std_logic_vector(C_MMAP_DWIDTH-1 downto 0); --
        -- AXI Read data input                                                --
                                                                              --
      mm2s_rresp            : In  std_logic_vector(1 downto 0);               --
        -- AXI Read response input                                            --
                                                                              --
      mm2s_rlast            : In  std_logic;                                  --
        -- AXI Read LAST input                                                --
                                                                              --
      mm2s_rvalid           : In  std_logic;                                  --
        -- AXI Read VALID input                                               --
                                                                              --
      mm2s_rready           : Out std_logic;                                  --
        -- AXI Read data READY output                                         --
      --------------------------------------------------------------------------
               
                
                
                
     -- MM2S DRE Control  -------------------------------------------------------------
                                                                                     --
      mm2s_dre_new_align      : Out std_logic;                                       --
        -- Active high signal indicating new DRE aligment required                   --
                                                                                     --
      mm2s_dre_use_autodest   : Out std_logic;                                       --
        -- Active high signal indicating to the DRE to use an auto-                  --
        -- calculated desination alignment based on the last transfer                --
                                                                                     --
      mm2s_dre_src_align      : Out std_logic_vector(C_ALIGN_WIDTH-1 downto 0);      --
        -- Bit field indicating the byte lane of the first valid data byte           --
        -- being sent to the DRE                                                     --
                                                                                     --
      mm2s_dre_dest_align     : Out std_logic_vector(C_ALIGN_WIDTH-1 downto 0);      --
        -- Bit field indicating the desired byte lane of the first valid data byte   --
        -- to be output by the DRE                                                   --
                                                                                     --
      mm2s_dre_flush          : Out std_logic;                                       --
        -- Active high signal indicating to the DRE to flush the current             --
        -- contents to the output register in preparation of a new alignment         --
        -- that will be comming on the next transfer input                           --
      ---------------------------------------------------------------------------------
               
                
                
                
     -- AXI Master Stream Channel------------------------------------------------------
                                                                                     --
      mm2s_strm_wvalid   : Out std_logic;                                            --
        -- AXI Stream VALID Output                                                   --
                                                                                     --
      mm2s_strm_wready   : In  Std_logic;                                            --
        -- AXI Stream READY input                                                    --
                                                                                     --
      mm2s_strm_wdata    : Out std_logic_vector(C_STREAM_DWIDTH-1 downto 0);         --
        -- AXI Stream data output                                                    --
                                                                                     --
      mm2s_strm_wstrb    : Out std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);     --    
        -- AXI Stream STRB output                                                    --
                                                                                     --
      mm2s_strm_wlast    : Out std_logic;                                            --
        -- AXI Stream LAST output                                                    --
      ---------------------------------------------------------------------------------
               
                
      
      -- MM2S Store and Forward Supplimental Control   --------------------------------
      -- This output is time aligned and qualified with the AXI Master Stream Channel--
                                                                                     --
      mm2s_data2sf_cmd_cmplt   : out std_logic;                                      --
                                                                                     --
      ---------------------------------------------------------------------------------
                                                                                     
                                                                                     
                                                                                     
                                                                                     
                                                                                     
                
                
      -- Command Calculator Interface -------------------------------------------------
                                                                                     --
      mstr2data_tag        : In std_logic_vector(C_TAG_WIDTH-1 downto 0);            --
         -- The next command tag                                                     --
                                                                                     --
      mstr2data_saddr_lsb  : In std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);       --
         -- The next command start address LSbs to use for the read data             --
         -- mux (only used if Stream data width is 8 or 16 bits).                    --
                                                                                     --
      mstr2data_len        : In std_logic_vector(7 downto 0);                        --
         -- The LEN value output to the Address Channel                              --
                                                                                     --
      mstr2data_strt_strb  : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);    --
         -- The starting strobe value to use for the first stream data beat          --
                                                                                     --
      mstr2data_last_strb  : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);    --
         -- The endiing (LAST) strobe value to use for the last stream               --
         -- data beat                                                                --
                                                                                     --
      mstr2data_drr        : In std_logic;                                           --
         -- The starting tranfer of a sequence of transfers                          --
                                                                                     --
      mstr2data_eof        : In std_logic;                                           --
         -- The endiing tranfer of a sequence of transfers                           --
                                                                                     --
      mstr2data_sequential : In std_logic;                                           --
         -- The next sequential tranfer of a sequence of transfers                   --
         -- spawned from a single parent command                                     --
                                                                                     --
      mstr2data_calc_error : In std_logic;                                           --
         -- Indication if the next command in the calculation pipe                   --
         -- has a calculation error                                                  --
                                                                                     --
      mstr2data_cmd_cmplt  : In std_logic;                                           --
         -- The indication to the Data Channel that the current                      --
         -- sub-command output is the last one compiled from the                     --
         -- parent command pulled from the Command FIFO                              --
                                                                                     --
      mstr2data_cmd_valid  : In std_logic;                                           --
         -- The next command valid indication to the Data Channel                    --
         -- Controller for the AXI MMap                                              --
                                                                                     --
      data2mstr_cmd_ready  : Out std_logic ;                                         --
         -- Indication from the Data Channel Controller that the                     --
         -- command is being accepted on the AXI Address Channel                     --
                                                                                     --
      mstr2data_dre_src_align   : In std_logic_vector(C_ALIGN_WIDTH-1 downto 0);     --
         -- The source (input) alignment for the DRE                                 --
                                                                                     --
      mstr2data_dre_dest_align  : In std_logic_vector(C_ALIGN_WIDTH-1 downto 0);     --
         -- The destinstion (output) alignment for the DRE                           --
      ---------------------------------------------------------------------------------
     
      
      
      
        
      -- Address Controller Interface -------------------------------------------------
                                                                                     --
      addr2data_addr_posted : In std_logic ;                                         --
         -- Indication from the Address Channel Controller to the                    --
         -- Data Controller that an address has been posted to the                   --
         -- AXI Address Channel                                                      --
      ---------------------------------------------------------------------------------


      
      -- Data Controller General Halted Status ----------------------------------------
                                                                                     --
      data2all_dcntlr_halted : Out std_logic;                                        --
         -- When asserted, this indicates the data controller has satisfied          --
         -- all pending transfers queued by the Address Controller and is halted.    --
      ---------------------------------------------------------------------------------
      
       
 
      -- Output Stream Skid Buffer Halt control ---------------------------------------
                                                                                     --
      data2skid_halt : Out std_logic;                                                --
         -- The data controller asserts this output for 1 primary clock period       --
         -- The pulse commands the MM2S Stream skid buffer to tun off outputs        --
         -- at the next tlast transmission.                                          --
      ---------------------------------------------------------------------------------
      
       
 
       
      -- Read Status Controller Interface ------------------------------------------------
                                                                                        --
      data2rsc_tag       : Out std_logic_vector(C_TAG_WIDTH-1 downto 0);                --
         -- The propagated command tag from the Command Calculator                      --
                                                                                        --
      data2rsc_calc_err  : Out std_logic ;                                              --
         -- Indication that the current command out from the Cntl FIFO                  --
         -- has a propagated calculation error from the Command Calculator              --
                                                                                        --
      data2rsc_okay      : Out std_logic ;                                              --
         -- Indication that the AXI Read transfer completed with OK status              --
                                                                                        --
      data2rsc_decerr    : Out std_logic ;                                              --
         -- Indication that the AXI Read transfer completed with decode error status    --
                                                                                        --
      data2rsc_slverr    : Out std_logic ;                                              --
         -- Indication that the AXI Read transfer completed with slave error status     --
                                                                                        --
      data2rsc_cmd_cmplt : Out std_logic ;                                              --
         -- Indication by the Data Channel Controller that the                          --
         -- corresponding status is the last status for a parent command                --
         -- pulled from the command FIFO                                                --
                                                                                        --
      rsc2data_ready     : in  std_logic;                                               --
         -- Handshake bit from the Read Status Controller Module indicating             --
         -- that the it is ready to accept a new Read status transfer                   --
                                                                                        --
      data2rsc_valid     : Out  std_logic ;                                             --
         -- Handshake bit output to the Read Status Controller Module                   --
         -- indicating that the Data Controller has valid tag and status                --
         -- indicators to transfer                                                      --
                                                                                        --
      rsc2mstr_halt_pipe : In std_logic                                                 --
         -- Status Flag indicating the Status Controller needs to stall the command     --
         -- execution pipe due to a Status flow issue or internal error. Generally      --
         -- this will occur if the Status FIFO is not being serviced fast enough to     --
         -- keep ahead of the command execution.                                        --
      ------------------------------------------------------------------------------------
      
      );
  
  end entity axi_datamover_rddata_cntl;
  
  
  architecture implementation of axi_datamover_rddata_cntl is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Function declaration   ----------------------------------------
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_set_cnt_width
    --
    -- Function Description:
    --    Sets a count width based on a fifo depth. A depth of 4 or less
    -- is a special case which requires a minimum count width of 3 bits.
    --
    -------------------------------------------------------------------
    function funct_set_cnt_width (fifo_depth : integer) return integer is
    
      Variable temp_cnt_width : Integer := 4;
    
    begin
    
      
      if (fifo_depth <= 4) then
      
         temp_cnt_width := 3;
      
      elsif (fifo_depth <= 8) then
      
         temp_cnt_width := 4;
      
      elsif (fifo_depth <= 16) then
      
         temp_cnt_width := 5;
      
      elsif (fifo_depth <= 32) then
      
         temp_cnt_width := 6;
      
      else  -- fifo depth <= 64
      
         temp_cnt_width := 7;
      
      end if;
      
      Return (temp_cnt_width);
       
       
    end function funct_set_cnt_width;
    
 
 
 
  
    -- Constant Declarations  --------------------------------------------
    
    Constant OKAY                   : std_logic_vector(1 downto 0) := "00";
    Constant EXOKAY                 : std_logic_vector(1 downto 0) := "01";
    Constant SLVERR                 : std_logic_vector(1 downto 0) := "10";
    Constant DECERR                 : std_logic_vector(1 downto 0) := "11";
                                    
    Constant STRM_STRB_WIDTH        : integer := C_STREAM_DWIDTH/8;
    Constant LEN_OF_ZERO            : std_logic_vector(7 downto 0) := (others => '0');
    Constant USE_SYNC_FIFO          : integer := 0;
    Constant REG_FIFO_PRIM          : integer := 0; 
    Constant BRAM_FIFO_PRIM         : integer := 1; 
    Constant SRL_FIFO_PRIM          : integer := 2; 
    Constant FIFO_PRIM_TYPE         : integer := SRL_FIFO_PRIM; 
    Constant TAG_WIDTH              : integer := C_TAG_WIDTH;
    Constant SADDR_LSB_WIDTH        : integer := C_SEL_ADDR_WIDTH;
    Constant LEN_WIDTH              : integer := 8;
    Constant STRB_WIDTH             : integer := C_STREAM_DWIDTH/8;
    Constant SOF_WIDTH              : integer := 1;
    Constant EOF_WIDTH              : integer := 1;
    Constant CMD_CMPLT_WIDTH        : integer := 1;
    Constant SEQUENTIAL_WIDTH       : integer := 1;
    Constant CALC_ERR_WIDTH         : integer := 1;
    Constant DRE_ALIGN_WIDTH        : integer := C_ALIGN_WIDTH;
                                    
    Constant DCTL_FIFO_WIDTH        : Integer := TAG_WIDTH        +  -- Tag field
                                                 SADDR_LSB_WIDTH  +  -- LS Address field width
                                                 LEN_WIDTH        +  -- LEN field
                                                 STRB_WIDTH       +  -- Starting Strobe field
                                                 STRB_WIDTH       +  -- Ending Strobe field
                                                 SOF_WIDTH        +  -- SOF Flag Field
                                                 EOF_WIDTH        +  -- EOF flag field
                                                 SEQUENTIAL_WIDTH +  -- Calc error flag
                                                 CMD_CMPLT_WIDTH  +  -- Sequential command flag
                                                 CALC_ERR_WIDTH   +  -- Command Complete Flag
                                                 DRE_ALIGN_WIDTH  +  -- DRE Source Align width
                                                 DRE_ALIGN_WIDTH ;   -- DRE Dest Align width
                                                 
                                    
    -- Caution, the INDEX calculations are order dependent so don't rearrange
    Constant TAG_STRT_INDEX         : integer := 0;
    Constant SADDR_LSB_STRT_INDEX   : integer := TAG_STRT_INDEX + TAG_WIDTH;
    Constant LEN_STRT_INDEX         : integer := SADDR_LSB_STRT_INDEX + SADDR_LSB_WIDTH;
    Constant STRT_STRB_STRT_INDEX   : integer := LEN_STRT_INDEX + LEN_WIDTH;
    Constant LAST_STRB_STRT_INDEX   : integer := STRT_STRB_STRT_INDEX + STRB_WIDTH;
    Constant SOF_STRT_INDEX         : integer := LAST_STRB_STRT_INDEX + STRB_WIDTH;
    Constant EOF_STRT_INDEX         : integer := SOF_STRT_INDEX + SOF_WIDTH;
    Constant SEQUENTIAL_STRT_INDEX  : integer := EOF_STRT_INDEX + EOF_WIDTH;
    Constant CMD_CMPLT_STRT_INDEX   : integer := SEQUENTIAL_STRT_INDEX + SEQUENTIAL_WIDTH;
    Constant CALC_ERR_STRT_INDEX    : integer := CMD_CMPLT_STRT_INDEX + CMD_CMPLT_WIDTH;
    Constant DRE_SRC_STRT_INDEX     : integer := CALC_ERR_STRT_INDEX + CALC_ERR_WIDTH;
    Constant DRE_DEST_STRT_INDEX    : integer := DRE_SRC_STRT_INDEX + DRE_ALIGN_WIDTH;
    
    Constant ADDR_INCR_VALUE        : integer := C_STREAM_DWIDTH/8;
    
    --Constant ADDR_POSTED_CNTR_WIDTH : integer := 5; -- allows up to 32 entry address queue
    Constant ADDR_POSTED_CNTR_WIDTH : integer := funct_set_cnt_width(C_DATA_CNTL_FIFO_DEPTH); 
    
    
    Constant ADDR_POSTED_ZERO       : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := (others => '0');
    Constant ADDR_POSTED_ONE        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := TO_UNSIGNED(1, ADDR_POSTED_CNTR_WIDTH);
    Constant ADDR_POSTED_MAX        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                       := (others => '1');
                    
    
    
    
    -- Signal Declarations  --------------------------------------------
    
    signal sig_good_dbeat               : std_logic := '0';
    signal sig_get_next_dqual           : std_logic := '0';
    signal sig_last_mmap_dbeat          : std_logic := '0';
    signal sig_last_mmap_dbeat_reg      : std_logic := '0';
    signal sig_data2mmap_ready          : std_logic := '0';
    signal sig_mmap2data_valid          : std_logic := '0';
    signal sig_mmap2data_last           : std_logic := '0';
    signal sig_aposted_cntr_ready       : std_logic := '0';
    signal sig_ld_new_cmd               : std_logic := '0';
    signal sig_ld_new_cmd_reg           : std_logic := '0';
    signal sig_cmd_cmplt_reg            : std_logic := '0';
    signal sig_tag_reg                  : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_lsb_reg             : std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_strt_strb_reg            : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_last_strb_reg            : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_addr_posted              : std_logic := '0';
    signal sig_addr_chan_rdy            : std_logic := '0';
    signal sig_dqual_rdy                : std_logic := '0';
    signal sig_good_mmap_dbeat          : std_logic := '0';
    signal sig_first_dbeat              : std_logic := '0';
    signal sig_last_dbeat               : std_logic := '0';
    signal sig_new_len_eq_0             : std_logic := '0';
    signal sig_dbeat_cntr               : unsigned(7 downto 0) := (others => '0');
    Signal sig_dbeat_cntr_int           : Integer range 0 to 255 := 0;
    signal sig_dbeat_cntr_eq_0          : std_logic := '0';
    signal sig_dbeat_cntr_eq_1          : std_logic := '0';
    signal sig_calc_error_reg           : std_logic := '0';
    signal sig_decerr                   : std_logic := '0';
    signal sig_slverr                   : std_logic := '0';
    signal sig_coelsc_okay_reg          : std_logic := '0';
    signal sig_coelsc_interr_reg        : std_logic := '0';
    signal sig_coelsc_decerr_reg        : std_logic := '0';
    signal sig_coelsc_slverr_reg        : std_logic := '0';
    signal sig_coelsc_cmd_cmplt_reg     : std_logic := '0';
    signal sig_coelsc_tag_reg           : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_pop_coelsc_reg           : std_logic := '0';
    signal sig_push_coelsc_reg          : std_logic := '0';
    signal sig_coelsc_reg_empty         : std_logic := '0';
    signal sig_coelsc_reg_full          : std_logic := '0';
    signal sig_rsc2data_ready           : std_logic := '0';
    signal sig_cmd_cmplt_last_dbeat     : std_logic := '0';
    signal sig_next_tag_reg             : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_strt_strb_reg       : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_next_last_strb_reg       : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_next_eof_reg             : std_logic := '0';
    signal sig_next_sequential_reg      : std_logic := '0';
    signal sig_next_cmd_cmplt_reg       : std_logic := '0';
    signal sig_next_calc_error_reg      : std_logic := '0';
    signal sig_next_dre_src_align_reg   : std_logic_vector(C_ALIGN_WIDTH-1 downto 0) := (others => '0');  
    signal sig_next_dre_dest_align_reg  : std_logic_vector(C_ALIGN_WIDTH-1 downto 0) := (others => '0'); 
    signal sig_pop_dqual_reg            : std_logic := '0';
    signal sig_push_dqual_reg           : std_logic := '0';
    signal sig_dqual_reg_empty          : std_logic := '0';
    signal sig_dqual_reg_full           : std_logic := '0';
    signal sig_addr_posted_cntr         : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_posted_cntr_eq_0    : std_logic := '0';
    signal sig_addr_posted_cntr_max     : std_logic := '0';
    signal sig_decr_addr_posted_cntr    : std_logic := '0';
    signal sig_incr_addr_posted_cntr    : std_logic := '0';
    signal sig_ls_addr_cntr             : unsigned(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_incr_ls_addr_cntr        : std_logic := '0';
    signal sig_addr_incr_unsgnd         : unsigned(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_no_posted_cmds           : std_logic := '0';
    Signal sig_cmd_fifo_data_in         : std_logic_vector(DCTL_FIFO_WIDTH-1 downto 0);
    Signal sig_cmd_fifo_data_out        : std_logic_vector(DCTL_FIFO_WIDTH-1 downto 0);
    signal sig_fifo_next_tag            : std_logic_vector(TAG_WIDTH-1 downto 0);
    signal sig_fifo_next_sadddr_lsb     : std_logic_vector(SADDR_LSB_WIDTH-1 downto 0);             
    signal sig_fifo_next_len            : std_logic_vector(LEN_WIDTH-1 downto 0);             
    signal sig_fifo_next_strt_strb      : std_logic_vector(STRB_WIDTH-1 downto 0);             
    signal sig_fifo_next_last_strb      : std_logic_vector(STRB_WIDTH-1 downto 0);             
    signal sig_fifo_next_drr            : std_logic := '0';
    signal sig_fifo_next_eof            : std_logic := '0';
    signal sig_fifo_next_cmd_cmplt      : std_logic := '0';
    signal sig_fifo_next_calc_error     : std_logic := '0';
    signal sig_fifo_next_sequential     : std_logic := '0';
    signal sig_fifo_next_dre_src_align  : std_logic_vector(C_ALIGN_WIDTH-1 downto 0) := (others => '0');  
    signal sig_fifo_next_dre_dest_align : std_logic_vector(C_ALIGN_WIDTH-1 downto 0) := (others => '0'); 
    signal sig_cmd_fifo_empty           : std_logic := '0';
    signal sig_fifo_wr_cmd_valid        : std_logic := '0';
    signal sig_fifo_wr_cmd_ready        : std_logic := '0';
    signal sig_fifo_rd_cmd_valid        : std_logic := '0';
    signal sig_fifo_rd_cmd_ready        : std_logic := '0';
    signal sig_sequential_push          : std_logic := '0';
    signal sig_clr_dqual_reg            : std_logic := '0';
    signal sig_advance_pipe             : std_logic := '0';
    signal sig_halt_reg                 : std_logic := '0';
    signal sig_halt_reg_dly1            : std_logic := '0';
    signal sig_halt_reg_dly2            : std_logic := '0';
    signal sig_halt_reg_dly3            : std_logic := '0';
    signal sig_data2skid_halt           : std_logic := '0';
    signal sig_rd_xfer_cmplt            : std_logic := '0';
    
                              
    
  begin --(architecture implementation)
  
    -- AXI MMap Data Channel Port assignments
    mm2s_rready          <= sig_data2mmap_ready;
    sig_mmap2data_valid  <= mm2s_rvalid        ;
    sig_mmap2data_last   <= mm2s_rlast         ;
    
    -- Read Status Block interface
    data2rsc_valid       <= sig_coelsc_reg_full      ;
    sig_rsc2data_ready   <= rsc2data_ready           ;
    
    data2rsc_tag         <= sig_coelsc_tag_reg       ;
    data2rsc_calc_err    <= sig_coelsc_interr_reg    ;
    data2rsc_okay        <= sig_coelsc_okay_reg      ;
    data2rsc_decerr      <= sig_coelsc_decerr_reg    ;
    data2rsc_slverr      <= sig_coelsc_slverr_reg    ;
    data2rsc_cmd_cmplt   <= sig_coelsc_cmd_cmplt_reg ;
    
    
                                                    
    -- AXI MM2S Stream Channel Port assignments               
    mm2s_strm_wvalid     <= (mm2s_rvalid             and         
                             sig_advance_pipe)       or
                            (sig_halt_reg            and  -- Force tvalid high on a Halt and
                             sig_dqual_reg_full      and  -- a transfer is scheduled and
                             not(sig_no_posted_cmds) and  -- there are cmds posted to AXi and
                             not(sig_calc_error_reg));    -- not a calc error       
    
            
                                                    
    mm2s_strm_wlast      <= (mm2s_rlast              and
                            sig_next_eof_reg)        or
                            (sig_halt_reg            and  -- Force tvalid high on a Halt and
                             sig_dqual_reg_full      and  -- a transfer is scheduled and
                             not(sig_no_posted_cmds) and  -- there are cmds posted to AXi and
                             not(sig_calc_error_reg));    -- not a calc error;        
    
    
     
    

GEN_MM2S_TKEEP_ENABLE5 : if C_ENABLE_MM2S_TKEEP = 1 generate
begin
   -- Generate the Write Strobes for the Stream interface
    mm2s_strm_wstrb <= (others => '1')
      When (sig_halt_reg = '1')        -- Force tstrb high on a Halt
      else sig_strt_strb_reg
      When (sig_first_dbeat = '1')
      Else sig_last_strb_reg
      When (sig_last_dbeat = '1')
      Else (others => '1');

 
end generate GEN_MM2S_TKEEP_ENABLE5;

GEN_MM2S_TKEEP_DISABLE5 : if C_ENABLE_MM2S_TKEEP = 0 generate
begin
   -- Generate the Write Strobes for the Stream interface
    mm2s_strm_wstrb <= (others => '1');


end generate GEN_MM2S_TKEEP_DISABLE5;

    
    
    
    -- MM2S Supplimental Controls
    mm2s_data2sf_cmd_cmplt <= (mm2s_rlast              and
                               sig_next_cmd_cmplt_reg) or
                              (sig_halt_reg            and  
                               sig_dqual_reg_full      and  
                               not(sig_no_posted_cmds) and  
                               not(sig_calc_error_reg));    
    
    
    
    
    
    
    -- Address Channel Controller synchro pulse input                  
    sig_addr_posted      <= addr2data_addr_posted;
                                                        
 
 
    -- Request to halt the Address Channel Controller                  
    data2addr_stop_req   <= sig_halt_reg;
 
    
    -- Halted flag to the reset module                  
    data2rst_stop_cmplt  <= (sig_halt_reg_dly3 and   -- Normal Mode shutdown
                            sig_no_posted_cmds and 
                            not(sig_calc_error_reg)) or
                            (sig_halt_reg_dly3 and   -- Shutdown after error trap
                             sig_calc_error_reg);
    
     
    
    -- Read Transfer Completed Status output
    mm2s_rd_xfer_cmplt <=  sig_rd_xfer_cmplt;                     
    
    
     
    -- Internal logic ------------------------------
 
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_RD_CMPLT_FLAG
    --
    -- Process Description:
    --   Implements the status flag indicating that a read data 
    -- transfer has completed. This is an echo of a rlast assertion
    -- and a qualified data beat on the AXI4 Read Data Channel 
    -- inputs.
    --
    -------------------------------------------------------------
    IMP_RD_CMPLT_FLAG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then
    
             sig_rd_xfer_cmplt <= '0';
    
           else
    
             sig_rd_xfer_cmplt <= sig_mmap2data_last and 
                                  sig_good_mmap_dbeat;
                                  
           end if; 
        end if;       
      end process IMP_RD_CMPLT_FLAG; 
     
    
 
  
    
    -- General flag for advancing the MMap Read and the Stream
    -- data pipelines
    sig_advance_pipe     <=  sig_addr_chan_rdy        and                                  
                             sig_dqual_rdy            and                                  
                             not(sig_coelsc_reg_full) and  -- new status back-pressure term
                             not(sig_calc_error_reg);                                      
    
                                      
    -- test for Kevin's status throttle case
    sig_data2mmap_ready  <= (mm2s_strm_wready or 
                             sig_halt_reg)    and    -- Ignore the Stream ready on a Halt request                              
                             sig_advance_pipe;          
    
     
     
    sig_good_mmap_dbeat  <= sig_data2mmap_ready and 
                            sig_mmap2data_valid;
    
    
    sig_last_mmap_dbeat  <= sig_good_mmap_dbeat and 
                            sig_mmap2data_last;
     
     
    sig_get_next_dqual   <= sig_last_mmap_dbeat; 
    
    
    
    
    
    
         
    ------------------------------------------------------------
    -- Instance: I_READ_MUX 
    --
    -- Description:
    --  Instance of the MM2S Read Data Channel Read Mux   
    --
    ------------------------------------------------------------
    I_READ_MUX : entity axi_datamover_v5_1_17.axi_datamover_rdmux
    generic map (
  
      C_SEL_ADDR_WIDTH     =>  C_SEL_ADDR_WIDTH ,   
      C_MMAP_DWIDTH        =>  C_MMAP_DWIDTH    ,   
      C_STREAM_DWIDTH      =>  C_STREAM_DWIDTH      
  
      )
    port map (
  
      mmap_read_data_in    =>  mm2s_rdata       ,   
      mux_data_out         =>  mm2s_strm_wdata  ,            
      mstr2data_saddr_lsb  =>  sig_addr_lsb_reg     
    
      );
   
   
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_LAST_DBEAT
    --
    -- Process Description:
    --   This implements a FLOP that creates a pulse
    -- indicating the LAST signal for an incoming read data channel
    -- has been received. Note that it is possible to have back to 
    -- back LAST databeats.
    --
    -------------------------------------------------------------
    REG_LAST_DBEAT : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then

             sig_last_mmap_dbeat_reg <= '0';
             
           else
             
             sig_last_mmap_dbeat_reg <= sig_last_mmap_dbeat;
             
           end if; 
         end if;       
       end process REG_LAST_DBEAT; 
  
    
    
    
    
    

     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_NO_DATA_CNTL_FIFO
     --
     -- If Generate Description:
     --   Omits the input data control FIFO if the requested FIFO
     -- depth is 1. The Data Qualifier Register serves as a 
     -- 1 deep FIFO by itself.
     --
     ------------------------------------------------------------
     GEN_NO_DATA_CNTL_FIFO : if (C_DATA_CNTL_FIFO_DEPTH = 1) generate

       begin

         -- Command Calculator Handshake output
         data2mstr_cmd_ready    <= sig_fifo_wr_cmd_ready;           
        
         sig_fifo_rd_cmd_valid  <= mstr2data_cmd_valid ;
         
         
         
         -- pre 13.1 sig_fifo_wr_cmd_ready  <= sig_dqual_reg_empty     and                                         
         -- pre 13.1                           sig_aposted_cntr_ready  and                                         
         -- pre 13.1                           not(rsc2mstr_halt_pipe) and  -- The Rd Status Controller is not stalling
         -- pre 13.1                           not(sig_calc_error_reg);     -- the command execution pipe and there is  
         -- pre 13.1                                                        -- no calculation error being propagated

         sig_fifo_wr_cmd_ready  <= sig_push_dqual_reg;


                                                                    
         
         sig_fifo_next_tag             <= mstr2data_tag        ;    
         sig_fifo_next_sadddr_lsb      <= mstr2data_saddr_lsb  ;    
         sig_fifo_next_len             <= mstr2data_len        ;    
         sig_fifo_next_strt_strb       <= mstr2data_strt_strb  ;    
         sig_fifo_next_last_strb       <= mstr2data_last_strb  ;    
         sig_fifo_next_drr             <= mstr2data_drr        ;    
         sig_fifo_next_eof             <= mstr2data_eof        ;    
         sig_fifo_next_sequential      <= mstr2data_sequential ;    
         sig_fifo_next_cmd_cmplt       <= mstr2data_cmd_cmplt  ;    
         sig_fifo_next_calc_error      <= mstr2data_calc_error ; 
            
         sig_fifo_next_dre_src_align   <= mstr2data_dre_src_align  ; 
         sig_fifo_next_dre_dest_align  <= mstr2data_dre_dest_align ; 
                                                              
             
   
       end generate GEN_NO_DATA_CNTL_FIFO;
         
    
    
    
    
      
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_DATA_CNTL_FIFO
     --
     -- If Generate Description:
     --   Includes the input data control FIFO if the requested 
     -- FIFO depth is more than 1.
     --
     ------------------------------------------------------------
     GEN_DATA_CNTL_FIFO : if (C_DATA_CNTL_FIFO_DEPTH > 1) generate

       begin

       
         -- Command Calculator Handshake output
         data2mstr_cmd_ready    <= sig_fifo_wr_cmd_ready;           
         
         sig_fifo_wr_cmd_valid  <= mstr2data_cmd_valid  ;
         

         sig_fifo_rd_cmd_ready    <= sig_push_dqual_reg;  -- pop the fifo when dqual reg is pushed   
                                                               

         
         
                              
         -- Format the input fifo data word
         sig_cmd_fifo_data_in  <=   mstr2data_dre_dest_align &
                                    mstr2data_dre_src_align  &
                                    mstr2data_calc_error     &
                                    mstr2data_cmd_cmplt      &
                                    mstr2data_sequential     &
                                    mstr2data_eof            &
                                    mstr2data_drr            &
                                    mstr2data_last_strb      &
                                    mstr2data_strt_strb      &
                                    mstr2data_len            &
                                    mstr2data_saddr_lsb      &
                                    mstr2data_tag ;
         
          
         -- Rip the output fifo data word
         sig_fifo_next_tag        <= sig_cmd_fifo_data_out((TAG_STRT_INDEX+TAG_WIDTH)-1 downto 
                                                            TAG_STRT_INDEX);                   
         sig_fifo_next_sadddr_lsb <= sig_cmd_fifo_data_out((SADDR_LSB_STRT_INDEX+SADDR_LSB_WIDTH)-1 downto 
                                                            SADDR_LSB_STRT_INDEX);
         sig_fifo_next_len        <= sig_cmd_fifo_data_out((LEN_STRT_INDEX+LEN_WIDTH)-1 downto 
                                                            LEN_STRT_INDEX);
         sig_fifo_next_strt_strb  <= sig_cmd_fifo_data_out((STRT_STRB_STRT_INDEX+STRB_WIDTH)-1 downto 
                                                            STRT_STRB_STRT_INDEX);
         sig_fifo_next_last_strb  <= sig_cmd_fifo_data_out((LAST_STRB_STRT_INDEX+STRB_WIDTH)-1 downto 
                                                            LAST_STRB_STRT_INDEX);
         sig_fifo_next_drr        <= sig_cmd_fifo_data_out(SOF_STRT_INDEX);
         sig_fifo_next_eof        <= sig_cmd_fifo_data_out(EOF_STRT_INDEX);
         sig_fifo_next_sequential <= sig_cmd_fifo_data_out(SEQUENTIAL_STRT_INDEX);
         sig_fifo_next_cmd_cmplt  <= sig_cmd_fifo_data_out(CMD_CMPLT_STRT_INDEX);
         sig_fifo_next_calc_error <= sig_cmd_fifo_data_out(CALC_ERR_STRT_INDEX);

         sig_fifo_next_dre_src_align   <= sig_cmd_fifo_data_out((DRE_SRC_STRT_INDEX+DRE_ALIGN_WIDTH)-1 downto 
                                                                 DRE_SRC_STRT_INDEX);
         sig_fifo_next_dre_dest_align  <= sig_cmd_fifo_data_out((DRE_DEST_STRT_INDEX+DRE_ALIGN_WIDTH)-1 downto 
                                                                 DRE_DEST_STRT_INDEX);
         
                                           
                                           
                                           
         ------------------------------------------------------------
         -- Instance: I_DATA_CNTL_FIFO 
         --
         -- Description:
         -- Instance for the Command Qualifier FIFO
         --
         ------------------------------------------------------------
          I_DATA_CNTL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (
        
            C_DWIDTH             =>  DCTL_FIFO_WIDTH        ,  
            C_DEPTH              =>  C_DATA_CNTL_FIFO_DEPTH ,  
            C_IS_ASYNC           =>  USE_SYNC_FIFO          ,  
            C_PRIM_TYPE          =>  FIFO_PRIM_TYPE         ,  
            C_FAMILY             =>  C_FAMILY                  
           
            )
          port map (
            
            -- Write Clock and reset
            fifo_wr_reset        =>   mmap_reset            ,  
            fifo_wr_clk          =>   primary_aclk          ,  
            
            -- Write Side
            fifo_wr_tvalid       =>   sig_fifo_wr_cmd_valid ,  
            fifo_wr_tready       =>   sig_fifo_wr_cmd_ready ,  
            fifo_wr_tdata        =>   sig_cmd_fifo_data_in  ,  
            fifo_wr_full         =>   open                  ,  
           
            -- Read Clock and reset
            fifo_async_rd_reset  =>   mmap_reset            ,   
            fifo_async_rd_clk    =>   primary_aclk          ,  
            
            -- Read Side
            fifo_rd_tvalid       =>   sig_fifo_rd_cmd_valid ,  
            fifo_rd_tready       =>   sig_fifo_rd_cmd_ready ,  
            fifo_rd_tdata        =>   sig_cmd_fifo_data_out ,  
            fifo_rd_empty        =>   sig_cmd_fifo_empty       
           
            );
        

       end generate GEN_DATA_CNTL_FIFO;
         
          
    
   
  
  
  
  
  
    -- Data Qualifier Register ------------------------------------
    
    sig_ld_new_cmd           <= sig_push_dqual_reg      ;
    sig_addr_chan_rdy        <= not(sig_addr_posted_cntr_eq_0);
    sig_dqual_rdy            <= sig_dqual_reg_full      ;
    sig_strt_strb_reg        <= sig_next_strt_strb_reg  ;
    sig_last_strb_reg        <= sig_next_last_strb_reg  ;
    sig_tag_reg              <= sig_next_tag_reg        ;
    sig_cmd_cmplt_reg        <= sig_next_cmd_cmplt_reg  ;
    sig_calc_error_reg       <= sig_next_calc_error_reg ;
    
    
    -- Flag indicating that there are no posted commands to AXI
    sig_no_posted_cmds       <= sig_addr_posted_cntr_eq_0;
    
    
    
    -- new for no bubbles between child requests
    sig_sequential_push      <= sig_good_mmap_dbeat and -- MMap handshake qualified
                                sig_last_dbeat      and -- last data beat of transfer
                                sig_next_sequential_reg;-- next queued command is sequential 
                                                        -- to the current command
    
    
    -- pre 13.1 sig_push_dqual_reg       <= (sig_sequential_push   or
    -- pre 13.1                              sig_dqual_reg_empty)  and 
    -- pre 13.1                             sig_fifo_rd_cmd_valid  and
    -- pre 13.1                             sig_aposted_cntr_ready and 
    -- pre 13.1                             not(rsc2mstr_halt_pipe);  -- The Rd Status Controller is not  
                                                                      -- stalling the command execution pipe
    
    sig_push_dqual_reg       <= (sig_sequential_push    or
                                 sig_dqual_reg_empty)   and 
                                sig_fifo_rd_cmd_valid   and
                                sig_aposted_cntr_ready  and 
                                not(sig_calc_error_reg) and -- 13.1 addition => An error has not been propagated
                                not(rsc2mstr_halt_pipe);    -- The Rd Status Controller is not  
                                                            -- stalling the command execution pipe
                                                        
                                                        
    sig_pop_dqual_reg        <= not(sig_next_calc_error_reg) and 
                                sig_get_next_dqual and 
                                sig_dqual_reg_full  ; 
    
  
    -- new for no bubbles between child requests
    sig_clr_dqual_reg        <=  mmap_reset         or
                                 (sig_pop_dqual_reg and
                                 not(sig_push_dqual_reg));
  
    
  -------------------------------------------------------------
  -- Synchronous Process with Sync Reset
  --
  -- Label: IMP_DQUAL_REG
  --
  -- Process Description:
  --    This process implements a register for the Data 
  -- Control and qualifiers. It operates like a 1 deep Sync FIFO.
  --
  -------------------------------------------------------------
  IMP_DQUAL_REG : process (primary_aclk)
     begin
       if (primary_aclk'event and primary_aclk = '1') then
          if (sig_clr_dqual_reg = '1') then
            
            sig_next_tag_reg             <= (others => '0');
            sig_next_strt_strb_reg       <= (others => '0');
            sig_next_last_strb_reg       <= (others => '0');
            sig_next_eof_reg             <= '0';
            sig_next_cmd_cmplt_reg       <= '0';
            sig_next_sequential_reg      <= '0';
            sig_next_calc_error_reg      <= '0';
            sig_next_dre_src_align_reg   <= (others => '0');
            sig_next_dre_dest_align_reg  <= (others => '0');
            
            sig_dqual_reg_empty          <= '1';
            sig_dqual_reg_full           <= '0';
            
          elsif (sig_push_dqual_reg = '1') then
            
            sig_next_tag_reg             <= sig_fifo_next_tag            ;
            sig_next_strt_strb_reg       <= sig_fifo_next_strt_strb      ;
            sig_next_last_strb_reg       <= sig_fifo_next_last_strb      ;
            sig_next_eof_reg             <= sig_fifo_next_eof            ;
            sig_next_cmd_cmplt_reg       <= sig_fifo_next_cmd_cmplt      ;
            sig_next_sequential_reg      <= sig_fifo_next_sequential     ;
            sig_next_calc_error_reg      <= sig_fifo_next_calc_error     ;
            sig_next_dre_src_align_reg   <= sig_fifo_next_dre_src_align  ;  
            sig_next_dre_dest_align_reg  <= sig_fifo_next_dre_dest_align ;  
            
            sig_dqual_reg_empty          <= '0';
            sig_dqual_reg_full           <= '1';
            
          else
            null;  -- don't change state
          end if; 
       end if;       
     end process IMP_DQUAL_REG; 
     

  
  
  
    
    
    -- Address LS Cntr logic  --------------------------
    
    sig_addr_lsb_reg         <= STD_LOGIC_VECTOR(sig_ls_addr_cntr);
    sig_addr_incr_unsgnd     <= TO_UNSIGNED(ADDR_INCR_VALUE, C_SEL_ADDR_WIDTH);
    sig_incr_ls_addr_cntr    <= sig_good_mmap_dbeat;
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: DO_ADDR_LSB_CNTR
    --
    -- Process Description:
    --  Implements the LS Address Counter used for controlling
    -- the Read Data Mux during Burst transfers
    --
    -------------------------------------------------------------
    DO_ADDR_LSB_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1'  or
               (sig_pop_dqual_reg  = '1'  and
                sig_push_dqual_reg = '0')) then                 -- Clear the Counter
              
              sig_ls_addr_cntr <= (others => '0');
            
            elsif (sig_push_dqual_reg = '1') then               -- Load the Counter
              
              sig_ls_addr_cntr <= unsigned(sig_fifo_next_sadddr_lsb);
            
            elsif (sig_incr_ls_addr_cntr = '1') then            -- Increment the Counter
              
              sig_ls_addr_cntr <= sig_ls_addr_cntr + sig_addr_incr_unsgnd;
            
            else
              null;  -- Hold Current value
            end if; 
         end if;       
       end process DO_ADDR_LSB_CNTR; 
    
    
    
    
    
    
    
    
    
    
    
    
    ----- Address posted Counter logic --------------------------------
    
    sig_incr_addr_posted_cntr <= sig_addr_posted              ;
    
    
    sig_decr_addr_posted_cntr <= sig_last_mmap_dbeat_reg      ;
    
    
    sig_aposted_cntr_ready    <= not(sig_addr_posted_cntr_max);
    
    sig_addr_posted_cntr_eq_0 <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_ZERO)
      Else '0';
    
    sig_addr_posted_cntr_max <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_MAX)
      Else '0';
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ADDR_POSTED_FIFO_CNTR
    --
    -- Process Description:
    --    This process implements a register for the Address 
    -- Posted FIFO that operates like a 1 deep Sync FIFO.
    --
    -------------------------------------------------------------
    IMP_ADDR_POSTED_FIFO_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_addr_posted_cntr <= ADDR_POSTED_ZERO;
              
            elsif (sig_incr_addr_posted_cntr = '1' and
                   sig_decr_addr_posted_cntr  = '0' and
                   sig_addr_posted_cntr_max = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr + ADDR_POSTED_ONE ;
              
            elsif (sig_incr_addr_posted_cntr  = '0' and
                   sig_decr_addr_posted_cntr   = '1' and
                   sig_addr_posted_cntr_eq_0 = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr - ADDR_POSTED_ONE ;
              
            else
              null;  -- don't change state
            end if; 
         end if;       
       end process IMP_ADDR_POSTED_FIFO_CNTR; 
     
         
      
      
      
      
      
      
    ------- First/Middle/Last Dbeat detirmination -------------------
     
     sig_new_len_eq_0 <= '1'
       When  (sig_fifo_next_len = LEN_OF_ZERO)
       else '0';
     
     
      
      
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: DO_FIRST_MID_LAST
     --
     -- Process Description:
     --  Implements the detection of the First/Mid/Last databeat of
     -- a transfer.
     --
     -------------------------------------------------------------
     DO_FIRST_MID_LAST : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (mmap_reset = '1') then
               
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '0';
             
             elsif (sig_ld_new_cmd = '1') then
               
               sig_first_dbeat   <= not(sig_new_len_eq_0);
               sig_last_dbeat    <= sig_new_len_eq_0;
             
             Elsif (sig_dbeat_cntr_eq_1 = '1' and
                    sig_good_mmap_dbeat = '1') Then
             
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '1';
             
             Elsif (sig_dbeat_cntr_eq_0 = '0' and
                    sig_dbeat_cntr_eq_1 = '0' and
                    sig_good_mmap_dbeat = '1') Then
             
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '0';
             
             else
               null; -- hols current state
             end if; 
          end if;       
        end process DO_FIRST_MID_LAST; 
    
    
   
   
   
   -------  Data Controller Halted Indication ------------------------------- 
    
 
    data2all_dcntlr_halted <= sig_no_posted_cmds  and
                              (sig_calc_error_reg or
                               rst2data_stop_request);
 
 
    
    
   -------  Data Beat counter logic ------------------------------- 
    sig_dbeat_cntr_int  <= TO_INTEGER(sig_dbeat_cntr);
    
    sig_dbeat_cntr_eq_0 <= '1'
      when (sig_dbeat_cntr_int = 0)
      Else '0';
    
    sig_dbeat_cntr_eq_1 <= '1'
      when (sig_dbeat_cntr_int = 1)
      Else '0';
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: DO_DBEAT_CNTR
    --
    -- Process Description:
    --
    --
    -------------------------------------------------------------
    DO_DBEAT_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              sig_dbeat_cntr <= (others => '0');
            elsif (sig_ld_new_cmd = '1') then
              sig_dbeat_cntr <= unsigned(sig_fifo_next_len);
            Elsif (sig_good_mmap_dbeat = '1' and
                   sig_dbeat_cntr_eq_0 = '0') Then
              sig_dbeat_cntr <= sig_dbeat_cntr-1;
            else
              null; -- Hold current state
            end if; 
         end if;       
       end process DO_DBEAT_CNTR; 
      
  
 
 
  
  
   ------  Read Response Status Logic  ------------------------------
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: LD_NEW_CMD_PULSE
   --
   -- Process Description:
   -- Generate a 1 Clock wide pulse when a new command has been
   -- loaded into the Command Register
   --
   -------------------------------------------------------------
   LD_NEW_CMD_PULSE : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset         = '1' or
               sig_ld_new_cmd_reg = '1') then
             sig_ld_new_cmd_reg <= '0';
           elsif (sig_ld_new_cmd = '1') then
             sig_ld_new_cmd_reg <= '1';
           else
             null; -- hold State
           end if; 
        end if;       
      end process LD_NEW_CMD_PULSE; 
  
                               
                               
   sig_pop_coelsc_reg  <= sig_coelsc_reg_full and
                          sig_rsc2data_ready ; 
                          
   sig_push_coelsc_reg <= (sig_good_mmap_dbeat and  
                           not(sig_coelsc_reg_full)) or
                          (sig_ld_new_cmd_reg and 
                           sig_calc_error_reg) ; 
   
   sig_cmd_cmplt_last_dbeat <= (sig_cmd_cmplt_reg and sig_mmap2data_last) or
                                sig_calc_error_reg;
   
   
      
  -------  Read Response Decode   
    
   -- Decode the AXI MMap Read Response       
   sig_decerr  <= '1'
     When (mm2s_rresp = DECERR and mm2s_rvalid = '1')
     Else '0'; 
          
   sig_slverr  <= '1'
     When (mm2s_rresp = SLVERR and mm2s_rvalid = '1')
     Else '0';      
   
   
   
          
          
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: RD_RESP_COELESC_REG
    --
    -- Process Description:
    --   Implement the Read error/status coelescing register. 
    -- Once a bit is set it will remain set until the overall 
    -- status is written to the Status Controller. 
    -- Tag bits are just registered at each valid dbeat.
    --
    -------------------------------------------------------------
    STATUS_COELESC_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset          = '1' or
               (sig_pop_coelsc_reg  = '1' and        -- Added more qualification here for simultaneus
                sig_push_coelsc_reg = '0')) then     -- push and pop condition per CR590244
                                                                                                
              sig_coelsc_tag_reg       <= (others => '0');
              sig_coelsc_cmd_cmplt_reg <= '0';
              sig_coelsc_interr_reg    <= '0';
              sig_coelsc_decerr_reg    <= '0';
              sig_coelsc_slverr_reg    <= '0';
              sig_coelsc_okay_reg      <= '1';       -- set back to default of "OKAY"
  
              sig_coelsc_reg_full      <= '0';
              sig_coelsc_reg_empty     <= '1';
  
  
              
            Elsif (sig_push_coelsc_reg = '1') Then
            
              sig_coelsc_tag_reg       <= sig_tag_reg;                             
              sig_coelsc_cmd_cmplt_reg <= sig_cmd_cmplt_last_dbeat;                  
              sig_coelsc_interr_reg    <= sig_calc_error_reg or 
                                          sig_coelsc_interr_reg;
              sig_coelsc_decerr_reg    <= sig_decerr or sig_coelsc_decerr_reg;
              sig_coelsc_slverr_reg    <= sig_slverr or sig_coelsc_slverr_reg;
              sig_coelsc_okay_reg      <= not(sig_decerr       or 
                                              sig_slverr       or 
                                              sig_calc_error_reg );
              
              sig_coelsc_reg_full      <= sig_cmd_cmplt_last_dbeat;
              sig_coelsc_reg_empty     <= not(sig_cmd_cmplt_last_dbeat);
                                            
              
            else
              
              null;  -- hold current state
              
            end if; 
         end if;       
       end process STATUS_COELESC_REG; 
   
   
   
   
   
   
   
   
   
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_DRE
    --
    -- If Generate Description:
    --  Ties off DRE Control signals to logic low when DRE is
    -- omitted from the MM2S functionality.
    --
    --
    ------------------------------------------------------------
    GEN_NO_DRE : if (C_INCLUDE_DRE = 0) generate
    
       begin
    
         mm2s_dre_new_align     <= '0';
         mm2s_dre_use_autodest  <= '0';
         mm2s_dre_src_align     <= (others => '0');
         mm2s_dre_dest_align    <= (others => '0');
         mm2s_dre_flush         <= '0';
        
       end generate GEN_NO_DRE;
   
    
    
    
    
    
    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_DRE_CNTLS
    --
    -- If Generate Description:
    -- Implements the DRE Control logic when MM2S DRE is enabled.
    --
    --  - The DRE needs to have forced alignment at a SOF assertion
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_DRE_CNTLS : if (C_INCLUDE_DRE = 1) generate
    
       -- local signals
       signal lsig_s_h_dre_autodest  : std_logic := '0';
       signal lsig_s_h_dre_new_align : std_logic := '0';
    
       begin
    
        
         mm2s_dre_new_align     <= lsig_s_h_dre_new_align;
         
         
         
         
         -- Autodest is asserted on a new parent command and the 
         -- previous parent command was not delimited with a EOF
         mm2s_dre_use_autodest  <= lsig_s_h_dre_autodest;
         
         
         
         
         -- Assign the DRE Source and Destination Alignments
         -- Only used when mm2s_dre_new_align is asserted 
         mm2s_dre_src_align     <= sig_next_dre_src_align_reg ;
         mm2s_dre_dest_align    <= sig_next_dre_dest_align_reg;
         
         
         -- Assert the Flush flag when the MMap Tlast input of the current transfer is
         -- asserted and the next transfer is not sequential and not the last 
         -- transfer of a packet.
         mm2s_dre_flush         <= mm2s_rlast and
                                   not(sig_next_sequential_reg) and   
                                   not(sig_next_eof_reg);
        
        
        
         
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_S_H_NEW_ALIGN
         --
         -- Process Description:
         --   Generates the new alignment command flag to the DRE.
         --
         -------------------------------------------------------------
         IMP_S_H_NEW_ALIGN : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset   = '1') then
                   
                   lsig_s_h_dre_new_align <= '0';
                 
                 
                 Elsif (sig_push_dqual_reg = '1' and
                        sig_fifo_next_drr  = '1') Then
                 
                   lsig_s_h_dre_new_align <= '1';
                 
                 elsif (sig_pop_dqual_reg = '1') then
                   
                   lsig_s_h_dre_new_align <=  sig_next_cmd_cmplt_reg and
                                             not(sig_next_sequential_reg) and
                                             not(sig_next_eof_reg);
                 
                 Elsif (sig_good_mmap_dbeat = '1') Then
                 
                   lsig_s_h_dre_new_align <= '0';
                 
                 
                 else
                   
                   null; -- hold current state
                 
                 end if; 
              end if;       
            end process IMP_S_H_NEW_ALIGN; 
        
        
        
         
         
        
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_S_H_AUTODEST
         --
         -- Process Description:
         --   Generates the control for the DRE indicating whether the
         -- DRE destination alignment should be derived from the write
         -- strobe stat of the last completed data-beat to the AXI 
         -- stream output.
         --
         -------------------------------------------------------------
         IMP_S_H_AUTODEST : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset   = '1') then
                   
                   lsig_s_h_dre_autodest <= '0';
                 
                 
                 Elsif (sig_push_dqual_reg = '1' and
                        sig_fifo_next_drr  = '1') Then
                   
                   lsig_s_h_dre_autodest <= '0';
                 
                 elsif (sig_pop_dqual_reg = '1') then
                   
                   lsig_s_h_dre_autodest <=  sig_next_cmd_cmplt_reg and
                                             not(sig_next_sequential_reg) and
                                             not(sig_next_eof_reg);
                 
                 Elsif (lsig_s_h_dre_new_align = '1' and
                        sig_good_mmap_dbeat    = '1') Then
                 
                   lsig_s_h_dre_autodest <= '0';
                 
                 
                 else
                   
                   null; -- hold current state
                 
                 end if; 
              end if;       
            end process IMP_S_H_AUTODEST; 
        
        
        
        
       end generate GEN_INCLUDE_DRE_CNTLS;
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   -------  Soft Shutdown Logic ------------------------------- 
    
    
    -- Assign the output port skid buf control
    data2skid_halt      <= sig_data2skid_halt;
    
    -- Create a 1 clock wide pulse to tell the output
    -- stream skid buffer to shut down its outputs
    sig_data2skid_halt  <=  sig_halt_reg_dly2 and 
                            not(sig_halt_reg_dly3);
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG
    --
    -- Process Description:
    --   Implements the flop for capturing the Halt request from 
    -- the Reset module.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg      <= '0';
            
            elsif (rst2data_stop_request = '1') then
              
              sig_halt_reg <= '1';
            
            else
              null;  -- Hold current State
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG; 
  
  
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG_DLY
    --
    -- Process Description:
    --   Implements the flops for delaying the halt request by 3
    -- clocks to allow the Address Controller to halt before the
    -- Data Contoller can safely indicate it has exhausted all
    -- transfers committed to the AXI Address Channel by the Address
    -- Controller.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG_DLY : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg_dly1 <= '0';
              sig_halt_reg_dly2 <= '0';
              sig_halt_reg_dly3 <= '0';
            
            else
              
              sig_halt_reg_dly1 <= sig_halt_reg;
              sig_halt_reg_dly2 <= sig_halt_reg_dly1;
              sig_halt_reg_dly3 <= sig_halt_reg_dly2;
            
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG_DLY; 
  
  
   
   
   
   
   
   
   
   
   
   
      
      
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_rd_status_cntl.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_rd_status_cntl.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Read Status Controller.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_rd_status_cntl is
    generic (
      
      C_STS_WIDTH          : Integer               := 8;
        -- sets the width of the Status ports
      
      C_TAG_WIDTH          : Integer range  1 to 8 := 4
        -- Sets the width of the Tag field in the Status reply
      
      );
    port (
      
      -- Clock and Reset input --------------------------------------
                                                                   --
      primary_aclk           : in  std_logic;                      --
         -- Primary synchronization clock for the Master side      --
         -- interface and internal logic. It is also used          --
         -- for the User interface synchronization when            --
         -- C_STSCMD_IS_ASYNC = 0.                                 --
                                                                   --
      -- Reset input                                               --
      mmap_reset             : in  std_logic;                      --
         -- Reset used for the internal master logic               --
      ---------------------------------------------------------------
      
      
      
                
                
      -- Command Calculator Status Interface  ---------------------------
                                                                       --
      calc2rsc_calc_error    : in std_logic ;                          --
         -- Indication from the Command Calculator that a calculation  --
         -- error has occured.                                         --
      -------------------------------------------------------------------
     
     
     
      
        
      -- Address Controller Status Interface ----------------------------
                                                                       --
      addr2rsc_calc_error    : In std_logic ;                          --
         -- Indication from the Data Channel Controller FIFO that it   --
         -- is empty (no commands pending)                             --
                                                                       --
      addr2rsc_fifo_empty    : In std_logic ;                          --
         -- Indication from the Address Controller FIFO that it        --
         -- is empty (no commands pending)                             --
      -------------------------------------------------------------------

                    
                    
                    
      --  Data Controller Status Interface ---------------------------------------------
                                                                                      --
      data2rsc_tag           : In std_logic_vector(C_TAG_WIDTH-1 downto 0);           --
         -- The command tag                                                           --
                                                                                      --
      data2rsc_calc_error    : In std_logic ;                                         --
         -- Indication from the Data Channel Controller FIFO that it                  --
         -- is empty (no commands pending)                                            --
                                                                                      --
      data2rsc_okay          : In std_logic ;                                         --
         -- Indication that the AXI Read transfer completed with OK status            --
                                                                                      --
      data2rsc_decerr        : In std_logic ;                                         --
         -- Indication that the AXI Read transfer completed with decode error status  --
                                                                                      --
      data2rsc_slverr        : In std_logic ;                                         --
         -- Indication that the AXI Read transfer completed with slave error status   --
                                                                                      --
      data2rsc_cmd_cmplt     : In std_logic ;                                         --
         -- Indication by the Data Channel Controller that the                        --
         -- corresponding status is the last status for a parent command              --
         -- pulled from the command FIFO                                              --
                                                                                      --
      rsc2data_ready         : Out  std_logic;                                        --
         -- Handshake bit from the Read Status Controller Module indicating           --
         -- that the it is ready to accept a new Read status transfer                 --
                                                                                      --
      data2rsc_valid         : in  std_logic ;                                        --
         -- Handshake bit output to the Read Status Controller Module                 --
         -- indicating that the Data Controller has valid tag and status              --
         -- indicators to transfer                                                    --
      ----------------------------------------------------------------------------------


      
      -- Command/Status Module Interface ----------------------------------------------
                                                                                     --
      rsc2stat_status        : Out std_logic_vector(C_STS_WIDTH-1 downto 0);         --
         -- Read Status value collected during a Read Data transfer                  --
         -- Output to the Command/Status Module                                      --
                                                                                     --
      stat2rsc_status_ready  : In  std_logic;                                        --
         -- Input from the Command/Status Module indicating that the                 --
         -- Status Reg/FIFO is ready to accept a transfer                            --
                                                                                     --
      rsc2stat_status_valid  : Out std_logic ;                                       --
         -- Control Signal to the Status Reg/FIFO indicating a new status            --
         -- output value is valid and ready for transfer                             --
      ---------------------------------------------------------------------------------

  
    
    
      -- Address and Data Controller Pipe halt ----------------------------------
                                                                               --
      rsc2mstr_halt_pipe     : Out std_logic                                   --
         -- Indication to Halt the Data and Address Command pipeline due       --
         -- to the Status FIFO going full or an internal error being logged    --
      ---------------------------------------------------------------------------

  
      );
  
  end entity axi_datamover_rd_status_cntl;
  
  
  architecture implementation of axi_datamover_rd_status_cntl is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    -- Constant Declarations  --------------------------------------------
    
    Constant OKAY               : std_logic_vector(1 downto 0) := "00";
    Constant EXOKAY             : std_logic_vector(1 downto 0) := "01";
    Constant SLVERR             : std_logic_vector(1 downto 0) := "10";
    Constant DECERR             : std_logic_vector(1 downto 0) := "11";
    Constant STAT_RSVD          : std_logic_vector(3 downto 0) := "0000";
    Constant TAG_WIDTH          : integer := C_TAG_WIDTH;
    Constant STAT_REG_TAG_WIDTH : integer := 4;
    
    
    -- Signal Declarations  --------------------------------------------
    
    signal sig_tag2status            : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_rsc2status_valid      : std_logic := '0';
    signal sig_rsc2data_ready        : std_logic := '0';
    signal sig_rd_sts_okay_reg       : std_logic := '0';
    signal sig_rd_sts_interr_reg     : std_logic := '0';
    signal sig_rd_sts_decerr_reg     : std_logic := '0';
    signal sig_rd_sts_slverr_reg     : std_logic := '0';
    signal sig_rd_sts_tag_reg        : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_pop_rd_sts_reg        : std_logic := '0';
    signal sig_push_rd_sts_reg       : std_logic := '0';
    Signal sig_rd_sts_push_ok        : std_logic := '0';
    signal sig_rd_sts_reg_empty      : std_logic := '0';
    signal sig_rd_sts_reg_full       : std_logic := '0';
    
    
    
    
    
            
  begin --(architecture implementation)
  
    -- Assign the status write output control
    rsc2stat_status_valid  <= sig_rsc2status_valid ;
    
    sig_rsc2status_valid   <= sig_rd_sts_reg_full;
    
                                           
    -- Formulate the status outout value (assumes an 8-bit status width)
    rsc2stat_status        <=  sig_rd_sts_okay_reg    &   
                               sig_rd_sts_slverr_reg  &
                               sig_rd_sts_decerr_reg  & 
                               sig_rd_sts_interr_reg  &
                               sig_tag2status;
    
    -- Detect that a push of a new status word is completing
    sig_rd_sts_push_ok   <= sig_rsc2status_valid and 
                            stat2rsc_status_ready;
    
    -- Signal a halt to the execution pipe if new status
    -- is valid but the Status FIFO is not accepting it
    rsc2mstr_halt_pipe   <=  sig_rsc2status_valid and
                             (not(stat2rsc_status_ready) ); 
   
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_TAG_LE_STAT
    --
    -- If Generate Description:
    -- Populates the TAG bits into the availble Status bits when
    -- the TAG width is less than or equal to the available number
    -- of bits in the Status word. 
    --
    ------------------------------------------------------------
    GEN_TAG_LE_STAT : if (TAG_WIDTH <= STAT_REG_TAG_WIDTH) generate
    
       -- local signals
         signal lsig_temp_tag_small : std_logic_vector(STAT_REG_TAG_WIDTH-1 downto 0) := (others => '0');
         
         
       begin
    
         sig_tag2status <= lsig_temp_tag_small;
         
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: POPULATE_SMALL_TAG
         --
         -- Process Description:
         --
         --
         -------------------------------------------------------------
         POPULATE_SMALL_TAG : process (sig_rd_sts_tag_reg)
            begin
         
              -- Set default value
              lsig_temp_tag_small <= (others => '0');
          
              -- Now overload actual TAG bits
              lsig_temp_tag_small(TAG_WIDTH-1 downto 0) <= sig_rd_sts_tag_reg;
          
         
            end process POPULATE_SMALL_TAG; 
         
         
       end generate GEN_TAG_LE_STAT;
     
     
     
     
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_TAG_GT_STAT
    --
    -- If Generate Description:
    -- Populates the TAG bits into the availble Status bits when
    -- the TAG width is greater than the available number of 
    -- bits in the Status word. The upper bits of the TAG are 
    -- clipped off (discarded). 
    --
    ------------------------------------------------------------
    GEN_TAG_GT_STAT : if (TAG_WIDTH > STAT_REG_TAG_WIDTH) generate
    
       -- local signals
         signal lsig_temp_tag_big : std_logic_vector(STAT_REG_TAG_WIDTH-1 downto 0);
         
         
       begin
    
         
         sig_tag2status <= lsig_temp_tag_big;
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: POPULATE_BIG_TAG
         --
         -- Process Description:
         --
         --
         -------------------------------------------------------------
         POPULATE_SMALL_TAG : process (sig_rd_sts_tag_reg)
            begin
         
              -- Set default value
              lsig_temp_tag_big <= (others => '0');
          
              -- Now overload actual TAG bits
              lsig_temp_tag_big <= sig_rd_sts_tag_reg(STAT_REG_TAG_WIDTH-1 downto 0);
          
         
            end process POPULATE_SMALL_TAG; 
         
         
       end generate GEN_TAG_GT_STAT;
     
     
     
     
     
          
   ------- Read Status Collection Logic --------------------------------       
    
    rsc2data_ready      <=  sig_rsc2data_ready ;
    
    sig_rsc2data_ready  <= sig_rd_sts_reg_empty;
    
    
    sig_push_rd_sts_reg <= data2rsc_valid and
                           sig_rsc2data_ready;
          
    sig_pop_rd_sts_reg  <= sig_rd_sts_push_ok;
    
    
          
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: RD_STATUS_FIFO_REG
    --
    -- Process Description:
    --   Implement Read status FIFO register. 
    -- This register holds the Read status from the Data Controller
    -- until it is transfered to the Status FIFO.
    --
    -------------------------------------------------------------
    RD_STATUS_FIFO_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1' or
                sig_pop_rd_sts_reg = '1') then
              
              sig_rd_sts_tag_reg       <= (others => '0');
              sig_rd_sts_interr_reg    <= '0';
              sig_rd_sts_decerr_reg    <= '0';
              sig_rd_sts_slverr_reg    <= '0';
              sig_rd_sts_okay_reg      <= '1'; -- set back to default of "OKAY"
  
              sig_rd_sts_reg_full      <= '0';
              sig_rd_sts_reg_empty     <= '1';
  
  
              
            Elsif (sig_push_rd_sts_reg = '1') Then
            
              sig_rd_sts_tag_reg       <= data2rsc_tag;                             
              sig_rd_sts_interr_reg    <= data2rsc_calc_error or 
                                          sig_rd_sts_interr_reg;
              sig_rd_sts_decerr_reg    <= data2rsc_decerr or sig_rd_sts_decerr_reg;
              sig_rd_sts_slverr_reg    <= data2rsc_slverr or sig_rd_sts_slverr_reg;
              sig_rd_sts_okay_reg      <= data2rsc_okay and 
                                          not(data2rsc_decerr          or 
                                              sig_rd_sts_decerr_reg    or
                                              data2rsc_slverr          or 
                                              sig_rd_sts_slverr_reg    or
                                              data2rsc_calc_error      or
                                              sig_rd_sts_interr_reg      
                                              );
              
              sig_rd_sts_reg_full      <= data2rsc_cmd_cmplt or
                                          data2rsc_calc_error;
              sig_rd_sts_reg_empty     <= not(data2rsc_cmd_cmplt or
                                              data2rsc_calc_error);
                                            
            else
              
              null;  -- hold current state
              
            end if; 
         end if;       
       end process RD_STATUS_FIFO_REG; 
      
    
    
    
    
          
          
          
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_wr_demux.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_wr_demux.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Write Strobe De-Multiplexer.                 
  --  This is needed when the native data width of the DataMover is narrower 
  --  than the AXI4 Write Data Channel.                
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_wr_demux is
    generic (
      
      C_SEL_ADDR_WIDTH     : Integer range  1  to  8 :=  5;
        -- Sets the width of the select control bus
      
      C_MMAP_DWIDTH        : Integer range 32 to 1024 := 32;
        -- Indicates the width of the AXI4 Write Data Channel
      
      C_STREAM_DWIDTH      : Integer range  8 to 1024 := 32
        -- Indicates the native data width of the DataMover S2MM. If 
        -- S2MM Store and Forward with upsizer is enabled, the width is 
        -- the AXi4 Write Data Channel, else it is the S2MM Stream data width.
      
      );
    port (
      
     
      -- AXI MMap Data Channel Input  --------------------------------------------
                                                                                --
      wstrb_in         : In  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);  --
        -- data input                                                           --
      ----------------------------------------------------------------------------
     
      
      
      -- AXI Master Stream  ------------------------------------------------------
                                                                                --
      demux_wstrb_out    : Out std_logic_vector((C_MMAP_DWIDTH/8)-1 downto 0);  --       
        --De-Mux strb output                                                    --
      ----------------------------------------------------------------------------
               
                
                
      -- Command Calculator Interface --------------------------------------------
                                                                                --
      debeat_saddr_lsb : In std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0)       --
         -- The next command start address LSbs to use for the read data        --
         -- mux (only used if Stream data width is less than the MMap Data      --
         -- Width).                                                             --
      ----------------------------------------------------------------------------
      
         
      );
  
  end entity axi_datamover_wr_demux;
  
  
  architecture implementation of axi_datamover_wr_demux is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function Decalarations -------------------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_mux_sel_width
    --
    -- Function Description:
    --   Calculates the number of needed bits for the Mux Select control
    -- based on the number of input channels to the mux.
    --
    -- Note that the number of input mux channels are always a 
    -- power of 2.
    --
    -------------------------------------------------------------------
    function func_mux_sel_width (num_channels : integer) return integer is
    
     Variable var_sel_width : integer := 0;
    
    begin
    
       case num_channels is
         --when 2 =>
         --    var_sel_width := 1;
         when 4 =>
             var_sel_width := 2;
         when 8 =>
             var_sel_width := 3;
         when 16 =>
             var_sel_width := 4;
         when 32 =>
             var_sel_width := 5;
         when 64 =>
             var_sel_width := 6;
         when 128 =>
             var_sel_width := 7;
         when others =>
             var_sel_width := 1; 
       end case;
       
       Return (var_sel_width);
        
        
    end function func_mux_sel_width;
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_sel_ls_index
    --
    -- Function Description:
    --   Calculates the LS index of the select field to rip from the
    -- input select bus.
    --
    -- Note that the number of input mux channels are always a 
    -- power of 2.
    --
    -------------------------------------------------------------------
    function func_sel_ls_index (stream_width : integer) return integer is
    
     Variable var_sel_ls_index : integer := 0;
    
    begin
    
       case stream_width is
         when 8 =>
             var_sel_ls_index := 0;
         when 16 =>
             var_sel_ls_index := 1;
         when 32 =>
             var_sel_ls_index := 2;
         when 64 =>
             var_sel_ls_index := 3;
         when 128 =>
             var_sel_ls_index := 4;
         when 256 =>
             var_sel_ls_index := 5;
         when 512 =>
             var_sel_ls_index := 6;
         when others =>  -- assume 1024 bit width
             var_sel_ls_index := 7;
       end case;
       
       Return (var_sel_ls_index);
        
        
    end function func_sel_ls_index;
    
    
    
    
    
    -- Constant Decalarations -------------------------------------------------
    
    Constant OMIT_DEMUX    : boolean := (C_STREAM_DWIDTH = C_MMAP_DWIDTH);
    Constant INCLUDE_DEMUX : boolean := not(OMIT_DEMUX);
    
    
    
    
    Constant STREAM_WSTB_WIDTH   : integer := C_STREAM_DWIDTH/8;
    Constant MMAP_WSTB_WIDTH     : integer := C_MMAP_DWIDTH/8;
    Constant NUM_MUX_CHANNELS    : integer := MMAP_WSTB_WIDTH/STREAM_WSTB_WIDTH;
    Constant MUX_SEL_WIDTH       : integer := func_mux_sel_width(NUM_MUX_CHANNELS);
    Constant MUX_SEL_LS_INDEX    : integer := func_sel_ls_index(C_STREAM_DWIDTH);
    
    
    -- Signal Declarations  --------------------------------------------
 
    signal sig_demux_wstrb_out   : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');



    
  begin --(architecture implementation)
  
  
  
  
   -- Assign the Output data port 
    demux_wstrb_out        <= sig_demux_wstrb_out;
  


    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_STRM_EQ_MMAP
    --
    -- If Generate Description:
    --   This IfGen implements the case where the Stream Data Width is 
    -- the same as the Memeory Map read Data width.
    --
    --
    ------------------------------------------------------------
    GEN_STRM_EQ_MMAP : if (OMIT_DEMUX) generate
        
       begin
        
          sig_demux_wstrb_out <= wstrb_in;
        
        
       end generate GEN_STRM_EQ_MMAP;
   
   
    
    
    
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_2XN
    --
    -- If Generate Description:
    --  2 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_2XN : if (INCLUDE_DEMUX and 
                  NUM_MUX_CHANNELS = 2) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);  -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                     -- with locally static subtype error in each of the
                                                                     -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_2XN_DEMUX
         --
         -- Process Description:
         --  Implement the 2XN DeMux
         --
         -------------------------------------------------------------
         DO_2XN_DEMUX : process (lsig_demux_sel_int_local,
                                  wstrb_in)
            begin
              
              -- Set default value
              lsig_demux_wstrb_out <=  (others => '0');
              
              case lsig_demux_sel_int_local is
                when 0 =>
                    lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
                
                when others => -- 1 case
                    lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1) <=  wstrb_in;
              end case;
              
            end process DO_2XN_DEMUX; 
 
         
       end generate GEN_2XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_4XN
    --
    -- If Generate Description:
    --  4 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_4XN : if (INCLUDE_DEMUX and 
                  NUM_MUX_CHANNELS = 4) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);  -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                 -- with locally static subtype error in each of the
                                                                 -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_4XN_DEMUX
         --
         -- Process Description:
         --  Implement the 4XN DeMux
         --
         -------------------------------------------------------------
         DO_4XN_DEMUX : process (lsig_demux_sel_int_local,
                                 wstrb_in)
           begin
              
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1) <=  wstrb_in;
               when 2 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2) <=  wstrb_in;
               
               when others =>  -- 3 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3) <=  wstrb_in;
             end case;
             
           end process DO_4XN_DEMUX; 
  
         
       end generate GEN_4XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_8XN
    --
    -- If Generate Description:
    --  8 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_8XN : if (INCLUDE_DEMUX and 
                  NUM_MUX_CHANNELS = 8) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);    -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                     -- with locally static subtype error in each of the
                                                                     -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_8XN_DEMUX
         --
         -- Process Description:
         --  Implement the 8XN DeMux
         --
         -------------------------------------------------------------
         DO_8XN_DEMUX : process (lsig_demux_sel_int_local,
                                 wstrb_in)
           begin
             
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1) <=  wstrb_in;
               when 2 =>                                                             
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2) <=  wstrb_in;
               when 3 =>                                                             
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3) <=  wstrb_in;
               when 4 =>                                                             
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*5)-1 downto STREAM_WSTB_WIDTH*4) <=  wstrb_in;
               when 5 =>                                                             
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*6)-1 downto STREAM_WSTB_WIDTH*5) <=  wstrb_in;
               when 6 =>                                                             
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*7)-1 downto STREAM_WSTB_WIDTH*6) <=  wstrb_in;
               
               when others => -- 7 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*8)-1 downto STREAM_WSTB_WIDTH*7) <=  wstrb_in;
             end case;
                 
           end process DO_8XN_DEMUX; 
 
         
       end generate GEN_8XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_16XN
    --
    -- If Generate Description:
    --  16 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_16XN : if (INCLUDE_DEMUX and 
                   NUM_MUX_CHANNELS = 16) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);  -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                 -- with locally static subtype error in each of the
                                                                 -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_16XN_DEMUX
         --
         -- Process Description:
         --  Implement the 16XN DeMux
         --
         -------------------------------------------------------------
         DO_16XN_DEMUX : process (lsig_demux_sel_int_local,
                                  wstrb_in)
           begin
             
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1)   <=  wstrb_in;
               when 2 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2)   <=  wstrb_in;
               when 3 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3)   <=  wstrb_in;
               when 4 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*5)-1 downto STREAM_WSTB_WIDTH*4)   <=  wstrb_in;
               when 5 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*6)-1 downto STREAM_WSTB_WIDTH*5)   <=  wstrb_in;
               when 6 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*7)-1 downto STREAM_WSTB_WIDTH*6)   <=  wstrb_in;
               when 7 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*8)-1 downto STREAM_WSTB_WIDTH*7)   <=  wstrb_in;
               when 8 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*9)-1 downto STREAM_WSTB_WIDTH*8)   <=  wstrb_in;
               when 9 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*10)-1 downto STREAM_WSTB_WIDTH*9)  <=  wstrb_in;
               when 10 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*11)-1 downto STREAM_WSTB_WIDTH*10) <=  wstrb_in;
               when 11 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*12)-1 downto STREAM_WSTB_WIDTH*11) <=  wstrb_in;
               when 12 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*13)-1 downto STREAM_WSTB_WIDTH*12) <=  wstrb_in;
               when 13 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*14)-1 downto STREAM_WSTB_WIDTH*13) <=  wstrb_in;
               when 14 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*15)-1 downto STREAM_WSTB_WIDTH*14) <=  wstrb_in;
               
               when others => -- 15 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*16)-1 downto STREAM_WSTB_WIDTH*15) <=  wstrb_in;
             end case;
          
           end process DO_16XN_DEMUX; 
 
         
       end generate GEN_16XN;
  
 
 
 
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_32XN
    --
    -- If Generate Description:
    --  32 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_32XN : if (INCLUDE_DEMUX and 
                   NUM_MUX_CHANNELS = 32) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);  -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                 -- with locally static subtype error in each of the
                                                                 -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_32XN_DEMUX
         --
         -- Process Description:
         --  Implement the 32XN DeMux
         --
         -------------------------------------------------------------
         DO_32XN_DEMUX : process (lsig_demux_sel_int_local,
                                  wstrb_in)
           begin
             
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1)   <=  wstrb_in;
               when 2 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2)   <=  wstrb_in;
               when 3 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3)   <=  wstrb_in;
               when 4 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*5)-1 downto STREAM_WSTB_WIDTH*4)   <=  wstrb_in;
               when 5 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*6)-1 downto STREAM_WSTB_WIDTH*5)   <=  wstrb_in;
               when 6 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*7)-1 downto STREAM_WSTB_WIDTH*6)   <=  wstrb_in;
               when 7 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*8)-1 downto STREAM_WSTB_WIDTH*7)   <=  wstrb_in;
               when 8 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*9)-1 downto STREAM_WSTB_WIDTH*8)   <=  wstrb_in;
               when 9 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*10)-1 downto STREAM_WSTB_WIDTH*9)  <=  wstrb_in;
               when 10 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*11)-1 downto STREAM_WSTB_WIDTH*10) <=  wstrb_in;
               when 11 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*12)-1 downto STREAM_WSTB_WIDTH*11) <=  wstrb_in;
               when 12 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*13)-1 downto STREAM_WSTB_WIDTH*12) <=  wstrb_in;
               when 13 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*14)-1 downto STREAM_WSTB_WIDTH*13) <=  wstrb_in;
               when 14 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*15)-1 downto STREAM_WSTB_WIDTH*14) <=  wstrb_in;
               when 15 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*16)-1 downto STREAM_WSTB_WIDTH*15) <=  wstrb_in;
               when 16 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*17)-1 downto STREAM_WSTB_WIDTH*16) <=  wstrb_in;
               when 17 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*18)-1 downto STREAM_WSTB_WIDTH*17) <=  wstrb_in;
               when 18 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*19)-1 downto STREAM_WSTB_WIDTH*18) <=  wstrb_in;
               when 19 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*20)-1 downto STREAM_WSTB_WIDTH*19) <=  wstrb_in;
               when 20 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*21)-1 downto STREAM_WSTB_WIDTH*20) <=  wstrb_in;
               when 21 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*22)-1 downto STREAM_WSTB_WIDTH*21) <=  wstrb_in;
               when 22 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*23)-1 downto STREAM_WSTB_WIDTH*22) <=  wstrb_in;
               when 23 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*24)-1 downto STREAM_WSTB_WIDTH*23) <=  wstrb_in;
               when 24 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*25)-1 downto STREAM_WSTB_WIDTH*24) <=  wstrb_in;
               when 25 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*26)-1 downto STREAM_WSTB_WIDTH*25) <=  wstrb_in;
               when 26 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*27)-1 downto STREAM_WSTB_WIDTH*26) <=  wstrb_in;
               when 27 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*28)-1 downto STREAM_WSTB_WIDTH*27) <=  wstrb_in;
               when 28 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*29)-1 downto STREAM_WSTB_WIDTH*28) <=  wstrb_in;
               when 29 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*30)-1 downto STREAM_WSTB_WIDTH*29) <=  wstrb_in;
               when 30 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*31)-1 downto STREAM_WSTB_WIDTH*30) <=  wstrb_in;
               
               when others => -- 31 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*32)-1 downto STREAM_WSTB_WIDTH*31) <=  wstrb_in;
             end case;
          
           end process DO_32XN_DEMUX; 
 
         
       end generate GEN_32XN;
  
 
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_64XN
    --
    -- If Generate Description:
    --  64 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_64XN : if (INCLUDE_DEMUX and 
                   NUM_MUX_CHANNELS = 64) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);  -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                 -- with locally static subtype error in each of the
                                                                 -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_64XN_DEMUX
         --
         -- Process Description:
         --  Implement the 32XN DeMux
         --
         -------------------------------------------------------------
         DO_64XN_DEMUX : process (lsig_demux_sel_int_local,
                                  wstrb_in)
           begin
             
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1)   <=  wstrb_in;
               when 2 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2)   <=  wstrb_in;
               when 3 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3)   <=  wstrb_in;
               when 4 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*5)-1 downto STREAM_WSTB_WIDTH*4)   <=  wstrb_in;
               when 5 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*6)-1 downto STREAM_WSTB_WIDTH*5)   <=  wstrb_in;
               when 6 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*7)-1 downto STREAM_WSTB_WIDTH*6)   <=  wstrb_in;
               when 7 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*8)-1 downto STREAM_WSTB_WIDTH*7)   <=  wstrb_in;
               when 8 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*9)-1 downto STREAM_WSTB_WIDTH*8)   <=  wstrb_in;
               when 9 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*10)-1 downto STREAM_WSTB_WIDTH*9)  <=  wstrb_in;
               when 10 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*11)-1 downto STREAM_WSTB_WIDTH*10) <=  wstrb_in;
               when 11 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*12)-1 downto STREAM_WSTB_WIDTH*11) <=  wstrb_in;
               when 12 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*13)-1 downto STREAM_WSTB_WIDTH*12) <=  wstrb_in;
               when 13 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*14)-1 downto STREAM_WSTB_WIDTH*13) <=  wstrb_in;
               when 14 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*15)-1 downto STREAM_WSTB_WIDTH*14) <=  wstrb_in;
               when 15 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*16)-1 downto STREAM_WSTB_WIDTH*15) <=  wstrb_in;
               when 16 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*17)-1 downto STREAM_WSTB_WIDTH*16) <=  wstrb_in;
               when 17 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*18)-1 downto STREAM_WSTB_WIDTH*17) <=  wstrb_in;
               when 18 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*19)-1 downto STREAM_WSTB_WIDTH*18) <=  wstrb_in;
               when 19 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*20)-1 downto STREAM_WSTB_WIDTH*19) <=  wstrb_in;
               when 20 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*21)-1 downto STREAM_WSTB_WIDTH*20) <=  wstrb_in;
               when 21 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*22)-1 downto STREAM_WSTB_WIDTH*21) <=  wstrb_in;
               when 22 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*23)-1 downto STREAM_WSTB_WIDTH*22) <=  wstrb_in;
               when 23 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*24)-1 downto STREAM_WSTB_WIDTH*23) <=  wstrb_in;
               when 24 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*25)-1 downto STREAM_WSTB_WIDTH*24) <=  wstrb_in;
               when 25 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*26)-1 downto STREAM_WSTB_WIDTH*25) <=  wstrb_in;
               when 26 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*27)-1 downto STREAM_WSTB_WIDTH*26) <=  wstrb_in;
               when 27 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*28)-1 downto STREAM_WSTB_WIDTH*27) <=  wstrb_in;
               when 28 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*29)-1 downto STREAM_WSTB_WIDTH*28) <=  wstrb_in;
               when 29 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*30)-1 downto STREAM_WSTB_WIDTH*29) <=  wstrb_in;
               when 30 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*31)-1 downto STREAM_WSTB_WIDTH*30) <=  wstrb_in;
               when 31 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*32)-1 downto STREAM_WSTB_WIDTH*31) <=  wstrb_in;
             
             
               when 32 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*33)-1 downto STREAM_WSTB_WIDTH*32) <=  wstrb_in;
               when 33 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*34)-1 downto STREAM_WSTB_WIDTH*33) <=  wstrb_in;
               when 34 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*35)-1 downto STREAM_WSTB_WIDTH*34) <=  wstrb_in;
               when 35 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*36)-1 downto STREAM_WSTB_WIDTH*35) <=  wstrb_in;
               when 36 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*37)-1 downto STREAM_WSTB_WIDTH*36) <=  wstrb_in;
               when 37 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*38)-1 downto STREAM_WSTB_WIDTH*37) <=  wstrb_in;
               when 38 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*39)-1 downto STREAM_WSTB_WIDTH*38) <=  wstrb_in;
               when 39 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*40)-1 downto STREAM_WSTB_WIDTH*39) <=  wstrb_in;
               when 40 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*41)-1 downto STREAM_WSTB_WIDTH*40) <=  wstrb_in;
               when 41 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*42)-1 downto STREAM_WSTB_WIDTH*41) <=  wstrb_in;
               when 42 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*43)-1 downto STREAM_WSTB_WIDTH*42) <=  wstrb_in;
               when 43 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*44)-1 downto STREAM_WSTB_WIDTH*43) <=  wstrb_in;
               when 44 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*45)-1 downto STREAM_WSTB_WIDTH*44) <=  wstrb_in;
               when 45 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*46)-1 downto STREAM_WSTB_WIDTH*45) <=  wstrb_in;
               when 46 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*47)-1 downto STREAM_WSTB_WIDTH*46) <=  wstrb_in;
               when 47 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*48)-1 downto STREAM_WSTB_WIDTH*47) <=  wstrb_in;
               when 48 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*49)-1 downto STREAM_WSTB_WIDTH*48) <=  wstrb_in;
               when 49 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*50)-1 downto STREAM_WSTB_WIDTH*49) <=  wstrb_in;
               when 50 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*51)-1 downto STREAM_WSTB_WIDTH*50) <=  wstrb_in;
               when 51 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*52)-1 downto STREAM_WSTB_WIDTH*51) <=  wstrb_in;
               when 52 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*53)-1 downto STREAM_WSTB_WIDTH*52) <=  wstrb_in;
               when 53 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*54)-1 downto STREAM_WSTB_WIDTH*53) <=  wstrb_in;
               when 54 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*55)-1 downto STREAM_WSTB_WIDTH*54) <=  wstrb_in;
               when 55 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*56)-1 downto STREAM_WSTB_WIDTH*55) <=  wstrb_in;
               when 56 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*57)-1 downto STREAM_WSTB_WIDTH*56) <=  wstrb_in;
               when 57 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*58)-1 downto STREAM_WSTB_WIDTH*57) <=  wstrb_in;
               when 58 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*59)-1 downto STREAM_WSTB_WIDTH*58) <=  wstrb_in;
               when 59 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*60)-1 downto STREAM_WSTB_WIDTH*59) <=  wstrb_in;
               when 60 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*61)-1 downto STREAM_WSTB_WIDTH*60) <=  wstrb_in;
               when 61 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*62)-1 downto STREAM_WSTB_WIDTH*61) <=  wstrb_in;
               when 62 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*63)-1 downto STREAM_WSTB_WIDTH*62) <=  wstrb_in;
               
               when others => -- 63 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*64)-1 downto STREAM_WSTB_WIDTH*63) <=  wstrb_in;
             
             
             end case;
          
           end process DO_64XN_DEMUX; 
 
         
       end generate GEN_64XN;
  
 
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_128XN
    --
    -- If Generate Description:
    --  128 channel demux case
    --
    --
    ------------------------------------------------------------
    GEN_128XN : if (INCLUDE_DEMUX and 
                    NUM_MUX_CHANNELS = 128) generate
    
       -- local signals
       signal sig_demux_sel_slice      : std_logic_vector(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_unsgnd     : unsigned(MUX_SEL_WIDTH-1 downto 0) := (others => '0');
       signal sig_demux_sel_int        : integer := 0;
       signal lsig_demux_sel_int_local : integer := 0;
       signal lsig_demux_wstrb_out     : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
       
       begin
    
         
        -- Rip the Mux Select bits needed for the Mux case from the input select bus
         sig_demux_sel_slice   <= debeat_saddr_lsb((MUX_SEL_LS_INDEX + MUX_SEL_WIDTH)-1 downto MUX_SEL_LS_INDEX);
        
         sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);    -- convert to unsigned
        
         sig_demux_sel_int     <=  TO_INTEGER(sig_demux_sel_unsgnd); -- convert to integer for MTI compile issue
                                                                     -- with locally static subtype error in each of the
                                                                     -- Mux IfGens
        
         lsig_demux_sel_int_local <= sig_demux_sel_int;
         
         sig_demux_wstrb_out      <= lsig_demux_wstrb_out;
       
          
          
          
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_128XN_DEMUX
         --
         -- Process Description:
         --  Implement the 32XN DeMux
         --
         -------------------------------------------------------------
         DO_128XN_DEMUX : process (lsig_demux_sel_int_local,
                                  wstrb_in)
           begin
             
             -- Set default value
             lsig_demux_wstrb_out <=  (others => '0');
              
             case lsig_demux_sel_int_local is
               
               when 0 =>
                   lsig_demux_wstrb_out(STREAM_WSTB_WIDTH-1 downto 0) <=  wstrb_in;
               when 1 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*2)-1 downto STREAM_WSTB_WIDTH*1)   <=  wstrb_in;
               when 2 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*3)-1 downto STREAM_WSTB_WIDTH*2)   <=  wstrb_in;
               when 3 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*4)-1 downto STREAM_WSTB_WIDTH*3)   <=  wstrb_in;
               when 4 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*5)-1 downto STREAM_WSTB_WIDTH*4)   <=  wstrb_in;
               when 5 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*6)-1 downto STREAM_WSTB_WIDTH*5)   <=  wstrb_in;
               when 6 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*7)-1 downto STREAM_WSTB_WIDTH*6)   <=  wstrb_in;
               when 7 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*8)-1 downto STREAM_WSTB_WIDTH*7)   <=  wstrb_in;
               when 8 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*9)-1 downto STREAM_WSTB_WIDTH*8)   <=  wstrb_in;
               when 9 =>                                                               
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*10)-1 downto STREAM_WSTB_WIDTH*9)  <=  wstrb_in;
               when 10 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*11)-1 downto STREAM_WSTB_WIDTH*10) <=  wstrb_in;
               when 11 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*12)-1 downto STREAM_WSTB_WIDTH*11) <=  wstrb_in;
               when 12 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*13)-1 downto STREAM_WSTB_WIDTH*12) <=  wstrb_in;
               when 13 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*14)-1 downto STREAM_WSTB_WIDTH*13) <=  wstrb_in;
               when 14 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*15)-1 downto STREAM_WSTB_WIDTH*14) <=  wstrb_in;
               when 15 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*16)-1 downto STREAM_WSTB_WIDTH*15) <=  wstrb_in;
               when 16 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*17)-1 downto STREAM_WSTB_WIDTH*16) <=  wstrb_in;
               when 17 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*18)-1 downto STREAM_WSTB_WIDTH*17) <=  wstrb_in;
               when 18 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*19)-1 downto STREAM_WSTB_WIDTH*18) <=  wstrb_in;
               when 19 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*20)-1 downto STREAM_WSTB_WIDTH*19) <=  wstrb_in;
               when 20 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*21)-1 downto STREAM_WSTB_WIDTH*20) <=  wstrb_in;
               when 21 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*22)-1 downto STREAM_WSTB_WIDTH*21) <=  wstrb_in;
               when 22 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*23)-1 downto STREAM_WSTB_WIDTH*22) <=  wstrb_in;
               when 23 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*24)-1 downto STREAM_WSTB_WIDTH*23) <=  wstrb_in;
               when 24 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*25)-1 downto STREAM_WSTB_WIDTH*24) <=  wstrb_in;
               when 25 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*26)-1 downto STREAM_WSTB_WIDTH*25) <=  wstrb_in;
               when 26 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*27)-1 downto STREAM_WSTB_WIDTH*26) <=  wstrb_in;
               when 27 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*28)-1 downto STREAM_WSTB_WIDTH*27) <=  wstrb_in;
               when 28 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*29)-1 downto STREAM_WSTB_WIDTH*28) <=  wstrb_in;
               when 29 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*30)-1 downto STREAM_WSTB_WIDTH*29) <=  wstrb_in;
               when 30 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*31)-1 downto STREAM_WSTB_WIDTH*30) <=  wstrb_in;
               when 31 =>                                                              
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*32)-1 downto STREAM_WSTB_WIDTH*31) <=  wstrb_in;
             
             
               when 32 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*33)-1 downto STREAM_WSTB_WIDTH*32) <=  wstrb_in;
               when 33 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*34)-1 downto STREAM_WSTB_WIDTH*33) <=  wstrb_in;
               when 34 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*35)-1 downto STREAM_WSTB_WIDTH*34) <=  wstrb_in;
               when 35 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*36)-1 downto STREAM_WSTB_WIDTH*35) <=  wstrb_in;
               when 36 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*37)-1 downto STREAM_WSTB_WIDTH*36) <=  wstrb_in;
               when 37 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*38)-1 downto STREAM_WSTB_WIDTH*37) <=  wstrb_in;
               when 38 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*39)-1 downto STREAM_WSTB_WIDTH*38) <=  wstrb_in;
               when 39 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*40)-1 downto STREAM_WSTB_WIDTH*39) <=  wstrb_in;
               when 40 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*41)-1 downto STREAM_WSTB_WIDTH*40) <=  wstrb_in;
               when 41 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*42)-1 downto STREAM_WSTB_WIDTH*41) <=  wstrb_in;
               when 42 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*43)-1 downto STREAM_WSTB_WIDTH*42) <=  wstrb_in;
               when 43 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*44)-1 downto STREAM_WSTB_WIDTH*43) <=  wstrb_in;
               when 44 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*45)-1 downto STREAM_WSTB_WIDTH*44) <=  wstrb_in;
               when 45 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*46)-1 downto STREAM_WSTB_WIDTH*45) <=  wstrb_in;
               when 46 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*47)-1 downto STREAM_WSTB_WIDTH*46) <=  wstrb_in;
               when 47 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*48)-1 downto STREAM_WSTB_WIDTH*47) <=  wstrb_in;
               when 48 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*49)-1 downto STREAM_WSTB_WIDTH*48) <=  wstrb_in;
               when 49 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*50)-1 downto STREAM_WSTB_WIDTH*49) <=  wstrb_in;
               when 50 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*51)-1 downto STREAM_WSTB_WIDTH*50) <=  wstrb_in;
               when 51 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*52)-1 downto STREAM_WSTB_WIDTH*51) <=  wstrb_in;
               when 52 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*53)-1 downto STREAM_WSTB_WIDTH*52) <=  wstrb_in;
               when 53 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*54)-1 downto STREAM_WSTB_WIDTH*53) <=  wstrb_in;
               when 54 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*55)-1 downto STREAM_WSTB_WIDTH*54) <=  wstrb_in;
               when 55 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*56)-1 downto STREAM_WSTB_WIDTH*55) <=  wstrb_in;
               when 56 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*57)-1 downto STREAM_WSTB_WIDTH*56) <=  wstrb_in;
               when 57 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*58)-1 downto STREAM_WSTB_WIDTH*57) <=  wstrb_in;
               when 58 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*59)-1 downto STREAM_WSTB_WIDTH*58) <=  wstrb_in;
               when 59 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*60)-1 downto STREAM_WSTB_WIDTH*59) <=  wstrb_in;
               when 60 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*61)-1 downto STREAM_WSTB_WIDTH*60) <=  wstrb_in;
               when 61 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*62)-1 downto STREAM_WSTB_WIDTH*61) <=  wstrb_in;
               when 62 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*63)-1 downto STREAM_WSTB_WIDTH*62) <=  wstrb_in;
               when 63 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*64)-1 downto STREAM_WSTB_WIDTH*63) <=  wstrb_in;
              
               
               when 64 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*65)-1 downto STREAM_WSTB_WIDTH*64) <=  wstrb_in;
               when 65 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*66)-1 downto STREAM_WSTB_WIDTH*65) <=  wstrb_in;
               when 66 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*67)-1 downto STREAM_WSTB_WIDTH*66) <=  wstrb_in;
               when 67 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*68)-1 downto STREAM_WSTB_WIDTH*67) <=  wstrb_in;
               when 68 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*69)-1 downto STREAM_WSTB_WIDTH*68) <=  wstrb_in;
               when 69 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*70)-1 downto STREAM_WSTB_WIDTH*69) <=  wstrb_in;
               when 70 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*71)-1 downto STREAM_WSTB_WIDTH*70) <=  wstrb_in;
               when 71 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*72)-1 downto STREAM_WSTB_WIDTH*71) <=  wstrb_in;
               when 72 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*73)-1 downto STREAM_WSTB_WIDTH*72) <=  wstrb_in;
               when 73 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*74)-1 downto STREAM_WSTB_WIDTH*73) <=  wstrb_in;
               when 74 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*75)-1 downto STREAM_WSTB_WIDTH*74) <=  wstrb_in;
               when 75 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*76)-1 downto STREAM_WSTB_WIDTH*75) <=  wstrb_in;
               when 76 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*77)-1 downto STREAM_WSTB_WIDTH*76) <=  wstrb_in;
               when 77 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*78)-1 downto STREAM_WSTB_WIDTH*77) <=  wstrb_in;
               when 78 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*79)-1 downto STREAM_WSTB_WIDTH*78) <=  wstrb_in;
               when 79 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*80)-1 downto STREAM_WSTB_WIDTH*79) <=  wstrb_in;
               when 80 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*81)-1 downto STREAM_WSTB_WIDTH*80) <=  wstrb_in;
               when 81 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*82)-1 downto STREAM_WSTB_WIDTH*81) <=  wstrb_in;
               when 82 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*83)-1 downto STREAM_WSTB_WIDTH*82) <=  wstrb_in;
               when 83 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*84)-1 downto STREAM_WSTB_WIDTH*83) <=  wstrb_in;
               when 84 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*85)-1 downto STREAM_WSTB_WIDTH*84) <=  wstrb_in;
               when 85 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*86)-1 downto STREAM_WSTB_WIDTH*85) <=  wstrb_in;
               when 86 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*87)-1 downto STREAM_WSTB_WIDTH*86) <=  wstrb_in;
               when 87 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*88)-1 downto STREAM_WSTB_WIDTH*87) <=  wstrb_in;
               when 88 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*89)-1 downto STREAM_WSTB_WIDTH*88) <=  wstrb_in;
               when 89 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*90)-1 downto STREAM_WSTB_WIDTH*89) <=  wstrb_in;
               when 90 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*91)-1 downto STREAM_WSTB_WIDTH*90) <=  wstrb_in;
               when 91 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*92)-1 downto STREAM_WSTB_WIDTH*91) <=  wstrb_in;
               when 92 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*93)-1 downto STREAM_WSTB_WIDTH*92) <=  wstrb_in;
               when 93 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*94)-1 downto STREAM_WSTB_WIDTH*93) <=  wstrb_in;
               when 94 =>                                                                   
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*95)-1 downto STREAM_WSTB_WIDTH*94) <=  wstrb_in;
               when 95 =>                                                                 
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*96)-1 downto STREAM_WSTB_WIDTH*95) <=  wstrb_in;
             
             
               when 96 =>
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*97 )-1 downto STREAM_WSTB_WIDTH*96 ) <=  wstrb_in;
               when 97 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*98 )-1 downto STREAM_WSTB_WIDTH*97 ) <=  wstrb_in;
               when 98 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*99 )-1 downto STREAM_WSTB_WIDTH*98 ) <=  wstrb_in;
               when 99 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*100)-1 downto STREAM_WSTB_WIDTH*99 ) <=  wstrb_in;
               when 100 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*101)-1 downto STREAM_WSTB_WIDTH*100) <=  wstrb_in;
               when 101 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*102)-1 downto STREAM_WSTB_WIDTH*101) <=  wstrb_in;
               when 102 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*103)-1 downto STREAM_WSTB_WIDTH*102) <=  wstrb_in;
               when 103 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*104)-1 downto STREAM_WSTB_WIDTH*103) <=  wstrb_in;
               when 104 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*105)-1 downto STREAM_WSTB_WIDTH*104) <=  wstrb_in;
               when 105 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*106)-1 downto STREAM_WSTB_WIDTH*105) <=  wstrb_in;
               when 106 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*107)-1 downto STREAM_WSTB_WIDTH*106) <=  wstrb_in;
               when 107 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*108)-1 downto STREAM_WSTB_WIDTH*107) <=  wstrb_in;
               when 108 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*109)-1 downto STREAM_WSTB_WIDTH*108) <=  wstrb_in;
               when 109 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*110)-1 downto STREAM_WSTB_WIDTH*109) <=  wstrb_in;
               when 110 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*111)-1 downto STREAM_WSTB_WIDTH*110) <=  wstrb_in;
               when 111 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*112)-1 downto STREAM_WSTB_WIDTH*111) <=  wstrb_in;
               when 112 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*113)-1 downto STREAM_WSTB_WIDTH*112) <=  wstrb_in;
               when 113 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*114)-1 downto STREAM_WSTB_WIDTH*113) <=  wstrb_in;
               when 114 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*115)-1 downto STREAM_WSTB_WIDTH*114) <=  wstrb_in;
               when 115 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*116)-1 downto STREAM_WSTB_WIDTH*115) <=  wstrb_in;
               when 116 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*117)-1 downto STREAM_WSTB_WIDTH*116) <=  wstrb_in;
               when 117 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*118)-1 downto STREAM_WSTB_WIDTH*117) <=  wstrb_in;
               when 118 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*119)-1 downto STREAM_WSTB_WIDTH*118) <=  wstrb_in;
               when 119 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*120)-1 downto STREAM_WSTB_WIDTH*119) <=  wstrb_in;
               when 120 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*121)-1 downto STREAM_WSTB_WIDTH*120) <=  wstrb_in;
               when 121 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*122)-1 downto STREAM_WSTB_WIDTH*121) <=  wstrb_in;
               when 122 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*123)-1 downto STREAM_WSTB_WIDTH*122) <=  wstrb_in;
               when 123 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*124)-1 downto STREAM_WSTB_WIDTH*123) <=  wstrb_in;
               when 124 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*125)-1 downto STREAM_WSTB_WIDTH*124) <=  wstrb_in;
               when 125 =>                                                                    
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*126)-1 downto STREAM_WSTB_WIDTH*125) <=  wstrb_in;
               when 126 =>                                                                 
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*127)-1 downto STREAM_WSTB_WIDTH*126) <=  wstrb_in;
               
               when others => -- 127 case
                   lsig_demux_wstrb_out((STREAM_WSTB_WIDTH*128)-1 downto STREAM_WSTB_WIDTH*127) <=  wstrb_in;
             
             
             
             end case;
          
           end process DO_128XN_DEMUX; 
 
         
       end generate GEN_128XN;
  
 
  
  
  
  
  
  
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_wrdata_cntl.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_wrdata_cntl.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Write Data Controller.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_fifo;
  use axi_datamover_v5_1_17.axi_datamover_strb_gen2;
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_wrdata_cntl is
    generic (
      
      C_REALIGNER_INCLUDED   : Integer range  0 to   1 :=  0;
        -- Indicates the Data Realignment function is included (external
        -- to this module)
      
      C_ENABLE_INDET_BTT     : Integer range  0 to   1 :=  0;
        -- Indicates the INDET BTT function is included (external
        -- to this module)
            
      C_SF_BYTES_RCVD_WIDTH  : Integer range  1 to  26 :=  1;
        -- Sets the width of the data2wsc_bytes_rcvd port used for 
        -- relaying the actual number of bytes received when Idet BTT is 
        -- enabled (C_ENABLE_INDET_BTT = 1)
      
      C_SEL_ADDR_WIDTH       : Integer range  1 to   8 :=  5;
        -- Sets the width of the LS bits of the transfer address that
        -- are being used to Demux write data to a wider AXI4 Write
        -- Data Bus
        
      C_DATA_CNTL_FIFO_DEPTH : Integer range  1 to  32 :=  4;
        -- Sets the depth of the internal command fifo used for the
        -- command queue
        
      C_MMAP_DWIDTH          : Integer range 32 to 1024 := 32;
        -- Indicates the native data width of the Read Data port
        
      C_STREAM_DWIDTH        : Integer range  8 to 1024 := 32;
        -- Sets the width of the Stream output data port
        
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        -- Indicates the width of the Tag field of the input command
        
      C_FAMILY               : String                  := "virtex7"
        -- Indicates the device family of the target FPGA
        
      
      );
    port (
      
      -- Clock and Reset inputs ----------------------------------------------
                                                                            --
      primary_aclk         : in  std_logic;                                 --
         -- Primary synchronization clock for the Master side               --
         -- interface and internal logic. It is also used                   --
         -- for the User interface synchronization when                     --
         -- C_STSCMD_IS_ASYNC = 0.                                          --
                                                                            --
      -- Reset input                                                        --
      mmap_reset           : in  std_logic;                                 --
         -- Reset used for the internal master logic                        --
      ------------------------------------------------------------------------
      

     
      
      -- Soft Shutdown internal interface ------------------------------------
                                                                            --
      rst2data_stop_request : in  std_logic;                                --
         -- Active high soft stop request to modules                        --
                                                                            --
      data2addr_stop_req    : Out std_logic;                                --
        -- Active high signal requesting the Address Controller             --
        -- to stop posting commands to the AXI Read Address Channel         --
                                                                            --
      data2rst_stop_cmplt   : Out std_logic;                                --
        -- Active high indication that the Data Controller has completed    --
        -- any pending transfers committed by the Address Controller        --
        -- after a stop has been requested by the Reset module.             --
      ------------------------------------------------------------------------
      
      
        
  
      -- Store and Forward support signals for external User logic ------------
                                                                             --
      wr_xfer_cmplt         : Out std_logic;                                 --
        -- Active high indication that the Data Controller has completed     --
        -- a single write data transfer on the AXI4 Write Data Channel.      --
        -- This signal is escentially echos the assertion of wlast sent      --
        -- to the AXI4.                                                      --
                                                                             --
      s2mm_ld_nxt_len        : out std_logic;                                --
        -- Active high pulse indicating a new xfer length has been queued    --
        -- to the WDC Cmd FIFO                                               --
                                                                             --
      s2mm_wr_len            : out std_logic_vector(7 downto 0);             --
        -- Bus indicating the AXI LEN value associated with the xfer command --
        -- loaded into the WDC Command FIFO.                                 --
      -------------------------------------------------------------------------
     
     
     
      -- AXI Write Data Channel Skid buffer I/O  ---------------------------------------
                                                                                      --
      data2skid_saddr_lsb   : out std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);      --
        -- Write DATA output to skid buffer                                           --
                                                                                      --
      data2skid_wdata       : Out  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);      --
        -- Write DATA output to skid buffer                                           --
                                                                                      --
      data2skid_wstrb       : Out  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);  --
        -- Write DATA output to skid buffer                                           --
                                                                                      --
      data2skid_wlast       : Out  std_logic;                                         --
        -- Write LAST output to skid buffer                                           --
                                                                                      --
      data2skid_wvalid      : Out  std_logic;                                         --
        -- Write VALID output to skid buffer                                          --
                                                                                      --
      skid2data_wready      : In  std_logic;                                          --
        -- Write READY input from skid buffer                                         --
      ----------------------------------------------------------------------------------
     
 
 
      -- AXI Slave Stream In -----------------------------------------------------------
                                                                                      --
      s2mm_strm_wvalid   : In  std_logic;                                             --
        -- AXI Stream VALID input                                                     --
                                                                                      --
      s2mm_strm_wready   : Out  Std_logic;                                            --
        -- AXI Stream READY Output                                                    --
                                                                                      --
      s2mm_strm_wdata    : In  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);          --
        -- AXI Stream data input                                                      --
                                                                                      --
      s2mm_strm_wstrb    : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);       --  
        -- AXI Stream STRB input                                                      --
                                                                                      --
      s2mm_strm_wlast    : In std_logic;                                              --
        -- AXI Stream LAST input                                                      --
      ----------------------------------------------------------------------------------
               
      
      
      -- Stream input sideband signal from Indeterminate BTT and/or DRE ----------------
                                                                                      --
      s2mm_strm_eop      : In std_logic;                                              --
        -- Stream End of Packet marker input. This is only used when Indeterminate    --
        -- BTT mode is enable. Otherwise it is ignored                                --
                                                                                      --
                                                                                      --
      s2mm_stbs_asserted : in  std_logic_vector(7 downto 0);                          --
        -- Indicates the number of asserted WSTRB bits for the                        --
        -- associated input stream data beat                                          --
                                                                                      --
                                                                                      --
      -- Realigner Underrun/overrun error flag used in non Indeterminate BTT          --
      -- Mode                                                                         --
      realign2wdc_eop_error  : In  std_logic ;                                        --
        -- Asserted active high and will only clear with reset. It is only used       --
        -- when Indeterminate BTT is not enabled and the Realigner Module is          --
        -- instantiated upstream from the WDC. The Realigner will detect overrun      --
        -- underrun conditions and will will relay these conditions via this signal.  --
      ----------------------------------------------------------------------------------        
      
      
                
                
                
      -- Command Calculator Interface --------------------------------------------------
                                                                                      --
      mstr2data_tag        : In std_logic_vector(C_TAG_WIDTH-1 downto 0);             --
         -- The next command tag                                                      --
                                                                                      --
      mstr2data_saddr_lsb  : In std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);        --
         -- The next command start address LSbs to use for the write strb             --
         -- demux (only used if Stream data width is less than the MMap Dwidth).      --
                                                                                      --
      mstr2data_len        : In std_logic_vector(7 downto 0);                         --
         -- The LEN value output to the Address Channel                               --
                                                                                      --
      mstr2data_strt_strb  : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);     --
         -- The starting strobe value to use for the first stream data beat           --
                                                                                      --
      mstr2data_last_strb  : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);     --
         -- The endiing (LAST) strobe value to use for the last stream                --
         -- data beat                                                                 --
                                                                                      --
      mstr2data_drr        : In std_logic;                                            --
         -- The starting tranfer of a sequence of transfers                           --
                                                                                      --
      mstr2data_eof        : In std_logic;                                            --
         -- The endiing tranfer of a sequence of transfers                            --
                                                                                      --
      mstr2data_sequential : In std_logic;                                            --
         -- The next sequential tranfer of a sequence of transfers                    --
         -- spawned from a single parent command                                      --
                                                                                      --
      mstr2data_calc_error : In std_logic;                                            --
         -- Indication if the next command in the calculation pipe                    --
         -- has a calculation error                                                   --
                                                                                      --
      mstr2data_cmd_cmplt  : In std_logic;                                            --
         -- The final child tranfer of a parent command fetched from                  --
         -- the Command FIFO (not necessarily an EOF command)                         --
                                                                                      --
      mstr2data_cmd_valid  : In std_logic;                                            --
         -- The next command valid indication to the Data Channel                     --
         -- Controller for the AXI MMap                                               --
                                                                                      --
      data2mstr_cmd_ready  : Out std_logic ;                                          --
         -- Indication from the Data Channel Controller that the                      --
         -- command is being accepted on the AXI Address                              --
         -- Channel                                                                   --
      ----------------------------------------------------------------------------------
      
      
      
        
      -- Address Controller Interface --------------------------------------------------
                                                                                      --
      addr2data_addr_posted    : In std_logic ;                                       --
         -- Indication from the Address Channel Controller to the                     --
         -- Data Controller that an address has been posted to the                    --
         -- AXI Address Channel                                                       --
                                                                                      --
                                                                                      --
      data2addr_data_rdy       : out std_logic;                                       --
         -- Indication that the Data Channel is ready to send the first               --
         -- databeat of the next command on the write data channel.                   --
         -- This is used for the "wait for data" feature which keeps the              --
         -- address controller from issuing a transfer request until the              --
         -- corresponding data valid is asserted on the stream input. The             --
         -- WDC will continue to assert the output until an assertion on              --
         -- the addr2data_addr_posted is received.                                    --
       ---------------------------------------------------------------------------------
  
  
      
      -- Premature TLAST assertion error flag ------------------------------------------
                                                                                      --
      data2all_tlast_error : Out std_logic;                                           --
         -- When asserted, this indicates the data controller detected                --
         -- a premature TLAST assertion on the incoming data stream.                  --
       ---------------------------------------------------------------------------------     
      
      
      -- Data Controller Halted Status -------------------------------------------------
                                                                                      --
      data2all_dcntlr_halted : Out std_logic;                                         --
         -- When asserted, this indicates the data controller has satisfied           --
         -- all pending transfers queued by the Address Controller and is halted.     --
      ----------------------------------------------------------------------------------
      
       
 
      -- Input Stream Skid Buffer Halt control -----------------------------------------
                                                                                      --
      data2skid_halt       : Out std_logic;                                           --
         -- The data controller asserts this output for 1 primary clock period        --
         -- The pulse commands the MM2S Stream skid buffer to tun off outputs         --
         -- at the next tlast transmission.                                           --
      ----------------------------------------------------------------------------------
      
       
 
       
      -- Write Status Controller Interface ---------------------------------------------
                                                                                      --
      data2wsc_tag         : Out std_logic_vector(C_TAG_WIDTH-1 downto 0);            --
         -- The command tag                                                           --
                                                                                      --
      data2wsc_calc_err    : Out std_logic ;                                          --
         -- Indication that the current command out from the Cntl FIFO                --
         -- has a calculation error                                                   --
                                                                                      --
      data2wsc_last_err    : Out std_logic ;                                          --
        -- Indication that the current write transfer encountered a premature         --
        -- TLAST assertion on the incoming Stream Channel                             --
                                                                                      --
      data2wsc_cmd_cmplt   : Out std_logic ;                                          --
         -- Indication by the Data Channel Controller that the                        --
         -- corresponding status is the last status for a command                     --
         -- pulled from the command FIFO                                              --
                                                                                      --
      wsc2data_ready       : in  std_logic;                                           --
         -- Input from the Write Status Module indicating that the                    --
         -- Status Reg/FIFO is ready to accept data                                   --
                                                                                      --
      data2wsc_valid       : Out  std_logic;                                          --
         -- Output to the Command/Status Module indicating that the                   --
         -- Data Controller has valid tag and err indicators to write                 --
         -- to the Status module                                                      --
                                                                                      --
      data2wsc_eop         : Out  std_logic;                                          --
         -- Output to the Write Status Controller indicating that the                 --
         -- associated command status also corresponds to a End of Packet             --
         -- marker for the input Stream. This is only used when Inderminate           --
         -- BTT is enabled in the S2MM.                                               --
                                                                                      --
      data2wsc_bytes_rcvd  : Out std_logic_vector(C_SF_BYTES_RCVD_WIDTH-1 downto 0);  --
         -- Output to the Write Status Controller indicating the actual               --
         -- number of bytes received from the Stream input for the                    --
         -- corresponding command status. This is only used when Inderminate          --
         -- BTT is enabled in the S2MM.                                               --
                                                                                      --
      wsc2mstr_halt_pipe   : In  std_logic                                            --
         -- Indication to Halt the Data and Address Command pipeline due              --
         -- to the Status FIFO going full or an internal error being logged           --
      ----------------------------------------------------------------------------------

    
      
      );
  
  end entity axi_datamover_wrdata_cntl;
  
  
  architecture implementation of axi_datamover_wrdata_cntl  is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Function declaration   ----------------------------------------
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_dbeat_residue_width
    --
    -- Function Description:
    --  Calculates the number of Least significant bits of the BTT field
    -- that are unused for the LEN calculation
    --
    -------------------------------------------------------------------
    function funct_get_dbeat_residue_width (bytes_per_beat : integer) return integer is

      Variable temp_dbeat_residue_width : Integer := 0; -- 8-bit stream

    begin

      case bytes_per_beat is
        
        when 128 =>  -- 1024 bits          -- Added per Per CR616409
            temp_dbeat_residue_width := 7; -- Added per Per CR616409
        when 64 =>   -- 512 bits           -- Added per Per CR616409
            temp_dbeat_residue_width := 6; -- Added per Per CR616409
        when 32 =>   -- 256 bits           
            temp_dbeat_residue_width := 5;
        when 16 =>   -- 128 bits
            temp_dbeat_residue_width := 4;
        when 8 =>    -- 64 bits
            temp_dbeat_residue_width := 3;
        when 4 =>    -- 32 bits
            temp_dbeat_residue_width := 2;
        when 2 =>    -- 16 bits
            temp_dbeat_residue_width := 1;
        when others =>  -- assume 1-byte transfers
            temp_dbeat_residue_width := 0;
      end case;

      Return (temp_dbeat_residue_width);

    end function funct_get_dbeat_residue_width;




    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_set_cnt_width
    --
    -- Function Description:
    --    Sets a count width based on a fifo depth. A depth of 4 or less
    -- is a special case which requires a minimum count width of 3 bits.
    --
    -------------------------------------------------------------------
    function funct_set_cnt_width (fifo_depth : integer) return integer is
    
      Variable temp_cnt_width : Integer := 4;
    
    begin
    
      
      if (fifo_depth <= 4) then
      
         temp_cnt_width := 3;
      
      elsif (fifo_depth <= 8) then
      
         temp_cnt_width := 4;
      
      elsif (fifo_depth <= 16) then
      
         temp_cnt_width := 5;
      
      elsif (fifo_depth <= 32) then
      
         temp_cnt_width := 6;
      
      else  -- fifo depth <= 64
      
         temp_cnt_width := 7;
      
      end if;
      
      Return (temp_cnt_width);
       
       
    end function funct_set_cnt_width;
    
 
 
 
  
    -- Constant Declarations  --------------------------------------------
    
    Constant STRM_STRB_WIDTH        : integer := C_STREAM_DWIDTH/8;
    Constant LEN_OF_ZERO            : std_logic_vector(7 downto 0) := (others => '0');
    Constant USE_SYNC_FIFO          : integer := 0;
    Constant REG_FIFO_PRIM          : integer := 0; 
    Constant BRAM_FIFO_PRIM         : integer := 1; 
    Constant SRL_FIFO_PRIM          : integer := 2; 
    Constant FIFO_PRIM_TYPE         : integer := SRL_FIFO_PRIM; 
    Constant TAG_WIDTH              : integer := C_TAG_WIDTH;
    Constant SADDR_LSB_WIDTH        : integer := C_SEL_ADDR_WIDTH;
    Constant LEN_WIDTH              : integer := 8;
    Constant STRB_WIDTH             : integer := C_STREAM_DWIDTH/8;
    Constant DRR_WIDTH              : integer := 1;
    Constant EOF_WIDTH              : integer := 1;
    Constant CALC_ERR_WIDTH         : integer := 1;
    Constant CMD_CMPLT_WIDTH        : integer := 1;
    Constant SEQUENTIAL_WIDTH       : integer := 1;
    Constant DCTL_FIFO_WIDTH        : Integer := TAG_WIDTH        +  -- Tag field
                                                 SADDR_LSB_WIDTH  +  -- LS Address field width
                                                 LEN_WIDTH        +  -- LEN field
                                                 STRB_WIDTH       +  -- Starting Strobe field
                                                 STRB_WIDTH       +  -- Ending Strobe field
                                                 DRR_WIDTH        +  -- DRE Re-alignment Request Flag Field
                                                 EOF_WIDTH        +  -- EOF flag field
                                                 SEQUENTIAL_WIDTH +  -- Sequential command flag
                                                 CMD_CMPLT_WIDTH  +  -- Command Complete Flag
                                                 CALC_ERR_WIDTH;     -- Calc error flag
    
    Constant TAG_STRT_INDEX         : integer := 0;
    Constant SADDR_LSB_STRT_INDEX   : integer := TAG_STRT_INDEX + TAG_WIDTH;
    Constant LEN_STRT_INDEX         : integer := SADDR_LSB_STRT_INDEX + SADDR_LSB_WIDTH;
    Constant STRT_STRB_STRT_INDEX   : integer := LEN_STRT_INDEX + LEN_WIDTH;
    Constant LAST_STRB_STRT_INDEX   : integer := STRT_STRB_STRT_INDEX + STRB_WIDTH;
    Constant DRR_STRT_INDEX         : integer := LAST_STRB_STRT_INDEX + STRB_WIDTH;
    Constant EOF_STRT_INDEX         : integer := DRR_STRT_INDEX + DRR_WIDTH;
    Constant SEQUENTIAL_STRT_INDEX  : integer := EOF_STRT_INDEX + EOF_WIDTH;
    Constant CMD_CMPLT_STRT_INDEX   : integer := SEQUENTIAL_STRT_INDEX+SEQUENTIAL_WIDTH;
    Constant CALC_ERR_STRT_INDEX    : integer := CMD_CMPLT_STRT_INDEX+CMD_CMPLT_WIDTH;        
    Constant ADDR_INCR_VALUE        : integer := C_STREAM_DWIDTH/8;
    
    Constant ADDR_POSTED_CNTR_WIDTH : integer := funct_set_cnt_width(C_DATA_CNTL_FIFO_DEPTH); 
    
    
    
    Constant ADDR_POSTED_ZERO       : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := (others => '0');
    Constant ADDR_POSTED_ONE        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := TO_UNSIGNED(1, ADDR_POSTED_CNTR_WIDTH);
    Constant ADDR_POSTED_MAX        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := (others => '1');
                    
    
    
    
    
    -- Signal Declarations  --------------------------------------------
    
    signal sig_get_next_dqual        : std_logic := '0';
    signal sig_last_mmap_dbeat       : std_logic := '0';
    signal sig_last_mmap_dbeat_reg   : std_logic := '0';
    signal sig_mmap2data_ready       : std_logic := '0';
    signal sig_data2mmap_valid       : std_logic := '0';
    signal sig_data2mmap_last        : std_logic := '0';
    signal sig_data2mmap_data        : std_logic_vector(C_STREAM_DWIDTH-1 downto 0) := (others => '0');
    signal sig_ld_new_cmd            : std_logic := '0';
    signal sig_ld_new_cmd_reg        : std_logic := '0';
    signal sig_cmd_cmplt_reg         : std_logic := '0';
    signal sig_calc_error_reg        : std_logic := '0';
    signal sig_tag_reg               : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_lsb_reg          : std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_strt_strb_reg         : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_last_strb_reg         : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_addr_posted           : std_logic := '0';
    signal sig_dqual_rdy             : std_logic := '0';
    signal sig_good_mmap_dbeat       : std_logic := '0';
    signal sig_first_dbeat           : std_logic := '0';
    signal sig_last_dbeat            : std_logic := '0';
    signal sig_single_dbeat          : std_logic := '0';
    signal sig_new_len_eq_0          : std_logic := '0';
    signal sig_dbeat_cntr            : unsigned(7 downto 0) := (others => '0');
    Signal sig_dbeat_cntr_int        : Integer range 0 to 255 := 0;
    signal sig_dbeat_cntr_eq_0       : std_logic := '0';
    signal sig_dbeat_cntr_eq_1       : std_logic := '0';
    signal sig_wsc_ready             : std_logic := '0';
    signal sig_push_to_wsc           : std_logic := '0';
    signal sig_push_to_wsc_cmplt     : std_logic := '0';
    signal sig_set_push2wsc          : std_logic := '0';
    signal sig_data2wsc_tag          : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_data2wsc_calc_err     : std_logic := '0';
    signal sig_data2wsc_last_err     : std_logic := '0';
    signal sig_data2wsc_cmd_cmplt    : std_logic := '0';
    signal sig_tlast_error           : std_logic := '0';
    signal sig_tlast_error_strbs     : std_logic := '0';
    signal sig_end_stbs_match_err    : std_logic := '0';
    signal sig_tlast_error_reg       : std_logic := '0';
    signal sig_cmd_is_eof            : std_logic := '0';
    signal sig_push_err2wsc          : std_logic := '0';
    signal sig_tlast_error_ovrrun    : std_logic := '0';
    signal sig_tlast_error_undrrun   : std_logic := '0';
    signal sig_next_tag_reg          : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_next_strt_strb_reg    : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_next_last_strb_reg    : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_next_eof_reg          : std_logic := '0';
    signal sig_next_sequential_reg   : std_logic := '0';
    signal sig_next_cmd_cmplt_reg    : std_logic := '0';
    signal sig_next_calc_error_reg   : std_logic := '0';
    signal sig_pop_dqual_reg         : std_logic := '0';
    signal sig_push_dqual_reg        : std_logic := '0';
    signal sig_dqual_reg_empty       : std_logic := '0';
    signal sig_dqual_reg_full        : std_logic := '0';
    signal sig_addr_posted_cntr      : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_posted_cntr_eq_0 : std_logic := '0';
    signal sig_addr_posted_cntr_max  : std_logic := '0';
    signal sig_decr_addr_posted_cntr : std_logic := '0';
    signal sig_incr_addr_posted_cntr : std_logic := '0';
    signal sig_addr_posted_cntr_eq_1 : std_logic := '0';
    signal sig_apc_going2zero        : std_logic := '0';
    signal sig_aposted_cntr_ready    : std_logic := '0';
    signal sig_addr_chan_rdy         : std_logic := '0';
    Signal sig_no_posted_cmds        : std_logic := '0';
    signal sig_ls_addr_cntr          : unsigned(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_incr_ls_addr_cntr     : std_logic := '0';
    signal sig_addr_incr_unsgnd      : unsigned(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    Signal sig_cmd_fifo_data_in      : std_logic_vector(DCTL_FIFO_WIDTH-1 downto 0) := (others => '0');
    Signal sig_cmd_fifo_data_out     : std_logic_vector(DCTL_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_tag         : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_sadddr_lsb  : std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_next_len         : std_logic_vector(7 downto 0) := (others => '0');
    signal sig_fifo_next_strt_strb   : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_fifo_next_last_strb   : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_fifo_next_drr         : std_logic := '0';
    signal sig_fifo_next_eof         : std_logic := '0';
    signal sig_fifo_next_cmd_cmplt   : std_logic := '0';
    signal sig_fifo_next_sequential  : std_logic := '0';
    signal sig_fifo_next_calc_error  : std_logic := '0';
    signal sig_cmd_fifo_empty        : std_logic := '0';
    signal sig_fifo_wr_cmd_valid     : std_logic := '0';
    signal sig_fifo_wr_cmd_ready     : std_logic := '0';
    signal sig_fifo_rd_cmd_valid     : std_logic := '0';
    signal sig_fifo_rd_cmd_ready     : std_logic := '0';
    signal sig_sequential_push       : std_logic := '0';
    signal sig_clr_dqual_reg         : std_logic := '0';
    signal sig_tlast_err_stop        : std_logic := '0';
    signal sig_halt_reg              : std_logic := '0';
    signal sig_halt_reg_dly1         : std_logic := '0';
    signal sig_halt_reg_dly2         : std_logic := '0';
    signal sig_halt_reg_dly3         : std_logic := '0';
    signal sig_data2skid_halt        : std_logic := '0';
    signal sig_stop_wvalid           : std_logic := '0';
    signal sig_data2rst_stop_cmplt   : std_logic := '0';
    signal sig_s2mm_strm_wready      : std_logic := '0';
    signal sig_good_strm_dbeat       : std_logic := '0';
    signal sig_halt_strb             : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_sfhalt_next_strt_strb : std_logic_vector(STRM_STRB_WIDTH-1 downto 0) := (others => '0');             
    signal sig_wfd_simult_clr_set    : std_logic := '0';
    signal sig_wr_xfer_cmplt         : std_logic := '0';
    signal sig_s2mm_ld_nxt_len       : std_logic := '0';
    signal sig_s2mm_wr_len           : std_logic_vector(7 downto 0) := (others => '0');
    signal sig_data2mstr_cmd_ready   : std_logic := '0';
    signal sig_spcl_push_err2wsc     : std_logic := '0';
    
    
                               
  begin --(architecture implementation)
  
    -- Command calculator handshake
    data2mstr_cmd_ready <= sig_data2mstr_cmd_ready;
    
    
    -- Write Data Channel Skid Buffer Port assignments
    sig_mmap2data_ready  <= skid2data_wready     ;
    data2skid_wvalid     <= sig_data2mmap_valid  ;
    data2skid_wlast      <= sig_data2mmap_last   ;
    data2skid_wdata      <= sig_data2mmap_data   ;
    data2skid_saddr_lsb  <= sig_addr_lsb_reg     ;
    
    -- AXI MM2S Stream Channel Port assignments           
    sig_data2mmap_data   <= s2mm_strm_wdata      ;

    
    -- Premature TLAST assertion indication
    data2all_tlast_error <= sig_tlast_error_reg  ;
    
    
    
    
   
    -- Stream Input Ready Handshake
    s2mm_strm_wready     <= sig_s2mm_strm_wready ;                                           
    
    
    
    sig_good_strm_dbeat  <= s2mm_strm_wvalid and
                            sig_s2mm_strm_wready;
    
    
    sig_data2mmap_last   <= sig_dbeat_cntr_eq_0 and
                            sig_dqual_rdy;

                      

    -- Write Status Block interface signals
    data2wsc_valid       <= sig_push_to_wsc and
                            not(sig_tlast_err_stop) ; -- only allow 1 status write on TLAST errror
    sig_wsc_ready        <= wsc2data_ready          ;
    data2wsc_tag         <= sig_data2wsc_tag        ;   
    data2wsc_calc_err    <= sig_data2wsc_calc_err   ; 
    data2wsc_last_err    <= sig_data2wsc_last_err   ; 
    data2wsc_cmd_cmplt   <= sig_data2wsc_cmd_cmplt  ;   
    
                                      
    -- Address Channel Controller synchro pulse input                  
    sig_addr_posted      <= addr2data_addr_posted;
                                                        
    
    
    -- Request to halt the Address Channel Controller                  
    data2addr_stop_req   <= sig_halt_reg or
                            sig_tlast_error_reg;
 
    
    -- Halted flag to the reset module                  
    data2rst_stop_cmplt  <= sig_data2rst_stop_cmplt;
    
    
    -- Indicate the Write Data Controller is always ready
    data2addr_data_rdy   <= '1'; 
    
    
    
    -- Write Transfer Completed Status output 
    wr_xfer_cmplt        <= sig_wr_xfer_cmplt ;
    
    -- New LEN value is being loaded 
    s2mm_ld_nxt_len      <= sig_s2mm_ld_nxt_len;
    
    -- The new LEN value
    s2mm_wr_len          <= sig_s2mm_wr_len;
    
    
     
     
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_WR_CMPLT_FLAG
    --
    -- Process Description:
    --   Implements the status flag indicating that a write data 
    -- transfer has completed. This is an echo of a wlast assertion
    -- and a qualified data beat on the AXI4 Write Data Channel.
    --
    -------------------------------------------------------------
    IMP_WR_CMPLT_FLAG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then
    
             sig_wr_xfer_cmplt <= '0';
    
           else
    
             sig_wr_xfer_cmplt <= sig_data2mmap_last and 
                                  sig_good_strm_dbeat;
                                  
           end if; 
        end if;       
      end process IMP_WR_CMPLT_FLAG; 
     
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_INDET_BTT
    --
    -- If Generate Description:
    --   Omits any Indeterminate BTT Support logic and includes
    -- any error detection needed in Non Indeterminate BTT mode.
    --
    ------------------------------------------------------------
    GEN_OMIT_INDET_BTT : if (C_ENABLE_INDET_BTT = 0) generate
    
      begin
   
       
        
        
        sig_sfhalt_next_strt_strb <= sig_fifo_next_strt_strb;
        
        
        
        
        -- Just housekeep the output port signals
        
        data2wsc_eop         <= '0';
   
        data2wsc_bytes_rcvd  <= (others => '0');
   
       
        
        
        
        -- WRSTRB logic ------------------------------
                  

        -- Generate the Write Strobes for the MMap Write Data Channel
        -- for the non Indeterminate BTT Case
        data2skid_wstrb  <= sig_strt_strb_reg 
          When (sig_first_dbeat  = '1')
          Else  sig_last_strb_reg
          When  (sig_last_dbeat  = '1')
          Else (others => '1');

        
                 
        -- Generate the Stream Ready for the Stream input side
        sig_s2mm_strm_wready <= sig_halt_reg            or  -- force tready if a halt requested
                                (sig_mmap2data_ready    and
                                sig_addr_chan_rdy       and -- This puts combinational logic in the stream WREADY path
                                sig_dqual_rdy           and
                                not(sig_calc_error_reg) and
                                not(sig_tlast_error_reg));   -- Stop the stream channel at a overrun/underrun detection
        
         
        
        -- MMap Write Data Channel Valid Handshaking
        sig_data2mmap_valid <= (s2mm_strm_wvalid       or
                               sig_tlast_error_reg     or  -- force valid if TLAST error 
                               sig_halt_reg       )    and -- force valid if halt requested       
                               sig_addr_chan_rdy       and -- xfers are commited on the address channel and       
                               sig_dqual_rdy           and -- there are commands in the command fifo        
                               not(sig_calc_error_reg) and
                               not(sig_stop_wvalid);       -- gate off wvalid immediately after a wlast for 1 clk
                                                           -- or when the soft shutdown has completed
              
      
        
        
        
        
        
        ------------------------------------------------------------
        -- If Generate
        --
        -- Label: GEN_LOCAL_ERR_DETECT
        --
        -- If Generate Description:
        --  Implements the local overrun and underrun detection when
        -- the S2MM Realigner is not included.
        --
        --
        ------------------------------------------------------------
        GEN_LOCAL_ERR_DETECT : if (C_REALIGNER_INCLUDED = 0) generate
        
        
           begin
        
             -------  Input Stream TLAST assertion error ------------------------------- 
             
             
             sig_tlast_error_ovrrun <= sig_cmd_is_eof       and
                                       sig_dbeat_cntr_eq_0  and
                                       sig_good_mmap_dbeat  and
                                       not(s2mm_strm_wlast);
             
             
             
             sig_tlast_error_undrrun <= s2mm_strm_wlast     and
                                        sig_good_mmap_dbeat and
                                        (not(sig_dbeat_cntr_eq_0) or
                                         not(sig_cmd_is_eof));
             
                    
                    
             sig_end_stbs_match_err  <=  '1'                            -- Set flag if the calculated end strobe value
               When ((s2mm_strm_wstrb    /= sig_next_last_strb_reg) and -- does not match the received strobe value 
                    (s2mm_strm_wlast     = '1') and                     -- at TLAST assertion
                    (sig_good_mmap_dbeat = '1'))                        -- Qualified databeat
               Else '0';
                    
                                 
             sig_tlast_error <=  (sig_tlast_error_ovrrun  or
                                  sig_tlast_error_undrrun or
                                  sig_end_stbs_match_err) and
                                  not(sig_halt_reg);          -- Suppress TLAST error when in soft shutdown 
                                 
                                 
             
             -- Just housekeep this when local TLAST error detection is used
             sig_spcl_push_err2wsc <= '0';
            
            
            
           
           end generate GEN_LOCAL_ERR_DETECT;
        
        
 
 
 
        ------------------------------------------------------------
        -- If Generate
        --
        -- Label: GEN_EXTERN_ERR_DETECT
        --
        -- If Generate Description:
        --  Omits the local overrun and underrun detection and relies
        -- on the S2MM Realigner for the detection.
        --
        ------------------------------------------------------------
        GEN_EXTERN_ERR_DETECT : if (C_REALIGNER_INCLUDED = 1) generate
        
        
           begin
        
 
              sig_tlast_error_undrrun <= '0';  -- not used here
 
              sig_tlast_error_ovrrun  <= '0';  -- not used here
 
              sig_end_stbs_match_err  <= '0';  -- not used here
 
 
           
              sig_tlast_error <= realign2wdc_eop_error and  -- External error detection asserted
                                 not(sig_halt_reg);         -- Suppress TLAST error when in soft shutdown
               
             
             
              -- Special case for pushing error status when timing is such that no 
              -- addresses have been posted to AXI and a TLAST error has been detected  
              -- by the Realigner module and propagated in from the Stream input side.
              sig_spcl_push_err2wsc <= sig_tlast_error_reg     and
                                       not(sig_tlast_err_stop) and
                                       not(sig_addr_chan_rdy );
             
             
             
             
             
             
               
               
           
           end generate GEN_EXTERN_ERR_DETECT;
 
 
 
 
 
 
 
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_TLAST_ERR_REG
        --
        -- Process Description:
        --  Implements a sample and hold flop for the flag indicating
        -- that the input Stream TLAST assertion was not at the expected
        -- data beat relative to the commanded number of databeats
        -- from the associated command from the SCC or PCC.
        -------------------------------------------------------------
        IMP_TLAST_ERR_REG : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (mmap_reset = '1') then
                  sig_tlast_error_reg <= '0';
                elsif (sig_tlast_error = '1') then
                  sig_tlast_error_reg <= '1';
                else
                  null;  -- hold current state
                end if; 
             end if;       
           end process IMP_TLAST_ERR_REG; 
           
           
           
           
           
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_TLAST_ERROR_STOP
        --
        -- Process Description:
        --  Implements the flop to generate a stop flag once the TLAST
        -- error condition has been relayed to the Write Status 
        -- Controller. This stop flag is used to prevent any more 
        -- pushes to the Write Status Controller.
        --
        -------------------------------------------------------------
        IMP_TLAST_ERROR_STOP : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (mmap_reset = '1') then
                  sig_tlast_err_stop <= '0';
                elsif (sig_tlast_error_reg   = '1' and
                       sig_push_to_wsc_cmplt = '1') then
                  sig_tlast_err_stop <= '1';
                else
                  null; -- Hold State
                end if; 
             end if;       
           end process IMP_TLAST_ERROR_STOP; 
           
           
           
      
      
      
      end generate GEN_OMIT_INDET_BTT;
   
   













    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INDET_BTT
    --
    -- If Generate Description:
    --   Includes any Indeterminate BTT Support logic. Primarily
    -- this is a counter for the input stream bytes received. The
    -- received byte count is relayed to the Write Status Controller
    -- for each parent command completed.
    -- When a packet completion is indicated via the EOP marker
    -- assertion, the status to the Write Status Controller also
    -- indicates the EOP condition.
    -- Note that underrun and overrun detection/error flagging
    -- is disabled in Indeterminate BTT Mode.
    --
    ------------------------------------------------------------
    GEN_INDET_BTT : if (C_ENABLE_INDET_BTT = 1) generate
    
      -- local constants
      Constant BYTE_CNTR_WIDTH          : integer := C_SF_BYTES_RCVD_WIDTH;
      Constant NUM_ZEROS_WIDTH          : integer := 8;
      Constant BYTES_PER_DBEAT          : integer := C_STREAM_DWIDTH/8;
      Constant STRBGEN_ADDR_SLICE_WIDTH : integer := 
                                          funct_get_dbeat_residue_width(BYTES_PER_DBEAT);
      
      Constant STRBGEN_ADDR_0            : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
      
      
      
      -- local signals
      signal lsig_byte_cntr             : unsigned(BYTE_CNTR_WIDTH-1 downto 0) := (others => '0');
      signal lsig_byte_cntr_incr_value  : unsigned(BYTE_CNTR_WIDTH-1 downto 0) := (others => '0');
      signal lsig_ld_byte_cntr          : std_logic := '0';
      signal lsig_incr_byte_cntr        : std_logic := '0';
      signal lsig_clr_byte_cntr         : std_logic := '0';
      signal lsig_end_of_cmd_reg        : std_logic := '0';
      signal lsig_eop_s_h_reg           : std_logic := '0';
      signal lsig_eop_reg               : std_logic := '0';
      signal sig_strbgen_addr           : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
      signal sig_strbgen_bytes          : std_logic_vector(STRBGEN_ADDR_SLICE_WIDTH   downto 0) := (others => '0');
      
      
      
      
      begin
   
       
        -- Assign the outputs to the Write Status Controller
        data2wsc_eop         <= lsig_eop_reg and 
                                not(sig_next_calc_error_reg);
         
        data2wsc_bytes_rcvd  <= STD_LOGIC_VECTOR(lsig_byte_cntr);
        
 
 
        -- WRSTRB logic ------------------------------
      
      
      
        --sig_strbgen_bytes <= (others => '1'); -- set to the max value
      
        
        -- set the length to the max number of bytes per databeat
        sig_strbgen_bytes <=  STD_LOGIC_VECTOR(TO_UNSIGNED(BYTES_PER_DBEAT, STRBGEN_ADDR_SLICE_WIDTH+1));
        
        
        
        
        
        
        sig_strbgen_addr  <= STD_LOGIC_VECTOR(RESIZE(UNSIGNED(sig_fifo_next_sadddr_lsb), 
                                                     STRBGEN_ADDR_SLICE_WIDTH)) ;
 
 
 
      
      ------------------------------------------------------------
      -- Instance: I_STRT_STRB_GEN 
      --
      -- Description:
      --  Strobe generator used to generate the starting databeat
      -- strobe value for soft shutdown case where the S2MM has to 
      -- flush out all of the transfers that have been committed
      -- to the AXI Write address channel. Starting Strobes must
      -- match the committed address offest for each transfer. 
      -- 
      ------------------------------------------------------------
      I_STRT_STRB_GEN : entity axi_datamover_v5_1_17.axi_datamover_strb_gen2
      generic map (
                            
        C_OP_MODE            =>  0                         , -- 0 = Offset/Length mode
        C_STRB_WIDTH         =>  BYTES_PER_DBEAT           ,   
        C_OFFSET_WIDTH       =>  STRBGEN_ADDR_SLICE_WIDTH  ,   
        C_NUM_BYTES_WIDTH    =>  STRBGEN_ADDR_SLICE_WIDTH+1           
    
        )
      port map (
        
        start_addr_offset    =>  sig_strbgen_addr         , 
        end_addr_offset      =>  STRBGEN_ADDR_0           , -- not used in op mode 0
        num_valid_bytes      =>  sig_strbgen_bytes        , 
        strb_out             =>  sig_sfhalt_next_strt_strb   
    
        );
                                  
     


   
   

        -- Generate the WSTRB to use during soft shutdown 
        sig_halt_strb  <= sig_strt_strb_reg 
          When (sig_first_dbeat   = '1' or
                sig_single_dbeat  = '1')
          Else  (others => '1');

           
                  
        -- Generate the Write Strobes for the MMap Write Data Channel
        -- for the Indeterminate BTT case. Strobes come from the Stream
        -- input from the Indeterminate BTT module during normal operation.
        -- However, during soft shutdown, those strobes become unpredictable
        -- so generated strobes have to be used.
        data2skid_wstrb <=  sig_halt_strb
          When (sig_halt_reg = '1')
        
          Else s2mm_strm_wstrb;
          
          
          
        -- Generate the Stream Ready for the Stream input side
        sig_s2mm_strm_wready <=  sig_halt_reg             or -- force tready if a halt requested
                                 (sig_mmap2data_ready    and -- MMap is accepting the xfers
                                 sig_addr_chan_rdy       and -- xfers are commited on the address channel and 
                                 sig_dqual_rdy           and -- there are commands in the command fifo        
                                 not(sig_calc_error_reg) and -- No internal error                             
                                 not(sig_stop_wvalid));      -- Gate off stream ready immediately after a wlast for 1 clk
                                                             -- or when the soft shutdown has completed
         
        
        -- MMap Write Data Channel Valid Handshaking
        sig_data2mmap_valid <= (s2mm_strm_wvalid        or -- Normal Stream input valid       
                               sig_halt_reg       )    and -- force valid if halt requested       
                               sig_addr_chan_rdy       and -- xfers are commited on the address channel and       
                               sig_dqual_rdy           and -- there are commands in the command fifo        
                               not(sig_calc_error_reg) and -- No internal error
                               not(sig_stop_wvalid);       -- Gate off wvalid immediately after a wlast for 1 clk
                                                           -- or when the soft shutdown has completed
              
      
         
        -- TLAST Error housekeeping for Indeterminate BTT Mode
        -- There is no Underrun/overrun in Stroe and Forward mode 
         
        sig_tlast_error_ovrrun  <= '0'; -- Not used with Indeterminate BTT
        sig_tlast_error_undrrun <= '0'; -- Not used with Indeterminate BTT
        sig_end_stbs_match_err  <= '0'; -- Not used with Indeterminate BTT
        sig_tlast_error         <= '0'; -- Not used with Indeterminate BTT
        sig_tlast_error_reg     <= '0'; -- Not used with Indeterminate BTT
        sig_tlast_err_stop      <= '0'; -- Not used with Indeterminate BTT
        
        
        
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_EOP_REG_FLOP
        --
        -- Process Description:
        --  Register the End of Packet marker.
        --
        -------------------------------------------------------------
        IMP_EOP_REG_FLOP : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (mmap_reset = '1') then
        
                 lsig_end_of_cmd_reg <= '0';
                 lsig_eop_reg        <= '0';
               
               
               Elsif (sig_good_strm_dbeat = '1') Then
               
        
                 lsig_end_of_cmd_reg <= sig_next_cmd_cmplt_reg and
                                        s2mm_strm_wlast;
                 
                 lsig_eop_reg        <= s2mm_strm_eop;
               
               else

                 null; -- hold current state  
                   
               end if; 
            end if;       
          end process IMP_EOP_REG_FLOP; 
        
        
        
        
 
        -----  Byte Counter Logic -----------------------------------------------
        -- The Byte counter reflects the actual byte count received on the 
        -- Stream input for each parent command loaded into the S2MM command
        -- FIFO. Thus it counts input bytes until the command complete qualifier
        -- is set and the TLAST input from the Stream input.
      
      
        lsig_clr_byte_cntr        <= lsig_end_of_cmd_reg and   -- Clear if a new stream packet does not start 
                                     not(sig_good_strm_dbeat); -- immediately after the previous one finished.    
        
     
        lsig_ld_byte_cntr         <= lsig_end_of_cmd_reg and -- Only load if a new stream packet starts       
                                     sig_good_strm_dbeat;    -- immediately after the previous one finished.       
        
        lsig_incr_byte_cntr       <= sig_good_strm_dbeat; 
        
        
        lsig_byte_cntr_incr_value <=  RESIZE(UNSIGNED(s2mm_stbs_asserted), 
                                                       BYTE_CNTR_WIDTH);
     
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_BYTE_CMTR
        --
        -- Process Description:
        -- Keeps a running byte count per burst packet loaded into the 
        -- xfer FIFO. It is based on the strobes set on the incoming
        -- Stream dbeat.
        --
        -------------------------------------------------------------
        IMP_BYTE_CMTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
               if (mmap_reset         = '1' or
                   lsig_clr_byte_cntr = '1') then 

                 lsig_byte_cntr <= (others => '0');
                 
               elsif (lsig_ld_byte_cntr = '1') then

                 lsig_byte_cntr <= lsig_byte_cntr_incr_value;
                 
               elsif (lsig_incr_byte_cntr = '1') then

                 lsig_byte_cntr <= lsig_byte_cntr + lsig_byte_cntr_incr_value;
                 
               else
                 null;  -- hold current value
               end if; 
             end if;       
           end process IMP_BYTE_CMTR; 
     
     
        
 
   
      end generate GEN_INDET_BTT;
   
   
    
    
    
    
    
    
              
    
    -- Internal logic ------------------------------
    
    sig_good_mmap_dbeat  <= sig_mmap2data_ready and 
                            sig_data2mmap_valid;
    
    
    sig_last_mmap_dbeat  <= sig_good_mmap_dbeat and 
                            sig_data2mmap_last;
     
     
    sig_get_next_dqual   <= sig_last_mmap_dbeat; 
    
    
    
    
    
    
         
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_LAST_DBEAT
    --
    -- Process Description:
    --   This implements a FLOP that creates a pulse
    -- indicating the LAST signal for an outgoing write data channel
    -- has been sent. Note that it is possible to have back to 
    -- back LAST databeats.
    --
    -------------------------------------------------------------
    REG_LAST_DBEAT : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then

             sig_last_mmap_dbeat_reg <= '0';
             
           else
             
             sig_last_mmap_dbeat_reg <= sig_last_mmap_dbeat;
             
           end if; 
         end if;       
       end process REG_LAST_DBEAT; 
  
 
 
 
 
    
    
    -----  Write Status Interface Stuff --------------------------
    
    sig_push_to_wsc_cmplt <= sig_push_to_wsc and sig_wsc_ready;
    
    
    sig_set_push2wsc      <= (sig_good_mmap_dbeat and
                             sig_dbeat_cntr_eq_0) or
                             sig_push_err2wsc     or
                             sig_spcl_push_err2wsc;   -- Special case from CR616212
                             
    
    
    
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_INTERR_PUSH_FLOP
    --
    -- Process Description:
    -- Generate a 1 clock wide pulse when a calc error has propagated
    -- from the Command Calculator. This pulse is used to force a 
    -- push of the error status to the Write Status Controller
    -- without a AXI transfer completion.
    --
    -------------------------------------------------------------
    IMP_INTERR_PUSH_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset       = '1' or
                sig_push_err2wsc = '1') then
              sig_push_err2wsc <= '0';
            elsif (sig_ld_new_cmd_reg = '1' and
                   sig_calc_error_reg = '1') then
              sig_push_err2wsc <= '1';
            else
              null; -- hold state
            end if; 
         end if;       
       end process IMP_INTERR_PUSH_FLOP; 
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_PUSH2WSC_FLOP
    --
    -- Process Description:
    -- Implements a Sample and hold register for the outbound status
    -- signals to the Write Status Controller (WSC). This register
    -- has to support back to back transfer completions.
    --
    -------------------------------------------------------------
    IMP_PUSH2WSC_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset             = '1'  or
               (sig_push_to_wsc_cmplt = '1'  and
                sig_set_push2wsc      = '0')) then
              
              sig_push_to_wsc        <= '0';
              sig_data2wsc_tag       <=  (others => '0');
              sig_data2wsc_calc_err  <=  '0';
              sig_data2wsc_last_err  <=  '0';
              sig_data2wsc_cmd_cmplt <=  '0';
              
            elsif (sig_set_push2wsc   = '1' and 
                   sig_tlast_err_stop = '0') then
              
              sig_push_to_wsc        <= '1';
              sig_data2wsc_tag       <= sig_tag_reg          ;
              sig_data2wsc_calc_err  <= sig_calc_error_reg   ;
              sig_data2wsc_last_err  <= sig_tlast_error_reg or 
                                        sig_tlast_error      ;
              sig_data2wsc_cmd_cmplt <= sig_cmd_cmplt_reg   or 
                                        sig_tlast_error_reg or
                                        sig_tlast_error      ;
              
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process IMP_PUSH2WSC_FLOP; 
     
  
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_LD_NEW_CMD_REG
    --
    -- Process Description:
    -- Registers the flag indicating a new command has been 
    -- loaded. Needs to be a 1 clk wide pulse.
    --
    -------------------------------------------------------------
    IMP_LD_NEW_CMD_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1' or
                sig_ld_new_cmd_reg = '1') then
              sig_ld_new_cmd_reg <= '0';
            else
              sig_ld_new_cmd_reg <= sig_ld_new_cmd;
            end if; 
         end if;       
       end process IMP_LD_NEW_CMD_REG; 
    
    
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_NXT_LEN_REG
    --
    -- Process Description:
    -- Registers the load control and length value for a command 
    -- passed to the WDC input command interface. The registered
    -- signals are used for the external Indeterminate BTT support
    -- ports.
    --
    -------------------------------------------------------------
    IMP_NXT_LEN_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1') then

              sig_s2mm_ld_nxt_len <= '0';
              sig_s2mm_wr_len     <= (others => '0');
              
            else
              sig_s2mm_ld_nxt_len <= mstr2data_cmd_valid and
                                     sig_data2mstr_cmd_ready;
              sig_s2mm_wr_len     <= mstr2data_len;
                                     
                                     
            end if; 
         end if;       
       end process IMP_NXT_LEN_REG; 
    
    
    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_DATA_CNTL_FIFO
    --
    -- If Generate Description:
     --   Omits the input data control FIFO if the requested FIFO
     -- depth is 1. The Data Qualifier Register serves as a 
     -- 1 deep FIFO by itself.
    --
    ------------------------------------------------------------
    GEN_NO_DATA_CNTL_FIFO : if (C_DATA_CNTL_FIFO_DEPTH = 1) generate
    
       
      begin

        -- Command Calculator Handshake output
        sig_data2mstr_cmd_ready <= sig_fifo_wr_cmd_ready;           
       
        sig_fifo_rd_cmd_valid   <= mstr2data_cmd_valid ;
        
        
        
        -- pre 13.1 sig_fifo_wr_cmd_ready  <= sig_dqual_reg_empty     and                                         
        -- pre 13.1                           sig_aposted_cntr_ready  and                                         
        -- pre 13.1                           not(wsc2mstr_halt_pipe) and -- The Wr Status Controller is not stalling
        -- pre 13.1                           not(sig_calc_error_reg);    -- the command execution pipe and there is  
        -- pre 13.1                                                       -- no calculation error being propagated    
        
        sig_fifo_wr_cmd_ready  <= sig_push_dqual_reg;
        
                                                              
        
        sig_fifo_next_tag         <= mstr2data_tag        ;    
        sig_fifo_next_sadddr_lsb  <= mstr2data_saddr_lsb  ;    
        sig_fifo_next_len         <= mstr2data_len        ;    
        sig_fifo_next_strt_strb   <= mstr2data_strt_strb  ;    
        sig_fifo_next_last_strb   <= mstr2data_last_strb  ;    
        sig_fifo_next_drr         <= mstr2data_drr        ;    
        sig_fifo_next_eof         <= mstr2data_eof        ;    
        sig_fifo_next_sequential  <= mstr2data_sequential ;    
        sig_fifo_next_cmd_cmplt   <= mstr2data_cmd_cmplt  ;    
        sig_fifo_next_calc_error  <= mstr2data_calc_error ;    
                                                             
             
   
      end generate GEN_NO_DATA_CNTL_FIFO;
  
  
 
    
    
    
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_DATA_CNTL_FIFO
     --
     -- If Generate Description:
     --   Includes the input data control FIFO if the requested 
     -- FIFO depth is more than 1.
     --
     ------------------------------------------------------------
     GEN_DATA_CNTL_FIFO : if (C_DATA_CNTL_FIFO_DEPTH > 1) generate

       begin

       
         -- Command Calculator Handshake output
         sig_data2mstr_cmd_ready  <= sig_fifo_wr_cmd_ready;           
         
         sig_fifo_wr_cmd_valid    <= mstr2data_cmd_valid  ;
         
         
         -- pop the fifo when dqual reg is pushed
         sig_fifo_rd_cmd_ready    <= sig_push_dqual_reg;     
                                                               

         
         
                              
         -- Format the input fifo data word
         sig_cmd_fifo_data_in  <=   mstr2data_calc_error &
                                    mstr2data_cmd_cmplt  &
                                    mstr2data_sequential &
                                    mstr2data_eof        &
                                    mstr2data_drr        &
                                    mstr2data_last_strb  &
                                    mstr2data_strt_strb  &
                                    mstr2data_len        &
                                    mstr2data_saddr_lsb  &
                                    mstr2data_tag ;
         
          
         -- Rip the output fifo data word
         sig_fifo_next_tag        <= sig_cmd_fifo_data_out((TAG_STRT_INDEX+TAG_WIDTH)-1 downto 
                                                            TAG_STRT_INDEX);                   
         sig_fifo_next_sadddr_lsb <= sig_cmd_fifo_data_out((SADDR_LSB_STRT_INDEX+SADDR_LSB_WIDTH)-1 downto 
                                                            SADDR_LSB_STRT_INDEX);
         sig_fifo_next_len        <= sig_cmd_fifo_data_out((LEN_STRT_INDEX+LEN_WIDTH)-1 downto 
                                                            LEN_STRT_INDEX);
         sig_fifo_next_strt_strb  <= sig_cmd_fifo_data_out((STRT_STRB_STRT_INDEX+STRB_WIDTH)-1 downto 
                                                            STRT_STRB_STRT_INDEX);
         sig_fifo_next_last_strb  <= sig_cmd_fifo_data_out((LAST_STRB_STRT_INDEX+STRB_WIDTH)-1 downto 
                                                            LAST_STRB_STRT_INDEX);
         sig_fifo_next_drr        <= sig_cmd_fifo_data_out(DRR_STRT_INDEX);
         sig_fifo_next_eof        <= sig_cmd_fifo_data_out(EOF_STRT_INDEX);
         sig_fifo_next_sequential <= sig_cmd_fifo_data_out(SEQUENTIAL_STRT_INDEX);
         sig_fifo_next_cmd_cmplt  <= sig_cmd_fifo_data_out(CMD_CMPLT_STRT_INDEX);
         sig_fifo_next_calc_error <= sig_cmd_fifo_data_out(CALC_ERR_STRT_INDEX);

         
         
         
         ------------------------------------------------------------
         -- Instance: I_DATA_CNTL_FIFO 
         --
         -- Description:
         -- Instance for the Command Qualifier FIFO
         --
         ------------------------------------------------------------
          I_DATA_CNTL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (
        
            C_DWIDTH             =>  DCTL_FIFO_WIDTH        , 
            C_DEPTH              =>  C_DATA_CNTL_FIFO_DEPTH , 
            C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
            C_PRIM_TYPE          =>  FIFO_PRIM_TYPE         , 
            C_FAMILY             =>  C_FAMILY                 
           
            )
          port map (
            
            -- Write Clock and reset
            fifo_wr_reset        =>   mmap_reset            , 
            fifo_wr_clk          =>   primary_aclk          , 
            
            -- Write Side
            fifo_wr_tvalid       =>   sig_fifo_wr_cmd_valid , 
            fifo_wr_tready       =>   sig_fifo_wr_cmd_ready , 
            fifo_wr_tdata        =>   sig_cmd_fifo_data_in  , 
            fifo_wr_full         =>   open                  , 
           
           
            -- Read Clock and reset
            fifo_async_rd_reset  =>   mmap_reset            ,   
            fifo_async_rd_clk    =>   primary_aclk          , 
            
            -- Read Side
            fifo_rd_tvalid       =>   sig_fifo_rd_cmd_valid , 
            fifo_rd_tready       =>   sig_fifo_rd_cmd_ready , 
            fifo_rd_tdata        =>   sig_cmd_fifo_data_out , 
            fifo_rd_empty        =>   sig_cmd_fifo_empty      
           
            );
        

       end generate GEN_DATA_CNTL_FIFO;
         
          
    
   
  
  
  
  
  
    -- Data Qualifier Register ------------------------------------
    
    
    sig_ld_new_cmd           <= sig_push_dqual_reg              ;
    sig_dqual_rdy            <= sig_dqual_reg_full              ;
    sig_strt_strb_reg        <= sig_next_strt_strb_reg          ;
    sig_last_strb_reg        <= sig_next_last_strb_reg          ;
    sig_tag_reg              <= sig_next_tag_reg                ;
    sig_cmd_cmplt_reg        <= sig_next_cmd_cmplt_reg          ;
    sig_calc_error_reg       <= sig_next_calc_error_reg         ;
    
    sig_cmd_is_eof           <= sig_next_eof_reg                ;
    
    
    
    -- new for no bubbles between child requests
    sig_sequential_push      <= sig_good_mmap_dbeat and -- MMap handshake qualified
                                sig_last_dbeat      and -- last data beat of transfer
                                sig_next_sequential_reg;-- next queued command is sequential 
                                                        -- to the current command
    
    
    -- pre 13.1 sig_push_dqual_reg        <= (sig_sequential_push   or
    -- pre 13.1                               sig_dqual_reg_empty)  and 
    -- pre 13.1                              sig_fifo_rd_cmd_valid  and
    -- pre 13.1                              sig_aposted_cntr_ready and 
    -- pre 13.1                              not(wsc2mstr_halt_pipe);  -- The Wr Status Controller is not     
    -- pre 13.1                                                        -- stalling the command execution pipe 

    
    sig_push_dqual_reg       <= (sig_sequential_push    or
                                 sig_dqual_reg_empty)   and 
                                sig_fifo_rd_cmd_valid   and
                                sig_aposted_cntr_ready  and 
                                not(sig_calc_error_reg) and -- 13.1 addition => An error has not been propagated
                                not(wsc2mstr_halt_pipe);    -- The Wr Status Controller is not  
                                                            -- stalling the command execution pipe
                                                        







                                                         
    sig_pop_dqual_reg         <= not(sig_next_calc_error_reg) and 
                                 sig_get_next_dqual and 
                                 sig_dqual_reg_full  ; 
    
  
    -- new for no bubbles between child requests
    sig_clr_dqual_reg        <=  mmap_reset         or
                                 (sig_pop_dqual_reg and
                                 not(sig_push_dqual_reg));
  
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_DQUAL_REG
    --
    -- Process Description:
    --    This process implements a register for the Data 
    -- Control and qualifiers. It operates like a 1 deep Sync FIFO.
    --
    -------------------------------------------------------------
    IMP_DQUAL_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_clr_dqual_reg = '1') then
              
              sig_next_tag_reg         <= (others => '0');
              sig_next_strt_strb_reg   <= (others => '0');
              sig_next_last_strb_reg   <= (others => '0');
              sig_next_eof_reg         <= '0'            ;
              sig_next_sequential_reg  <= '0'            ;
              sig_next_cmd_cmplt_reg   <= '0'            ;
              sig_next_calc_error_reg  <= '0'            ;
                                                        
              sig_dqual_reg_empty      <= '1'            ;
              sig_dqual_reg_full       <= '0'            ;
                                                        
            elsif (sig_push_dqual_reg = '1') then
              
              sig_next_tag_reg        <= sig_fifo_next_tag         ;
              sig_next_strt_strb_reg  <= sig_sfhalt_next_strt_strb ;
              sig_next_last_strb_reg  <= sig_fifo_next_last_strb   ;
              sig_next_eof_reg        <= sig_fifo_next_eof         ;
              sig_next_sequential_reg <= sig_fifo_next_sequential  ;
              sig_next_cmd_cmplt_reg  <= sig_fifo_next_cmd_cmplt   ;
              sig_next_calc_error_reg <= sig_fifo_next_calc_error  ;
              
              sig_dqual_reg_empty     <= '0';
              sig_dqual_reg_full      <= '1';
              
            else
              null;  -- don't change state
            end if; 
         end if;       
       end process IMP_DQUAL_REG; 
     

  
  
  
    
    
    -- Address LS Cntr logic  --------------------------
   
    sig_addr_lsb_reg         <= STD_LOGIC_VECTOR(sig_ls_addr_cntr);
    sig_addr_incr_unsgnd     <= TO_UNSIGNED(ADDR_INCR_VALUE, C_SEL_ADDR_WIDTH);
    sig_incr_ls_addr_cntr    <= sig_good_mmap_dbeat;
    
   
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: DO_ADDR_LSB_CNTR
    --
    -- Process Description:
    --  Implements the LS Address Counter used for controlling
    -- the Write STRB  DeMux during Burst transfers
    --
    -------------------------------------------------------------
    DO_ADDR_LSB_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1' or
               (sig_pop_dqual_reg  = '1'and
                sig_push_dqual_reg = '0')) then                 -- Clear the Counter
              
              sig_ls_addr_cntr <= (others => '0');
            
            elsif (sig_push_dqual_reg = '1') then               -- Load the Counter
              
              sig_ls_addr_cntr <= unsigned(sig_fifo_next_sadddr_lsb);
            
            elsif (sig_incr_ls_addr_cntr = '1') then            -- Increment the Counter
              
              sig_ls_addr_cntr <= sig_ls_addr_cntr + sig_addr_incr_unsgnd;
            
            else
              null;  -- Hold Current value
            end if; 
         end if;       
       end process DO_ADDR_LSB_CNTR; 
    
    
    
    
    
    
    
    
    
    
    
    
   -- Address Posted Counter Logic --------------------------------------
   
    sig_addr_chan_rdy         <= not(sig_addr_posted_cntr_eq_0 or 
                                     sig_apc_going2zero)         ; -- Gates data channel xfer handshake
    
    sig_aposted_cntr_ready    <= not(sig_addr_posted_cntr_max)   ; -- Gates new command fetching
    
    sig_no_posted_cmds        <= sig_addr_posted_cntr_eq_0       ; -- Used for flushing cmds that are posted
    
 
 
 
    
    sig_incr_addr_posted_cntr <= sig_addr_posted         ;
    
    sig_decr_addr_posted_cntr <= sig_last_mmap_dbeat_reg ;
    
    sig_addr_posted_cntr_eq_0 <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_ZERO)
      Else '0';
    
    sig_addr_posted_cntr_max <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_MAX)
      Else '0';
    
    
    sig_addr_posted_cntr_eq_1 <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_ONE)
      Else '0';
    
    sig_apc_going2zero  <= sig_addr_posted_cntr_eq_1 and
                           sig_decr_addr_posted_cntr and
                           not(sig_incr_addr_posted_cntr);
    
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ADDR_POSTED_FIFO_CNTR
    --
    -- Process Description:
    --    This process implements a counter for the tracking  
    -- if an Address has been posted on the AXI address channel.
    -- The Data Controller must wait for an address to be posted
    -- before proceeding with the corresponding data transfer on
    -- the Data Channel. The counter is also used to track flushing
    -- operations where all transfers commited on the  AXI Address
    -- Channel have to be completed before a halt can occur.
    -------------------------------------------------------------
    IMP_ADDR_POSTED_FIFO_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_addr_posted_cntr <= ADDR_POSTED_ZERO;
              
            elsif (sig_incr_addr_posted_cntr = '1' and
                   sig_decr_addr_posted_cntr = '0' and
                   sig_addr_posted_cntr_max  = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr + ADDR_POSTED_ONE ;
              
            elsif (sig_incr_addr_posted_cntr = '0' and
                   sig_decr_addr_posted_cntr = '1' and
                   sig_addr_posted_cntr_eq_0 = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr - ADDR_POSTED_ONE ;
              
            else
              null;  -- don't change state
            end if; 
         end if;       
       end process IMP_ADDR_POSTED_FIFO_CNTR; 
 
 
      
      
      
    ------- First/Middle/Last Dbeat detimination -------------------
     
     sig_new_len_eq_0 <= '1'
       When  (sig_fifo_next_len = LEN_OF_ZERO)
       else '0';
     
     
      
      
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: DO_FIRST_MID_LAST
     --
     -- Process Description:
     --  Implements the detection of the First/Mid/Last databeat of
     -- a transfer.
     --
     -------------------------------------------------------------
     DO_FIRST_MID_LAST : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (mmap_reset = '1') then
               
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '0';
               sig_single_dbeat  <= '0';
             
             elsif (sig_ld_new_cmd = '1') then
               
               sig_first_dbeat   <= not(sig_new_len_eq_0);
               sig_last_dbeat    <= sig_new_len_eq_0;
               sig_single_dbeat  <= sig_new_len_eq_0;
             
             Elsif (sig_dbeat_cntr_eq_1 = '1' and
                    sig_good_mmap_dbeat = '1') Then
             
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '1';
               sig_single_dbeat  <= '0';
             
             Elsif (sig_dbeat_cntr_eq_0 = '0' and
                    sig_dbeat_cntr_eq_1 = '0' and
                    sig_good_mmap_dbeat = '1') Then
             
               sig_first_dbeat   <= '0';
               sig_last_dbeat    <= '0';
               sig_single_dbeat  <= '0';
             
             else
               null; -- hold current state
             end if; 
          end if;       
        end process DO_FIRST_MID_LAST; 
    
    
   
   
   
   -------  Data Controller Halted Indication ------------------------------- 
    
 
    data2all_dcntlr_halted <= sig_no_posted_cmds or
                              sig_calc_error_reg;
 
 
    
    
       
       
       
       
       
       
    
    
   -------  Data Beat counter logic ------------------------------- 
    
    
    
    
    
    sig_dbeat_cntr_int  <= TO_INTEGER(sig_dbeat_cntr);
    
    sig_dbeat_cntr_eq_0 <= '1'
      when (sig_dbeat_cntr_int = 0)
      Else '0';
    
    sig_dbeat_cntr_eq_1 <= '1'
      when (sig_dbeat_cntr_int = 1)
      Else '0';
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: DO_DBEAT_CNTR
    --
    -- Process Description:
    -- Implements the transfer data beat counter used to track 
    -- progress of the transfer.
    --
    -------------------------------------------------------------
    DO_DBEAT_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              sig_dbeat_cntr <= (others => '0');
            elsif (sig_ld_new_cmd = '1') then
              sig_dbeat_cntr <= unsigned(sig_fifo_next_len);
            Elsif (sig_good_mmap_dbeat = '1' and
                   sig_dbeat_cntr_eq_0 = '0') Then
              sig_dbeat_cntr <= sig_dbeat_cntr-1;
            else
              null; -- Hold current state
            end if; 
         end if;       
       end process DO_DBEAT_CNTR; 
  
  
  
  
  
  
  
  
  
  
  
  
   -------  Soft Shutdown Logic ------------------------------- 
    
    
    
    
    
    -- Formulate the soft shutdown complete flag
    sig_data2rst_stop_cmplt  <= (sig_halt_reg_dly3        and   -- Normal Mode shutdown
                                 sig_no_posted_cmds       and 
                                 not(sig_calc_error_reg)) or
                                (sig_halt_reg_dly3  and         -- Shutdown after error trap
                                 sig_calc_error_reg);
    
    
              
    
    -- Generate a gate signal to deassert the WVALID output
    -- for 1 clock cycle after a WLAST is issued. This only 
    -- occurs when in soft shutdown mode. 
    sig_stop_wvalid  <= (sig_last_mmap_dbeat_reg and
                        sig_halt_reg) or
                        sig_data2rst_stop_cmplt;
  
  
    
    
    
    -- Assign the output port skid buf control for the
    -- input Stream skid buffer
    data2skid_halt      <= sig_data2skid_halt;
    
    -- Create a 1 clock wide pulse to tell the input
    -- stream skid buffer to shut down.
    sig_data2skid_halt  <=  sig_halt_reg_dly2 and 
                            not(sig_halt_reg_dly3);
    
    
  
  
     
     
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG
    --
    -- Process Description:
    --   Implements the flop for capturing the Halt request from 
    -- the Reset module.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg      <= '0';
            
            elsif (rst2data_stop_request = '1') then
              
              sig_halt_reg <= '1';
            
            else
              null;  -- Hold current State
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG; 
  
  
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG_DLY
    --
    -- Process Description:
    --   Implements the flops for delaying the halt request by 3
    -- clocks to allow the Address Controller to halt before the
    -- Data Contoller can safely indicate it has exhausted all
    -- transfers committed to the AXI Address Channel by the Address
    -- Controller.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG_DLY : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg_dly1 <= '0';
              sig_halt_reg_dly2 <= '0';
              sig_halt_reg_dly3 <= '0';
            
            else
              
              sig_halt_reg_dly1 <= sig_halt_reg;
              sig_halt_reg_dly2 <= sig_halt_reg_dly1;
              sig_halt_reg_dly3 <= sig_halt_reg_dly2;
            
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG_DLY; 
  
  
   
    
    
    
    
    
    
 
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_wr_status_cntl.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_wr_status_cntl.vhd
  --
  -- Description:     
  --    This file implements the DataMover Master Write Status Controller.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_fifo;
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_wr_status_cntl is
    generic (
      
      C_ENABLE_INDET_BTT     : Integer range  0 to   1 :=  0;
        -- Specifies if the Indeterminate BTT Module is enabled
        -- for use (outside of this module)
      
      C_SF_BYTES_RCVD_WIDTH  : Integer range  1 to  26 :=  1;
        -- Sets the width of the data2wsc_bytes_rcvd port used for 
        -- relaying the actual number of bytes received when Idet BTT is 
        -- enabled (C_ENABLE_INDET_BTT = 1)
      
      C_STS_FIFO_DEPTH       : Integer range  1 to  32 :=  8;
        -- Specifies the depth of the internal status queue fifo
      
      C_STS_WIDTH            : Integer range  8 to  35 :=  8;
        -- sets the width of the Status ports
      
      C_TAG_WIDTH            : Integer range  1 to 8   :=  4;
        -- Sets the width of the Tag field in the Status reply
      C_MCDMA                : integer range 0 to 1 := 0;
      
      C_FAMILY               : String                  := "virtex7"
        -- Specifies the target FPGA device family
      
      
      );
    port (
      
      -- Clock and Reset inputs ------------------------------------------
                                                                        --
      primary_aclk         : in  std_logic;                             --
         -- Primary synchronization clock for the Master side           --
         -- interface and internal logic. It is also used               --
         -- for the User interface synchronization when                 --
         -- C_STSCMD_IS_ASYNC = 0.                                      --
                                                                        --
      -- Reset input                                                    --
      mmap_reset           : in  std_logic;                             --
         -- Reset used for the internal master logic                    --
      --------------------------------------------------------------------
      

     
      
      -- Soft Shutdown Control interface  --------------------------------
                                                                        --
      rst2wsc_stop_request : in  std_logic;                             --
         -- Active high soft stop request to modules                    --
                                                                        --
      wsc2rst_stop_cmplt   : Out std_logic;                             --
        -- Active high indication that the Write status Controller      --
        -- has completed any pending transfers committed by the         --
        -- Address Controller after a stop has been requested by        --
        -- the Reset module.                                            --
                                                                        --
      addr2wsc_addr_posted : In std_logic ;                             --
         -- Indication from the Address Channel Controller to the       --
         -- write Status Controller that an address has been posted     --
         -- to the AXI Address Channel                                  --
      --------------------------------------------------------------------


     
     
      --  Write Response Channel Interface -------------------------------
                                                                        --
      s2mm_bresp          : In std_logic_vector(1 downto 0);            --
         -- The Write response value                                    --
                                                                        --
      s2mm_bvalid         : In std_logic ;                              --
         -- Indication from the Write Response Channel that a new       --
         -- write status input is valid                                 --
                                                                        --
      s2mm_bready         : out std_logic ;                             --
         -- Indication to the Write Response Channel that the           --
         -- Status module is ready for a new status input               --
      --------------------------------------------------------------------


       
       
      -- Command Calculator Interface -------------------------------------
                                                                         --
      calc2wsc_calc_error    : in std_logic ;                            --
         -- Indication from the Command Calculator that a calculation    --
         -- error has occured.                                           --
      ---------------------------------------------------------------------
     
     
      
        
      -- Address Controller Status ----------------------------------------
                                                                         --
      addr2wsc_calc_error    : In std_logic ;                            --
         -- Indication from the Address Channel Controller that it       --
         -- has encountered a calculation error from the command         --
         -- Calculator                                                   --
                                                                         --
      addr2wsc_fifo_empty    : In std_logic ;                            --
         -- Indication from the Address Controller FIFO that it          --
         -- is empty (no commands pending)                               --
      ---------------------------------------------------------------------

                    
                    
                    
      --  Data Controller Status ---------------------------------------------------------
                                                                                        --
      data2wsc_tag           : In std_logic_vector(C_TAG_WIDTH-1 downto 0);             --
         -- The command tag                                                             --
                                                                                        --
      data2wsc_calc_error    : In std_logic ;                                           --
         -- Indication from the Data Channel Controller FIFO that it                    --
         -- has encountered a Calculation error in the command pipe                     --
                                                                                        --
      data2wsc_last_error    : In std_logic ;                                           --
         -- Indication from the Write Data Channel Controller that a                    --
         -- premature TLAST assertion was encountered on the incoming                   --
         -- Stream Channel                                                              --
                                                                                        --
      data2wsc_cmd_cmplt    : In std_logic ;                                            --
         -- Indication from the Data Channel Controller that the                        --
         -- corresponding status is the final status for a parent                       --
         -- command fetched from the command FIFO                                       --
                                                                                        --
      data2wsc_valid         : In std_logic ;                                           --
         -- Indication from the Data Channel Controller FIFO that it                    --
         -- has a new tag/error status to transfer                                      --
                                                                                        --
      wsc2data_ready         : out std_logic ;                                          --
         -- Indication to the Data Channel Controller FIFO that the                     --
         -- Status module is ready for a new tag/error status input                     --
                                                                                        --
                                                                                        --
      data2wsc_eop           : In  std_logic;                                           --
         -- Input from the Write Data Controller indicating that the                    --
         -- associated command status also corresponds to a End of Packet               --
         -- marker for the input Stream. This is only used when Store and               --
         -- Forward is enabled in the S2MM.                                             --
                                                                                        --
      data2wsc_bytes_rcvd    : In  std_logic_vector(C_SF_BYTES_RCVD_WIDTH-1 downto 0);  --
         -- Input from the Write Data Controller indicating the actual                  --
         -- number of bytes received from the Stream input for the                      --
         -- corresponding command status. This is only used when Store and              --
         -- Forward is enabled in the S2MM.                                             --
      ------------------------------------------------------------------------------------
      
      
      
      -- Command/Status Interface --------------------------------------------------------
                                                                                        --
      wsc2stat_status       : Out std_logic_vector(C_STS_WIDTH-1 downto 0);             --
         -- Read Status value collected during a Read Data transfer                     --
         -- Output to the Command/Status Module                                         --
                                                                                        --
      stat2wsc_status_ready : In  std_logic;                                            --
         -- Input from the Command/Status Module indicating that the                    --
         -- Status Reg/FIFO is Full and cannot accept more staus writes                 --
                                                                                        --
      wsc2stat_status_valid : Out std_logic ;                                           --
         -- Control Signal to Write the Status value to the Status                      --
         -- Reg/FIFO                                                                    --
      ------------------------------------------------------------------------------------

  
                                                                             
                                                                             
      -- Address and Data Controller Pipe halt --------------------------------
                                                                             --
      wsc2mstr_halt_pipe    : Out std_logic                                  --
         -- Indication to Halt the Data and Address Command pipeline due     --
         -- to the Status pipe getting full at some point                    --
      -------------------------------------------------------------------------

  
      );
  
  end entity axi_datamover_wr_status_cntl;
  
  
  architecture implementation of axi_datamover_wr_status_cntl is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

 
 
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_set_cnt_width
    --
    -- Function Description:
    --    Sets a count width based on a fifo depth. A depth of 4 or less
    -- is a special case which requires a minimum count width of 3 bits.
    --
    -------------------------------------------------------------------
    function funct_set_cnt_width (fifo_depth : integer) return integer is
    
      Variable temp_cnt_width : Integer := 4;
    
    begin
    
      
      if (fifo_depth <= 4) then
      
         temp_cnt_width := 3;
      
      elsif (fifo_depth <= 8) then
      
         temp_cnt_width := 4;
      
      elsif (fifo_depth <= 16) then
      
         temp_cnt_width := 5;
      
      elsif (fifo_depth <= 32) then
      
         temp_cnt_width := 6;
      
      else  -- fifo depth <= 64
      
         temp_cnt_width := 7;
      
      end if;
      
      Return (temp_cnt_width);
       
       
    end function funct_set_cnt_width;
    
 
 
 
  
    -- Constant Declarations  --------------------------------------------
    
    Constant OKAY                   : std_logic_vector(1 downto 0) := "00";
    Constant EXOKAY                 : std_logic_vector(1 downto 0) := "01";
    Constant SLVERR                 : std_logic_vector(1 downto 0) := "10";
    Constant DECERR                 : std_logic_vector(1 downto 0) := "11";
    Constant STAT_RSVD              : std_logic_vector(3 downto 0) := "0000";
    Constant TAG_WIDTH              : integer := C_TAG_WIDTH;
    Constant STAT_REG_TAG_WIDTH     : integer := 4;
    Constant SYNC_FIFO_SELECT       : integer := 0;
    Constant SRL_FIFO_TYPE          : integer := 2;
    Constant DCNTL_SFIFO_DEPTH      : integer := C_STS_FIFO_DEPTH;
    Constant DCNTL_STATCNT_WIDTH    : integer := funct_set_cnt_width(C_STS_FIFO_DEPTH);-- bits
    Constant DCNTL_HALT_THRES       : unsigned(DCNTL_STATCNT_WIDTH-1 downto 0) := 
                                      TO_UNSIGNED(DCNTL_SFIFO_DEPTH-2,DCNTL_STATCNT_WIDTH);
    Constant DCNTL_STATCNT_ZERO     : unsigned(DCNTL_STATCNT_WIDTH-1 downto 0) := (others => '0');
    Constant DCNTL_STATCNT_MAX      : unsigned(DCNTL_STATCNT_WIDTH-1 downto 0) := 
                                      TO_UNSIGNED(DCNTL_SFIFO_DEPTH,DCNTL_STATCNT_WIDTH);
    Constant DCNTL_STATCNT_ONE      : unsigned(DCNTL_STATCNT_WIDTH-1 downto 0) := 
                                      TO_UNSIGNED(1, DCNTL_STATCNT_WIDTH);
    Constant WRESP_WIDTH            : integer := 2;
    Constant WRESP_SFIFO_WIDTH      : integer := WRESP_WIDTH;
    Constant WRESP_SFIFO_DEPTH      : integer := DCNTL_SFIFO_DEPTH;
    
    Constant ADDR_POSTED_CNTR_WIDTH : integer := funct_set_cnt_width(C_STS_FIFO_DEPTH);-- bits 
    
    
    Constant ADDR_POSTED_ZERO       : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := (others => '0');
    Constant ADDR_POSTED_ONE        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := TO_UNSIGNED(1, ADDR_POSTED_CNTR_WIDTH);
    Constant ADDR_POSTED_MAX        : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) 
                                      := (others => '1');
    
    
    -- Signal Declarations  --------------------------------------------
    
    signal sig_valid_status_rdy      : std_logic := '0';
    signal sig_decerr                : std_logic := '0';
    signal sig_slverr                : std_logic := '0';
    signal sig_coelsc_okay_reg       : std_logic := '0';
    signal sig_coelsc_interr_reg     : std_logic := '0';
    signal sig_coelsc_decerr_reg     : std_logic := '0';
    signal sig_coelsc_slverr_reg     : std_logic := '0';
    signal sig_coelsc_tag_reg        : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_pop_coelsc_reg        : std_logic := '0';
    signal sig_push_coelsc_reg       : std_logic := '0';
    signal sig_coelsc_reg_empty      : std_logic := '0';
    signal sig_coelsc_reg_full       : std_logic := '0';
    signal sig_tag2status            : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_tag_reg          : std_logic_vector(TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_err_reg          : std_logic := '0';
    signal sig_data_last_err_reg     : std_logic := '0';
    signal sig_data_cmd_cmplt_reg    : std_logic := '0';
    signal sig_bresp_reg             : std_logic_vector(1 downto 0) := (others => '0');
    signal sig_push_status           : std_logic := '0';
    Signal sig_status_push_ok        : std_logic := '0';
    signal sig_status_valid          : std_logic := '0';
    signal sig_wsc2data_ready        : std_logic := '0';
    signal sig_s2mm_bready           : std_logic := '0';
    signal sig_wresp_sfifo_in        : std_logic_vector(WRESP_SFIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_wresp_sfifo_out       : std_logic_vector(WRESP_SFIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_wresp_sfifo_wr_valid  : std_logic := '0';
    signal sig_wresp_sfifo_wr_ready  : std_logic := '0';
    signal sig_wresp_sfifo_wr_full   : std_logic := '0';
    signal sig_wresp_sfifo_rd_valid  : std_logic := '0';
    signal sig_wresp_sfifo_rd_ready  : std_logic := '0';
    signal sig_wresp_sfifo_rd_empty  : std_logic := '0';
    signal sig_halt_reg              : std_logic := '0';
    signal sig_halt_reg_dly1         : std_logic := '0';
    signal sig_halt_reg_dly2         : std_logic := '0';
    signal sig_halt_reg_dly3         : std_logic := '0';
    signal sig_addr_posted_cntr      : unsigned(ADDR_POSTED_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_posted_cntr_eq_0 : std_logic := '0';
    signal sig_addr_posted_cntr_eq_1 : std_logic := '0';
    signal sig_addr_posted_cntr_max  : std_logic := '0';
    signal sig_decr_addr_posted_cntr : std_logic := '0';
    signal sig_incr_addr_posted_cntr : std_logic := '0';
    signal sig_no_posted_cmds        : std_logic := '0';
    signal sig_addr_posted           : std_logic := '0';
    signal sig_all_cmds_done         : std_logic := '0';
    signal sig_wsc2stat_status       : std_logic_vector(C_STS_WIDTH-1 downto 0) := (others => '0');
    signal sig_dcntl_sfifo_wr_valid  : std_logic := '0';
    signal sig_dcntl_sfifo_wr_ready  : std_logic := '0';
    signal sig_dcntl_sfifo_wr_full   : std_logic := '0';
    signal sig_dcntl_sfifo_rd_valid  : std_logic := '0';
    signal sig_dcntl_sfifo_rd_ready  : std_logic := '0';
    signal sig_dcntl_sfifo_rd_empty  : std_logic := '0';
    signal sig_wdc_statcnt           : unsigned(DCNTL_STATCNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_incr_statcnt          : std_logic := '0';
    signal sig_decr_statcnt          : std_logic := '0';
    signal sig_statcnt_eq_max        : std_logic := '0';
    signal sig_statcnt_eq_0          : std_logic := '0';
    signal sig_statcnt_gt_eq_thres   : std_logic := '0';
    signal sig_wdc_status_going_full : std_logic := '0';
                                           
                                           
                                           
            
  begin --(architecture implementation)
  
    
    -- Assign the ready output to the AXI Write Response Channel
    s2mm_bready           <= sig_s2mm_bready or
                             sig_halt_reg;     -- force bready if a Halt is requested
    
    -- Assign the ready output to the Data Controller status interface
    wsc2data_ready        <= sig_wsc2data_ready;
    
    -- Assign the status valid output control to the Status FIFO
    wsc2stat_status_valid <= sig_status_valid ;
    
    -- Formulate the status output value to the Status FIFO
    wsc2stat_status       <=  sig_wsc2stat_status;
    
     
    -- Formulate the status write request signal
    sig_status_valid      <= sig_push_status;
    
                                           
     
    -- Indicate the desire to push a coelesced status word 
    -- to the Status FIFO
    sig_push_status       <= sig_coelsc_reg_full;
    
    
    
    -- Detect that a push of a new status word is completing
    sig_status_push_ok    <= sig_status_valid and
                             stat2wsc_status_ready; 
    
    sig_pop_coelsc_reg    <= sig_status_push_ok;
    
    
    -- Signal a halt to the execution pipe if new status
    -- is valid but the Status FIFO is not accepting it or
    -- the WDC Status FIFO is going full
    wsc2mstr_halt_pipe    <= (sig_status_valid and
                             not(stat2wsc_status_ready)) or
                             sig_wdc_status_going_full;
 
    
    -- Monitor the Status capture registers to detect a 
    -- qualified Status set and push to the coelescing register
    -- when available to do so
    sig_push_coelsc_reg   <= sig_valid_status_rdy and 
                             sig_coelsc_reg_empty;
    
    --    pre CR616212  sig_valid_status_rdy  <= (sig_wresp_sfifo_rd_valid  and 
    --    pre CR616212                            sig_dcntl_sfifo_rd_valid) or
    --    pre CR616212                           (sig_data_err_reg and
    --    pre CR616212                            sig_dcntl_sfifo_rd_valid);     
          
    sig_valid_status_rdy  <= (sig_wresp_sfifo_rd_valid  and 
                              sig_dcntl_sfifo_rd_valid) or
                             (sig_data_err_reg and
                              sig_dcntl_sfifo_rd_valid) or  -- or Added for CR616212
                             (sig_data_last_err_reg and     -- Added for CR616212
                              sig_dcntl_sfifo_rd_valid);    -- Added for CR616212 
          
 
 
 
    -- Decode the AXI MMap Read Respose       
    sig_decerr  <= '1'
      When sig_bresp_reg = DECERR
      Else '0'; 
           
    sig_slverr  <= '1'
      When sig_bresp_reg = SLVERR
      Else '0';      
          
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_TAG_LE_STAT
    --
    -- If Generate Description:
    -- Populates the TAG bits into the availble Status bits when
    -- the TAG width is less than or equal to the available number
    -- of bits in the Status word. 
    --
    ------------------------------------------------------------
    GEN_TAG_LE_STAT : if (TAG_WIDTH <= STAT_REG_TAG_WIDTH) generate
    
       -- local signals
         signal lsig_temp_tag_small : std_logic_vector(STAT_REG_TAG_WIDTH-1 downto 0) := (others => '0');
         
         
       begin
    
         sig_tag2status <= lsig_temp_tag_small;
         
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: POPULATE_SMALL_TAG
         --
         -- Process Description:
         --
         --
         -------------------------------------------------------------
         POPULATE_SMALL_TAG : process (sig_coelsc_tag_reg)
            begin
         
              -- Set default value
              lsig_temp_tag_small <= (others => '0');
          
              -- Now overload actual TAG bits
              lsig_temp_tag_small(TAG_WIDTH-1 downto 0) <= sig_coelsc_tag_reg;
          
         
            end process POPULATE_SMALL_TAG; 
         
         
       end generate GEN_TAG_LE_STAT;
     
     
     
     
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_TAG_GT_STAT
    --
    -- If Generate Description:
    -- Populates the TAG bits into the availble Status bits when
    -- the TAG width is greater than the available number of 
    -- bits in the Status word. The upper bits of the TAG are 
    -- clipped off (discarded). 
    --
    ------------------------------------------------------------
    GEN_TAG_GT_STAT : if (TAG_WIDTH > STAT_REG_TAG_WIDTH) generate
    
       -- local signals
         signal lsig_temp_tag_big : std_logic_vector(STAT_REG_TAG_WIDTH-1 downto 0) := (others => '0');
         
         
       begin
    
         
         sig_tag2status <= lsig_temp_tag_big;
         
         
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: POPULATE_BIG_TAG
         --
         -- Process Description:
         --
         --
         -------------------------------------------------------------
         POPULATE_SMALL_TAG : process (sig_coelsc_tag_reg)
            begin
         
              -- Set default value
              lsig_temp_tag_big <= (others => '0');
          
              -- Now overload actual TAG bits
              lsig_temp_tag_big <= sig_coelsc_tag_reg(STAT_REG_TAG_WIDTH-1 downto 0);
          
         
            end process POPULATE_SMALL_TAG; 
         
         
       end generate GEN_TAG_GT_STAT;
     
     
     
    
    
    
    
    
    
    
    
    
     
     
    
    
    
    -------------------------------------------------------------------------
    -- Write Response Channel input FIFO and logic
    
                        
    -- BRESP is the only fifo data
    sig_wresp_sfifo_in       <=  s2mm_bresp;     
    
    
    -- The fifo output is already in the right format
    sig_bresp_reg            <=  sig_wresp_sfifo_out;
    
    
    -- Write Side assignments
    sig_wresp_sfifo_wr_valid <=  s2mm_bvalid;
    
    sig_s2mm_bready          <=  sig_wresp_sfifo_wr_ready;
    
    
    -- read Side ready assignment
    sig_wresp_sfifo_rd_ready <=  sig_push_coelsc_reg;
    
    
    
    ------------------------------------------------------------
    -- Instance: I_WRESP_STATUS_FIFO 
    --
    -- Description:
    -- Instance for the AXI Write Response FIFO
    --
    ------------------------------------------------------------
     I_WRESP_STATUS_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
     generic map (
   
       C_DWIDTH             =>  WRESP_SFIFO_WIDTH         ,  
       C_DEPTH              =>  WRESP_SFIFO_DEPTH         ,  
       C_IS_ASYNC           =>  SYNC_FIFO_SELECT          ,  
       C_PRIM_TYPE          =>  SRL_FIFO_TYPE             ,  
       C_FAMILY             =>  C_FAMILY                     
      
       )
     port map (
       
       -- Write Clock and reset
       fifo_wr_reset        =>   mmap_reset               ,  
       fifo_wr_clk          =>   primary_aclk             ,  
       
       -- Write Side
       fifo_wr_tvalid       =>   sig_wresp_sfifo_wr_valid ,  
       fifo_wr_tready       =>   sig_wresp_sfifo_wr_ready ,  
       fifo_wr_tdata        =>   sig_wresp_sfifo_in       ,  
       fifo_wr_full         =>   sig_wresp_sfifo_wr_full  ,  
      
      
       -- Read Clock and reset (not used in Sync mode)
       fifo_async_rd_reset  =>   mmap_reset               ,    
       fifo_async_rd_clk    =>   primary_aclk             ,  
       
       -- Read Side
       fifo_rd_tvalid       =>   sig_wresp_sfifo_rd_valid ,  
       fifo_rd_tready       =>   sig_wresp_sfifo_rd_ready ,  
       fifo_rd_tdata        =>   sig_wresp_sfifo_out      ,  
       fifo_rd_empty        =>   sig_wresp_sfifo_rd_empty    
      
       );
   

    
    
    
    
    
    --------  Write Data Controller Status FIFO Going Full Logic -------------
    
    
    sig_incr_statcnt   <= sig_dcntl_sfifo_wr_valid and
                          sig_dcntl_sfifo_wr_ready;
    
    sig_decr_statcnt   <= sig_dcntl_sfifo_rd_valid and
                          sig_dcntl_sfifo_rd_ready;
    
          
    sig_statcnt_eq_max <= '1'
      when (sig_wdc_statcnt = DCNTL_STATCNT_MAX)
      Else '0';
          
    sig_statcnt_eq_0   <= '1'
      when (sig_wdc_statcnt = DCNTL_STATCNT_ZERO)
      Else '0';
          
    sig_statcnt_gt_eq_thres <= '1'
      when (sig_wdc_statcnt >= DCNTL_HALT_THRES)
      Else '0';
          
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_WDC_GOING_FULL_FLOP
    --
    -- Process Description:
    --  Implements a flop for the WDC Status FIFO going full flag.
    --
    -------------------------------------------------------------
    IMP_WDC_GOING_FULL_FLOP : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then
    
             sig_wdc_status_going_full <= '0';
           
           else
    
             sig_wdc_status_going_full <= sig_statcnt_gt_eq_thres;
    
           end if; 
        end if;       
      end process IMP_WDC_GOING_FULL_FLOP; 
    
          
          
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_DCNTL_FIFO_CNTR
    --
    -- Process Description:
    --   Implements a simple counter keeping track of the number
    -- of entries in the WDC Status FIFO. If the Status FIFO gets
    -- too full, the S2MM Data Pipe has to be halted.
    --
    -------------------------------------------------------------
    IMP_DCNTL_FIFO_CNTR : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset = '1') then
    
             sig_wdc_statcnt <= (others => '0');
    
           elsif (sig_incr_statcnt   = '1' and 
                  sig_decr_statcnt   = '0' and
                  sig_statcnt_eq_max = '0') then
    
             sig_wdc_statcnt <= sig_wdc_statcnt + DCNTL_STATCNT_ONE;
    
           elsif (sig_incr_statcnt = '0' and 
                  sig_decr_statcnt = '1' and
                  sig_statcnt_eq_0 = '0') then
    
             sig_wdc_statcnt <= sig_wdc_statcnt - DCNTL_STATCNT_ONE;
    
           else
    
             null; -- Hold current count value
    
           end if; 
        end if;       
      end process IMP_DCNTL_FIFO_CNTR; 
          
          
          
          
          
          
          
          
          
          
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_INDET_BTT
    --
    -- If Generate Description:
    --  Implements the logic needed when Indeterminate BTT is
    -- not enabled in the S2MM function.
    --
    ------------------------------------------------------------
    GEN_OMIT_INDET_BTT : if (C_ENABLE_INDET_BTT = 0) generate
    
       -- Local Constants
       Constant DCNTL_SFIFO_WIDTH           : integer := STAT_REG_TAG_WIDTH+3;
       Constant DCNTL_SFIFO_CMD_CMPLT_INDEX : integer := 0;
       Constant DCNTL_SFIFO_TLAST_ERR_INDEX : integer := 1;
       Constant DCNTL_SFIFO_CALC_ERR_INDEX  : integer := 2;
       Constant DCNTL_SFIFO_TAG_INDEX       : integer := DCNTL_SFIFO_CALC_ERR_INDEX+1;
    
       
       -- local signals
       signal sig_dcntl_sfifo_in        : std_logic_vector(DCNTL_SFIFO_WIDTH-1 downto 0) := (others => '0');
       signal sig_dcntl_sfifo_out       : std_logic_vector(DCNTL_SFIFO_WIDTH-1 downto 0) := (others => '0');
    
    
       begin
    
       
         sig_wsc2stat_status       <=  sig_coelsc_okay_reg    &   
                                       sig_coelsc_slverr_reg  &
                                       sig_coelsc_decerr_reg  & 
                                       sig_coelsc_interr_reg  &
                                       sig_tag2status;
         
         
         
         -----------------------------------------------------------------------------
         -- Data Controller Status FIFO and Logic
         
         
         -- Concatonate Input bits to build Dcntl fifo data word
         sig_dcntl_sfifo_in      <=  data2wsc_tag        &   -- bit 3 to tag Width+2
                                     data2wsc_calc_error &   -- bit 2
                                     data2wsc_last_error &   -- bit 1
                                     data2wsc_cmd_cmplt  ;   -- bit 0
         
                       
         -- Rip the DCntl fifo outputs back to constituant pieces              
         sig_data_tag_reg        <= sig_dcntl_sfifo_out((DCNTL_SFIFO_TAG_INDEX+STAT_REG_TAG_WIDTH)-1 downto
                                                        DCNTL_SFIFO_TAG_INDEX);
                                                        
         sig_data_err_reg        <= sig_dcntl_sfifo_out(DCNTL_SFIFO_CALC_ERR_INDEX) ;
         
         sig_data_last_err_reg   <= sig_dcntl_sfifo_out(DCNTL_SFIFO_TLAST_ERR_INDEX);
         
         sig_data_cmd_cmplt_reg  <= sig_dcntl_sfifo_out(DCNTL_SFIFO_CMD_CMPLT_INDEX);
        
         
         
         -- Data Control Valid/Ready assignments
         sig_dcntl_sfifo_wr_valid <= data2wsc_valid     ;
         
         sig_wsc2data_ready       <= sig_dcntl_sfifo_wr_ready; 
         
         
         
         -- read side ready assignment
         sig_dcntl_sfifo_rd_ready <= sig_push_coelsc_reg;
               
                                                  
         
         ------------------------------------------------------------
         -- Instance: I_DATA_CNTL_STATUS_FIFO 
         --
         -- Description:
         -- Instance for the Command Qualifier FIFO
         --
         ------------------------------------------------------------
          I_DATA_CNTL_STATUS_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (
        
            C_DWIDTH             =>  DCNTL_SFIFO_WIDTH         , 
            C_DEPTH              =>  DCNTL_SFIFO_DEPTH         , 
            C_IS_ASYNC           =>  SYNC_FIFO_SELECT          , 
            C_PRIM_TYPE          =>  SRL_FIFO_TYPE             , 
            C_FAMILY             =>  C_FAMILY                    
           
            )
          port map (
            
            -- Write Clock and reset
            fifo_wr_reset        =>   mmap_reset               , 
            fifo_wr_clk          =>   primary_aclk             , 
            
            -- Write Side
            fifo_wr_tvalid       =>   sig_dcntl_sfifo_wr_valid , 
            fifo_wr_tready       =>   sig_dcntl_sfifo_wr_ready , 
            fifo_wr_tdata        =>   sig_dcntl_sfifo_in       , 
            fifo_wr_full         =>   sig_dcntl_sfifo_wr_full  , 
           
           
            -- Read Clock and reset (not used in Sync mode)
            fifo_async_rd_reset  =>   mmap_reset               ,   
            fifo_async_rd_clk    =>   primary_aclk             , 
            
            -- Read Side
            fifo_rd_tvalid       =>   sig_dcntl_sfifo_rd_valid , 
            fifo_rd_tready       =>   sig_dcntl_sfifo_rd_ready , 
            fifo_rd_tdata        =>   sig_dcntl_sfifo_out      , 
            fifo_rd_empty        =>   sig_dcntl_sfifo_rd_empty   
           
            );
        

         
         
         
            
            
       
       
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: STATUS_COELESC_REG
         --
         -- Process Description:
         --   Implement error status coelescing register. 
         -- Once a bit is set it will remain set until the overall 
         -- status is written to the Status FIFO. 
         -- Tag bits are just registered at each valid dbeat.
         --
         -------------------------------------------------------------
         STATUS_COELESC_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset         = '1' or
                     sig_pop_coelsc_reg = '1') then
                   
                   sig_coelsc_tag_reg       <= (others => '0');
                   sig_coelsc_interr_reg    <= '0';
                   sig_coelsc_decerr_reg    <= '0';
                   sig_coelsc_slverr_reg    <= '0';
                   sig_coelsc_okay_reg      <= '1'; -- set back to default of "OKAY"
       
                   sig_coelsc_reg_full      <= '0';
                   sig_coelsc_reg_empty     <= '1';
       
       
                   
                 Elsif (sig_push_coelsc_reg = '1') Then
                 
                   sig_coelsc_tag_reg       <= sig_data_tag_reg;                             
                   sig_coelsc_interr_reg    <= sig_data_err_reg      or 
                                               sig_data_last_err_reg or 
                                               sig_coelsc_interr_reg;
                   sig_coelsc_decerr_reg    <= not(sig_data_err_reg) and 
                                               (sig_decerr           or 
                                                sig_coelsc_decerr_reg);
                   sig_coelsc_slverr_reg    <= not(sig_data_err_reg) and 
                                               (sig_slverr           or 
                                                sig_coelsc_slverr_reg);
                   sig_coelsc_okay_reg      <= not(sig_decerr            or 
                                                   sig_coelsc_decerr_reg or
                                                   sig_slverr            or 
                                                   sig_coelsc_slverr_reg or
                                                   sig_data_err_reg      or
                                                   sig_data_last_err_reg or    
                                                   sig_coelsc_interr_reg      
                                                   );
       
                   sig_coelsc_reg_full      <= sig_data_cmd_cmplt_reg;
                   sig_coelsc_reg_empty     <= not(sig_data_cmd_cmplt_reg);
                                                 
                   
                 else
                   
                   null;  -- hold current state
                   
                 end if; 
              end if;       
            end process STATUS_COELESC_REG; 
       
       
       
       
       
       
       end generate GEN_OMIT_INDET_BTT;
    
    
    
    
    
    
    
    
    
    
    
   

    
    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ENABLE_INDET_BTT
    --
    -- If Generate Description:
    --  Implements the logic needed when Indeterminate BTT is
    -- enabled in the S2MM function. Primary difference is the
    -- addition to the reported status of the End of Packet 
    -- marker (EOP) and the received byte count for the parent 
    -- command.
    --
    ------------------------------------------------------------
    GEN_ENABLE_INDET_BTT : if (C_ENABLE_INDET_BTT = 1) generate
    
       -- Local Constants
       Constant SF_DCNTL_SFIFO_WIDTH         : integer := TAG_WIDTH +
                                                          C_SF_BYTES_RCVD_WIDTH + 3;
       Constant SF_SFIFO_LS_TAG_INDEX        : integer := 0;
       Constant SF_SFIFO_MS_TAG_INDEX        : integer := SF_SFIFO_LS_TAG_INDEX + (TAG_WIDTH-1);
       Constant SF_SFIFO_CALC_ERR_INDEX      : integer := SF_SFIFO_MS_TAG_INDEX+1;
       Constant SF_SFIFO_CMD_CMPLT_INDEX     : integer := SF_SFIFO_CALC_ERR_INDEX+1;
       Constant SF_SFIFO_LS_BYTES_RCVD_INDEX : integer := SF_SFIFO_CMD_CMPLT_INDEX+1;
       Constant SF_SFIFO_MS_BYTES_RCVD_INDEX : integer := SF_SFIFO_LS_BYTES_RCVD_INDEX+
                                                          (C_SF_BYTES_RCVD_WIDTH-1);
       Constant SF_SFIFO_EOP_INDEX           : integer := SF_SFIFO_MS_BYTES_RCVD_INDEX+1;
       Constant BYTES_RCVD_FIELD_WIDTH       : integer := 23+3*C_MCDMA;
       
       
       -- local signals
       signal sig_dcntl_sfifo_in        : std_logic_vector(SF_DCNTL_SFIFO_WIDTH-1 downto 0) := (others => '0');
       signal sig_dcntl_sfifo_out       : std_logic_vector(SF_DCNTL_SFIFO_WIDTH-1 downto 0) := (others => '0');
       signal sig_data_bytes_rcvd       : std_logic_vector(C_SF_BYTES_RCVD_WIDTH-1 downto 0) := (others => '0');
       signal sig_data_eop              : std_logic := '0';
       signal sig_coelsc_bytes_rcvd     : std_logic_vector(C_SF_BYTES_RCVD_WIDTH-1 downto 0) := (others => '0');
       signal sig_coelsc_eop            : std_logic := '0';
       signal sig_coelsc_bytes_rcvd_pad : std_logic_vector(BYTES_RCVD_FIELD_WIDTH-1 downto 0) := (others => '0');
 
    
       begin
    
       
                                                                
         sig_wsc2stat_status     <=  sig_coelsc_eop            &
                                     sig_coelsc_bytes_rcvd_pad &
                                     sig_coelsc_okay_reg       &   
                                     sig_coelsc_slverr_reg     &
                                     sig_coelsc_decerr_reg     & 
                                     sig_coelsc_interr_reg     &
                                     sig_tag2status;
         
            
         
         
         -----------------------------------------------------------------------------
         -- Data Controller Status FIFO and Logic


     
         
         -- Concatonate Input bits to build Dcntl fifo input data word
         sig_dcntl_sfifo_in      <=  data2wsc_eop        & -- ms bit
                                     data2wsc_bytes_rcvd & -- bit 7 to C_SF_BYTES_RCVD_WIDTH+7  
                                     data2wsc_cmd_cmplt  & -- bit 6 
                                     data2wsc_calc_error & -- bit 4  
                                     data2wsc_tag;         -- bits 0 to 3
                       
                       
         -- Rip the DCntl fifo outputs back to constituant pieces              
         
         sig_data_eop            <= sig_dcntl_sfifo_out(SF_SFIFO_EOP_INDEX);
         
         sig_data_bytes_rcvd     <= sig_dcntl_sfifo_out(SF_SFIFO_MS_BYTES_RCVD_INDEX downto 
                                                        SF_SFIFO_LS_BYTES_RCVD_INDEX);
         
         sig_data_cmd_cmplt_reg  <= sig_dcntl_sfifo_out(SF_SFIFO_CMD_CMPLT_INDEX);
          
         sig_data_err_reg        <= sig_dcntl_sfifo_out(SF_SFIFO_CALC_ERR_INDEX);
         
         sig_data_tag_reg        <= sig_dcntl_sfifo_out(SF_SFIFO_MS_TAG_INDEX downto 
                                                        SF_SFIFO_LS_TAG_INDEX) ;
         
         
         
         
         -- Data Control Valid/Ready assignments
         sig_dcntl_sfifo_wr_valid <= data2wsc_valid ;
         
         sig_wsc2data_ready       <= sig_dcntl_sfifo_wr_ready; 
         
         
         
         -- read side ready assignment
         sig_dcntl_sfifo_rd_ready <= sig_push_coelsc_reg;
               
                                                  
         
         ------------------------------------------------------------
         -- Instance: I_SF_DATA_CNTL_STATUS_FIFO 
         --
         -- Description:
         -- Instance for the Command Qualifier FIFO when Store and
         -- Forward is included.
         --
         ------------------------------------------------------------
          I_SF_DATA_CNTL_STATUS_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (
        
            C_DWIDTH             =>  SF_DCNTL_SFIFO_WIDTH      ,  
            C_DEPTH              =>  DCNTL_SFIFO_DEPTH         ,  
            C_IS_ASYNC           =>  SYNC_FIFO_SELECT          ,  
            C_PRIM_TYPE          =>  SRL_FIFO_TYPE             ,  
            C_FAMILY             =>  C_FAMILY                     
           
            )
          port map (
            
            -- Write Clock and reset
            fifo_wr_reset        =>   mmap_reset               ,  
            fifo_wr_clk          =>   primary_aclk             ,  
            
            -- Write Side
            fifo_wr_tvalid       =>   sig_dcntl_sfifo_wr_valid ,  
            fifo_wr_tready       =>   sig_dcntl_sfifo_wr_ready ,  
            fifo_wr_tdata        =>   sig_dcntl_sfifo_in       ,  
            fifo_wr_full         =>   sig_dcntl_sfifo_wr_full  ,  
           
            -- Read Clock and reset (not used in Sync mode)
            fifo_async_rd_reset  =>   mmap_reset               ,     
            fifo_async_rd_clk    =>   primary_aclk             ,   
            
            -- Read Side
            fifo_rd_tvalid       =>   sig_dcntl_sfifo_rd_valid ,  
            fifo_rd_tready       =>   sig_dcntl_sfifo_rd_ready ,  
            fifo_rd_tdata        =>   sig_dcntl_sfifo_out      ,  
            fifo_rd_empty        =>   sig_dcntl_sfifo_rd_empty    
           
            );
        

         
         
         
            
            
       
       
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: SF_STATUS_COELESC_REG
         --
         -- Process Description:
         --   Implement error status coelescing register. 
         -- Once a bit is set it will remain set until the overall 
         -- status is written to the Status FIFO. 
         -- Tag bits are just registered at each valid dbeat.
         --
         -------------------------------------------------------------
         SF_STATUS_COELESC_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset         = '1' or
                     sig_pop_coelsc_reg = '1') then
                   
                   sig_coelsc_tag_reg       <= (others => '0');
                   sig_coelsc_interr_reg    <= '0';
                   sig_coelsc_decerr_reg    <= '0';
                   sig_coelsc_slverr_reg    <= '0';
                   sig_coelsc_okay_reg      <= '1'; -- set back to default of "OKAY"
                   sig_coelsc_bytes_rcvd    <= (others => '0');
                   sig_coelsc_eop           <= '0';
      
       
                   sig_coelsc_reg_full      <= '0';
                   sig_coelsc_reg_empty     <= '1';
       
       
                   
                 Elsif (sig_push_coelsc_reg = '1') Then
                 
                   sig_coelsc_tag_reg       <= sig_data_tag_reg;                             
                   sig_coelsc_interr_reg    <= sig_data_err_reg      or 
                                               sig_coelsc_interr_reg;
                   sig_coelsc_decerr_reg    <= not(sig_data_err_reg) and 
                                               (sig_decerr           or 
                                                sig_coelsc_decerr_reg);
                   sig_coelsc_slverr_reg    <= not(sig_data_err_reg) and 
                                               (sig_slverr           or 
                                                sig_coelsc_slverr_reg);
                   sig_coelsc_okay_reg      <= not(sig_decerr            or 
                                                   sig_coelsc_decerr_reg or
                                                   sig_slverr            or 
                                                   sig_coelsc_slverr_reg or
                                                   sig_data_err_reg      or
                                                   sig_coelsc_interr_reg      
                                                   );
                   sig_coelsc_bytes_rcvd    <= sig_data_bytes_rcvd;
                   sig_coelsc_eop           <= sig_data_eop;
      
       
                   sig_coelsc_reg_full      <= sig_data_cmd_cmplt_reg;
                   sig_coelsc_reg_empty     <= not(sig_data_cmd_cmplt_reg);
                                                 
                   
                 else
                   
                   null;  -- hold current state
                   
                 end if; 
              end if;       
            end process SF_STATUS_COELESC_REG; 
       
       
       
       
       
       
         
         ------------------------------------------------------------
         -- If Generate
         --
         -- Label: SF_GEN_PAD_BYTES_RCVD
         --
         -- If Generate Description:
         --  Pad the bytes received value with zeros to fill in the 
         -- status field width.
         --
         --
         ------------------------------------------------------------
         SF_GEN_PAD_BYTES_RCVD : if (C_SF_BYTES_RCVD_WIDTH < BYTES_RCVD_FIELD_WIDTH) generate
         
           begin
            
             sig_coelsc_bytes_rcvd_pad(BYTES_RCVD_FIELD_WIDTH-1 downto 
                                       C_SF_BYTES_RCVD_WIDTH) <= (others => '0');
            
            
             sig_coelsc_bytes_rcvd_pad(C_SF_BYTES_RCVD_WIDTH-1 downto 0) <=  sig_coelsc_bytes_rcvd;
            
           
           end generate SF_GEN_PAD_BYTES_RCVD;
       
       
       
         
         
         ------------------------------------------------------------
         -- If Generate
         --
         -- Label: SF_GEN_NO_PAD_BYTES_RCVD
         --
         -- If Generate Description:
         --  No padding required for the bytes received value.
         --
         --
         ------------------------------------------------------------
         SF_GEN_NO_PAD_BYTES_RCVD : if (C_SF_BYTES_RCVD_WIDTH = BYTES_RCVD_FIELD_WIDTH) generate
         
           begin
            
               sig_coelsc_bytes_rcvd_pad <= sig_coelsc_bytes_rcvd; -- no pad required
            
           
           end generate SF_GEN_NO_PAD_BYTES_RCVD;
       
       
          
          
       
       end generate GEN_ENABLE_INDET_BTT;
    
    
    
    
    
    
    
    
    
    
    
   -------  Soft Shutdown Logic ------------------------------- 
    
    
  
  
   -- Address Posted Counter Logic ---------------------t-----------------
   -- Supports soft shutdown by tracking when all commited Write 
   -- transfers to the AXI Bus have had corresponding Write Status 
   -- Reponses Received.   

    
    sig_addr_posted           <= addr2wsc_addr_posted ;
    
    sig_incr_addr_posted_cntr <= sig_addr_posted      ;
    
    sig_decr_addr_posted_cntr <= sig_s2mm_bready  and
                                 s2mm_bvalid          ;
        
    sig_addr_posted_cntr_eq_0 <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_ZERO)
      Else '0';

    sig_addr_posted_cntr_eq_1 <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_ONE)
      Else '0';

    
    sig_addr_posted_cntr_max <= '1'
      when (sig_addr_posted_cntr = ADDR_POSTED_MAX)
      Else '0';
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ADDR_POSTED_FIFO_CNTR
    --
    -- Process Description:
    --    This process implements a counter for the tracking  
    -- if an Address has been posted on the AXI address channel.
    -- The counter is used to track flushing operations where all
    -- transfers committed on the AXI Address Channel have to
    --  be completed before a halt can occur.
    -------------------------------------------------------------
    IMP_ADDR_POSTED_FIFO_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_addr_posted_cntr <= ADDR_POSTED_ZERO;
              
            elsif (sig_incr_addr_posted_cntr = '1' and
                   sig_decr_addr_posted_cntr = '0' and
                   sig_addr_posted_cntr_max  = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr + ADDR_POSTED_ONE ;
              
            elsif (sig_incr_addr_posted_cntr = '0' and
                   sig_decr_addr_posted_cntr = '1' and
                   sig_addr_posted_cntr_eq_0 = '0') then
              
              sig_addr_posted_cntr <= sig_addr_posted_cntr - ADDR_POSTED_ONE ;
              
            else
              null;  -- don't change state
            end if; 
         end if;       
       end process IMP_ADDR_POSTED_FIFO_CNTR; 
 
 
    
    
    wsc2rst_stop_cmplt <= sig_all_cmds_done;
    
    
    
    
    sig_no_posted_cmds <= (sig_addr_posted_cntr_eq_0 and
                            not(addr2wsc_calc_error)) or
                           (sig_addr_posted_cntr_eq_1 and
                            addr2wsc_calc_error);
    
  
                         
    sig_all_cmds_done <=  sig_no_posted_cmds and
                          sig_halt_reg_dly3;   
                               
                               
                               
    
    
  
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG
    --
    -- Process Description:
    --   Implements the flop for capturing the Halt request from 
    -- the Reset module.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg      <= '0';
            
            elsif (rst2wsc_stop_request = '1') then
              
              sig_halt_reg <= '1';
            
            else
              null;  -- Hold current State
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG; 
  
  
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_HALT_REQ_REG_DLY
    --
    -- Process Description:
    --   Implements the flops for delaying the halt request by 3
    -- clocks to allow the Address Controller to halt before the
    -- Data Contoller can safely indicate it has exhausted all
    -- transfers committed to the AXI Address Channel by the Address
    -- Controller.
    --
    -------------------------------------------------------------
    IMP_HALT_REQ_REG_DLY : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then
              
              sig_halt_reg_dly1 <= '0';
              sig_halt_reg_dly2 <= '0';
              sig_halt_reg_dly3 <= '0';
            
            else
              
              sig_halt_reg_dly1 <= sig_halt_reg;
              sig_halt_reg_dly2 <= sig_halt_reg_dly1;
              sig_halt_reg_dly3 <= sig_halt_reg_dly2;
            
            end if; 
         end if;       
       end process IMP_HALT_REQ_REG_DLY; 
  
  
   
      
          
          
  
  end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_skid2mm_buf.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_skid2mm_buf.vhd
--
-- Description:     
--  Implements the AXi Skid Buffer in the Option 2 (Registerd outputs) mode.                
--
--  This Module also provides Write Data Bus Mirroring and WSTRB
--  Demuxing to match a narrow Stream to a wider MMap Write 
--  Channel. By doing this in the skid buffer, the resource 
--  utilization of the skid buffer can be minimized by only
--  having to buffer/mux the Stream data width, not the MMap
--  Data width.   
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


library axi_datamover_v5_1_17; 
use axi_datamover_v5_1_17.axi_datamover_wr_demux;

-------------------------------------------------------------------------------

entity axi_datamover_skid2mm_buf is
  generic (
    
    C_MDATA_WIDTH         : INTEGER range 32 to 1024 := 32 ;
       --  Width of the MMap Write Data bus (in bits)
    C_SDATA_WIDTH         : INTEGER range 8 to 1024 := 32 ;
       --  Width of the Stream Data bus (in bits)
    C_ADDR_LSB_WIDTH      : INTEGER range 1 to 8 := 5
       --  Width of the LS address bus needed to Demux the WSTRB
       
    );
  port (
     
     -- Clock and Reset Inputs -------------------------------------------
                                                                        --
     ACLK         : In  std_logic ;                                     --
     ARST         : In  std_logic ;                                     --
     ---------------------------------------------------------------------
     
      
     -- Slave Side (Wr Data Controller Input Side) -----------------------
                                                                        --
     S_ADDR_LSB   : in  std_logic_vector(C_ADDR_LSB_WIDTH-1 downto 0);  --
     S_VALID      : In  std_logic ;                                     --
     S_READY      : Out std_logic ;                                     --
     S_DATA       : In  std_logic_vector(C_SDATA_WIDTH-1 downto 0);     --
     S_STRB       : In  std_logic_vector((C_SDATA_WIDTH/8)-1 downto 0); --
     S_LAST       : In  std_logic ;                                     --
     ---------------------------------------------------------------------
     

     -- Master Side (MMap Write Data Output Side) ------------------------
     M_VALID      : Out std_logic ;                                     --
     M_READY      : In  std_logic ;                                     --
     M_DATA       : Out std_logic_vector(C_MDATA_WIDTH-1 downto 0);     --
     M_STRB       : Out std_logic_vector((C_MDATA_WIDTH/8)-1 downto 0); --
     M_LAST       : Out std_logic                                       --
     ---------------------------------------------------------------------
     
    );

end entity axi_datamover_skid2mm_buf;


architecture implementation of axi_datamover_skid2mm_buf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  Constant IN_DATA_WIDTH       : integer := C_SDATA_WIDTH;
  Constant MM2STRM_WIDTH_RATIO : integer := C_MDATA_WIDTH/C_SDATA_WIDTH;
  
  
-- Signals decalrations -------------------------

  Signal sig_reset_reg         : std_logic := '0';
  signal sig_spcl_s_ready_set  : std_logic := '0';
  signal sig_data_skid_reg     : std_logic_vector(IN_DATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_reg     : std_logic_vector((C_MDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_reg     : std_logic := '0';
  signal sig_skid_reg_en       : std_logic := '0';
  signal sig_data_skid_mux_out : std_logic_vector(IN_DATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_mux_out : std_logic_vector((C_MDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_mux_out : std_logic := '0';
  signal sig_skid_mux_sel      : std_logic := '0';
  signal sig_data_reg_out      : std_logic_vector(IN_DATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_reg_out      : std_logic_vector((C_MDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_reg_out      : std_logic := '0';
  signal sig_data_reg_out_en   : std_logic := '0';
  signal sig_m_valid_out       : std_logic := '0';
  signal sig_m_valid_dup       : std_logic := '0';
  signal sig_m_valid_comb      : std_logic := '0';
  signal sig_s_ready_out       : std_logic := '0';
  signal sig_s_ready_dup       : std_logic := '0';
  signal sig_s_ready_comb      : std_logic := '0';
  signal sig_mirror_data_out   : std_logic_vector(C_MDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_wstrb_demux_out   : std_logic_vector((C_MDATA_WIDTH/8)-1 downto 0) := (others => '0');
                                         
                                         
                                         
 
-- Register duplication attribute assignments to control fanout
-- on handshake output signals  
  
  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration
  
  Attribute KEEP of sig_m_valid_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_m_valid_dup : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup : signal is "TRUE"; -- definition
  
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_out : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_dup : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_out : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup : signal is "no"; 
  
  
  

begin --(architecture implementation)

   M_VALID <= sig_m_valid_out;         
   S_READY <= sig_s_ready_out; 
    
   M_STRB  <= sig_strb_reg_out;
   M_LAST  <= sig_last_reg_out;                
   M_DATA  <= sig_mirror_data_out;
            
   -- Assign the special S_READY FLOP set signal
   sig_spcl_s_ready_set <= sig_reset_reg;
  
            
   -- Generate the ouput register load enable control
   sig_data_reg_out_en <= M_READY or not(sig_m_valid_dup);

   -- Generate the skid inpit register load enable control
   sig_skid_reg_en     <= sig_s_ready_dup;
  
   -- Generate the skid mux select control
   sig_skid_mux_sel    <= not(sig_s_ready_dup);
   
   
   -- Skid Mux  
   sig_data_skid_mux_out <=  sig_data_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  S_DATA;
  
   sig_strb_skid_mux_out <=  sig_strb_skid_reg
     When (sig_skid_mux_sel = '1')
     --Else  S_STRB;
     Else  sig_wstrb_demux_out;
  
   sig_last_skid_mux_out <=  sig_last_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  S_LAST;
  
   
   -- m_valid combinational logic        
   sig_m_valid_comb <= S_VALID or
                      (sig_m_valid_dup and
                      (not(sig_s_ready_dup) or
                       not(M_READY)));
   
   
   
   -- s_ready combinational logic        
   sig_s_ready_comb <= M_READY or
                      (sig_s_ready_dup and
                      (not(sig_m_valid_dup) or
                       not(S_VALID)));
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_THE_RST
   --
   -- Process Description:
   -- Register input reset
   --
   -------------------------------------------------------------
   REG_THE_RST : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           
            sig_reset_reg <= ARST;
           
        end if;       
      end process REG_THE_RST; 
   
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: S_READY_FLOP
   --
   -- Process Description:
   -- Registers S_READY handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   S_READY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_s_ready_out  <= '0';
             sig_s_ready_dup  <= '0';
            
           Elsif (sig_spcl_s_ready_set = '1') Then
           
             sig_s_ready_out  <= '1';
             sig_s_ready_dup  <= '1';
           
           else

             sig_s_ready_out  <= sig_s_ready_comb;
             sig_s_ready_dup  <= sig_s_ready_comb;
            
           end if; 
        end if;       
      end process S_READY_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: M_VALID_FLOP
   --
   -- Process Description:
   -- Registers M_VALID handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   M_VALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                 = '1' or
               sig_spcl_s_ready_set = '1') then -- Fix from AXI DMA

             sig_m_valid_out  <= '0';
             sig_m_valid_dup  <= '0';
            
           else

             sig_m_valid_out  <= sig_m_valid_comb;
             sig_m_valid_dup  <= sig_m_valid_comb;
            
           end if; 
        end if;       
      end process M_VALID_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_DATA_REG
   --
   -- Process Description:
   -- This process implements the Skid register for the 
   -- Skid Buffer Data signals.
   --
   -------------------------------------------------------------
   SKID_DATA_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           
           if  (sig_skid_reg_en = '1') then
             
             sig_data_skid_reg <= S_DATA;
             
           else
             null;  -- hold current state
           end if;
            
        end if;       
      end process SKID_DATA_REG; 
            
            
   
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_CNTL_REG
   --
   -- Process Description:
   -- This process implements the Output registers for the 
   -- Skid Buffer Control signals
   --
   -------------------------------------------------------------
   SKID_CNTL_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_strb_skid_reg <= (others => '0');
             sig_last_skid_reg <= '0';
             
           elsif (sig_skid_reg_en = '1') then
             
             sig_strb_skid_reg <= sig_wstrb_demux_out;
             sig_last_skid_reg <= S_LAST;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process SKID_CNTL_REG; 
            
            
   
            
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_DATA_REG
   --
   -- Process Description:
   -- This process implements the Output register for the 
   -- Data signals.
   --
   -------------------------------------------------------------
   OUTPUT_DATA_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           
           if (sig_data_reg_out_en = '1') then
             
             sig_data_reg_out <= sig_data_skid_mux_out;
             
           else
             null;  -- hold current state
           end if;
            
        end if;       
      end process OUTPUT_DATA_REG; 
            
            
 
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_CNTL_REG
   --
   -- Process Description:
   -- This process implements the Output registers for the 
   -- control signals.
   --
   -------------------------------------------------------------
   OUTPUT_CNTL_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_strb_reg_out <= (others => '0');
             sig_last_reg_out <= '0';
             
           elsif (sig_data_reg_out_en = '1') then
             
             sig_strb_reg_out <= sig_strb_skid_mux_out;
             sig_last_reg_out <= sig_last_skid_mux_out;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process OUTPUT_CNTL_REG; 
            
            
 
 
 
 
 
 
   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: DO_WR_DATA_MIRROR
   --
   -- Process Description:
   -- Implement the Write Data Mirror structure
   -- 
   -- Note that it is required that the Stream Width be less than
   -- or equal to the MMap WData width.
   --
   -------------------------------------------------------------
   DO_WR_DATA_MIRROR : process (sig_data_reg_out)
      begin
   
        for slice_index in 0 to MM2STRM_WIDTH_RATIO-1 loop
        
          sig_mirror_data_out(((C_SDATA_WIDTH*slice_index)+C_SDATA_WIDTH)-1 
                              downto C_SDATA_WIDTH*slice_index)
                              
                              <= sig_data_reg_out;
        
        end loop;
 
   
      end process DO_WR_DATA_MIRROR; 
   
 
 
 
 
        
    ------------------------------------------------------------
    -- Instance: I_WSTRB_DEMUX 
    --
    -- Description:
    -- Instance for the Write Strobe DeMux.    
    --
    ------------------------------------------------------------
     I_WSTRB_DEMUX : entity axi_datamover_v5_1_17.axi_datamover_wr_demux
     generic map (
      
       C_SEL_ADDR_WIDTH     =>  C_ADDR_LSB_WIDTH   ,  
       C_MMAP_DWIDTH        =>  C_MDATA_WIDTH      ,  
       C_STREAM_DWIDTH      =>  C_SDATA_WIDTH         
      
       )
     port map (
   
       wstrb_in             =>  S_STRB              , 
       demux_wstrb_out      =>  sig_wstrb_demux_out ,        
       debeat_saddr_lsb     =>  S_ADDR_LSB            
   
       );
   
 
 

end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_skid_buf.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_skid_buf.vhd
--
-- Description:     
--  Implements the AXi Skid Buffer in the Option 2 (Registerd outputs) mode.                
--                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;



-------------------------------------------------------------------------------

entity axi_datamover_skid_buf is
  generic (
    C_WDATA_WIDTH : INTEGER := 32  
       --  Width of the Stream Data bus (in bits) 
               
    );
  port (
    
    -- Clock and Reset Inputs ---------------------------------------------
    aclk         : In  std_logic ;                                       --
    arst         : In  std_logic ;                                       --
    -----------------------------------------------------------------------
    
    
    -- Shutdown control (assert for 1 clk pulse) --------------------------
                                                                         --
    skid_stop    : In std_logic  ;                                       --
    -----------------------------------------------------------------------
    
    
    -- Slave Side (Stream Data Input) -------------------------------------
    s_valid      : In  std_logic ;                                       --
    s_ready      : Out std_logic ;                                       --
    s_data       : In  std_logic_vector(C_WDATA_WIDTH-1 downto 0);       --
    s_strb       : In  std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);   --
    s_last       : In  std_logic ;                                       --
    -----------------------------------------------------------------------
    

    -- Master Side (Stream Data Output ------------------------------------
    m_valid      : Out std_logic ;                                       --
    m_ready      : In  std_logic ;                                       --
    m_data       : Out std_logic_vector(C_WDATA_WIDTH-1 downto 0);       --
    m_strb       : Out std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);   --
    m_last       : Out std_logic                                         --
    -----------------------------------------------------------------------
    );

end entity axi_datamover_skid_buf;


architecture implementation of axi_datamover_skid_buf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



-- Signals decalrations -------------------------

  Signal sig_reset_reg         : std_logic := '0';
  signal sig_spcl_s_ready_set  : std_logic := '0';
  signal sig_data_skid_reg     : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_reg     : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_reg     : std_logic := '0';
  signal sig_skid_reg_en       : std_logic := '0';
  signal sig_data_skid_mux_out : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_mux_out : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_mux_out : std_logic := '0';
  signal sig_skid_mux_sel      : std_logic := '0';
  signal sig_data_reg_out      : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_reg_out      : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_reg_out      : std_logic := '0';
  signal sig_data_reg_out_en   : std_logic := '0';
  signal sig_m_valid_out       : std_logic := '0';
  signal sig_m_valid_dup       : std_logic := '0';
  signal sig_m_valid_comb      : std_logic := '0';
  signal sig_s_ready_out       : std_logic := '0';
  signal sig_s_ready_dup       : std_logic := '0';
  signal sig_s_ready_comb      : std_logic := '0';
  signal sig_stop_request      : std_logic := '0';
  signal sig_stopped           : std_logic := '0';
  signal sig_sready_stop       : std_logic := '0';
  signal sig_sready_early_stop : std_logic := '0';
  signal sig_sready_stop_set   : std_logic := '0';
  signal sig_sready_stop_reg   : std_logic := '0';
  signal sig_mvalid_stop_reg   : std_logic := '0';
  signal sig_mvalid_stop       : std_logic := '0';
  signal sig_mvalid_early_stop : std_logic := '0';
  signal sig_mvalid_stop_set   : std_logic := '0';
  signal sig_slast_with_stop   : std_logic := '0';
  signal sig_sstrb_stop_mask   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_sstrb_with_stop   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  
  

 
-- Register duplication attribute assignments to control fanout
-- on handshake output signals  
  
  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration
  
  Attribute KEEP of sig_m_valid_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_m_valid_dup : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup : signal is "TRUE"; -- definition
  
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_out : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_dup : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_out : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup : signal is "no"; 
  
  
  

begin --(architecture implementation)

   m_valid <= sig_m_valid_out;         
   s_ready <= sig_s_ready_out; 
    
   m_strb  <= sig_strb_reg_out;
   m_last  <= sig_last_reg_out;                
   m_data  <= sig_data_reg_out;    
            
  
  
  
   -- Special shutdown logic version od Slast.
   -- A halt request forces a tlast through the skig buffer
   sig_slast_with_stop <= s_last or sig_stop_request;
   sig_sstrb_with_stop <= s_strb or sig_sstrb_stop_mask;
  
  
   -- Assign the special s_ready FLOP set signal
   sig_spcl_s_ready_set <= sig_reset_reg;
  
            
   -- Generate the ouput register load enable control
   sig_data_reg_out_en <= m_ready or not(sig_m_valid_dup);

   -- Generate the skid input register load enable control
   sig_skid_reg_en     <= sig_s_ready_dup;
  
   -- Generate the skid mux select control
   sig_skid_mux_sel    <= not(sig_s_ready_dup);
   
   
   -- Skid Mux  
   sig_data_skid_mux_out <=  sig_data_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  s_data;
  
   sig_strb_skid_mux_out <=  sig_strb_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_sstrb_with_stop;
  
   sig_last_skid_mux_out <=  sig_last_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_slast_with_stop;
  
   
   -- m_valid combinational logic        
   sig_m_valid_comb <= s_valid or
                      (sig_m_valid_dup and
                      (not(sig_s_ready_dup) or
                       not(m_ready)));
   
   
   
   -- s_ready combinational logic        
   sig_s_ready_comb <= m_ready or
                      (sig_s_ready_dup and
                      (not(sig_m_valid_dup) or
                       not(s_valid)));
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_THE_RST
   --
   -- Process Description:
   -- Register input reset
   --
   -------------------------------------------------------------
   REG_THE_RST : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           
            sig_reset_reg <= ARST;
           
        end if;       
      end process REG_THE_RST; 
   
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: S_READY_FLOP
   --
   -- Process Description:
   -- Registers s_ready handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   S_READY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                  = '1' or
               sig_sready_stop       = '1' or
               sig_sready_early_stop = '1') then  -- Special stop condition

             sig_s_ready_out  <= '0';
             sig_s_ready_dup  <= '0';
            
           Elsif (sig_spcl_s_ready_set = '1') Then
           
             sig_s_ready_out  <= '1';
             sig_s_ready_dup  <= '1';
           
           else

             sig_s_ready_out  <= sig_s_ready_comb;
             sig_s_ready_dup  <= sig_s_ready_comb;
            
           end if; 
        end if;       
      end process S_READY_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: M_VALID_FLOP
   --
   -- Process Description:
   -- Registers m_valid handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   M_VALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                  = '1' or
               sig_spcl_s_ready_set  = '1' or    -- Fix from AXI DMA
               sig_mvalid_stop       = '1' or
               sig_mvalid_stop_set   = '1') then -- Special stop condition

             sig_m_valid_out  <= '0';
             sig_m_valid_dup  <= '0';
            
           else

             sig_m_valid_out  <= sig_m_valid_comb;
             sig_m_valid_dup  <= sig_m_valid_comb;
            
           end if; 
        end if;       
      end process M_VALID_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_REG
   --
   -- Process Description:
   -- This process implements the output registers for the 
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   SKID_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_data_skid_reg <= (others => '0');
             sig_strb_skid_reg <= (others => '0');
             sig_last_skid_reg <= '0';
             
           elsif (sig_skid_reg_en = '1') then
             
             sig_data_skid_reg <= s_data;
             sig_strb_skid_reg <= sig_sstrb_with_stop;
             sig_last_skid_reg <= sig_slast_with_stop;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process SKID_REG; 
            
            
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_REG
   --
   -- Process Description:
   -- This process implements the output registers for the 
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   OUTPUT_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                = '1' or
               sig_mvalid_stop_reg = '1') then
             
             sig_data_reg_out <= (others => '0');
             sig_strb_reg_out <= (others => '0');
             sig_last_reg_out <= '0';
             
           elsif (sig_data_reg_out_en = '1') then
             
             sig_data_reg_out <= sig_data_skid_mux_out;
             sig_strb_reg_out <= sig_strb_skid_mux_out;
             sig_last_reg_out <= sig_last_skid_mux_out;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process OUTPUT_REG; 
            
            
  
  
  
  
  
  
  
  
  
  
  
  
   -------- Special Stop Logic --------------------------------------
   
   
   sig_sready_stop        <= sig_sready_stop_reg; 
  
  
   sig_sready_early_stop  <= skid_stop; -- deassert S_READY immediately
   
  
   sig_sready_stop_set    <= sig_sready_early_stop;
   
                                     
   sig_mvalid_stop        <=  sig_mvalid_stop_reg;
                                     
                                     
   sig_mvalid_early_stop  <= sig_m_valid_dup and
                            m_ready and
                            skid_stop;
  
    
   sig_mvalid_stop_set    <=  sig_mvalid_early_stop or
                              (sig_stop_request and 
                               not(sig_m_valid_dup)) or
                              (sig_m_valid_dup and
                               m_ready         and
                               sig_stop_request);
   
   
   
                             
    
    
                                     
                                     
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_STOP_REQ_FLOP
   --
   -- Process Description:
   -- This process implements the Stop request flop. It is a 
   -- sample and hold register that can only be cleared by reset.
   --
   -------------------------------------------------------------
   IMP_STOP_REQ_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_stop_request    <= '0';
             sig_sstrb_stop_mask <= (others => '0');
             
           elsif (skid_stop = '1') then
             
             sig_stop_request    <= '1';
             sig_sstrb_stop_mask <= (others => '1');
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_STOP_REQ_FLOP; 
            
            
  
  
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_SREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the s_ready 
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_SREADY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_sready_stop_reg <= '0';
             
           elsif (sig_sready_stop_set  = '1') then
             
             sig_sready_stop_reg <= '1';
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_CLR_SREADY_FLOP; 
            
            
  
  
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_MVALID_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the m_valid 
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_MVALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then
             
             sig_mvalid_stop_reg <= '0';
             
           elsif (sig_mvalid_stop_set  = '1') then
             
             sig_mvalid_stop_reg <= '1';
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_CLR_MVALID_FLOP; 
            
            


end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_rd_sf.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_rd_sf.vhd
  --
  -- Description:     
  --    This file implements the AXI DataMover Read (MM2S) Store and Forward module. 
  --  The design utilizes the AXI DataMover's new address pipelining
  --  control function. The design is such that predictive address  
  --  pipelining can be supported on the AXI Read Bus without over-commiting 
  --  the internal Data FIFO and potentially throttling the Read Data Channel 
  --  if the Data FIFO goes full. 
  -- 
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library lib_pkg_v1_0_2;
  use lib_pkg_v1_0_2.lib_pkg.all;
  use lib_pkg_v1_0_2.lib_pkg.clog2;

  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_sfifo_autord;
  use axi_datamover_v5_1_17.axi_datamover_fifo;

  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_rd_sf is
    generic (
      
      C_SF_FIFO_DEPTH        : Integer range 128 to 8192 := 512;
        -- Sets the desired depth of the internal Data FIFO.
      
      C_MAX_BURST_LEN        : Integer range  2 to  256 :=  16;
        -- Indicates the max burst length being used by the external
        -- AXI4 Master for each AXI4 transfer request.
        
      C_DRE_IS_USED          : Integer range   0 to    1 :=   0;
        -- Indicates if the external Master is utilizing a DRE on
        -- the stream input to this module.
         
      C_DRE_CNTL_FIFO_DEPTH  : Integer range  1 to  32 :=  1;
        -- Specifies the depth of the internal dre control queue fifo
      
      C_DRE_ALIGN_WIDTH      : Integer range  1 to   6 :=  2;
        -- Sets the width of the DRE alignment control ports
      
      C_MMAP_DWIDTH          : Integer range   32 to  1024 := 64;
        -- Sets the AXI4 Memory Mapped Bus Data Width 
      
      C_STREAM_DWIDTH        : Integer range   8 to  1024 :=  32;
        -- Sets the Stream Data Width for the Input and Output
        -- Data streams.
        
      C_STRT_SF_OFFSET_WIDTH : Integer range   1 to 7 :=  2;
        -- Sets the bit width of the starting address offset port
        -- This should be set to log2(C_MMAP_DWIDTH/C_STREAM_DWIDTH)
    C_ENABLE_MM2S_TKEEP             : integer range 0 to 1 := 1; 
        
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        -- Indicates the width of the Tag field of the input DRE command
        
      C_FAMILY               : String  := "virtex7"
        -- Indicates the target FPGA Family.
      
      );
    port (
      
      -- Clock and Reset inputs --------------------------------------------
                                                                          --
      aclk                    : in  std_logic;                            --
         -- Primary synchronization clock for the Master side             --
         -- interface and internal logic. It is also used                 --
         -- for the User interface synchronization when                   --
         -- C_STSCMD_IS_ASYNC = 0.                                        --
                                                                          --
      -- Reset input                                                      --
      reset                   : in  std_logic;                            --
         -- Reset used for the internal syncronization logic              --
      ----------------------------------------------------------------------
    
    
      -- DataMover Read Side Address Pipelining Control Interface ----------
                                                                          --
      ok_to_post_rd_addr      : Out  Std_logic;                           --
        -- Indicates that the transfer token pool has at least            --
        -- one token available to borrow                                  --
                                                                          --
      rd_addr_posted          : In std_logic;                             --
        -- Indication that a read address has been posted to AXI4         --
                                                                          --
      rd_xfer_cmplt           : In std_logic;                             --
        -- Indicates that the Datamover has completed a Read Data         --
        -- transfer on the AXI4                                           --
      ----------------------------------------------------------------------
      
       
        
      -- Read Side Stream In from DataMover MM2S Read Data Controller ----------------------
                                                                                          --
      sf2sin_tready           : Out  Std_logic;                                           --
        -- DRE  Stream READY input                                                        --
                                                                                          --
      sin2sf_tvalid           : In  std_logic;                                            --
        -- DRE Stream VALID Output                                                        --
                                                                                          --
      sin2sf_tdata            : In  std_logic_vector(C_MMAP_DWIDTH-1 downto 0);           --
        -- DRE  Stream DATA input                                                         --
                                                                                          --
      sin2sf_tkeep            : In std_logic_vector((C_MMAP_DWIDTH/8)-1 downto 0);        --   
        -- DRE  Stream STRB input                                                         --
                                                                                          --
      sin2sf_tlast            : In std_logic;                                             --
        -- DRE  Xfer LAST input                                                           --
      --------------------------------------------------------------------------------------

      
      -- RDC Store and Forward Supplimental Controls ---------------------
      -- These are time aligned and qualified with the RDC Stream Input --
                                                                        --
      data2sf_cmd_cmplt       : In std_logic;                           --
      data2sf_dre_flush       : In std_logic;                           --
      --------------------------------------------------------------------
     
     
               
                
      -- DRE Control Interface from the Command Calculator  -----------------------------
                                                                                       --
      dre2mstr_cmd_ready      : Out std_logic ;                                        --
        -- Indication from the DRE that the command is being                           --
        -- accepted from the Command Calculator                                        --
                                                                                       --
      mstr2dre_cmd_valid      : In std_logic;                                          --
        -- The next command valid indication to the DRE                                --
        -- from the Command Calculator                                                 --
                                                                                       --
      mstr2dre_tag            : In std_logic_vector(C_TAG_WIDTH-1 downto 0);           --
        -- The next command tag                                                        --
                                                                                       --
      mstr2dre_dre_src_align  : In std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
        -- The source (input) alignment for the DRE                                    --
                                                                                       --
      mstr2dre_dre_dest_align : In std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
        -- The destinstion (output) alignment for the DRE                              --
                                                                                       --
      -- mstr2dre_btt            : In std_logic_vector(C_BTT_USED-1 downto 0);            --
      --   -- The bytes to transfer value for the input command                           --
                                                                                       --
      mstr2dre_drr            : In std_logic;                                          --
        -- The starting tranfer of a sequence of transfers                             --
                                                                                       --
      mstr2dre_eof            : In std_logic;                                          --
        -- The endiing tranfer of a sequence of transfers                              --
                                                                                       --
      -- mstr2dre_cmd_cmplt      : In std_logic;                                          --
      --   -- The last tranfer command of a sequence of transfers                         --
      --   -- spawned from a single parent command                                        --
                                                                                       --
      mstr2dre_calc_error     : In std_logic;                                          --
        -- Indication if the next command in the calculation pipe                      --
        -- has a calculation error                                                     --
                                                                                       --
      mstr2dre_strt_offset    : In std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0);--
        -- Outputs the starting offset of a transfer. This is used with Store          --
        -- and Forward Packer/Unpacker logic                                           --
      -----------------------------------------------------------------------------------



     -- MM2S DRE Control  -------------------------------------------------------------
                                                                                     --
      sf2dre_new_align      : Out std_logic;                                         --
        -- Active high signal indicating new DRE aligment required                   --
                                                                                     --
      sf2dre_use_autodest   : Out std_logic;                                         --
        -- Active high signal indicating to the DRE to use an auto-                  --
        -- calculated desination alignment based on the last transfer                --
                                                                                     --
      sf2dre_src_align      : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);    --
        -- Bit field indicating the byte lane of the first valid data byte           --
        -- being sent to the DRE                                                     --
                                                                                     --
      sf2dre_dest_align     : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);    --
        -- Bit field indicating the desired byte lane of the first valid data byte   --
        -- to be output by the DRE                                                   --
                                                                                     --
      sf2dre_flush          : Out std_logic;                                         --
        -- Active high signal indicating to the DRE to flush the current             --
        -- contents to the output register in preparation of a new alignment         --
        -- that will be comming on the next transfer input                           --
      ---------------------------------------------------------------------------------
               
                
                
                
      -- Stream Out  -----------------------------------------------------------------------
                                                                                          --
      sout2sf_tready          : In  std_logic;                                            --
        -- Write READY input from the Stream Master                                       --
                                                                                          --
      sf2sout_tvalid          : Out  std_logic;                                           --
        -- Write VALID output to the Stream Master                                        --
                                                                                          --
      sf2sout_tdata           : Out  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);        --
        -- Write DATA output to the Stream Master                                         --
                                                                                          --
      sf2sout_tkeep           : Out  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);    --
        -- Write DATA output to the Stream Master                                         --
                                                                                          --
      sf2sout_tlast           : Out  std_logic                                            --
        -- Write LAST output to the Stream Master                                         --
      --------------------------------------------------------------------------------------
 
      );
  
  end entity axi_datamover_rd_sf;
  
  
  architecture implementation of axi_datamover_rd_sf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Functions ---------------------------------------------------------------------------
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_fifo_cnt_width
    --
    -- Function Description:
    --   simple function to set the width of the data fifo read 
    -- and write count outputs. 
    -------------------------------------------------------------------
    function funct_get_fifo_cnt_width (fifo_depth : integer) 
             return integer is
    
      Variable temp_width : integer := 8;
    
    begin
    
      if (fifo_depth = 1) then
      
         temp_width := 1;
      
      elsif (fifo_depth  = 2) then
      
         temp_width := 2;
      
      elsif (fifo_depth  <= 4) then
      
         temp_width := 3;
      
      elsif (fifo_depth  <= 8) then
      
         temp_width := 4;
      
      elsif (fifo_depth  <= 16) then
      
         temp_width := 5;
      
      elsif (fifo_depth  <= 32) then
      
         temp_width := 6;
      
      elsif (fifo_depth  <= 64) then
      
         temp_width := 7;
      
      elsif (fifo_depth  <= 128) then
      
         temp_width := 8;
      
      elsif (fifo_depth  <= 256) then
      
         temp_width := 9;
      
      elsif (fifo_depth  <= 512) then
      
         temp_width := 10;
      
      elsif (fifo_depth  <= 1024) then
      
         temp_width := 11;
      
      elsif (fifo_depth  <= 2048) then
      
         temp_width := 12;
      
      elsif (fifo_depth  <= 4096) then
      
         temp_width := 13;
      
      else -- assume 8192 depth
      
         temp_width := 14;
      
      end if;
      
      
      Return (temp_width);
     
    
    end function funct_get_fifo_cnt_width;
    
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_wrcnt_lsrip
    --
    -- Function Description:
    --   Calculates the ls index of the upper slice of the data fifo
    -- write count needed to repesent one max burst worth of data
    -- present in the fifo.
    --
    -------------------------------------------------------------------
    function funct_get_wrcnt_lsrip (max_burst_dbeats : integer) return integer is
    
      Variable temp_ls_index : Integer := 0;
    
    begin
      
      if (max_burst_dbeats <= 2) then
      
        temp_ls_index := 1;
      
      elsif (max_burst_dbeats <= 4) then
      
        temp_ls_index := 2;
      
      elsif (max_burst_dbeats <= 8) then
      
        temp_ls_index := 3;
      
      elsif (max_burst_dbeats <= 16) then
      
        temp_ls_index := 4;
      
      elsif (max_burst_dbeats <= 32) then
      
        temp_ls_index := 5;
      
      elsif (max_burst_dbeats <= 64) then
      
        temp_ls_index := 6;
      
      elsif (max_burst_dbeats <= 128) then
      
        temp_ls_index := 7;
      
      else
      
        temp_ls_index := 8;
      
      end if;
      
      Return (temp_ls_index);
      
      
    end function funct_get_wrcnt_lsrip;
    
     
     
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_stall_thresh
    --
    -- Function Description:
    -- Calculates the Stall threshold for the input side of the Data
    -- FIFO. If DRE is being used by the DataMover, then the threshold
    -- must be reduced to account for the potential of an extra write
    -- databeat per request (DRE alignment dependent).
    --
    -------------------------------------------------------------------
    function funct_get_stall_thresh (dre_is_used         : integer;
                                     max_xfer_length     : integer;
                                     data_fifo_depth     : integer;
                                     pipeline_delay_clks : integer;
                                     fifo_settling_clks  : integer) return integer is
    
      Constant DRE_PIPE_DELAY             : integer := 2; -- clks
      
      Variable var_num_max_xfers_allowed  : Integer := 0;
      Variable var_dre_dbeat_overhead     : Integer := 0;
      Variable var_delay_fudge_factor     : Integer := 0;    
      Variable var_thresh_headroom        : Integer := 0;
      Variable var_stall_thresh           : Integer := 0;
      
    begin
    
      var_num_max_xfers_allowed := data_fifo_depth/max_xfer_length;
      
      var_dre_dbeat_overhead    := var_num_max_xfers_allowed * dre_is_used;
      
      
      var_delay_fudge_factor    := (dre_is_used * DRE_PIPE_DELAY) + 
                                   pipeline_delay_clks            + 
                                   fifo_settling_clks;
      
      var_thresh_headroom       := max_xfer_length        + 
                                   var_dre_dbeat_overhead + 
                                   var_delay_fudge_factor;
      
      -- Scale the result to be in max transfer length increments
      var_stall_thresh          := (data_fifo_depth - var_thresh_headroom)/max_xfer_length;
      
      Return (var_stall_thresh);
      
      
    end function funct_get_stall_thresh;
    
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_size_drecntl_fifo
    --
    -- Function Description:
    --  Assures that the DRE control fifo depth is at least 4 deep else it
    -- is equal to the number of max burst transfers that can fit in the
    -- Store and Forward Data FIFO.
    --
    -------------------------------------------------------------------
    function funct_size_drecntl_fifo (sf_fifo_depth    : integer;
                                      max_burst_length : integer) return integer is
    
      
      Constant NEEDED_FIFO_DEPTH : integer := sf_fifo_depth/max_burst_length;
      
      
      Variable temp_fifo_depth : Integer := 4;
    
    begin
    
      If (NEEDED_FIFO_DEPTH < 4) Then
    
        temp_fifo_depth := 4;
      
      Else 

        temp_fifo_depth := NEEDED_FIFO_DEPTH;
          
      End if;
      
      
      Return (temp_fifo_depth);
      
      
    end function funct_size_drecntl_fifo;
    

     
     

    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_cntr_width
    --
    -- Function Description:
    --  Detirmine the width needed for the address offset counter used
    -- for the data fifo mux selects.
    --
    -------------------------------------------------------------------
    function funct_get_cntr_width (num_count_states : integer) return integer is
    
     Variable lvar_temp_width : Integer := 1;
    
    begin
      
      if (num_count_states <= 2) then
      
         lvar_temp_width := 1;
      
      elsif (num_count_states <= 4) then
      
         lvar_temp_width := 2;
      
      elsif (num_count_states <= 8) then
      
         lvar_temp_width := 3;
      
      elsif (num_count_states <= 16) then
      
         lvar_temp_width := 4;
      
      elsif (num_count_states <= 32) then
      
         lvar_temp_width := 5;
      
      elsif (num_count_states <= 64) then
      
         lvar_temp_width := 6;
      
      Else   -- 128 cnt states
         
         lvar_temp_width := 7;
      
      end if;
      
      
      
      Return (lvar_temp_width);
      
      
      
    end function funct_get_cntr_width;
    
    
    
    
    -- Constants ---------------------------------------------------------------------------
    
    Constant LOGIC_LOW                 : std_logic := '0';
    Constant LOGIC_HIGH                : std_logic := '1';
    
    Constant BLK_MEM_FIFO              : integer := 1;
    Constant SRL_FIFO                  : integer := 0;
    Constant NOT_NEEDED                : integer := 0;
    
    
    Constant MMAP_TKEEP_WIDTH          : integer := C_MMAP_DWIDTH/8; -- bits
    Constant TLAST_WIDTH               : integer := 1;               -- bits
    Constant CMPLT_WIDTH               : integer := 1;               -- bits
    Constant DRE_FLUSH_WIDTH           : integer := 1;               -- bits
    
    
    Constant DATA_FIFO_DEPTH           : integer := C_SF_FIFO_DEPTH;
    Constant DATA_FIFO_CNT_WIDTH       : integer := funct_get_fifo_cnt_width(DATA_FIFO_DEPTH);
    Constant DF_WRCNT_RIP_LS_INDEX     : integer := funct_get_wrcnt_lsrip(C_MAX_BURST_LEN);
    Constant DATA_FIFO_WIDTH           : integer := C_MMAP_DWIDTH    +
                                                    MMAP_TKEEP_WIDTH*C_ENABLE_MM2S_TKEEP +
                                                    TLAST_WIDTH      +
                                                    CMPLT_WIDTH      +
                                                    DRE_FLUSH_WIDTH;
    
    Constant DATA_OUT_LSB_INDEX        : integer := 0;
    Constant DATA_OUT_MSB_INDEX        : integer := C_MMAP_DWIDTH-1;
    
    Constant TKEEP_OUT_LSB_INDEX       : integer := DATA_OUT_MSB_INDEX+1;
    Constant TKEEP_OUT_MSB_INDEX       : integer := (TKEEP_OUT_LSB_INDEX+MMAP_TKEEP_WIDTH*C_ENABLE_MM2S_TKEEP)-1*C_ENABLE_MM2S_TKEEP;
    
    Constant TLAST_OUT_INDEX           : integer := TKEEP_OUT_MSB_INDEX+1*C_ENABLE_MM2S_TKEEP;
    Constant CMPLT_OUT_INDEX           : integer := TLAST_OUT_INDEX+1;
    Constant DRE_FLUSH_OUT_INDEX       : integer := CMPLT_OUT_INDEX+1;
    
    
    Constant TOKEN_POOL_SIZE           : integer := C_SF_FIFO_DEPTH / C_MAX_BURST_LEN;
    
    Constant TOKEN_CNTR_WIDTH          : integer := clog2(TOKEN_POOL_SIZE)+1;
    
    Constant TOKEN_CNT_ZERO            : Unsigned(TOKEN_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(0, TOKEN_CNTR_WIDTH);
    
    Constant TOKEN_CNT_ONE             : Unsigned(TOKEN_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, TOKEN_CNTR_WIDTH);
    
    Constant TOKEN_CNT_MAX             : Unsigned(TOKEN_CNTR_WIDTH-1 downto 0) :=  
                                         TO_UNSIGNED(TOKEN_POOL_SIZE, TOKEN_CNTR_WIDTH);
    
    Constant THRESH_COMPARE_WIDTH      : integer := TOKEN_CNTR_WIDTH+2;
    
              
    Constant RD_PATH_PIPE_DEPTH        : integer := 2; -- clocks excluding DRE
    
    Constant WRCNT_SETTLING_TIME       : integer := 2; -- data fifo push or pop settling clocks
    
    
    Constant DRE_COMPENSATION          : integer := 0; -- DRE does not contribute since it is on
                                                       -- the output side of the Store and Forward
    
    Constant RD_ADDR_POST_STALL_THRESH : integer := 
                                         funct_get_stall_thresh(DRE_COMPENSATION   ,
                                                                C_MAX_BURST_LEN    ,
                                                                C_SF_FIFO_DEPTH    ,
                                                                RD_PATH_PIPE_DEPTH ,
                                                                WRCNT_SETTLING_TIME);
    
    Constant RD_ADDR_POST_STALL_THRESH_US : Unsigned(THRESH_COMPARE_WIDTH-1 downto 0) := 
                                            TO_UNSIGNED(RD_ADDR_POST_STALL_THRESH , 
                                                        THRESH_COMPARE_WIDTH);
    
    
    Constant UNCOM_WRCNT_1             : Unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, DATA_FIFO_CNT_WIDTH);
    
    Constant UNCOM_WRCNT_0             : Unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(0, DATA_FIFO_CNT_WIDTH);
    

    Constant USE_SYNC_FIFO             : integer := 0;
    Constant SRL_FIFO_PRIM             : integer := 2;
    
    Constant TAG_WIDTH                 : integer := C_TAG_WIDTH;
    Constant SRC_ALIGN_WIDTH           : integer := C_DRE_ALIGN_WIDTH;
    Constant DEST_ALIGN_WIDTH          : integer := C_DRE_ALIGN_WIDTH;
    Constant DRR_WIDTH                 : integer := 1;
    Constant EOF_WIDTH                 : integer := 1;
    Constant CALC_ERR_WIDTH            : integer := 1;
    Constant SF_OFFSET_WIDTH           : integer := C_STRT_SF_OFFSET_WIDTH;
    
    

    
    
    
    -- Signals ---------------------------------------------------------------------------
    
    signal sig_good_sin_strm_dbeat    : std_logic := '0';
    signal sig_strm_sin_ready         : std_logic := '0';
    
    signal sig_good_sout_strm_dbeat   : std_logic := '0';
    signal sig_sout2sf_tready         : std_logic := '0';
    signal sig_sf2sout_tvalid         : std_logic := '0';
    signal sig_sf2sout_tdata          : std_logic_vector(C_STREAM_DWIDTH-1 downto 0) := (others => '0');
    signal sig_sf2sout_tkeep          : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_sf2sout_tlast          : std_logic := '0';
    
    signal sig_sf2dre_flush           : std_logic := '0';
    
    signal sig_push_data_fifo         : std_logic := '0';
    signal sig_pop_data_fifo          : std_logic := '0';
    signal sig_data_fifo_full         : std_logic := '0';
    signal sig_data_fifo_data_in      : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_dvalid       : std_logic := '0';
    signal sig_data_fifo_data_out     : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_wr_cnt       : std_logic_vector(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_wr_cnt_unsgnd     : unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_wrcnt_mblen_slice      : unsigned(DATA_FIFO_CNT_WIDTH-1 downto 
                                                 DF_WRCNT_RIP_LS_INDEX) := (others => '0');
    
    signal sig_ok_to_post_rd_addr     : std_logic := '0';
    signal sig_rd_addr_posted         : std_logic := '0';
    signal sig_rd_xfer_cmplt          : std_logic := '0';
    signal sig_taking_last_token      : std_logic := '0';
    signal sig_stall_rd_addr_posts    : std_logic := '0';
    
    signal sig_incr_token_cntr        : std_logic := '0';
    signal sig_decr_token_cntr        : std_logic := '0';
    signal sig_token_eq_max           : std_logic := '0';
    signal sig_token_eq_zero          : std_logic := '0';
    signal sig_token_eq_one           : std_logic := '0';
    signal sig_token_cntr             : Unsigned(TOKEN_CNTR_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_tokens_commited        : Unsigned(TOKEN_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_commit_plus_actual     : unsigned(THRESH_COMPARE_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_cntl_fifo_has_data     : std_logic := '0';
    signal sig_get_cntl_fifo_data     : std_logic := '0';
                    
    signal sig_curr_tag_reg           : std_logic_vector(TAG_WIDTH-1 downto 0)        := (others => '0');
    signal sig_curr_src_align_reg     : std_logic_vector(SRC_ALIGN_WIDTH-1 downto 0)  := (others => '0');
    signal sig_curr_dest_align_reg    : std_logic_vector(DEST_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_curr_drr_reg           : std_logic := '0';
    signal sig_curr_eof_reg           : std_logic := '0';
    signal sig_curr_calc_error_reg    : std_logic := '0';
    signal sig_curr_strt_offset_reg   : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_ld_dre_cntl_reg        : std_logic := '0';
    
    signal sig_dfifo_data_out         : std_logic_vector(C_MMAP_DWIDTH-1 downto 0)    := (others => '0');
    signal sig_dfifo_tkeep_out        : std_logic_vector(MMAP_TKEEP_WIDTH-1 downto 0) := (others => '0');
    signal sig_dfifo_tlast_out        : std_logic := '0';
    signal sig_dfifo_cmd_cmplt_out    : std_logic := '0';
    signal sig_dfifo_dre_flush_out    : std_logic := '0';
    
  
  begin --(architecture implementation)
  
   
   
    -- Read Side (MM2S) Control Flags port connections
    ok_to_post_rd_addr       <= sig_ok_to_post_rd_addr ;
    sig_rd_addr_posted       <= rd_addr_posted         ;
    sig_rd_xfer_cmplt        <= rd_xfer_cmplt          ;
    
    
    
    --  Output Stream Port connections
    sig_sout2sf_tready       <= sout2sf_tready        ;
    sf2sout_tvalid           <= sig_sf2sout_tvalid    ;
    sf2sout_tdata            <= sig_sf2sout_tdata     ; 
    --sf2sout_tkeep            <= sig_sf2sout_tkeep     ;
    sf2sout_tlast            <= sig_sf2sout_tlast and
                                sig_sf2sout_tvalid    ;
    
   



GEN_MM2S_TKEEP_ENABLE4 : if C_ENABLE_MM2S_TKEEP = 1 generate
begin

    sf2sout_tkeep            <= sig_sf2sout_tkeep     ;
 
end generate GEN_MM2S_TKEEP_ENABLE4;

GEN_MM2S_TKEEP_DISABLE4 : if C_ENABLE_MM2S_TKEEP = 0 generate
begin

  sf2sout_tkeep        <= (others => '1');

end generate GEN_MM2S_TKEEP_DISABLE4;




 
    -- Input Stream port connections 
    sf2sin_tready            <= sig_strm_sin_ready;
    
    sig_strm_sin_ready       <= not(sig_data_fifo_full); -- Throttle if Read Side Data fifo goes full.
                                                         -- This should never happen if read address 
                                                         -- posting control is working properly.
    
    
    -- Stream transfer qualifiers
    
    sig_good_sin_strm_dbeat  <= sin2sf_tvalid and
                                sig_strm_sin_ready;
                               
 
    sig_good_sout_strm_dbeat <= sig_sf2sout_tvalid and  
                                sig_sout2sf_tready;     
  
  
  
  
  
  
  
 ---------------------------------------------------------------- 
 -- Unpacking Logic    ------------------------------------------
 ---------------------------------------------------------------- 
 
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_UNPACKING
    --
    -- If Generate Description:
    --    Omits any unpacking logic in the Store and Forward module.
    -- The Stream and MMap data widths are the same. The Data FIFO
    -- output can be connected directly to the stream outputs.
    --
    ------------------------------------------------------------
    OMIT_UNPACKING : if (C_MMAP_DWIDTH = C_STREAM_DWIDTH) generate
    
      signal lsig_cmd_loaded          : std_logic := '0';
      signal lsig_ld_cmd              : std_logic := '0';
      signal lsig_cmd_cmplt_dbeat     : std_logic := '0';
      signal lsig_cmd_cmplt           : std_logic := '0';
      
      begin
   
            
            
        -- Data FIFO Output to the stream attachments
        sig_sf2sout_tvalid      <=  sig_data_fifo_dvalid and 
                                    lsig_cmd_loaded     ;
        
        sig_sf2sout_tdata       <=  sig_dfifo_data_out  ;
        
        sig_sf2sout_tkeep       <=  sig_dfifo_tkeep_out ;
        
        sig_sf2sout_tlast       <=  sig_dfifo_tlast_out ;
        
        sig_sf2dre_flush        <=  sig_dfifo_dre_flush_out   ;
        
         
         
        -- Control for reading the Data FIFO
        sig_pop_data_fifo       <=  lsig_cmd_loaded    and
                                    sig_sout2sf_tready and 
                                    sig_data_fifo_dvalid;
        
        -- Control for reading the Command/Offset FIFO
        sig_get_cntl_fifo_data  <= lsig_ld_cmd ;
      
        
        -- Control for loading the DRE Control Reg
        sig_ld_dre_cntl_reg     <= lsig_ld_cmd ;
        
       
        lsig_cmd_cmplt_dbeat    <= sig_dfifo_cmd_cmplt_out and
                                   lsig_cmd_loaded         and
                                   sig_data_fifo_dvalid    and
                                   sig_sout2sf_tready  ;

     
        -- Generate the control that loads the DRE
        lsig_ld_cmd             <= (sig_cntl_fifo_has_data and  -- startup or gap case
                                    not(lsig_cmd_loaded))  or
                                   (sig_cntl_fifo_has_data and  -- back to back commands
                                    lsig_cmd_cmplt_dbeat);
                                      
         
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_CMD_LOADED
        --
        -- Process Description:
        --  Implements the flop indicating a command from the cmd fifo
        -- has been loaded into the DRE Output Register.
        --
        -------------------------------------------------------------
        IMP_CMD_LOADED : process (aclk)
          begin
            if (aclk'event and aclk = '1') then
              if (reset = '1') then
       
                lsig_cmd_loaded <= '0';
       
              Elsif (lsig_ld_cmd = '1' ) Then
              
                lsig_cmd_loaded <= '1';
              
              elsif (sig_cntl_fifo_has_data = '0' and   -- No more commands queued and
                     lsig_cmd_cmplt_dbeat   = '1') then
       
                lsig_cmd_loaded <= '0';
       
              else
       
                null;  -- Hold Current State
       
              end if; 
            end if;       
          end process IMP_CMD_LOADED; 
        
        
        
       
       
       
      
      end generate OMIT_UNPACKING;
    
     
    
    
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_UNPACKING
    --
    -- If Generate Description:
    --    Includes unpacking logic in the Store and Forward module.
    -- The MMap Data bus is wider than the Stream width.
    --
    ------------------------------------------------------------
    INCLUDE_UNPACKING : if (C_MMAP_DWIDTH > C_STREAM_DWIDTH) generate
    
      Constant MMAP2STRM_WIDTH_RATO  : integer := C_MMAP_DWIDTH/C_STREAM_DWIDTH;
    
      Constant DATA_SLICE_WIDTH      : integer := C_STREAM_DWIDTH;
      
      Constant TKEEP_SLICE_WIDTH     : integer := C_STREAM_DWIDTH/8;
      
      Constant FLAG_SLICE_WIDTH      : integer := TLAST_WIDTH;
      
      Constant OFFSET_CNTR_WIDTH     : integer := funct_get_cntr_width(MMAP2STRM_WIDTH_RATO);
      
      Constant OFFSET_CNT_ONE        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(1, OFFSET_CNTR_WIDTH);
      
      Constant OFFSET_CNT_MAX        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(MMAP2STRM_WIDTH_RATO-1, OFFSET_CNTR_WIDTH);
      
      
      
      -- Types -----------------------------------------------------------------------------
      type lsig_data_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(DATA_SLICE_WIDTH-1 downto 0);

      type lsig_tkeep_slice_type is array(MMAP2STRM_WIDTH_RATO downto 0) of
                    std_logic_vector(TKEEP_SLICE_WIDTH-1 downto 0);

      type lsig_flag_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(FLAG_SLICE_WIDTH-1 downto 0);


       
      -- local signals
      
      signal lsig_0ffset_cntr         : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := (others => '0');
      signal lsig_ld_offset           : std_logic := '0';
      signal lsig_incr_offset         : std_logic := '0';
      signal lsig_offset_cntr_eq_max  : std_logic := '0';
      signal lsig_fifo_data_out_wide  : lsig_data_slice_type;
      signal lsig_fifo_tkeep_out_wide : lsig_tkeep_slice_type;
      signal lsig_mux_sel             : integer range 0 to MMAP2STRM_WIDTH_RATO-1;
      signal lsig_data_mux_out        : std_logic_vector(DATA_SLICE_WIDTH-1 downto 0) ;
      signal lsig_tkeep_mux_out       : std_logic_vector(TKEEP_SLICE_WIDTH-1 downto 0);
      signal lsig_tlast_out           : std_logic := '0';
      signal lsig_dre_flush_out       : std_logic := '0';
      signal lsig_this_fifo_wrd_done  : std_logic := '0';
      signal lsig_cmd_loaded          : std_logic := '0';
      signal lsig_cmd_cmplt_dbeat     : std_logic := '0';
      signal lsig_cmd_cmplt           : std_logic := '0';
      signal lsig_next_slice_tkeep_0  : std_logic := '0';
       
        
      begin
    
       
       sig_sf2sout_tvalid      <= sig_data_fifo_dvalid and 
                                  lsig_cmd_loaded      ;
       
       sig_sf2sout_tdata       <= lsig_data_mux_out    ;
       
       sig_sf2sout_tkeep       <= lsig_tkeep_mux_out(TKEEP_SLICE_WIDTH-1 downto 0);
      
       sig_sf2sout_tlast       <= lsig_tlast_out       ;
      
       sig_sf2dre_flush        <= lsig_dre_flush_out   ;
       

       
       
       -- Control for reading the Data FIFO
       sig_pop_data_fifo       <= lsig_this_fifo_wrd_done and
                                  lsig_cmd_loaded         and
                                  sig_sout2sf_tready      and 
                                  sig_data_fifo_dvalid;
     
       -- Control for reading the Command/Offset FIFO
       sig_get_cntl_fifo_data  <= lsig_ld_offset;
       
       
       -- Control for loading the DRE Control Reg
       sig_ld_dre_cntl_reg     <= lsig_ld_offset ;
       
       
       lsig_next_slice_tkeep_0 <= lsig_fifo_tkeep_out_wide(lsig_mux_sel+1)(0);
       
       
       -- Detirmine if a Command Complete condition exists
       lsig_cmd_cmplt  <= '1'
         when (sig_dfifo_cmd_cmplt_out = '1' and
               lsig_next_slice_tkeep_0 = '0')
         Else '0';
       
       
       
       -- Detirmine if a TLAST condition exists
       -- From the RDC via the Data FIFO
       lsig_tlast_out <= '1'
         when (sig_dfifo_tlast_out     = '1' and
               lsig_next_slice_tkeep_0 = '0')
         Else '0';
        
       
       -- Detimine if a DRE Flush condition exists
       -- From the RDC via the Data FIFO
       lsig_dre_flush_out <= '1'
         when (sig_dfifo_dre_flush_out = '1' and
               lsig_next_slice_tkeep_0 = '0')
         Else '0';
      
      
      
       
       
       lsig_cmd_cmplt_dbeat <= lsig_cmd_cmplt          and
                               lsig_cmd_loaded         and
                               sig_data_fifo_dvalid    and
                               sig_sout2sf_tready  ;

     
       
       -- Check to see if the FIFO output word is finished. This occurs
       -- when the offset counter is at max value or the tlast from the
       -- fifo is set and the LS TKEED of the next MS Slice is zero.
       lsig_this_fifo_wrd_done  <= '1'
         When (lsig_offset_cntr_eq_max = '1' or
              (lsig_cmd_cmplt_dbeat    = '1' and
               lsig_next_slice_tkeep_0 = '0'))
         Else '0';
      
       
        
       -- Generate the control that loads the starting address
       -- offset for the next input packet
       lsig_ld_offset          <= (sig_cntl_fifo_has_data and  -- startup or gap case
                                   not(lsig_cmd_loaded))  or
                                  (sig_cntl_fifo_has_data and  -- back to back commands
                                   lsig_cmd_cmplt_dbeat);
                                  
       -- Generate the control for incrementing the offset counter
       lsig_incr_offset        <= sig_good_sout_strm_dbeat;
       
       
       -- Check to see if the offset counter has reached its max
       -- value
       lsig_offset_cntr_eq_max <=  '1'
         when  (lsig_0ffset_cntr = OFFSET_CNT_MAX)
         Else '0';
       
       
       
        
        
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_CMD_LOADED
       --
       -- Process Description:
       --  Implements the flop indicating a command from the cmd fifo
       -- has been loaded into the unpacker control logic.
       --
       -------------------------------------------------------------
       IMP_CMD_LOADED : process (aclk)
         begin
           if (aclk'event and aclk = '1') then
             if (reset = '1') then
      
               lsig_cmd_loaded <= '0';
      
             Elsif (lsig_ld_offset = '1' ) Then
             
               lsig_cmd_loaded <= '1';
             
             elsif (sig_cntl_fifo_has_data = '0' and   -- No more commands queued
                    lsig_cmd_cmplt_dbeat   = '1') then
      
               lsig_cmd_loaded <= '0';
      
             else
      
               null;  -- Hold Current State
      
             end if; 
           end if;       
         end process IMP_CMD_LOADED; 
       
       
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_OFFSET_CNTR
       --
       -- Process Description:
       --  Implements the address offset counter that is used to 
       -- generate the data and tkeep mux selects.
       -- Note that the counter has to be loaded with the starting
       -- offset plus one to sync up with the data input.
       -------------------------------------------------------------
       IMP_OFFSET_CNTR : process (aclk)
         begin
           if (aclk'event and aclk = '1') then
              if (reset = '1') then
       
                lsig_0ffset_cntr <= (others => '0');
       
              Elsif (lsig_ld_offset = '1') Then
              
                lsig_0ffset_cntr <= UNSIGNED(sig_curr_strt_offset_reg);
              
              elsif (lsig_incr_offset = '1') then
       
                lsig_0ffset_cntr <= lsig_0ffset_cntr + OFFSET_CNT_ONE;
       
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_OFFSET_CNTR; 
       
       
       
       
     
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_DATA_CONVERTER
       --
       -- For Generate Description:
       --   This ForGen converts the FIFO output data and tkeep from a single
       -- std logic vector type to a vector of slices. 
       --
       ------------------------------------------------------------
       DO_DATA_CONVERTER : for slice_index in 1 to MMAP2STRM_WIDTH_RATO generate
       
       begin
        
         lsig_fifo_data_out_wide(slice_index-1) <=
                            sig_dfifo_data_out((slice_index*DATA_SLICE_WIDTH)-1 downto 
                            (slice_index-1)*DATA_SLICE_WIDTH);
        
         
         lsig_fifo_tkeep_out_wide(slice_index-1) <=
                            sig_dfifo_tkeep_out((slice_index*TKEEP_SLICE_WIDTH)-1 downto 
                            (slice_index-1)*TKEEP_SLICE_WIDTH);
         
        
       end generate DO_DATA_CONVERTER;
     
     
       -- Assign the extra tkeep slice to all zeros to allow for detection
       -- of the data word done when the ls tkeep bit of the next tkeep 
       -- slice is zero and the offset count is pointing to the last slice
       -- position.
       lsig_fifo_tkeep_out_wide(MMAP2STRM_WIDTH_RATO) <= (others => '0');

       
       
       -- Mux the appropriate data and tkeep slice to the stream output
       lsig_mux_sel       <=  TO_INTEGER(lsig_0ffset_cntr);
     
       lsig_data_mux_out  <=  lsig_fifo_data_out_wide(lsig_mux_sel) ; 
     
       lsig_tkeep_mux_out(TKEEP_SLICE_WIDTH-1 downto 0) <=  lsig_fifo_tkeep_out_wide(lsig_mux_sel);
       
      
       
       
      end generate INCLUDE_UNPACKING;
     
   
   
   
   
   
   
   
     
    
    
  
  
      ------------------------------------------------------------
      -- If Generate
      --
      -- Label: OMIT_DRE_CNTL
      --
      -- If Generate Description:
      --   This IfGen is used to omit the DRE control logic and 
      -- minimize the Control FIFO when MM2S DRE is not included
      -- in the MM2S. 
      --
      ------------------------------------------------------------
      OMIT_DRE_CNTL : if (C_DRE_IS_USED = 0) generate
      
        
        -- Constant Declarations ------------------------------------------------------------------
        
        Constant USE_SYNC_FIFO           : integer := 0;
        Constant SRL_FIFO_PRIM           : integer := 2;
        
        Constant TAG_WIDTH               : integer := C_TAG_WIDTH;
        Constant DRR_WIDTH               : integer := 1;
        Constant EOF_WIDTH               : integer := 1;
        Constant CALC_ERR_WIDTH          : integer := 1;
        Constant SF_OFFSET_WIDTH         : integer := C_STRT_SF_OFFSET_WIDTH;
        
        Constant SF_OFFSET_FIFO_DEPTH    : integer := funct_size_drecntl_fifo(C_DRE_CNTL_FIFO_DEPTH,
                                                                              C_MAX_BURST_LEN);
        
        
        Constant SF_OFFSET_FIFO_WIDTH    : Integer := TAG_WIDTH        +  -- Tag field
                                                      DRR_WIDTH        +  -- DRE Re-alignment Request Flag Field
                                                      EOF_WIDTH        +  -- EOF flag field
                                                      CALC_ERR_WIDTH   +  -- Calc error flag
                                                      SF_OFFSET_WIDTH;    -- Store and Forward Offset

        Constant TAG_STRT_INDEX          : integer := 0;
        Constant DRR_STRT_INDEX          : integer := TAG_STRT_INDEX + TAG_WIDTH;
        Constant EOF_STRT_INDEX          : integer := DRR_STRT_INDEX + DRR_WIDTH;
        Constant CALC_ERR_STRT_INDEX     : integer := EOF_STRT_INDEX + EOF_WIDTH;
        Constant SF_OFFSET_STRT_INDEX    : integer := CALC_ERR_STRT_INDEX+CALC_ERR_WIDTH;
        
       
        
        -- Signal Declarations --------------------------------------------------------------------
        
        signal sig_offset_fifo_data_in   : std_logic_vector(SF_OFFSET_FIFO_WIDTH-1 downto 0) := (others => '0');
        signal sig_offset_fifo_data_out  : std_logic_vector(SF_OFFSET_FIFO_WIDTH-1 downto 0) := (others => '0');
        signal sig_offset_fifo_wr_valid  : std_logic := '0';
        signal sig_offset_fifo_wr_ready  : std_logic := '0';
        signal sig_offset_fifo_rd_valid  : std_logic := '0';
        signal sig_offset_fifo_rd_ready  : std_logic := '0';
             
        
        
        begin
      
          
          -- PCC DRE Command interface handshake 
          dre2mstr_cmd_ready        <= sig_offset_fifo_wr_ready ;
          sig_offset_fifo_wr_valid  <= mstr2dre_cmd_valid       ;
          
          
          -- No DRE so no controls
          sf2dre_new_align          <= '0';
          sf2dre_use_autodest       <= '0';
          sf2dre_src_align          <= (others => '0');
          sf2dre_dest_align         <= (others => '0');
          sf2dre_flush              <= '0';
      
          -- No DRE so no alignment values
          sig_curr_src_align_reg    <= (others => '0');
          sig_curr_dest_align_reg   <= (others => '0');
          
          
          
          -- Format the input data word for the Offset FIFO Queue
          sig_offset_fifo_data_in   <= mstr2dre_strt_offset  &  -- MS field
                                       mstr2dre_calc_error   &   
                                       mstr2dre_eof          &   
                                       mstr2dre_drr          &   
                                       mstr2dre_tag;             -- LS Field
          
          
          
          sig_cntl_fifo_has_data    <= sig_offset_fifo_rd_valid ;
          sig_offset_fifo_rd_ready  <= sig_get_cntl_fifo_data   ;
          
          
          -- Rip the output fifo data word
          sig_curr_tag_reg          <= sig_offset_fifo_data_out((TAG_STRT_INDEX+TAG_WIDTH)-1 downto TAG_STRT_INDEX);
          sig_curr_drr_reg          <= sig_offset_fifo_data_out(DRR_STRT_INDEX);
          sig_curr_eof_reg          <= sig_offset_fifo_data_out(EOF_STRT_INDEX);
          sig_curr_calc_error_reg   <= sig_offset_fifo_data_out(CALC_ERR_STRT_INDEX);
          sig_curr_strt_offset_reg  <= sig_offset_fifo_data_out((SF_OFFSET_STRT_INDEX+SF_OFFSET_WIDTH)-1 downto 
                                                                SF_OFFSET_STRT_INDEX);


          
          
          
          
               
          ------------------------------------------------------------
          -- Instance: I_DRE_CNTL_FIFO
          --
          -- Description:
          -- Instance for the Offset Control FIFO. This is still needed
          -- by the unpacker logic to get the starting offset at the
          -- begining of an input packet coming out of the Store and 
          -- Forward data FIFO.
          --
          ------------------------------------------------------------
          I_DRE_CNTL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (

            C_DWIDTH             =>  SF_OFFSET_FIFO_WIDTH   , 
            C_DEPTH              =>  SF_OFFSET_FIFO_DEPTH   , 
            C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
            C_PRIM_TYPE          =>  SRL_FIFO_PRIM          , 
            C_FAMILY             =>  C_FAMILY                 

            )
          port map (

            -- Write Clock and reset
            fifo_wr_reset        =>  reset                    , 
            fifo_wr_clk          =>  aclk                     , 

            -- Write Side
            fifo_wr_tvalid       =>  sig_offset_fifo_wr_valid , 
            fifo_wr_tready       =>  sig_offset_fifo_wr_ready , 
            fifo_wr_tdata        =>  sig_offset_fifo_data_in  , 
            fifo_wr_full         =>  open                     , 


            -- Read Clock and reset
            fifo_async_rd_reset  =>  aclk                     , 
            fifo_async_rd_clk    =>  reset                    , 

            -- Read Side
            fifo_rd_tvalid       =>  sig_offset_fifo_rd_valid , 
            fifo_rd_tready       =>  sig_offset_fifo_rd_ready , 
            fifo_rd_tdata        =>  sig_offset_fifo_data_out , 
            fifo_rd_empty        =>  open                    

            );





      
        end generate OMIT_DRE_CNTL;
      
      
      
      
      
     
     
     
      
      
      
      ------------------------------------------------------------
      -- If Generate
      --
      -- Label: INCLUDE_DRE_CNTL
      --
      -- If Generate Description:
      --   This IfGen is used to include the DRE control logic and 
      -- Control FIFO when MM2S DRE is included in the MM2S.
      --
      --
      ------------------------------------------------------------
      INCLUDE_DRE_CNTL : if (C_DRE_IS_USED = 1) generate
      
        
        -- Constant Declarations
        
        Constant DRECNTL_FIFO_DEPTH    : integer := funct_size_drecntl_fifo(C_DRE_CNTL_FIFO_DEPTH,
                                                                            C_MAX_BURST_LEN);
        
        
        Constant DRECNTL_FIFO_WIDTH    : Integer := TAG_WIDTH        +  -- Tag field
                                                    SRC_ALIGN_WIDTH  +  -- Source align field width
                                                    DEST_ALIGN_WIDTH +  -- Dest align field width
                                                    DRR_WIDTH        +  -- DRE Re-alignment Request Flag Field
                                                    EOF_WIDTH        +  -- EOF flag field
                                                    CALC_ERR_WIDTH   +  -- Calc error flag
                                                    SF_OFFSET_WIDTH;    -- Store and Forward Offset

        Constant TAG_STRT_INDEX        : integer := 0;
        Constant SRC_ALIGN_STRT_INDEX  : integer := TAG_STRT_INDEX + TAG_WIDTH;
        Constant DEST_ALIGN_STRT_INDEX : integer := SRC_ALIGN_STRT_INDEX + SRC_ALIGN_WIDTH;
        Constant DRR_STRT_INDEX        : integer := DEST_ALIGN_STRT_INDEX + DEST_ALIGN_WIDTH;
        Constant EOF_STRT_INDEX        : integer := DRR_STRT_INDEX + DRR_WIDTH;
        Constant CALC_ERR_STRT_INDEX   : integer := EOF_STRT_INDEX + EOF_WIDTH;
        Constant SF_OFFSET_STRT_INDEX  : integer := CALC_ERR_STRT_INDEX+CALC_ERR_WIDTH;
        
        
        
        
        
        signal sig_cmd_fifo_data_in        : std_logic_vector(DRECNTL_FIFO_WIDTH-1 downto 0) := (others => '0');
        signal sig_cmd_fifo_data_out       : std_logic_vector(DRECNTL_FIFO_WIDTH-1 downto 0) := (others => '0');
        signal sig_fifo_wr_cmd_valid       : std_logic := '0';
        signal sig_fifo_wr_cmd_ready       : std_logic := '0';
        signal sig_fifo_rd_cmd_valid       : std_logic := '0';
        signal sig_fifo_rd_cmd_ready       : std_logic := '0';
             
        signal sig_dre_align_ready         : std_logic := '0';
        signal sig_dre_align_valid_reg     : std_logic := '0';
        signal sig_dre_use_autodest_reg    : std_logic := '0';
        signal sig_dre_src_align_reg       : std_logic_vector(SRC_ALIGN_WIDTH-1 downto 0)  := (others => '0');
        signal sig_dre_dest_align_reg      : std_logic_vector(DEST_ALIGN_WIDTH-1 downto 0) := (others => '0');
        signal sig_dre_flush_reg           : std_logic := '0';
             
        begin
 
 
          
          -- Assign the DRE Control Outputs
          sf2dre_new_align      <= sig_dre_align_valid_reg;
          sf2dre_use_autodest   <= sig_dre_use_autodest_reg;
          sf2dre_src_align      <= sig_dre_src_align_reg;
          sf2dre_dest_align     <= sig_dre_dest_align_reg;
          sf2dre_flush          <= sig_sf2dre_flush;      -- from RDC via data FIFO
      
 
          
          -- PCC DRE Command interface handshake 
          dre2mstr_cmd_ready    <= sig_fifo_wr_cmd_ready;
          sig_fifo_wr_cmd_valid <= mstr2dre_cmd_valid   ;
          
          -- Format the input data word for the DRE Control FIFO Queue
          sig_cmd_fifo_data_in  <=  mstr2dre_strt_offset    &
                                    mstr2dre_calc_error     &
                                    mstr2dre_eof            &   
                                    mstr2dre_drr            &   
                                    mstr2dre_dre_dest_align &   
                                    mstr2dre_dre_src_align  &   
                                    mstr2dre_tag;   
          
          
          
          
          
          -- Formulate the DRE Control FIFO Read signaling
          sig_cntl_fifo_has_data   <= sig_fifo_rd_cmd_valid  ;
          sig_fifo_rd_cmd_ready    <= sig_get_cntl_fifo_data ;
          
          
          
          
                                       
                              
          -- Rip the output fifo data word
          sig_curr_tag_reg         <= sig_cmd_fifo_data_out((TAG_STRT_INDEX+TAG_WIDTH)-1 downto TAG_STRT_INDEX);
          sig_curr_src_align_reg   <= sig_cmd_fifo_data_out((SRC_ALIGN_STRT_INDEX+SRC_ALIGN_WIDTH)-1 downto 
                                                            SRC_ALIGN_STRT_INDEX);
          sig_curr_dest_align_reg  <= sig_cmd_fifo_data_out((DEST_ALIGN_STRT_INDEX+DEST_ALIGN_WIDTH)-1 downto 
                                                            DEST_ALIGN_STRT_INDEX);
          sig_curr_drr_reg         <= sig_cmd_fifo_data_out(DRR_STRT_INDEX);
          sig_curr_eof_reg         <= sig_cmd_fifo_data_out(EOF_STRT_INDEX);
          sig_curr_calc_error_reg  <= sig_cmd_fifo_data_out(CALC_ERR_STRT_INDEX);
          sig_curr_strt_offset_reg <= sig_cmd_fifo_data_out((SF_OFFSET_STRT_INDEX+SF_OFFSET_WIDTH)-1 downto 
                                                            SF_OFFSET_STRT_INDEX);


               
                              
                              
                                       
          ------------------------------------------------------------
          -- Instance: I_DRE_CNTL_FIFO
          --
          -- Description:
          -- Instance for the DRE Control FIFO
          --
          ------------------------------------------------------------
          I_DRE_CNTL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
          generic map (

            C_DWIDTH             =>  DRECNTL_FIFO_WIDTH     , 
            C_DEPTH              =>  DRECNTL_FIFO_DEPTH     , 
            C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
            C_PRIM_TYPE          =>  SRL_FIFO_PRIM          , 
            C_FAMILY             =>  C_FAMILY                 

            )
          port map (

            -- Write Clock and reset
            fifo_wr_reset        =>   reset                 , 
            fifo_wr_clk          =>   aclk                  , 

            -- Write Side
            fifo_wr_tvalid       =>   sig_fifo_wr_cmd_valid , 
            fifo_wr_tready       =>   sig_fifo_wr_cmd_ready , 
            fifo_wr_tdata        =>   sig_cmd_fifo_data_in  , 
            fifo_wr_full         =>   open                  , 


            -- Read Clock and reset
            fifo_async_rd_reset  =>   aclk                  , 
            fifo_async_rd_clk    =>   reset                 , 

            -- Read Side
            fifo_rd_tvalid       =>   sig_fifo_rd_cmd_valid , 
            fifo_rd_tready       =>   sig_fifo_rd_cmd_ready , 
            fifo_rd_tdata        =>   sig_cmd_fifo_data_out , 
            fifo_rd_empty        =>   open                    

            );



          
  
          
           
           
          
          -------------------------------------------------------------------------
          -- DRE Control Register
          -------------------------------------------------------------------------
          
           
          
          -- The DRE will auto-flush on a received TLAST so a commanded Flush 
          -- is not needed.                                                             
          sig_dre_flush_reg         <= '0';
  
  

          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_CNTL_REG
          --
          -- Process Description:
          --  Implements the DRE alignment Output Register.
          --
          -------------------------------------------------------------
          IMP_CNTL_REG : process (aclk)
            begin
              if (aclk'event and aclk = '1') then
                if (reset = '1') then
         
                  sig_dre_use_autodest_reg  <= '0'             ;
                  sig_dre_src_align_reg     <= (others => '0') ;
                  sig_dre_dest_align_reg    <= (others => '0') ;
                
                Elsif (sig_ld_dre_cntl_reg = '1' ) Then
                
                  sig_dre_use_autodest_reg  <= not(sig_curr_drr_reg)   ;
                  sig_dre_src_align_reg     <= sig_curr_src_align_reg  ;
                  sig_dre_dest_align_reg    <= sig_curr_dest_align_reg ;
                
                
                Elsif (sig_good_sout_strm_dbeat = '1') Then
                
                  sig_dre_use_autodest_reg  <= '0'             ;
                  sig_dre_src_align_reg     <= (others => '0') ;
                  sig_dre_dest_align_reg    <= (others => '0') ;
                
                else
         
                  null;  -- Hold Current State
         
                end if; 
              end if;       
            end process IMP_CNTL_REG; 
          
        
        
       
            
            
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_DRE_CNTL_VALID_REG
          --
          -- Process Description:
          --  Implements the DRE Alignment valid Register.
          --
          -------------------------------------------------------------
          IMP_DRE_CNTL_VALID_REG : process (aclk)
            begin
              if (aclk'event and aclk = '1') then
                if (reset = '1') then
         
                  sig_dre_align_valid_reg   <= '0' ; 
                
                Elsif (sig_ld_dre_cntl_reg = '1' ) Then
                
                  sig_dre_align_valid_reg   <= '1'  ; 
                
                
                Elsif (sig_good_sout_strm_dbeat = '1') Then
                
                  sig_dre_align_valid_reg   <= '0' ; 
                
                else
         
                  null;  -- Hold Current State
         
                end if; 
              end if;       
            end process IMP_DRE_CNTL_VALID_REG; 
          
        
        
 
      
        end generate INCLUDE_DRE_CNTL;
  
 
  
  
  
  
  
  
  
  
  
  
  
 
 ---------------------------------------------------------------- 
 -- Token Counter Logic  
 -- Predicting fifo space availability at some point in the  
 -- future is based on managing a virtual pool of transfer tokens.
 -- A token represents 1 max length burst worth of space in the
 -- Data FIFO. 
 ---------------------------------------------------------------- 
    
    
    -- calculate how many tokens are commited to pending transfers
    sig_tokens_commited <= TOKEN_CNT_MAX - sig_token_cntr;
    
    
    
    -- Decrement the token counter when a token is
    -- borrowed
    sig_decr_token_cntr <= '1'
      when (sig_rd_addr_posted = '1' and 
            sig_token_eq_zero  = '0')
      else '0';
    
    
    -- Increment the token counter when a  
    -- token is returned.
    sig_incr_token_cntr <= '1'
      when (sig_rd_xfer_cmplt = '1' and 
            sig_token_eq_max  = '0')
      else '0';
  
    
    
    -- Detect when the xfer token count is at max value
    sig_token_eq_max <= '1' 
     when (sig_token_cntr = TOKEN_CNT_MAX)
     Else '0';
  
    -- Detect when the xfer token count is at one
    sig_token_eq_one <= '1' 
     when (sig_token_cntr = TOKEN_CNT_ONE)
     Else '0';
  
    -- Detect when the xfer token count is at zero
    sig_token_eq_zero <= '1' 
     when (sig_token_cntr = TOKEN_CNT_ZERO)
     Else '0';
  
    -- Look ahead to see if the xfer token pool is going empty
    sig_taking_last_token <= '1'
      When (sig_token_eq_one   = '1' and
            sig_rd_addr_posted = '1')
      Else '0';
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_TOKEN_CNTR
    --
    -- Process Description:
    -- Implements the Token counter
    --
    -------------------------------------------------------------
    IMP_TOKEN_CNTR : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
          if (reset  = '1' ) then 

            sig_token_cntr <= TOKEN_CNT_MAX;
            
          elsif (sig_incr_token_cntr = '1' and
                 sig_decr_token_cntr = '0') then

            sig_token_cntr <= sig_token_cntr + TOKEN_CNT_ONE;
            
          elsif (sig_incr_token_cntr = '0' and
                 sig_decr_token_cntr = '1') then

            sig_token_cntr <= sig_token_cntr - TOKEN_CNT_ONE;
            
          else
            null;  -- hold current value
          end if; 
        end if;       
      end process IMP_TOKEN_CNTR; 

 
     
     
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_TOKEN_AVAIL_FLAG
    --
    -- Process Description:
    --   Implements the flag indicating that the AXI Read Master
    -- can post a read address request on the AXI4 bus.
    --
    -- Read address posting can occur if:
    --
    --  - The write side LEN fifo is not empty.                   
    --  - The commited plus actual Data FIFO space is less than 
    --    the stall threshold (a max length read burst can fit 
    --    in the data FIFO without overflow).   
    --  - The max allowed commited read count has not been reached.      
    --
    -- The flag is cleared after each address has been posted to
    -- ensure a second unauthorized post does not occur.
    -------------------------------------------------------------
    IMP_TOKEN_AVAIL_FLAG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (reset              = '1' or
               sig_rd_addr_posted = '1') then
    
             sig_ok_to_post_rd_addr <= '0';
    
           else
    
             sig_ok_to_post_rd_addr <= not(sig_stall_rd_addr_posts) and -- the commited Data FIFO space is approaching full 
                                       not(sig_token_eq_zero)       and -- max allowed pending reads has not been reached
                                       not(sig_taking_last_token);      -- the max allowed pending reads is about to be reached
    
           end if; 
        end if;       
      end process IMP_TOKEN_AVAIL_FLAG; 
 
 
 
  
  
    
    
 
 
  
  
    
    
 ---------------------------------------------------------------- 
 -- Data FIFO Logic ------------------------------------------
 ---------------------------------------------------------------- 
 
   
GEN_MM2S_TKEEP_ENABLE3 : if C_ENABLE_MM2S_TKEEP = 1 generate
begin

    
    -- FIFO Output ripping to components
    sig_dfifo_data_out       <=  sig_data_fifo_data_out(DATA_OUT_MSB_INDEX downto
                                                        DATA_OUT_LSB_INDEX);
     
    sig_dfifo_tkeep_out      <=  sig_data_fifo_data_out(TKEEP_OUT_MSB_INDEX downto
                                                        TKEEP_OUT_LSB_INDEX);
     
    sig_dfifo_tlast_out      <=  sig_data_fifo_data_out(TLAST_OUT_INDEX) ;
    
    sig_dfifo_cmd_cmplt_out  <=  sig_data_fifo_data_out(CMPLT_OUT_INDEX) ;
  
    sig_dfifo_dre_flush_out  <=  sig_data_fifo_data_out(DRE_FLUSH_OUT_INDEX) ;
  

end generate GEN_MM2S_TKEEP_ENABLE3;

GEN_MM2S_TKEEP_DISABLE3 : if C_ENABLE_MM2S_TKEEP = 0 generate
begin
    
    -- FIFO Output ripping to components
    sig_dfifo_data_out       <=  sig_data_fifo_data_out(DATA_OUT_MSB_INDEX downto
                                                        DATA_OUT_LSB_INDEX);
     
    sig_dfifo_tkeep_out      <=  (others => '1');
     
    sig_dfifo_tlast_out      <=  sig_data_fifo_data_out(TLAST_OUT_INDEX) ;
    
    sig_dfifo_cmd_cmplt_out  <=  sig_data_fifo_data_out(CMPLT_OUT_INDEX) ;
  
    sig_dfifo_dre_flush_out  <=  sig_data_fifo_data_out(DRE_FLUSH_OUT_INDEX) ;
  


end generate GEN_MM2S_TKEEP_DISABLE3;


 
  
    
    -- Stall Threshold calculations
    sig_fifo_wr_cnt_unsgnd   <= UNSIGNED(sig_data_fifo_wr_cnt);
 
    sig_wrcnt_mblen_slice    <= sig_fifo_wr_cnt_unsgnd(DATA_FIFO_CNT_WIDTH-1 downto 
                                                       DF_WRCNT_RIP_LS_INDEX);
    
    sig_commit_plus_actual   <= RESIZE(sig_tokens_commited, THRESH_COMPARE_WIDTH) +
                                RESIZE(sig_wrcnt_mblen_slice, THRESH_COMPARE_WIDTH);
    
    
    -- Compare the commited read space plus the actual used space against the
    -- stall threshold. Assert the read address posting stall flag if the
    -- threshold is met or exceeded.
    sig_stall_rd_addr_posts  <= '1'
      when (sig_commit_plus_actual > RD_ADDR_POST_STALL_THRESH_US)
      Else '0';
    
    
    
    
    -- FIFO Rd/WR Controls
    sig_push_data_fifo <= sig_good_sin_strm_dbeat;
    
    -- sig_pop_data_fifo  <= sig_sout2sf_tready and 
    --                       sig_data_fifo_dvalid;
    
    
      
GEN_MM2S_TKEEP_ENABLE2 : if C_ENABLE_MM2S_TKEEP = 1 generate
begin

 
    -- Concatonate the Stream inputs into the single FIFO data in value 
    sig_data_fifo_data_in <= data2sf_dre_flush &  -- ms Field
                             data2sf_cmd_cmplt &  
                             sin2sf_tlast      &
                             sin2sf_tkeep      & 
                             sin2sf_tdata;        -- ls field


end generate GEN_MM2S_TKEEP_ENABLE2;

GEN_MM2S_TKEEP_DISABLE2 : if C_ENABLE_MM2S_TKEEP = 0 generate
begin
 
    -- Concatonate the Stream inputs into the single FIFO data in value 
    sig_data_fifo_data_in <= data2sf_dre_flush &  -- ms Field
                             data2sf_cmd_cmplt &  
                             sin2sf_tlast      &
                             --sin2sf_tkeep      & 
                             sin2sf_tdata;        -- ls field



end generate GEN_MM2S_TKEEP_DISABLE2;

   
   
                                                    
    ------------------------------------------------------------
    -- Instance: I_DATA_FIFO 
    --
    -- Description:
    --  Implements the Store and Forward data FIFO (synchronous)   
    --
    ------------------------------------------------------------
    I_DATA_FIFO : entity axi_datamover_v5_1_17.axi_datamover_sfifo_autord
    generic map (

      C_DWIDTH                =>  DATA_FIFO_WIDTH       ,  
      C_DEPTH                 =>  DATA_FIFO_DEPTH       ,  
      C_DATA_CNT_WIDTH        =>  DATA_FIFO_CNT_WIDTH   ,  
      C_NEED_ALMOST_EMPTY     =>  NOT_NEEDED            ,  
      C_NEED_ALMOST_FULL      =>  NOT_NEEDED            ,  
      C_USE_BLKMEM            =>  BLK_MEM_FIFO          ,  
      C_FAMILY                =>  C_FAMILY                 

      )
    port map (

     -- Inputs 
      SFIFO_Sinit             =>  reset                  , 
      SFIFO_Clk               =>  aclk                   , 
      SFIFO_Wr_en             =>  sig_push_data_fifo     , 
      SFIFO_Din               =>  sig_data_fifo_data_in  , 
      SFIFO_Rd_en             =>  sig_pop_data_fifo      , 
      SFIFO_Clr_Rd_Data_Valid =>  LOGIC_LOW              , 
      
     -- Outputs
      SFIFO_DValid            =>  sig_data_fifo_dvalid   , 
      SFIFO_Dout              =>  sig_data_fifo_data_out , 
      SFIFO_Full              =>  sig_data_fifo_full     , 
      SFIFO_Empty             =>  open                   , 
      SFIFO_Almost_full       =>  open                   , 
      SFIFO_Almost_empty      =>  open                   , 
      SFIFO_Rd_count          =>  open                   ,  
      SFIFO_Rd_count_minus1   =>  open                   ,  
      SFIFO_Wr_count          =>  sig_data_fifo_wr_cnt   ,  
      SFIFO_Rd_ack            =>  open                     

    );



 
 
 
 
 
 
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_wr_sf.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_wr_sf.vhd
  --
  -- Description:     
  --    This file implements the AXI DataMover Write (S2MM) Store and Forward module. 
  --  The design utilizes the AXI DataMover's new address pipelining
  --  control function.  This module buffers write data and provides status and 
  --  control features such that the DataMover Write Master is only allowed 
  --  to post AXI WRite Requests if the associated write data needed to complete
  --  the Write Data transfer is present in the Data FIFO. In addition, the Write 
  --  side logic is such that Write transfer requests can be pipelined to the 
  --  AXI4 bus based on the Data FIFO contents but ahead of the actual Write Data
  --  transfers.
  -- 
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  library lib_pkg_v1_0_2;
  library lib_srl_fifo_v1_0_2;
  use lib_pkg_v1_0_2.lib_pkg.all;
  use lib_pkg_v1_0_2.lib_pkg.clog2;
  use lib_srl_fifo_v1_0_2.srl_fifo_f;
  
 

  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_sfifo_autord;

  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_wr_sf is
    generic (
      
      C_WR_ADDR_PIPE_DEPTH   : Integer range 1 to 30 := 4;
        -- This parameter indicates the depth of the DataMover
        -- write address pipelining queues for the Main data transport
        -- channels. The effective address pipelining on the AXI4 
        -- Write Address Channel will be the value assigned plus 2. 
      
      C_SF_FIFO_DEPTH        : Integer range 128 to 8192 := 512;
        -- Sets the desired depth of the internal Data FIFO.
      
    --   C_MAX_BURST_LEN        : Integer range  16 to  256 :=  16;
    --     -- Indicates the max burst length being used by the external
    --     -- AXI4 Master for each AXI4 transfer request.
        
    --   C_DRE_IS_USED          : Integer range   0 to    1 :=   0;
    --     -- Indicates if the external Master is utilizing a DRE on
    --     -- the stream input to this module.
         
      C_MMAP_DWIDTH          : Integer range   32 to  1024 := 64;
        -- Sets the AXI4 Memory Mapped Bus Data Width 
      
      C_STREAM_DWIDTH        : Integer range   8 to  1024 :=  16;
        -- Sets the Stream Data Width for the Input and Output
        -- Data streams.
  
      C_STRT_OFFSET_WIDTH    : Integer range   1 to 7 :=  2;
        -- Sets the bit width of the starting address offset port
        -- This should be set to log2(C_MMAP_DWIDTH/C_STREAM_DWIDTH)
        
      C_FAMILY               : String  := "virtex7"
        -- Indicates the target FPGA Family.
      
      );
    port (
      
      -- Clock and Reset inputs -----------------------------------------------       
                                                                             --       
      aclk                    : in  std_logic;                               --       
         -- Primary synchronization clock for the Master side                --       
         -- interface and internal logic. It is also used                    --       
         -- for the User interface synchronization when                      --       
         -- C_STSCMD_IS_ASYNC = 0.                                           --       
                                                                             --       
      -- Reset input                                                         --       
      reset                   : in  std_logic;                               --       
         -- Reset used for the internal syncronization logic                 --       
      -------------------------------------------------------------------------
      
      
    
    
      -- Slave Stream Input  ------------------------------------------------------------ 
                                                                                       -- 
      sf2sin_tready           : Out Std_logic;                                         -- 
        -- DRE  Stream READY input                                                     -- 
                                                                                       -- 
      sin2sf_tvalid           : In  std_logic;                                         -- 
        -- DRE Stream VALID Output                                                     -- 
                                                                                       -- 
      sin2sf_tdata            : In  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);      --    
        -- DRE  Stream DATA input                                                      -- 
                                                                                       -- 
      sin2sf_tkeep            : In  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);  --       
        -- DRE  Stream STRB input                                                      -- 
                                                                                       -- 
      sin2sf_tlast            : In  std_logic;                                         -- 
        -- DRE  Xfer LAST input                                                        --
                                                                                       -- 
      sin2sf_error            : In  std_logic;                                         -- 
        -- Stream Underrun/Overrun error input                                         --
      ----------------------------------------------------------------------------------- 
  
 
  
      -- Starting Address Offset Input  ------------------------------------------------- 
                                                                                       --
      sin2sf_strt_addr_offset : In std_logic_vector(C_STRT_OFFSET_WIDTH-1 downto 0);   -- 
        -- Used by Packing logic to set the initial data slice position for the        --
        -- packing operation. Packing is only needed if the MMap and Stream Data       --
        -- widths do not match.                                                        -- 
      ----------------------------------------------------------------------------------- 
               
                
      -- DataMover Write Side Address Pipelining Control Interface ---------------------- 
                                                                                       -- 
      ok_to_post_wr_addr      : Out  Std_logic;                                        -- 
        -- Indicates that the internal FIFO has enough data                            -- 
        -- physically present to supply one more max length                            -- 
        -- burst transfer or a completion burst                                        -- 
        -- (tlast asserted)                                                            -- 
                                                                                       -- 
      wr_addr_posted          : In std_logic;                                          -- 
        -- Indication that a write address has been posted to AXI4                     -- 
                                                                                       -- 
                                                                                       -- 
      wr_xfer_cmplt           : In  Std_logic;                                         -- 
        -- Indicates that the Datamover has completed a Write Data                     -- 
        -- transfer on the AXI4                                                        -- 
                                                                                       -- 
                                                                                       -- 
      wr_ld_nxt_len           : in  std_logic;                                         -- 
        -- Active high pulse indicating a new transfer LEN qualifier                   -- 
        -- has been queued to the DataMover Write Data Controller                      -- 
                                                                                       -- 
      wr_len                  : in  std_logic_vector(7 downto 0);                      -- 
        -- The actual LEN qualifier value that has been queued to the                  -- 
        -- DataMover Write Data Controller                                             --
      ----------------------------------------------------------------------------------- 


         
      
      -- Write Side Stream Out to DataMover S2MM ---------------------------------------- 
                                                                                       -- 
      sout2sf_tready          : In  std_logic;                                         -- 
        -- Write READY input from the Stream Master                                    -- 
                                                                                       -- 
      sf2sout_tvalid          : Out  std_logic;                                        -- 
        -- Write VALID output to the Stream Master                                     -- 
                                                                                       -- 
      sf2sout_tdata           : Out  std_logic_vector(C_MMAP_DWIDTH-1 downto 0);       -- 
        -- Write DATA output to the Stream Master                                      -- 
                                                                                       -- 
      sf2sout_tkeep           : Out  std_logic_vector((C_MMAP_DWIDTH/8)-1 downto 0);   -- 
        -- Write DATA output to the Stream Master                                      -- 
                                                                                       -- 
      sf2sout_tlast           : Out  std_logic;                                        -- 
        -- Write LAST output to the Stream Master                                      --
                                                                                       -- 
      sf2sout_error           : Out  std_logic                                         -- 
        -- Stream Underrun/Overrun error input                                         --
      ----------------------------------------------------------------------------------- 
     
 
      );
  
  end entity axi_datamover_wr_sf;
  
  
  architecture implementation of axi_datamover_wr_sf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Functions ---------------------------------------------------------------------------
 
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_pwr2_depth
    --
    -- Function Description:
    --  Rounds up to the next power of 2 depth value in an input
    --  range of 1 to 8192
    --
    -------------------------------------------------------------------
    function funct_get_pwr2_depth (min_depth : integer) return integer is
     
      Variable var_temp_depth : Integer := 16;
     
    begin
       
      
      if (min_depth = 1) then
      
         var_temp_depth := 1;
      
      elsif (min_depth  = 2) then
      
         var_temp_depth := 2;
      
      elsif (min_depth  <= 4) then
      
         var_temp_depth := 4;
      
      elsif (min_depth  <= 8) then
      
         var_temp_depth := 8;
      
      elsif (min_depth  <= 16) then
      
         var_temp_depth := 16;
      
      elsif (min_depth  <= 32) then
      
         var_temp_depth := 32;
      
      elsif (min_depth  <= 64) then
      
         var_temp_depth := 64;
      
      elsif (min_depth  <= 128) then
      
         var_temp_depth := 128;
      
      elsif (min_depth  <= 256) then
      
         var_temp_depth := 256;
      
      elsif (min_depth  <= 512) then
      
         var_temp_depth := 512;
      
      elsif (min_depth  <= 1024) then
      
         var_temp_depth := 1024;
      
      elsif (min_depth  <= 2048) then
      
         var_temp_depth := 2048;
      
      elsif (min_depth  <= 4096) then
      
         var_temp_depth := 4096;
      
      else -- assume 8192 depth
      
         var_temp_depth := 8192;
      
      end if;
      
       
       
      Return (var_temp_depth);
       
       
    end function funct_get_pwr2_depth;
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_fifo_cnt_width
    --
    -- Function Description:
    --   simple function to set the width of the data fifo read 
    -- and write count outputs. 
    -------------------------------------------------------------------
    function funct_get_fifo_cnt_width (fifo_depth : integer) 
             return integer is
    
      Variable temp_width : integer := 8;
    
    begin
    
      if (fifo_depth = 1) then
      
         temp_width := 1;
      
      elsif (fifo_depth  = 2) then
      
         temp_width := 2;
      
      elsif (fifo_depth  <= 4) then
      
         temp_width := 3;
      
      elsif (fifo_depth  <= 8) then
      
         temp_width := 4;
      
      elsif (fifo_depth  <= 16) then
      
         temp_width := 5;
      
      elsif (fifo_depth  <= 32) then
      
         temp_width := 6;
      
      elsif (fifo_depth  <= 64) then
      
         temp_width := 7;
      
      elsif (fifo_depth  <= 128) then
      
         temp_width := 8;
      
      elsif (fifo_depth  <= 256) then
      
         temp_width := 9;
      
      elsif (fifo_depth  <= 512) then
      
         temp_width := 10;
      
      elsif (fifo_depth  <= 1024) then
      
         temp_width := 11;
      
      elsif (fifo_depth  <= 2048) then
      
         temp_width := 12;
      
      elsif (fifo_depth  <= 4096) then
      
         temp_width := 13;
      
      else -- assume 8192 depth
      
         temp_width := 14;
      
      end if;
      
      
      Return (temp_width);
     
    
    end function funct_get_fifo_cnt_width;
    
   
   
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_cntr_width
    --
    -- Function Description:
    --  This function calculates the needed counter bit width from the 
    -- number of count sates needed (input).
    --
    -------------------------------------------------------------------
    function funct_get_cntr_width (num_cnt_values : integer) return integer is
    
      Variable temp_cnt_width : Integer := 0;
    
    begin
    
      
      if (num_cnt_values <= 2) then
      
        temp_cnt_width := 1;
      
      elsif (num_cnt_values <= 4) then
      
        temp_cnt_width := 2;
      
      elsif (num_cnt_values <= 8) then
      
        temp_cnt_width := 3;
      
      elsif (num_cnt_values <= 16) then
      
        temp_cnt_width := 4;
      
      elsif (num_cnt_values <= 32) then
      
        temp_cnt_width := 5;
      
      elsif (num_cnt_values <= 64) then
      
        temp_cnt_width := 6;
      
      elsif (num_cnt_values <= 128) then
      
        temp_cnt_width := 7;
      
      else
      
        temp_cnt_width := 8;
      
      end if;
      
      
      
      
      Return (temp_cnt_width);
      
      
    end function funct_get_cntr_width;
    

    
    
    
    -- Constants ---------------------------------------------------------------------------
    
    Constant LOGIC_LOW                 : std_logic := '0';
    Constant LOGIC_HIGH                : std_logic := '1';
    
    Constant BLK_MEM_FIFO              : integer := 1;
    Constant SRL_FIFO                  : integer := 0;
    Constant NOT_NEEDED                : integer := 0;
    
    
    Constant WSTB_WIDTH                : integer := C_MMAP_DWIDTH/8; -- bits
    Constant TLAST_WIDTH               : integer := 1;               -- bits
    Constant EOP_ERR_WIDTH             : integer := 1;               -- bits
    
    
    
    Constant DATA_FIFO_DEPTH           : integer := C_SF_FIFO_DEPTH;
    Constant DATA_FIFO_CNT_WIDTH       : integer := funct_get_fifo_cnt_width(DATA_FIFO_DEPTH);
    -- Constant DF_WRCNT_RIP_LS_INDEX     : integer := funct_get_wrcnt_lsrip(C_MAX_BURST_LEN);
    
     
    Constant DATA_FIFO_WIDTH           : integer := C_MMAP_DWIDTH +
                                                    --WSTB_WIDTH     +
                                                    TLAST_WIDTH   +
                                                    EOP_ERR_WIDTH;
    
    Constant DATA_OUT_MSB_INDEX        : integer := C_MMAP_DWIDTH-1;
    Constant DATA_OUT_LSB_INDEX        : integer := 0;
    
   --  Constant TSTRB_OUT_LSB_INDEX       : integer := DATA_OUT_MSB_INDEX+1;
   --  Constant TSTRB_OUT_MSB_INDEX       : integer := (TSTRB_OUT_LSB_INDEX+WSTB_WIDTH)-1;
    
   -- Constant TLAST_OUT_INDEX           : integer := TSTRB_OUT_MSB_INDEX+1;
    Constant TLAST_OUT_INDEX           : integer := DATA_OUT_MSB_INDEX+1;
    
    Constant EOP_ERR_OUT_INDEX         : integer := TLAST_OUT_INDEX+1;
    
    
    Constant WR_LEN_FIFO_DWIDTH        : integer := 8;
    Constant WR_LEN_FIFO_DEPTH         : integer := funct_get_pwr2_depth(C_WR_ADDR_PIPE_DEPTH + 2);
    
    Constant LEN_CNTR_WIDTH            : integer := 8;
    Constant LEN_CNT_ZERO              : Unsigned(LEN_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(0, LEN_CNTR_WIDTH);
    Constant LEN_CNT_ONE               : Unsigned(LEN_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, LEN_CNTR_WIDTH);
    
    Constant WR_XFER_CNTR_WIDTH        : integer := 8;
    Constant WR_XFER_CNT_ZERO          : Unsigned(WR_XFER_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(0, WR_XFER_CNTR_WIDTH);
    Constant WR_XFER_CNT_ONE           : Unsigned(WR_XFER_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, WR_XFER_CNTR_WIDTH);
    
    Constant UNCOM_WRCNT_1             : Unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, DATA_FIFO_CNT_WIDTH);
    
    Constant UNCOM_WRCNT_0             : Unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(0, DATA_FIFO_CNT_WIDTH);
    
    
    
    
    
    
    
    
    -- Signals ---------------------------------------------------------------------------
    
    
    signal sig_good_sin_strm_dbeat    : std_logic := '0';
    signal sig_strm_sin_ready         : std_logic := '0';
    
    signal sig_sout2sf_tready         : std_logic := '0';
    signal sig_sf2sout_tvalid         : std_logic := '0';
    signal sig_sf2sout_tdata          : std_logic_vector(C_MMAP_DWIDTH-1 downto 0) := (others => '0');
    signal sig_sf2sout_tkeep          : std_logic_vector(WSTB_WIDTH-1 downto 0) := (others => '0');
    signal sig_sf2sout_tlast          : std_logic := '0';
    
    signal sig_push_data_fifo         : std_logic := '0';
    signal sig_pop_data_fifo          : std_logic := '0';
    signal sig_data_fifo_full         : std_logic := '0';
    signal sig_data_fifo_data_in      : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_dvalid       : std_logic := '0';
    signal sig_data_fifo_data_out     : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    
    signal sig_ok_to_post_wr_addr     : std_logic := '0';
    signal sig_wr_addr_posted         : std_logic := '0';
    signal sig_wr_xfer_cmplt          : std_logic := '0';
    
    signal sig_wr_ld_nxt_len          : std_logic := '0';
    signal sig_push_len_fifo          : std_logic := '0';
    signal sig_pop_len_fifo           : std_logic := '0';
    signal sig_len_fifo_full          : std_logic := '0';
    signal sig_len_fifo_empty         : std_logic := '0';
    signal sig_len_fifo_data_in       : std_logic_vector(WR_LEN_FIFO_DWIDTH-1 downto 0) := (others => '0');
    signal sig_len_fifo_data_out      : std_logic_vector(WR_LEN_FIFO_DWIDTH-1 downto 0) := (others => '0');
    signal sig_len_fifo_len_out_un    : unsigned(WR_LEN_FIFO_DWIDTH-1 downto 0) := (others => '0');
  
    signal sig_uncom_wrcnt            : unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_sub_len_uncom_wrcnt    : std_logic := '0';
    signal sig_incr_uncom_wrcnt       : std_logic := '0';
    signal sig_resized_fifo_len       : unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_num_wr_dbeats_needed   : unsigned(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_enough_dbeats_rcvd     : std_logic := '0';
                    
    signal sig_sf2sout_eop_err_out    : std_logic := '0';
    
    signal sig_good_fifo_write        : std_logic := '0';
    
  
  begin --(architecture implementation)
  
   
   
    -- Write Side (S2MM) Control Flags port connections
    ok_to_post_wr_addr       <= sig_ok_to_post_wr_addr ;
    sig_wr_addr_posted       <= wr_addr_posted         ;
    sig_wr_xfer_cmplt        <= wr_xfer_cmplt          ;
  
    sig_wr_ld_nxt_len        <= wr_ld_nxt_len          ;
    sig_len_fifo_data_in     <= wr_len                 ;
  
    
    
    --  Output Stream Port connections
    sig_sout2sf_tready       <= sout2sf_tready          ;
    sf2sout_tvalid           <= sig_sf2sout_tvalid      ;
    sf2sout_tdata            <= sig_sf2sout_tdata       ; 
    sf2sout_tkeep            <= sig_sf2sout_tkeep       ;
    sf2sout_tlast            <= sig_sf2sout_tlast and
                                sig_sf2sout_tvalid      ;
    sf2sout_error            <= sig_sf2sout_eop_err_out ;
                               
                               
    
    -- Input Stream port connections 
    sf2sin_tready            <= sig_strm_sin_ready;
    
                                                          
    sig_good_sin_strm_dbeat  <= sin2sf_tvalid and
                                sig_strm_sin_ready;
                               
 
  
    
    
 ---------------------------------------------------------------- 
 -- Packing Logic      ------------------------------------------
 ---------------------------------------------------------------- 
 
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_PACKING
    --
    -- If Generate Description:
    --    Omits any packing logic in the Store and Forward module.
    -- The Stream and MMap data widths are the same.
    --
    ------------------------------------------------------------
    OMIT_PACKING : if (C_MMAP_DWIDTH = C_STREAM_DWIDTH) generate
    
       begin
    
        
         sig_good_fifo_write   <= sig_good_sin_strm_dbeat;
         
         sig_strm_sin_ready    <= not(sig_data_fifo_full); 
         
         
         sig_push_data_fifo    <= sig_good_sin_strm_dbeat;
       
          
         -- Concatonate the Stream inputs into the single FIFO data in value 
         sig_data_fifo_data_in <= sin2sf_error &
                                  sin2sf_tlast &
                                --  sin2sf_tkeep & 
                                  sin2sf_tdata;
       
       end generate OMIT_PACKING;
     
     
    
    
  
  
  
  
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_PACKING
    --
    -- If Generate Description:
    --    Includes packing logic in the Store and Forward module.
    -- The MMap Data bus is wider than the Stream width.
    --
    ------------------------------------------------------------
    INCLUDE_PACKING : if (C_MMAP_DWIDTH > C_STREAM_DWIDTH) generate
    
      Constant MMAP2STRM_WIDTH_RATO  : integer := C_MMAP_DWIDTH/C_STREAM_DWIDTH;
    
      Constant DATA_SLICE_WIDTH      : integer := C_STREAM_DWIDTH;
      
      Constant FLAG_SLICE_WIDTH      : integer := TLAST_WIDTH     + 
                                                  EOP_ERR_WIDTH;
      
      
      
      
      
      
      Constant OFFSET_CNTR_WIDTH     : integer := funct_get_cntr_width(MMAP2STRM_WIDTH_RATO);
      
      Constant OFFSET_CNT_ONE        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(1, OFFSET_CNTR_WIDTH);
      
      Constant OFFSET_CNT_MAX        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(MMAP2STRM_WIDTH_RATO-1, OFFSET_CNTR_WIDTH);
      
      
      
      
      -- Types -----------------------------------------------------------------------------
      type lsig_data_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(DATA_SLICE_WIDTH-1 downto 0);

      type lsig_flag_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(FLAG_SLICE_WIDTH-1 downto 0);


       
      -- local signals
      
      signal lsig_data_slice_reg      : lsig_data_slice_type;
      signal lsig_flag_slice_reg      : lsig_flag_slice_type;
      
       
      signal lsig_reg_segment         : std_logic_vector(DATA_SLICE_WIDTH-1 downto 0)   := (others => '0');
      signal lsig_segment_ld          : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      signal lsig_segment_clr         : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      
      signal lsig_0ffset_to_to_use    : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := (others => '0');
      
      signal lsig_0ffset_cntr         : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := (others => '0');
      signal lsig_ld_offset           : std_logic := '0';
      signal lsig_incr_offset         : std_logic := '0';
      signal lsig_offset_cntr_eq_max  : std_logic := '0';
      
      signal lsig_combined_data       : std_logic_vector(C_MMAP_DWIDTH-1 downto 0) := (others => '0');
      
      
      signal lsig_tlast_or            : std_logic := '0';
      signal lsig_eop_err_or          : std_logic := '0';
      
      signal lsig_partial_tlast_or    : std_logic_vector(MMAP2STRM_WIDTH_RATO downto 0) := (others => '0');
      signal lsig_partial_eop_err_or  : std_logic_vector(MMAP2STRM_WIDTH_RATO downto 0) := (others => '0');
      
      signal lsig_packer_full         : std_logic := '0';
      signal lsig_packer_empty        : std_logic := '0';
      signal lsig_set_packer_full     : std_logic := '0';
      signal lsig_good_push2fifo      : std_logic := '0';
      signal lsig_first_dbeat         : std_logic := '0';
      
        
        
        
      begin
    
       
       -- Assign the flag indicating that a fifo write is going
       -- to occur at the next rising clock edge.
       sig_good_fifo_write     <=  lsig_good_push2fifo;
       
       
       -- Generate the stream ready
       sig_strm_sin_ready       <= not(lsig_packer_full) or
                                   lsig_good_push2fifo ; 
       
       
       -- Format the FIFO input data 
       sig_data_fifo_data_in   <= lsig_eop_err_or    &   -- MS Bit
                                  lsig_tlast_or      &
                                  lsig_combined_data  ;  -- LS Bits
        
       
       -- Generate a write to the Data FIFO input
       sig_push_data_fifo      <= lsig_packer_full;
       
       
       -- Generate a flag indicating a write to the DataFIFO 
       -- is going to complete 
       lsig_good_push2fifo    <=  lsig_packer_full and
                                  not(sig_data_fifo_full);
       
       -- Generate the control that loads the starting address
       -- offset for the next input packet
       lsig_ld_offset          <= lsig_first_dbeat and
                                  sig_good_sin_strm_dbeat;
                                  
       -- Generate the control for incrementing the offset counter
       lsig_incr_offset        <= sig_good_sin_strm_dbeat;
       
       
       -- Generate a flag indicating the packer input register
       -- array is full or has loaded the last data beat of
       -- the input paket
       lsig_set_packer_full    <=  sig_good_sin_strm_dbeat  and
                                   (sin2sf_tlast            or 
                                    lsig_offset_cntr_eq_max);

       -- Check to see if the offset counter has reached its max
       -- value
       lsig_offset_cntr_eq_max <=  '1'
         --when  (lsig_0ffset_cntr = OFFSET_CNT_MAX)
         when  (lsig_0ffset_to_to_use = OFFSET_CNT_MAX)
         Else '0';
       
       
       -- Mux between the input start offset and the offset counter
       -- output to use for the packer slice load control.  
       lsig_0ffset_to_to_use <= UNSIGNED(sin2sf_strt_addr_offset) 
         when (lsig_first_dbeat = '1')
         Else lsig_0ffset_cntr;
       
        
        
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_OFFSET_LD_MARKER
       --
       -- Process Description:
       --  Implements the flop indicating the first databeat of
       -- an input data packet.
       --
       -------------------------------------------------------------
       IMP_OFFSET_LD_MARKER : process (aclk)
         begin
           if (aclk'event and aclk = '1') then
              if (reset = '1') then
       
                lsig_first_dbeat <= '1';
       
              elsif (sig_good_sin_strm_dbeat = '1' and
                     sin2sf_tlast            = '0') then
       
                lsig_first_dbeat <= '0';
       
              Elsif (sig_good_sin_strm_dbeat = '1' and
                     sin2sf_tlast            = '1') Then
              
                lsig_first_dbeat <= '1';
              
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_OFFSET_LD_MARKER; 
       
       
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_OFFSET_CNTR
       --
       -- Process Description:
       --  Implements the address offset counter that is used to 
       -- steer the data loads into the packer register slices.
       -- Note that the counter has to be loaded with the starting
       -- offset plus one to sync up with the data input.
       -------------------------------------------------------------
       IMP_OFFSET_CNTR : process (aclk)
         begin
           if (aclk'event and aclk = '1') then
              if (reset = '1') then
       
                lsig_0ffset_cntr <= (others => '0');
       
              Elsif (lsig_ld_offset = '1') Then
              
               lsig_0ffset_cntr <= UNSIGNED(sin2sf_strt_addr_offset) + OFFSET_CNT_ONE;
              
              elsif (lsig_incr_offset = '1') then
       
                lsig_0ffset_cntr <= lsig_0ffset_cntr + OFFSET_CNT_ONE;
       
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_OFFSET_CNTR; 
       
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_PACK_REG_FULL
       --
       -- Process Description:
       --   Implements the Packer Register full/empty flags
       --
       -------------------------------------------------------------
       IMP_PACK_REG_FULL : process (aclk)
         begin
           if (aclk'event and aclk = '1') then
              if (reset = '1') then
       
                lsig_packer_full  <= '0';
                lsig_packer_empty <= '1';
       
              Elsif (lsig_set_packer_full = '1' and
                     lsig_packer_full     = '0') Then
              
                lsig_packer_full  <= '1';
                lsig_packer_empty <= '0';
       
              elsif (lsig_set_packer_full = '0' and
                     lsig_good_push2fifo  = '1') then
              
                lsig_packer_full  <= '0';
                lsig_packer_empty <= '1';
       
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_PACK_REG_FULL; 
       
       
       
       
       
       
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_REG_SLICES
       --
       -- For Generate Description:
       --
       --  Implements the Packng Register Slices
       --
       --
       ------------------------------------------------------------
       DO_REG_SLICES : for slice_index in 0 to MMAP2STRM_WIDTH_RATO-1 generate


       
       begin
       
        
         -- generate the register load enable for each slice segment based
         -- on the address offset count value
         lsig_segment_ld(slice_index) <= '1'
           when (sig_good_sin_strm_dbeat = '1' and
                TO_INTEGER(lsig_0ffset_to_to_use) = slice_index)
           Else '0';
         
         
        
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_DATA_SLICE
         --
         -- Process Description:
         --   Implement a data register slice for the packer. 
         --
         -------------------------------------------------------------
         IMP_DATA_SLICE : process (aclk)
           begin
             if (aclk'event and aclk = '1') then
               if (reset = '1') then
        
                 lsig_data_slice_reg(slice_index) <= (others => '0');
        
               elsif (lsig_segment_ld(slice_index) = '1') then
        
                 lsig_data_slice_reg(slice_index) <= sin2sf_tdata;
        
               -- optional clear of slice reg 
               elsif (lsig_segment_ld(slice_index) = '0' and
                      lsig_good_push2fifo          = '1') then

                 lsig_data_slice_reg(slice_index) <= (others => '0');
        
               else
        
                 null;  -- Hold Current State
        
               end if; 
             end if;       
           end process IMP_DATA_SLICE; 
        
        
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_FLAG_SLICE
         --
         -- Process Description:
         --   Implement a flag register slice for the packer.
         --
         -------------------------------------------------------------
         IMP_FLAG_SLICE : process (aclk)
           begin
             if (aclk'event and aclk = '1') then
               if (reset = '1') then
        
                 lsig_flag_slice_reg(slice_index) <= (others => '0');
        
               elsif (lsig_segment_ld(slice_index) = '1') then
        
                 lsig_flag_slice_reg(slice_index) <= sin2sf_tlast & -- bit 1
                                                     sin2sf_error;  -- bit 0
               
               elsif (lsig_segment_ld(slice_index) = '0' and
                      lsig_good_push2fifo          = '1') then

                 lsig_flag_slice_reg(slice_index) <= (others => '0');
        
               else
        
                 null;  -- Hold Current State
        
               end if; 
             end if;       
           end process IMP_FLAG_SLICE; 
        
        
        
         
       end generate DO_REG_SLICES;
       
       
        
        
        
        
                                                                                
       -- Do the OR functions of the Flags -------------------------------------
       lsig_tlast_or   <= lsig_partial_tlast_or(MMAP2STRM_WIDTH_RATO-1) ;
       lsig_eop_err_or <= lsig_partial_eop_err_or(MMAP2STRM_WIDTH_RATO-1);
       
       lsig_partial_tlast_or(0)   <= lsig_flag_slice_reg(0)(1);
       lsig_partial_eop_err_or(0) <= lsig_flag_slice_reg(0)(0);
       

       
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_FLAG_OR
       --
       -- For Generate Description:
       --  Implement the OR of the TLAST and EOP Error flags.
       --
       --
       --
       ------------------------------------------------------------
       DO_FLAG_OR : for slice_index in 1 to MMAP2STRM_WIDTH_RATO-1 generate
       
       begin
     
          lsig_partial_tlast_or(slice_index)   <= lsig_partial_tlast_or(slice_index-1) or
                                                  --lsig_partial_tlast_or(slice_index);
                                                  lsig_flag_slice_reg(slice_index)(1);
                                                  
                                                  
                                                  
                                                  
          lsig_partial_eop_err_or(slice_index) <= lsig_partial_eop_err_or(slice_index-1) or
                                                  --lsig_partial_eop_err_or(slice_index); 
                                                  lsig_flag_slice_reg(slice_index)(0);
       
       end generate DO_FLAG_OR;

     
        
        
     
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_DATA_COMBINER
       --
       -- For Generate Description:
       --   Combines the Data Slice register outputs into a single
       -- vector for input to the Data FIFO.
       --
       --
       ------------------------------------------------------------
       DO_DATA_COMBINER : for slice_index in 1 to MMAP2STRM_WIDTH_RATO generate
       
       begin
        
         lsig_combined_data((slice_index*DATA_SLICE_WIDTH)-1 downto 
                            (slice_index-1)*DATA_SLICE_WIDTH) <=
                            lsig_data_slice_reg(slice_index-1);
        
        
       end generate DO_DATA_COMBINER;
     
     
     
     
     
       
       
      end generate INCLUDE_PACKING;
     
     
    
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
     
 ---------------------------------------------------------------- 
 -- Data FIFO Logic    ------------------------------------------
 ---------------------------------------------------------------- 
 
     
     -- FIFO Input attachments
     
     -- sig_push_data_fifo <= sig_good_sin_strm_dbeat;
     
     
     -- -- Concatonate the Stream inputs into the single FIFO data in value 
     -- sig_data_fifo_data_in <= sin2sf_error &
     --                          sin2sf_tlast &
     --                          sin2sf_tkeep & 
     --                          sin2sf_tdata;
 
    
    
     -- FIFO Output to output stream attachments
     sig_sf2sout_tvalid      <=  sig_data_fifo_dvalid ;
     
     sig_sf2sout_tdata       <=  sig_data_fifo_data_out(DATA_OUT_MSB_INDEX downto
                                                        DATA_OUT_LSB_INDEX);
     
     -- sig_sf2sout_tkeep       <=  sig_data_fifo_data_out(TSTRB_OUT_MSB_INDEX downto
     --                                                    TSTRB_OUT_LSB_INDEX);
     
     -- When this Store and Forward is enabled, the Write Data Controller ignores the 
     -- TKEEP input so this is not sent through the FIFO.
     sig_sf2sout_tkeep       <=  (others => '1');
     
     
     
     sig_sf2sout_tlast       <=  sig_data_fifo_data_out(TLAST_OUT_INDEX) ;
     
     sig_sf2sout_eop_err_out <=  sig_data_fifo_data_out(EOP_ERR_OUT_INDEX) ;
     
     
     -- FIFO Rd/WR Controls
     
     
     sig_pop_data_fifo  <= sig_sout2sf_tready and 
                           sig_data_fifo_dvalid;
     
                                                     
    ------------------------------------------------------------
    -- Instance: I_DATA_FIFO 
    --
    -- Description:
    --  Implements the Store and Forward data FIFO (synchronous)   
    --
    ------------------------------------------------------------
    I_DATA_FIFO : entity axi_datamover_v5_1_17.axi_datamover_sfifo_autord
    generic map (

      C_DWIDTH                =>  DATA_FIFO_WIDTH       ,  
      C_DEPTH                 =>  DATA_FIFO_DEPTH       ,  
      C_DATA_CNT_WIDTH        =>  DATA_FIFO_CNT_WIDTH   ,  
      C_NEED_ALMOST_EMPTY     =>  NOT_NEEDED            ,  
      C_NEED_ALMOST_FULL      =>  NOT_NEEDED            ,  
      C_USE_BLKMEM            =>  BLK_MEM_FIFO          ,  
      C_FAMILY                =>  C_FAMILY                 

      )
    port map (

     -- Inputs 
      SFIFO_Sinit             =>  reset                  , 
      SFIFO_Clk               =>  aclk                   , 
      SFIFO_Wr_en             =>  sig_push_data_fifo     , 
      SFIFO_Din               =>  sig_data_fifo_data_in  , 
      SFIFO_Rd_en             =>  sig_pop_data_fifo      , 
      SFIFO_Clr_Rd_Data_Valid =>  LOGIC_LOW              , 
      
     -- Outputs
      SFIFO_DValid            =>  sig_data_fifo_dvalid   , 
      SFIFO_Dout              =>  sig_data_fifo_data_out , 
      SFIFO_Full              =>  sig_data_fifo_full     , 
      SFIFO_Empty             =>  open                   , 
      SFIFO_Almost_full       =>  open                   , 
      SFIFO_Almost_empty      =>  open                   , 
      SFIFO_Rd_count          =>  open                   ,  
      SFIFO_Rd_count_minus1   =>  open                   ,  
      SFIFO_Wr_count          =>  open                   ,  
      SFIFO_Rd_ack            =>  open                     

    );



 
 
 
 
 
 
 
 
 
 
 
-------------------------------------------------------------------- 
-- Write Side Control Logic  
--------------------------------------------------------------------

    -- Convert the LEN fifo data output to unsigned
    sig_len_fifo_len_out_un <= unsigned(sig_len_fifo_data_out);
   
    -- Resize the unsigned LEN output to the Data FIFO writecount width
    sig_resized_fifo_len    <= RESIZE(sig_len_fifo_len_out_un , DATA_FIFO_CNT_WIDTH);
   
    
    -- The actual number of databeats needed for the queued write transfer
    -- is the current LEN fifo output plus 1.
    sig_num_wr_dbeats_needed <= sig_resized_fifo_len + UNCOM_WRCNT_1;
   
   
    -- Compare the uncommited receved data beat count to that needed
    -- for the next queued write request.
    sig_enough_dbeats_rcvd <= '1'
      When (sig_num_wr_dbeats_needed <= sig_uncom_wrcnt)
      else '0';
    
    
    
    
    -- Increment the uncommited databeat counter on a good input
    -- stream databeat (Read Side of SF)
   -- sig_incr_uncom_wrcnt    <=  sig_good_sin_strm_dbeat;
    sig_incr_uncom_wrcnt    <=  sig_good_fifo_write;
   

    -- Subtract the current number of databeats needed from the
    -- uncommited databeat counter when the associated transfer
    -- address/qualifiers have been posted to the AXI Write 
    -- Address Channel
    sig_sub_len_uncom_wrcnt <= sig_wr_addr_posted;
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_UNCOM_DBEAT_CNTR
    --
    -- Process Description:
    -- Implements the counter that keeps track of the received read
    -- data beat count that has not been commited to a transfer on  
    -- the write side with a Write Address posting.
    --
    -------------------------------------------------------------
    IMP_UNCOM_DBEAT_CNTR : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
          if (reset            = '1') then 

            sig_uncom_wrcnt <= UNCOM_WRCNT_0;
            
          elsif (sig_incr_uncom_wrcnt    = '1' and
                 sig_sub_len_uncom_wrcnt = '1') then

            sig_uncom_wrcnt <= sig_uncom_wrcnt - sig_resized_fifo_len;
            
          elsif (sig_incr_uncom_wrcnt    = '1' and
                 sig_sub_len_uncom_wrcnt = '0') then

            sig_uncom_wrcnt <= sig_uncom_wrcnt + UNCOM_WRCNT_1;
            
          elsif (sig_incr_uncom_wrcnt    = '0' and
                 sig_sub_len_uncom_wrcnt = '1') then

            sig_uncom_wrcnt <= sig_uncom_wrcnt - sig_num_wr_dbeats_needed;
            
          else
            null;  -- hold current value
          end if; 
        end if;       
      end process IMP_UNCOM_DBEAT_CNTR; 
    
    
    





  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_WR_ADDR_POST_FLAG
   --
   -- Process Description:
   --   Implements the flag indicating that the pending write
   -- transfer's data beat count has been received on the input
   -- side of the Data FIFO. This means the Write side can post
   -- the associated write address to the AXI4 bus and the 
   -- associated write data transfer can complete without CDMA
   -- throttling the Write Data Channel.     
   --
   -- The flag is cleared immediately after an address is posted
   -- to prohibit a second unauthorized posting while the control
   -- logic stabilizes to the next LEN FIFO value
   --.
   -------------------------------------------------------------
   IMP_WR_ADDR_POST_FLAG : process (aclk)
     begin
       if (aclk'event and aclk = '1') then
          if (reset              = '1' or
              sig_wr_addr_posted = '1') then
   
            sig_ok_to_post_wr_addr <= '0';
   
          else
   
            sig_ok_to_post_wr_addr <= not(sig_len_fifo_empty) and
                                      sig_enough_dbeats_rcvd; 
   
          end if; 
       end if;       
     end process IMP_WR_ADDR_POST_FLAG; 


 
   
   
   
   
   
   -------------------------------------------------------------
   -- LEN FIFO logic 
   -- The LEN FIFO stores the xfer lengths needed for each queued 
   -- write transfer in the DataMover S2MM Write Data Controller.  
    
   sig_push_len_fifo    <= sig_wr_ld_nxt_len and
                           not(sig_len_fifo_full);


   sig_pop_len_fifo     <= wr_addr_posted and
                           not(sig_len_fifo_empty);
  
 
 


   ------------------------------------------------------------
   -- Instance: I_WR_LEN_FIFO 
   --
   -- Description:
   -- Implement the LEN FIFO using SRL FIFO elements    
   --
   ------------------------------------------------------------
   I_WR_LEN_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
   generic map (

     C_DWIDTH      =>  WR_LEN_FIFO_DWIDTH   ,  
     C_DEPTH       =>  WR_LEN_FIFO_DEPTH    ,  
     C_FAMILY      =>  C_FAMILY      

     )
   port map (

     Clk           =>  aclk                  ,  
     Reset         =>  reset                 ,  
     FIFO_Write    =>  sig_push_len_fifo     ,  
     Data_In       =>  sig_len_fifo_data_in  ,  
     FIFO_Read     =>  sig_pop_len_fifo      ,  
     Data_Out      =>  sig_len_fifo_data_out ,  
     FIFO_Empty    =>  sig_len_fifo_empty    ,  
     FIFO_Full     =>  sig_len_fifo_full     ,  
     Addr          =>  open                
 
     );

    

   
     
 
 
 
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_stbs_set.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_stbs_set.vhd
  --
  -- Description:     
  --    This file implements a module to count the number of strobe bits that 
  --    are asserted active high on the input strobe bus. This module does not
  --    support sparse strobe assertions.              
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  


  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_stbs_set is
    generic (
      
      C_STROBE_WIDTH    : Integer range 1 to 128 := 8
        -- Specifies the width (in bits) of the input strobe bus.
      
      );
    port (
      
      -- Input Strobe bus ----------------------------------------------------
                                                                            --
      tstrb_in          : in  std_logic_vector(C_STROBE_WIDTH-1 downto 0);  --
      ------------------------------------------------------------------------
      
      
      -- Asserted Strobes count output ---------------------------------------
                                                                            --
      num_stbs_asserted : Out std_logic_vector(7 downto 0)                  --
        -- Indicates the number of asserted tstrb_in bits                   --
      ------------------------------------------------------------------------
     
      );
  
  end entity axi_datamover_stbs_set;
  
  
  architecture implementation of axi_datamover_stbs_set is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_8bit_stbs_set
    --
    -- Function Description:
    --  Implements an 8-bit lookup table for calculating the number
    -- of asserted bits within an 8-bit strobe vector.
    --
    -- Note that this function assumes that asserted strobes are 
    -- contiguous with each other (no sparse strobe assertions). 
    --
    -------------------------------------------------------------------
    function funct_8bit_stbs_set (strb_8 : std_logic_vector(7 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 4;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 8 := 0;
    
    begin
    
      case strb_8 is
        
        -------  1 bit --------------------------
        when "00000001" | "00000010" | "00000100" | "00001000" | 
             "00010000" | "00100000" | "01000000" | "10000000" =>
        
          lvar_num_set := 1;
        
        
        -------  2 bit --------------------------
        when "00000011" | "00000110" | "00001100" | "00011000" | 
             "00110000" | "01100000" | "11000000"  =>
        
          lvar_num_set := 2;
        
        
        -------  3 bit --------------------------
        when "00000111" | "00001110" | "00011100" | "00111000" | 
             "01110000" | "11100000"   =>
        
          lvar_num_set := 3;
        
        
        -------  4 bit --------------------------
        when "00001111" | "00011110" | "00111100" | "01111000" | 
             "11110000"    =>
        
          lvar_num_set := 4;
        
        
        -------  5 bit --------------------------
        when "00011111" | "00111110" | "01111100" | "11111000"  =>
        
          lvar_num_set := 5;
        
        
        -------  6 bit --------------------------
        when "00111111" | "01111110" | "11111100"  =>
        
          lvar_num_set := 6;
        
        
        -------  7 bit --------------------------
        when "01111111" | "11111110"   =>
        
          lvar_num_set := 7;
        
        
        -------  8 bit --------------------------
        when "11111111"    =>
        
          lvar_num_set := 8;
        
        
        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_8bit_stbs_set;
    
    
    
    
    
    
    -- Constants
    
    Constant LOGIC_LOW              : std_logic := '0';
    Constant LOGIC_HIGH             : std_logic := '1';
    Constant BITS_FOR_STBS_ASSERTED : integer := 8; -- increments of 8 bits
    Constant NUM_ZEROS_WIDTH        : integer := BITS_FOR_STBS_ASSERTED;
    
    
    -- Signals
    
    signal sig_strb_input           : std_logic_vector(C_STROBE_WIDTH-1 downto 0) := (others => '0');
    signal sig_stbs_asserted        : std_logic_vector(BITS_FOR_STBS_ASSERTED-1 downto 0) := (others => '0');


    
    
  begin --(architecture implementation)
  
   
   num_stbs_asserted     <= sig_stbs_asserted;
   
   sig_strb_input        <= tstrb_in         ;
    
    
    
    
 
 
    -------------------------------------------------------------------------
    ----------------  Asserted TSTRB calculation logic  --------------------- 
    -------------------------------------------------------------------------
    
    
 
   
     
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_1_STRB
     --
     -- If Generate Description:
     --   1-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_1_STRB : if (C_STROBE_WIDTH = 1) generate
     
     
        begin
     
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_1BIT_STRB
          --
          -- Process Description:
          --
          --
          -------------------------------------------------------------
          IMP_1BIT_STRB : process (sig_strb_input)
             begin
          
               
               -- Concatonate the strobe to the ls bit of
               -- the asserted value
               sig_stbs_asserted <= "0000000" &
                                    sig_strb_input(0);
          
             end process IMP_1BIT_STRB; 
        
        end generate GEN_1_STRB;
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_2_STRB
     --
     -- If Generate Description:
     --   2-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_2_STRB : if (C_STROBE_WIDTH = 2) generate
     
     
        signal lsig_num_set     : integer range 0 to 2 := 0;
        signal lsig_strb_vect   : std_logic_vector(1 downto 0) := (others => '0');
        
        begin
     
          
          lsig_strb_vect <=  sig_strb_input;
          
          
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_2BIT_STRB
          --
          -- Process Description:
          --  Calculates the number of strobes set fo the 2-bit 
          -- strobe case
          --
          -------------------------------------------------------------
          IMP_2BIT_STRB : process (lsig_strb_vect)
             begin
              
               case lsig_strb_vect is
                 when "01" | "10" =>
                   lsig_num_set <= 1;
                 when "11" =>
                   lsig_num_set <= 2;
                 when others =>
                   lsig_num_set <= 0;
               end case;
               
             end process IMP_2BIT_STRB; 
             
          
          sig_stbs_asserted <= STD_LOGIC_VECTOR(TO_UNSIGNED(lsig_num_set,
                                                            BITS_FOR_STBS_ASSERTED));
     
        
        end generate GEN_2_STRB;
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_4_STRB
     --
     -- If Generate Description:
     --   4-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_4_STRB : if (C_STROBE_WIDTH = 4) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  "0000" & sig_strb_input; -- make and 8-bit vector 
                                                     -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                      BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_4_STRB;
   
   
  
  
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_8_STRB
     --
     -- If Generate Description:
     --   8-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_8_STRB : if (C_STROBE_WIDTH = 8) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  sig_strb_input; -- make and 8-bit vector 
                                            -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                           BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_8_STRB;
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_16_STRB
     --
     -- If Generate Description:
     --   16-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_16_STRB : if (C_STROBE_WIDTH = 16) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0); -- make and 8-bit vector 
                                                           -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8); -- make and 8-bit vector 
                                                            -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_16_STRB;
   
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_32_STRB
     --
     -- If Generate Description:
     --   32-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_32_STRB : if (C_STROBE_WIDTH = 32) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_32_STRB;
   
   
   
 
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_64_STRB
     --
     -- If Generate Description:
     --   64-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_64_STRB : if (C_STROBE_WIDTH = 64) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8   : std_logic_vector(7 downto 0) := (others => '0');
       
       
       
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5 <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6 <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7 <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8 <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
   
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs5 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs6 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs7 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs8 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_64_STRB;
   
   
   
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_128_STRB
     --
     -- If Generate Description:
     --   128-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_128_STRB : if (C_STROBE_WIDTH = 128) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect9    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect10   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect11   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect12   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect13   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect14   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect15   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect16   : std_logic_vector(7 downto 0) := (others => '0');
       
       
       
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs9  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs10 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs11 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs12 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs13 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs14 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs15 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs16 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect9   <=  sig_strb_input(71 downto 64);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect10  <=  sig_strb_input(79 downto 72);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect11  <=  sig_strb_input(87 downto 80); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect12  <=  sig_strb_input(95 downto 88); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect13  <=  sig_strb_input(103 downto 96);   -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect14  <=  sig_strb_input(111 downto 104);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect15  <=  sig_strb_input(119 downto 112); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect16  <=  sig_strb_input(127 downto 120); -- make and 8-bit vector 
                                                       -- for the function call
          
          
          
         lsig_num_in_stbs1  <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2  <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3  <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4  <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5  <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6  <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7  <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8  <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
         
   
         lsig_num_in_stbs9  <=  funct_8bit_stbs_set(lsig_strb_vect9) ;
          
         lsig_num_in_stbs10 <=  funct_8bit_stbs_set(lsig_strb_vect10) ;
         
         lsig_num_in_stbs11 <=  funct_8bit_stbs_set(lsig_strb_vect11) ;
         
         lsig_num_in_stbs12 <=  funct_8bit_stbs_set(lsig_strb_vect12) ;
   
   
         lsig_num_in_stbs13 <=  funct_8bit_stbs_set(lsig_strb_vect13) ;
   
         lsig_num_in_stbs14 <=  funct_8bit_stbs_set(lsig_strb_vect14) ;
   
         lsig_num_in_stbs15 <=  funct_8bit_stbs_set(lsig_strb_vect15) ;
   
         lsig_num_in_stbs16 <=  funct_8bit_stbs_set(lsig_strb_vect16) ;
   
          
          
         lsig_num_total     <= RESIZE(lsig_num_in_stbs1  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs2  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs3  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs4  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs5  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs6  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs7  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs8  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs9  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs10 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs11 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs12 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs13 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs14 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs15 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs16 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted  <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_128_STRB;
   
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_stbs_set_nodre.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_stbs_set_nodre.vhd
  --
  -- Description:     
  --    This file implements a module to count the number of strobe bits that 
  --    are asserted active high on the input strobe bus. This module does not
  --    support sparse strobe assertions.              
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  


  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_stbs_set_nodre is
    generic (
      
      C_STROBE_WIDTH    : Integer range 1 to 128 := 8
        -- Specifies the width (in bits) of the input strobe bus.
      
      );
    port (
      
      -- Input Strobe bus ----------------------------------------------------
                                                                            --
      tstrb_in          : in  std_logic_vector(C_STROBE_WIDTH-1 downto 0);  --
      ------------------------------------------------------------------------
      
      
      -- Asserted Strobes count output ---------------------------------------
                                                                            --
      num_stbs_asserted : Out std_logic_vector(7 downto 0)                  --
        -- Indicates the number of asserted tstrb_in bits                   --
      ------------------------------------------------------------------------
     
      );
  
  end entity axi_datamover_stbs_set_nodre;
  
  
  architecture implementation of axi_datamover_stbs_set_nodre is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_8bit_stbs_set
    --
    -- Function Description:
    --  Implements an 8-bit lookup table for calculating the number
    -- of asserted bits within an 8-bit strobe vector.
    --
    -- Note that this function assumes that asserted strobes are 
    -- contiguous with each other (no sparse strobe assertions). 
    --
    -------------------------------------------------------------------
    function funct_8bit_stbs_set (strb_8 : std_logic_vector(7 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 4;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 8 := 0;
    
    begin
    
      case strb_8 is
        
        -------  1 bit --------------------------
        when "00000001" =>
        
          lvar_num_set := 1;
        
        
        -------  2 bit --------------------------
        when "00000011" =>
        
          lvar_num_set := 2;
        
        
        -------  3 bit --------------------------
        when "00000111" =>
        
          lvar_num_set := 3;
        
        
        -------  4 bit --------------------------
        when "00001111" =>
             
        
          lvar_num_set := 4;
        
        
        -------  5 bit --------------------------
        when "00011111" =>
        
          lvar_num_set := 5;
        
        
        -------  6 bit --------------------------
        when "00111111" =>
        
          lvar_num_set := 6;
        
        
        -------  7 bit --------------------------
        when "01111111" =>
        
          lvar_num_set := 7;
        
        
        -------  8 bit --------------------------
        when "11111111" =>
        
          lvar_num_set := 8;
        
        
        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_8bit_stbs_set;


    function funct_256bit_stbs_set (strb_3 : std_logic_vector(2 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 5;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 24 := 0;
    
    begin
    
      case strb_3 is
        
--        when "0000000" =>
        
--          lvar_num_set := 0;
        -------  1 bit --------------------------
        when "001" =>
        
          lvar_num_set := 8;
        
        -------  2 bit --------------------------
        when "011" =>
        
          lvar_num_set := 16;
        
        -------  3 bit --------------------------
        when "111" =>
        
          lvar_num_set := 24;

        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_256bit_stbs_set;




    function funct_512bit_stbs_set (strb_3 : std_logic_vector(6 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 6;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 56 := 0;
    
    begin
    
      case strb_3 is
        
--        when "0000000" =>
        
--          lvar_num_set := 0;
        -------  1 bit --------------------------
        when "0000001" =>
        
          lvar_num_set := 8;
        
        -------  2 bit --------------------------
        when "0000011" =>
        
          lvar_num_set := 16;
        
        -------  3 bit --------------------------
        when "0000111" =>
        
          lvar_num_set := 24;

        when "0001111" =>
        
          lvar_num_set := 32;

        when "0011111" =>
        
          lvar_num_set := 40;

        when "0111111" =>
        
          lvar_num_set := 48;

        when "1111111" =>
        
          lvar_num_set := 56;

        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_512bit_stbs_set;


    function funct_1024bit_stbs_set (strb_3 : std_logic_vector(14 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 7;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 120 := 0;
    
    begin
    
      case strb_3 is
        
        -------  1 bit --------------------------
        when "000000000000001" =>
        
          lvar_num_set := 8;
        
        -------  2 bit --------------------------
        when "000000000000011" =>
        
          lvar_num_set := 16;
        
        -------  3 bit --------------------------
        when "000000000000111" =>
        
          lvar_num_set := 24;

        when "000000000001111" =>
        
          lvar_num_set := 32;

        when "000000000011111" =>
        
          lvar_num_set := 40;

        when "000000000111111" =>
        
          lvar_num_set := 48;

        when "000000001111111" =>
        
          lvar_num_set := 56;

        when "000000011111111" =>
        
          lvar_num_set := 64;

        when "000000111111111" =>
        
          lvar_num_set := 72;

        when "000001111111111" =>
        
          lvar_num_set := 80;

        when "000011111111111" =>
        
          lvar_num_set := 88;

        when "000111111111111" =>
        
          lvar_num_set := 96;

        when "001111111111111" =>
        
          lvar_num_set := 104;

        when "011111111111111" =>
        
          lvar_num_set := 112;

        when "111111111111111" =>
        
          lvar_num_set := 120;

        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_1024bit_stbs_set;


--    function funct_8bit_stbs_set (strb_8 : std_logic_vector(7 downto 0)) return unsigned is
--    
--      Constant ASSERTED_VALUE_WIDTH : integer := 4;-- 4 bits needed
--      
--      
--      Variable lvar_num_set : Integer range 0 to 8 := 0;
--    
--    begin
--    
--      case strb_8 is
--        
----        -------  1 bit --------------------------
--        when "00000001" | "00000010" | "00000100" | "00001000" | 
--             "00010000" | "00100000" | "01000000" | "10000000" =>
--        
--          lvar_num_set := 1;
--        
--        
--        -------  2 bit --------------------------
--        when "00000011" | "00000110" | "00001100" | "00011000" | 
--             "00110000" | "01100000" | "11000000"  =>
--        
--          lvar_num_set := 2;
--        
--        
--        -------  3 bit --------------------------
--        when "00000111" | "00001110" | "00011100" | "00111000" | 
--             "01110000" | "11100000"   =>
--        
--          lvar_num_set := 3;
--        
--        
--        -------  4 bit --------------------------
--        when "00001111" | "00011110" | "00111100" | "01111000" | 
--             "11110000"    =>
--        
--          lvar_num_set := 4;
--        
--        
--        -------  5 bit --------------------------
--        when "00011111" | "00111110" | "01111100" | "11111000"  =>
--        
--          lvar_num_set := 5;
--        
--        
--        -------  6 bit --------------------------
--        when "00111111" | "01111110" | "11111100"  =>
--        
--          lvar_num_set := 6;
--        
--        
--        -------  7 bit --------------------------
--        when "01111111" | "11111110"   =>
--        
--          lvar_num_set := 7;
--        
--        
--        -------  8 bit --------------------------
--        when "11111111"    =>
--        
--          lvar_num_set := 8;
--        
--        
--        ------- all zeros or sparse strobes ------
--        When others =>  
--        
--          lvar_num_set := 0;
--        
--      end case;
--      
--      
--      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
--       
--       
--      
--    end function funct_8bit_stbs_set;
    
    
    
    
    
    
    -- Constants
    
    Constant LOGIC_LOW              : std_logic := '0';
    Constant LOGIC_HIGH             : std_logic := '1';
    Constant BITS_FOR_STBS_ASSERTED : integer := 8; -- increments of 8 bits
    Constant NUM_ZEROS_WIDTH        : integer := BITS_FOR_STBS_ASSERTED;
    
    
    -- Signals
    
    signal sig_strb_input           : std_logic_vector(C_STROBE_WIDTH-1 downto 0) := (others => '0');
    signal sig_stbs_asserted        : std_logic_vector(BITS_FOR_STBS_ASSERTED-1 downto 0) := (others => '0');


    
    
  begin --(architecture implementation)
  
   
   num_stbs_asserted     <= sig_stbs_asserted;
   
   sig_strb_input        <= tstrb_in         ;
    
    
    
    
 
 
    -------------------------------------------------------------------------
    ----------------  Asserted TSTRB calculation logic  --------------------- 
    -------------------------------------------------------------------------
    
    
 
   
     
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_1_STRB
     --
     -- If Generate Description:
     --   1-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_1_STRB : if (C_STROBE_WIDTH = 1) generate
     
     
        begin
     
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_1BIT_STRB
          --
          -- Process Description:
          --
          --
          -------------------------------------------------------------
          IMP_1BIT_STRB : process (sig_strb_input)
             begin
          
               
               -- Concatonate the strobe to the ls bit of
               -- the asserted value
               sig_stbs_asserted <= "0000000" &
                                    sig_strb_input(0);
          
             end process IMP_1BIT_STRB; 
        
        end generate GEN_1_STRB;
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_2_STRB
     --
     -- If Generate Description:
     --   2-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_2_STRB : if (C_STROBE_WIDTH = 2) generate
     
     
        signal lsig_num_set     : integer range 0 to 2 := 0;
        signal lsig_strb_vect   : std_logic_vector(1 downto 0) := (others => '0');
        
        begin
     
          
          lsig_strb_vect <=  sig_strb_input;
          
          
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_2BIT_STRB
          --
          -- Process Description:
          --  Calculates the number of strobes set fo the 2-bit 
          -- strobe case
          --
          -------------------------------------------------------------
          IMP_2BIT_STRB : process (lsig_strb_vect)
             begin
              
               case lsig_strb_vect is
                 when "01" | "10" =>
                   lsig_num_set <= 1;
                 when "11" =>
                   lsig_num_set <= 2;
                 when others =>
                   lsig_num_set <= 0;
               end case;
               
             end process IMP_2BIT_STRB; 
             
          
          sig_stbs_asserted <= STD_LOGIC_VECTOR(TO_UNSIGNED(lsig_num_set,
                                                            BITS_FOR_STBS_ASSERTED));
     
        
        end generate GEN_2_STRB;
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_4_STRB
     --
     -- If Generate Description:
     --   4-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_4_STRB : if (C_STROBE_WIDTH = 4) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  "0000" & sig_strb_input; -- make and 8-bit vector 
                                                     -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                      BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_4_STRB;
   
   
  
  
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_8_STRB
     --
     -- If Generate Description:
     --   8-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_8_STRB : if (C_STROBE_WIDTH = 8) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  sig_strb_input; -- make and 8-bit vector 
                                            -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                           BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_8_STRB;
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_16_STRB
     --
     -- If Generate Description:
     --   16-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_16_STRB : if (C_STROBE_WIDTH = 16) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0); -- make and 8-bit vector 
                                                           -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8); -- make and 8-bit vector 
                                                            -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_16_STRB;
   
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_32_STRB
     --
     -- If Generate Description:
     --   32-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_32_STRB : if (C_STROBE_WIDTH = 32) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');

       signal lsig_new_vect     : std_logic_vector (2 downto 0) := (others => '0'); 
       signal lsig_num_new_stbs1 : unsigned(4 downto 0) := (others => '0');
       signal lsig_new_vect1 : std_logic_vector (7 downto 0) := (others => '0');
       signal lsig_num_new_vect1 : unsigned(3 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
          
          
     --    lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH);
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);

         lsig_new_vect <= sig_strb_input (24) & sig_strb_input (16) & sig_strb_input (8); 

         lsig_num_new_stbs1 <=  funct_256bit_stbs_set(lsig_new_vect) ;

         lsig_num_new_vect1 <= funct_8bit_stbs_set(lsig_new_vect1);

         lsig_num_total    <= RESIZE(lsig_num_new_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_new_vect1 , RESULT_BIT_WIDTH);

     process (lsig_new_vect, sig_strb_input)
     begin
      case lsig_new_vect is
        
        -------  1 bit --------------------------
        when "000" =>
          lsig_new_vect1 <= sig_strb_input (7 downto 0); 

        when "001" =>

          lsig_new_vect1 <= sig_strb_input (15 downto 8); 

        -------  2 bit --------------------------
        when "011" =>

          lsig_new_vect1 <= sig_strb_input (23 downto 16); 

        -------  3 bit --------------------------
        when "111" =>

          lsig_new_vect1 <= sig_strb_input (31 downto 24); 


        ------- all zeros or sparse strobes ------
        When others =>

          lsig_new_vect1 <= (others => '0');

      end case;
      end process;
     
     
       end generate GEN_32_STRB;
   
   
   
 
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_64_STRB
     --
     -- If Generate Description:
     --   64-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_64_STRB : if (C_STROBE_WIDTH = 64) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
       signal lsig_num_total1    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
       signal lsig_new_vect     : std_logic_vector (6 downto 0) := (others => '0'); 
       signal lsig_num_new_stbs1 : unsigned(5 downto 0) := (others => '0');
       signal lsig_new_vect1 : std_logic_vector (7 downto 0) := (others => '0');
       signal lsig_num_new_vect1 : unsigned(3 downto 0) := (others => '0');
       
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          



          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5 <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6 <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7 <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8 <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
   
          
          
     --    lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs5 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs6 , RESULT_BIT_WIDTH) +
     --                         RESIZE(lsig_num_in_stbs7 , RESULT_BIT_WIDTH) +
      --                        RESIZE(lsig_num_in_stbs8 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);


         lsig_new_vect <=  sig_strb_input(56) & sig_strb_input (48) & sig_strb_input (40)  
                         & sig_strb_input(32) & sig_strb_input (24) & sig_strb_input (16) & sig_strb_input (8); 

         lsig_num_new_stbs1 <=  funct_512bit_stbs_set(lsig_new_vect) ;

         lsig_num_new_vect1 <= funct_8bit_stbs_set(lsig_new_vect1);

         lsig_num_total    <= RESIZE(lsig_num_new_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_new_vect1 , RESULT_BIT_WIDTH);

     process (lsig_new_vect, sig_strb_input)
     begin
      case lsig_new_vect is
        
        -------  1 bit --------------------------
        when "0000000" =>
          lsig_new_vect1 <= sig_strb_input (7 downto 0); 

        when "0000001" =>

          lsig_new_vect1 <= sig_strb_input (15 downto 8); 

        -------  2 bit --------------------------
        when "0000011" =>

          lsig_new_vect1 <= sig_strb_input (23 downto 16); 

        -------  3 bit --------------------------
        when "0000111" =>

          lsig_new_vect1 <= sig_strb_input (31 downto 24); 

        when "0001111" =>

          lsig_new_vect1 <= sig_strb_input (39 downto 32); 

        when "0011111" =>

          lsig_new_vect1 <= sig_strb_input (47 downto 40); 

        when "0111111" =>

          lsig_new_vect1 <= sig_strb_input (55 downto 48); 

        when "1111111" =>

          lsig_new_vect1 <= sig_strb_input (63 downto 56); 


        ------- all zeros or sparse strobes ------
        When others =>

          lsig_new_vect1 <= (others => '0');

      end case;
      end process;

     
     
       end generate GEN_64_STRB;
   
   
   
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_128_STRB
     --
     -- If Generate Description:
     --   128-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_128_STRB : if (C_STROBE_WIDTH = 128) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect9    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect10   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect11   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect12   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect13   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect14   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect15   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect16   : std_logic_vector(7 downto 0) := (others => '0');
       
       
       
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs9  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs10 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs11 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs12 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs13 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs14 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs15 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs16 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
       signal lsig_num_total1    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
       signal lsig_new_vect     : std_logic_vector (14 downto 0) := (others => '0'); 
       signal lsig_num_new_stbs1 : unsigned(6 downto 0) := (others => '0');
       signal lsig_new_vect1 : std_logic_vector (7 downto 0) := (others => '0');
       signal lsig_num_new_vect1 : unsigned(3 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect9   <=  sig_strb_input(71 downto 64);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect10  <=  sig_strb_input(79 downto 72);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect11  <=  sig_strb_input(87 downto 80); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect12  <=  sig_strb_input(95 downto 88); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect13  <=  sig_strb_input(103 downto 96);   -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect14  <=  sig_strb_input(111 downto 104);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect15  <=  sig_strb_input(119 downto 112); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect16  <=  sig_strb_input(127 downto 120); -- make and 8-bit vector 
                                                       -- for the function call
          
          
          
         lsig_num_in_stbs1  <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2  <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3  <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4  <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5  <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6  <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7  <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8  <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
         
   
         lsig_num_in_stbs9  <=  funct_8bit_stbs_set(lsig_strb_vect9) ;
          
         lsig_num_in_stbs10 <=  funct_8bit_stbs_set(lsig_strb_vect10) ;
         
         lsig_num_in_stbs11 <=  funct_8bit_stbs_set(lsig_strb_vect11) ;
         
         lsig_num_in_stbs12 <=  funct_8bit_stbs_set(lsig_strb_vect12) ;
   
   
         lsig_num_in_stbs13 <=  funct_8bit_stbs_set(lsig_strb_vect13) ;
   
         lsig_num_in_stbs14 <=  funct_8bit_stbs_set(lsig_strb_vect14) ;
   
         lsig_num_in_stbs15 <=  funct_8bit_stbs_set(lsig_strb_vect15) ;
   
         lsig_num_in_stbs16 <=  funct_8bit_stbs_set(lsig_strb_vect16) ;
   
          
          
  --       lsig_num_total     <= RESIZE(lsig_num_in_stbs1  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs2  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs3  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs4  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs5  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs6  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs7  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs8  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs9  , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs10 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs11 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs12 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs13 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs14 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs15 , RESULT_BIT_WIDTH) +
  --                             RESIZE(lsig_num_in_stbs16 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted  <= STD_LOGIC_VECTOR(lsig_num_total);

         lsig_new_vect <= sig_strb_input (120) & sig_strb_input (112)   
                          & sig_strb_input(104) & sig_strb_input (96) & sig_strb_input (88)   
                          & sig_strb_input(80) & sig_strb_input (72) & sig_strb_input (64)   
                          & sig_strb_input(56) & sig_strb_input (48) & sig_strb_input (40)  
                          & sig_strb_input(32) & sig_strb_input (24) & sig_strb_input (16) & sig_strb_input (8); 

         lsig_num_new_stbs1 <=  funct_1024bit_stbs_set(lsig_new_vect) ;

         lsig_num_new_vect1 <= funct_8bit_stbs_set(lsig_new_vect1);

         lsig_num_total    <= RESIZE(lsig_num_new_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_new_vect1 , RESULT_BIT_WIDTH);

     process (lsig_new_vect, sig_strb_input)
     begin
      case lsig_new_vect is
        
        -------  1 bit --------------------------
        when "000000000000000" =>
          lsig_new_vect1 <= sig_strb_input (7 downto 0); 

        when "000000000000001" =>

          lsig_new_vect1 <= sig_strb_input (15 downto 8); 

        -------  2 bit --------------------------
        when "000000000000011" =>

          lsig_new_vect1 <= sig_strb_input (23 downto 16); 

        -------  3 bit --------------------------
        when "000000000000111" =>

          lsig_new_vect1 <= sig_strb_input (31 downto 24); 

        when "000000000001111" =>

          lsig_new_vect1 <= sig_strb_input (39 downto 32); 

        when "000000000011111" =>

          lsig_new_vect1 <= sig_strb_input (47 downto 40); 

        when "000000000111111" =>

          lsig_new_vect1 <= sig_strb_input (55 downto 48); 

        when "000000001111111" =>

          lsig_new_vect1 <= sig_strb_input (63 downto 56); 

        when "000000011111111" =>

          lsig_new_vect1 <= sig_strb_input (71 downto 64); 

        when "000000111111111" =>

          lsig_new_vect1 <= sig_strb_input (79 downto 72); 

        when "000001111111111" =>

          lsig_new_vect1 <= sig_strb_input (87 downto 80); 

        when "000011111111111" =>

          lsig_new_vect1 <= sig_strb_input (95 downto 88); 

        when "000111111111111" =>

          lsig_new_vect1 <= sig_strb_input (103 downto 96); 

        when "001111111111111" =>

          lsig_new_vect1 <= sig_strb_input (111 downto 104); 

        when "011111111111111" =>

          lsig_new_vect1 <= sig_strb_input (119 downto 112); 

        when "111111111111111" =>

          lsig_new_vect1 <= sig_strb_input (127 downto 120); 

        ------- all zeros or sparse strobes ------
        When others =>

          lsig_new_vect1 <= (others => '0');

      end case;
      end process;

     
     
       end generate GEN_128_STRB;
   
  
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_ibttcc.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_ibttcc.vhd
  --
  -- Description:     
  --    This file implements the DataMover Indeterminate BTT Command Calculator
  -- (SFCC) for the Indeterminate BTT operation mode of the DataMover S2MM 
  -- function.  Since Indeterminate BTT is totally dependent on the data                
  -- received from the S2MM input Stream for command generation, Predictive 
  -- child request calculation is not needed.  
  --                 
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_ibttcc is
    generic (
      
      C_SF_XFER_BYTES_WIDTH : Integer range  1 to  14 :=  8;
        -- sets the width of the sf2pcc_xfer_bytes port which is
        -- used to indicate the number of actual bytes received
        -- by the IBTT functions
      
      
      C_DRE_ALIGN_WIDTH     : Integer range  1 to   6 :=  2;
        -- Sets the width of the DRE Aligment output ports
        
      C_SEL_ADDR_WIDTH      : Integer range  1 to   8 :=  5;
        -- Sets the width of the LS address bus used for 
        -- Muxing/Demuxing data to/from a wider AXI4 data bus
      
      C_ADDR_WIDTH          : Integer range 32 to  64 := 32;
        -- Sets the width of the AXi Address Channel 
      
      C_STREAM_DWIDTH       : Integer range  8 to 1024 := 32;
        -- Sets the width of the Native Data width that
        -- is being supported by the PCC
      
      C_MAX_BURST_LEN       : Integer range 2 to 256 := 16;
        -- Indicates the max allowed burst length to use for
        -- AXI4 transfer calculations
      
      C_CMD_WIDTH           : Integer                 := 68;
        -- Sets the width of the input command port
      
      C_TAG_WIDTH           : Integer range  1 to   8 :=  4;
        -- Sets the width of the Tag field in the input command
      
      C_BTT_USED            : Integer range  8 to  26 := 16 ;
        -- Sets the width of the used portion of the BTT field
        -- of the input command
      
      C_NATIVE_XFER_WIDTH    : Integer range  8 to 1024 :=  32;
        -- Indicates the Native transfer width to use for all
        -- transfer calculations. This will either be the DataMover
        -- input Stream width or the AXI4 MMap data width depending
        -- on DataMover parameterization.
      
      C_STRT_SF_OFFSET_WIDTH : Integer range  1 to   7 :=  1;
        -- Indicates the width of the starting address offset
        -- bus passed to Store and Forward functions incorporating
        -- upsizer/downsizer logic.                                                    
      C_MCDMA : integer range 0 to 1 := 0
      );
    port (
      
      -- Clock and Reset input ------------------------------------------
                                                                       --
      primary_aclk         : in  std_logic;                            --
         -- Primary synchronization clock for the Master side          --
         -- interface and internal logic. It is also used              --
         -- for the User interface synchronization when                --
         -- C_STSCMD_IS_ASYNC = 0.                                     --
                                                                       --
      -- Reset input                                                   --
      mmap_reset           : in  std_logic;                            --
        -- Reset used for the internal master logic                    --
      -------------------------------------------------------------------
      
       
       
     
      -- Master Command FIFO/Register Interface ------------------------------------------
                                                                                        --
      cmd2mstr_command      : in std_logic_vector(C_CMD_WIDTH-1 downto 0);              --
         -- The next command value available from the Command FIFO/Register             --
      cache2mstr_command      : in std_logic_vector(7 downto 0);                --
         -- The next command value available from the Command FIFO/Register               --
                                                                                        --
      cmd2mstr_cmd_valid    : in std_logic;                                             --
         -- Handshake bit indicating if the Command FIFO/Register has at least 1 entry  --
                                                                                        --
      mst2cmd_cmd_ready     : out  std_logic;                                           --
         -- Handshake bit indicating the Command Calculator is ready to accept          --
         -- another command                                                             --
      ------------------------------------------------------------------------------------
      
      
      
      -- Store and Forward Block Interface -----------------------------------------------
                                                                                        --
      sf2pcc_xfer_valid       : In std_logic;                                           --
        -- Indicates that at least 1 xfer descriptor entry is in in the IBtt            --
        -- XFER_DESCR_FIFO.                                                             --
                                                                                        --
      pcc2sf_xfer_ready       : Out std_logic;                                          --
        -- Indicates to the Store and Forward module that the xfer descriptor           --
        -- is being accepted by the SFCC.                                               --
                                                                                        --
                                                                                        --
      sf2pcc_cmd_cmplt        : In std_logic;                                           --
        -- Indicates that the next Store and Forward pending data block                 --
        -- is the last one associated with the corresponding command loaded             --
        -- into the Realigner.                                                          --
                                                                                        --
                                                                                        --
      sf2pcc_packet_eop       : In  std_logic;                                          --
        -- Indicates the end of a Stream Packet corresponds to the pending              --
        -- xfer data described by this xfer descriptor.                                 --
                                                                                        --
                                                                                        --
      sf2pcc_xfer_bytes       : In std_logic_vector(C_SF_XFER_BYTES_WIDTH-1 downto 0);  --
        -- This data byte count is used by the SFCC to increment the Address            --
        -- Counter to the next starting address for the next sequential transfer.       --
      ------------------------------------------------------------------------------------
 
      
      
       
      -- Address Channel Controller Interface --------------------------------------------
                                                                                        --
      mstr2addr_tag        : out std_logic_vector(C_TAG_WIDTH-1 downto 0);              --
         -- The next command tag                                                        --
                                                                                        --
      mstr2addr_addr       : out std_logic_vector(C_ADDR_WIDTH-1 downto 0);             --
         -- The next command address to put on the AXI MMap ADDR                        --
                                                                                        --
      mstr2addr_len        : out std_logic_vector(7 downto 0);                          --
         -- The next command length to put on the AXI MMap LEN                          --
                                                                                        --
      mstr2addr_size       : out std_logic_vector(2 downto 0);                          --
         -- The next command size to put on the AXI MMap SIZE                           --
                                                                                        --
      mstr2addr_burst      : out std_logic_vector(1 downto 0);                          --
         -- The next command burst type to put on the AXI MMap BURST                    --
                                                                                        --
      mstr2addr_cache     : out std_logic_vector(3 downto 0);                  --
         -- The next command burst type to put on the AXI MMap BURST           --

      mstr2addr_user     : out std_logic_vector(3 downto 0);                  --
         -- The next command burst type to put on the AXI MMap BURST           --
      mstr2addr_cmd_cmplt  : out std_logic;                                             --
         -- The indication to the Address Channel that the current                      --
         -- sub-command output is the last one compiled from the                        --
         -- parent command pulled from the Command FIFO                                 --
                                                                                        --
      mstr2addr_calc_error : out std_logic;                                             --
         -- Indication if the next command in the calculation pipe                      --
         -- has a calcualtion error                                                     --
                                                                                        --
      mstr2addr_cmd_valid  : out std_logic;                                             --
         -- The next command valid indication to the Address Channel                    --
         -- Controller for the AXI MMap                                                 --
                                                                                        --
      addr2mstr_cmd_ready  : In std_logic;                                              --
         -- Indication from the Address Channel Controller that the                     --
         -- command is being accepted                                                   --
      ------------------------------------------------------------------------------------
      
      
      
      
      -- Data Channel Controller Interface -----------------------------------------------
                                                                                        --
      mstr2data_tag        : out std_logic_vector(C_TAG_WIDTH-1 downto 0);              --
         -- The next command tag                                                        --
                                                                                        --
      mstr2data_saddr_lsb  : out std_logic_vector(C_SEL_ADDR_WIDTH-1 downto 0);         --
         -- The next command start address LSbs to use for the read data                --
         -- mux (only used if Stream data width is less than the MMap data              --
         -- width).                                                                     --
                                                                                        --
      mstr2data_len        : out std_logic_vector(7 downto 0);                          --
         -- The LEN value output to the Address Channel                                 --
                                                                                        --
      mstr2data_strt_strb  : out std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0);  --
         -- The starting strobe value to use for the data transfer                      --
                                                                                        --
      mstr2data_last_strb  : out std_logic_vector((C_NATIVE_XFER_WIDTH/8)-1 downto 0);  --
         -- The endiing (LAST) strobe value to use for the data transfer                --
                                                                                        --
      mstr2data_drr        : out std_logic;                                             --
         -- The starting tranfer of a sequence of transfers                             --
                                                                                        --
      mstr2data_eof        : out std_logic;                                             --
         -- The endiing tranfer of a sequence of parent transfer commands               --
                                                                                        --
      mstr2data_sequential : Out std_logic;                                             --
         -- The next sequential tranfer of a sequence of transfers                      --
         -- spawned from a single parent command                                        --
                                                                                        --
      mstr2data_calc_error : out std_logic;                                             --
         -- Indication if the next command in the calculation pipe                      --
         -- has a calculation error                                                     --
                                                                                        --
      mstr2data_cmd_cmplt  : out std_logic;                                             --
         -- The indication to the Data Channel that the current                         --
         -- sub-command output is the last one compiled from the                        --
         -- parent command pulled from the Command FIFO                                 --
                                                                                        --
      mstr2data_cmd_valid  : out std_logic;                                             --
         -- The next command valid indication to the Data Channel                       --
         -- Controller for the AXI MMap                                                 --
                                                                                        --
      data2mstr_cmd_ready  : In std_logic ;                                             --
         -- Indication from the Data Channel Controller that the                        --
         -- command is being accepted on the AXI Address                                --
         -- Channel                                                                     --
      ------------------------------------------------------------------------------------
     
      
      
      -- Output flag indicating that a calculation error has occured ---------------------
                                                                                        --
      calc_error               : Out std_logic;                                         --
         -- Indication from the Command Calculator that a calculation                   --
         -- error has occured.                                                          --
      ------------------------------------------------------------------------------------  
      
      
         
         
      -- Special S2MM DRE Controller Interface -------------------------------------------
                                                                                        --
      dre2mstr_cmd_ready        : In std_logic ;                                        --
         -- Indication from the S2MM DRE Controller that it can                         --
         -- accept another command.                                                     --
                                                                                        --
      mstr2dre_cmd_valid        : out std_logic ;                                       --
         -- The next command valid indication to the S2MM DRE                           --
         -- Controller.                                                                 --
                                                                                        --
      mstr2dre_tag              : out std_logic_vector(C_TAG_WIDTH-1 downto 0);         --
         -- The next command tag                                                        --
                                                                                        --
      mstr2dre_dre_src_align    : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) ;  --
         -- The source (S2MM Stream) alignment for the S2MM DRE                         --
                                                                                        --
      mstr2dre_dre_dest_align   : Out std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) ;  --
         -- The destinstion (S2MM MMap) alignment for the S2MM DRE                      --
                                                                                        --
      mstr2dre_btt              : out std_logic_vector(C_BTT_USED-1 downto 0) ;         --
         -- The BTT value output to the S2MM DRE. This is needed for                    --
         -- Scatter operations.                                                         --
                                                                                        --
      mstr2dre_drr              : out std_logic ;                                       --
         -- The starting tranfer of a sequence of transfers                             --
                                                                                        --
      mstr2dre_eof              : out std_logic ;                                       --
         -- The endiing tranfer of a sequence of parent transfer commands               --
                                                                                        --
      mstr2dre_cmd_cmplt        : Out std_logic ;                                       --
         -- The next sequential tranfer of a sequence of transfers                      --
         -- spawned from a single parent command                                        --
                                                                                        --
      mstr2dre_calc_error       : out std_logic ;                                       --
         -- Indication if the next command in the calculation pipe                      --
         -- has a calculation error                                                     --
      ------------------------------------------------------------------------------------

     
     
     -- Store and Forward Support Start Offset --------------------------------------------- 
                                                                                          -- 
     mstr2dre_strt_offset       : out std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0) -- 
       -- Relays the starting address offset for a transfer to the Store and Forward      -- 
       -- functions incorporating upsizer/downsizer logic                                 -- 
     ---------------------------------------------------------------------------------------    


     
      );
  
  end entity axi_datamover_ibttcc;
  
  
  architecture implementation of axi_datamover_ibttcc is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
  
  
  
  -- Function declarations  -------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_dbeat_residue_width
    --
    -- Function Description:
    --  Calculates the number of Least significant bits of the BTT field
    -- that are unused for the LEN calculation
    --
    -------------------------------------------------------------------
    function funct_get_dbeat_residue_width (bytes_per_beat : integer) return integer is

      Variable temp_dbeat_residue_width : Integer := 0; -- 8-bit stream

    begin

      case bytes_per_beat is
        when 1 =>  
            temp_dbeat_residue_width := 0;
        when 2 =>
            temp_dbeat_residue_width := 1;
        when 4 =>
            temp_dbeat_residue_width := 2;
        when 8 =>
            temp_dbeat_residue_width := 3;
        when 16 =>
            temp_dbeat_residue_width := 4;
        when 32 =>
            temp_dbeat_residue_width := 5;
        when 64 =>
            temp_dbeat_residue_width := 6;
        
        when others =>  -- 128-byte transfers
            temp_dbeat_residue_width := 7;
      end case;

      Return (temp_dbeat_residue_width);

    end function funct_get_dbeat_residue_width;
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_burstcnt_offset
    --
    -- Function Description:
    -- Calculates the bit offset from the residue bits needed to detirmine
    -- the load value for the burst counter.
    --
    -------------------------------------------------------------------
    function funct_get_burst_residue_width (max_burst_len : integer) return integer is
                                    
    
      Variable temp_burst_residue_width : Integer := 0;
    
    begin

      case max_burst_len is
        
        when 256 =>
          temp_burst_residue_width := 8;
        when 128 =>
          temp_burst_residue_width := 7;
        when 64 =>
          temp_burst_residue_width := 6;
        when 32 =>
          temp_burst_residue_width := 5;
        when 16 =>
          temp_burst_residue_width := 4;
        when 8 =>
          temp_burst_residue_width := 3;
        when 4 =>
          temp_burst_residue_width := 2;
        when others =>   -- assume 2 dbeats
          temp_burst_residue_width := 1;
      end case;
      
      Return (temp_burst_residue_width);
     
    end function funct_get_burst_residue_width;
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_get_axi_size
    --
    -- Function Description:
    --  Calcilates the AXi MMAP Size qualifier based on the data width
    --
    -------------------------------------------------------------------
    function func_get_axi_size (native_dwidth : integer) return std_logic_vector is
    
        
      Constant AXI_SIZE_1BYTE    : std_logic_vector(2 downto 0) := "000"; 
      Constant AXI_SIZE_2BYTE    : std_logic_vector(2 downto 0) := "001"; 
      Constant AXI_SIZE_4BYTE    : std_logic_vector(2 downto 0) := "010"; 
      Constant AXI_SIZE_8BYTE    : std_logic_vector(2 downto 0) := "011"; 
      Constant AXI_SIZE_16BYTE   : std_logic_vector(2 downto 0) := "100"; 
      Constant AXI_SIZE_32BYTE   : std_logic_vector(2 downto 0) := "101"; 
      Constant AXI_SIZE_64BYTE   : std_logic_vector(2 downto 0) := "110"; 
      Constant AXI_SIZE_128BYTE  : std_logic_vector(2 downto 0) := "111"; 
      
      Variable temp_size : std_logic_vector(2 downto 0) := (others => '0');
    
    begin
    
      
       case native_dwidth is
         when 8 =>  
           temp_size := AXI_SIZE_1BYTE;
         when 16 =>
           temp_size := AXI_SIZE_2BYTE;
         when 32 =>
           temp_size := AXI_SIZE_4BYTE;
         when 64 =>
           temp_size := AXI_SIZE_8BYTE;
         when 128 =>
           temp_size := AXI_SIZE_16BYTE;
         when 256 =>
           temp_size := AXI_SIZE_32BYTE;
         when 512 =>
           temp_size := AXI_SIZE_64BYTE;
         
         when others => -- 1024 bit dwidth
           temp_size := AXI_SIZE_128BYTE;
       end case;
       
      
       Return (temp_size);
      
      
    end function func_get_axi_size;
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_sf_offset_ls_index
    --
    -- Function Description:
    --   Calculates the Ls index of the Store and Forward
    --  starting offset bus based on the User Stream Width.
    --
    -------------------------------------------------------------------
    function funct_get_sf_offset_ls_index (stream_width : integer) return integer is
    
      Variable lvar_temp_ls_index : Integer := 0;
    
    begin
    
      case stream_width is
        when 8 =>
          lvar_temp_ls_index := 0;
        when 16 =>
          lvar_temp_ls_index := 1;
        when 32 =>
          lvar_temp_ls_index := 2;
        when 64 =>
          lvar_temp_ls_index := 3;
        when 128 =>
          lvar_temp_ls_index := 4;
        when 256 =>
          lvar_temp_ls_index := 5;
        when 512 =>
          lvar_temp_ls_index := 6;
        when others => -- 1024
          lvar_temp_ls_index := 7;
      end case;
      
      Return (lvar_temp_ls_index);
    
    
    end function funct_get_sf_offset_ls_index;
    


                                     
    
    -- Constant Declarations  ----------------------------------------
    
    Constant BASE_CMD_WIDTH         : integer  := 32+C_MCDMA*3; -- Bit Width of Command LS (no address)
    Constant CMD_BTT_WIDTH          : integer  := C_BTT_USED;
    Constant CMD_BTT_LS_INDEX       : integer  := 0;
    Constant CMD_BTT_MS_INDEX       : integer  := CMD_BTT_WIDTH-1;
    Constant CMD_TYPE_INDEX         : integer  := 23+C_MCDMA*3;
    Constant CMD_DRR_INDEX          : integer  := BASE_CMD_WIDTH-1;
    Constant CMD_EOF_INDEX          : integer  := BASE_CMD_WIDTH-2;
    Constant CMD_DSA_WIDTH          : integer  := 6;
    Constant CMD_DSA_LS_INDEX       : integer  := CMD_TYPE_INDEX+1;
    Constant CMD_DSA_MS_INDEX       : integer  := (CMD_DSA_LS_INDEX+CMD_DSA_WIDTH)-1;
    Constant CMD_ADDR_LS_INDEX      : integer  := BASE_CMD_WIDTH;
    Constant CMD_ADDR_MS_INDEX      : integer  := (C_ADDR_WIDTH+BASE_CMD_WIDTH)-1;
    Constant CMD_TAG_WIDTH          : integer  := C_TAG_WIDTH;
    Constant CMD_TAG_LS_INDEX       : integer  := C_ADDR_WIDTH+BASE_CMD_WIDTH;
    Constant CMD_TAG_MS_INDEX       : integer  := (CMD_TAG_LS_INDEX+CMD_TAG_WIDTH)-1;
    
    
    ----------------------------------------------------------------------------------------
    -- Command calculation constants
    
    Constant SIZE_TO_USE            : std_logic_vector(2 downto 0) := func_get_axi_size(C_NATIVE_XFER_WIDTH);
    Constant BYTES_PER_DBEAT        : integer  := C_NATIVE_XFER_WIDTH/8;
    Constant DBEATS_PER_BURST       : integer  := C_MAX_BURST_LEN;
    Constant BYTES_PER_MAX_BURST    : integer  := DBEATS_PER_BURST*BYTES_PER_DBEAT;
    Constant LEN_WIDTH              : integer  := 8;  -- 8 bits fixed 
    Constant DBEAT_RESIDUE_WIDTH    : integer  := funct_get_dbeat_residue_width(BYTES_PER_DBEAT);
    Constant BURST_RESIDUE_WIDTH    : integer  := funct_get_burst_residue_width(C_MAX_BURST_LEN);
    Constant BTT_RESIDUE_WIDTH      : integer  := DBEAT_RESIDUE_WIDTH+BURST_RESIDUE_WIDTH + 1;
    Constant BTT_ZEROS              : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0'); 
    Constant BTT_RESIDUE_0          : unsigned := TO_UNSIGNED( 0, BTT_RESIDUE_WIDTH);
    Constant ADDR_CNTR_WIDTH        : integer  := 16;  -- Addres Counter slice 
    Constant ADDR_CNTR_MAX_VALUE    : unsigned := TO_UNSIGNED((2**ADDR_CNTR_WIDTH)-1, ADDR_CNTR_WIDTH);   
    Constant ADDR_CNTR_ONE          : unsigned := TO_UNSIGNED(1, ADDR_CNTR_WIDTH);   
    Constant MBAA_ADDR_SLICE_WIDTH  : integer  := DBEAT_RESIDUE_WIDTH+BURST_RESIDUE_WIDTH;
    Constant SF_BYTE_XFERED_WIDTH   : integer  := C_SF_XFER_BYTES_WIDTH;
    Constant BTT_UPPER_WIDTH        : integer  := CMD_BTT_WIDTH - BTT_RESIDUE_WIDTH;
    Constant BTT_UPPER_MS_INDEX     : integer  := CMD_BTT_WIDTH-1;
    Constant BTT_UPPER_LS_INDEX     : integer  := BTT_RESIDUE_WIDTH;
    Constant BTT_UPPER_ZERO         : unsigned(BTT_UPPER_WIDTH-1 downto 0) := (others => '0');
    

    Constant SF_OFFSET_LS_INDEX     : integer  := funct_get_sf_offset_ls_index(C_STREAM_DWIDTH);
    Constant SF_OFFSET_MS_INDEX     : integer  := (SF_OFFSET_LS_INDEX + C_STRT_SF_OFFSET_WIDTH)-1;
    
    
               
    -- Type Declarations  --------------------------------------------
    
    type PARENT_SM_STATE_TYPE is (
                P_INIT,
                P_WAIT_FOR_CMD,
                P_LD_FIRST_CMD,
                P_LD_CHILD_CMD,
                P_LD_LAST_CMD ,
                EXTRA, EXTRA2,
                P_ERROR_TRAP
                );
  
    type CHILD_SM_STATE_TYPE is (
                CH_INIT,
                WAIT_FOR_PCMD,
                CH_WAIT_FOR_SF_CMD,
                CH_LD_CHILD_CMD,
                CH_CHK_IF_DONE,
                CH_ERROR_TRAP1,
                CH_ERROR_TRAP2
                );
  
  
  
    
    
    
    -- Signal Declarations  --------------------------------------------
    
    
    -- Parent Command State Machine
    Signal sig_psm_state                     : PARENT_SM_STATE_TYPE := P_INIT;
    Signal sig_psm_state_ns                  : PARENT_SM_STATE_TYPE := P_INIT;
    signal sig_psm_halt_ns                   : std_logic := '0';
    signal sig_psm_halt                      : std_logic := '0';
    signal sig_psm_pop_input_cmd_ns          : std_logic := '0';
    signal sig_psm_pop_input_cmd             : std_logic := '0';
    signal sig_psm_ld_calc1_ns               : std_logic := '0';
    signal sig_psm_ld_calc1                  : std_logic := '0';
    signal sig_psm_ld_calc2_ns               : std_logic := '0';
    signal sig_psm_ld_calc2                  : std_logic := '0';
    signal sig_psm_ld_realigner_reg_ns       : std_logic := '0';
    signal sig_psm_ld_realigner_reg          : std_logic := '0';
    signal sig_psm_ld_chcmd_reg_ns           : std_logic := '0';
    signal sig_psm_ld_chcmd_reg              : std_logic := '0';
    
    -- Child Command State Machine
    Signal sig_csm_state                     : CHILD_SM_STATE_TYPE := CH_INIT;
    Signal sig_csm_state_ns                  : CHILD_SM_STATE_TYPE := CH_INIT;
    signal sig_csm_ld_xfer                   : std_logic := '0';
    signal sig_csm_ld_xfer_ns                : std_logic := '0';
    signal sig_csm_pop_sf_fifo               : std_logic := '0';
    signal sig_csm_pop_sf_fifo_ns            : std_logic := '0';
    signal sig_csm_pop_child_cmd             : std_logic := '0';
    signal sig_csm_pop_child_cmd_ns          : std_logic := '0';
    
    ----------------------------------------------------------------------------------------
    -- Burst Buster signals
    signal sig_last_xfer_valid               : std_logic := '0';
    signal sig_btt_residue_slice             : Unsigned(BTT_RESIDUE_WIDTH-1 downto 0) := (others => '0');

    -- Input command register
    signal sig_push_input_reg                : std_logic := '0';
    signal sig_pop_input_reg                 : std_logic := '0';
    signal sig_xfer_cache_reg               : std_logic_vector (3 downto 0) := "0000";
    signal sig_xfer_user_reg                : std_logic_vector (3 downto 0) := "0000";
    signal sig_input_burst_type_reg          : std_logic := '0';
    signal sig_input_cache_type_reg         : std_logic_vector (3 downto 0) := "0000";
    signal sig_input_user_type_reg          : std_logic_vector (3 downto 0) := "0000";
    signal sig_input_dsa_reg                 : std_logic_vector(CMD_DSA_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_drr_reg                 : std_logic := '0';
    signal sig_input_eof_reg                 : std_logic := '0';
    signal sig_input_tag_reg                 : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_reg_empty               : std_logic := '0';
    signal sig_input_reg_full                : std_logic := '0';
  
    -- Output qualifier Register
    signal sig_push_xfer_reg                 : std_logic := '0';
    signal sig_pop_xfer_reg                  : std_logic := '0';
    signal sig_xfer_addr_reg                 : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_type_reg                 : std_logic := '0';
    signal sig_xfer_len_reg                  : std_logic_vector(LEN_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_tag_reg                  : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_drr_reg                  : std_logic := '0';
    signal sig_xfer_eof_reg                  : std_logic := '0';
    signal sig_xfer_strt_strb_reg            : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb_reg             : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_is_seq_reg               : std_logic := '0';
    signal sig_xfer_cmd_cmplt_reg            : std_logic := '0';
    signal sig_xfer_calc_err_reg             : std_logic := '0';
    signal sig_xfer_reg_empty                : std_logic := '0';
    signal sig_xfer_reg_full                 : std_logic := '0';
    
    -- Address Counter
    signal sig_ld_child_addr_cntr            : std_logic := '0';
    signal sig_incr_child_addr_cntr          : std_logic := '0';
    signal sig_child_addr_cntr_incr          : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_byte_change_minus1            : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
  
    -- misc
    signal sig_xfer_is_seq                   : std_logic := '0';
    signal sig_xfer_len                      : std_logic_vector(LEN_WIDTH-1 downto 0);
    signal sig_xfer_strt_strb                : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_end_strb                 : std_logic_vector(BYTES_PER_DBEAT-1 downto 0) := (others => '0');
    signal sig_xfer_address                  : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_xfer_size                     : std_logic_vector(2 downto 0) := (others => '0');
    signal sig_cmd_addr_slice                : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_btt_slice                 : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_type_slice                : std_logic := '0';
    signal sig_cmd_cache_slice              : std_logic_vector (3 downto 0) := "0000";
    signal sig_cmd_user_slice               : std_logic_vector (3 downto 0) := "0000";
    signal sig_cmd_tag_slice                 : std_logic_vector(CMD_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_dsa_slice                 : std_logic_vector(CMD_DSA_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_drr_slice                 : std_logic := '0';
    signal sig_cmd_eof_slice                 : std_logic := '0';
    signal sig_calc_error_reg                : std_logic := '0';
        
   -- PCC2 stuff 
    signal sig_first_child_xfer              : std_logic := '0';
    signal sig_bytes_to_mbaa                 : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_addr_lsh_rollover       : std_logic := '0';
    signal sig_child_addr_lsh_rollover_reg   : std_logic := '0';
    --signal sig_child_addr_msh_rollover       : std_logic := '0';
    --signal sig_child_addr_msh_rollover_reg   : std_logic := '0';
    signal sig_child_addr_msh_eq_max         : std_logic := '0';
    --signal sig_child_addr_msh_eq_max_reg     : std_logic := '0';
    signal sig_predict_child_addr_lsh_slv    : std_logic_vector(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_predict_child_addr_lsh        : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_addr_cntr_lsh           : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_addr_cntr_lsh_slv       : std_logic_vector(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_addr_cntr_msh           : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_ld_btt_cntr                   : std_logic := '0';
    signal sig_decr_btt_cntr                 : std_logic := '0';
    signal sig_btt_cntr                      : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_is_zero                   : std_logic := '0';
    signal sig_btt_lt_b2mbaa                 : std_logic := '0';
    signal sig_btt_eq_b2mbaa                 : std_logic := '0';
    signal sig_cmd2data_valid                : std_logic := '0';
    signal sig_clr_cmd2data_valid            : std_logic := '0';
    signal sig_cmd2addr_valid                : std_logic := '0';
    signal sig_clr_cmd2addr_valid            : std_logic := '0';
    
    -- Unaligned start address support
    signal sig_adjusted_addr_incr            : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    --signal sig_adjusted_child_addr_incr_reg  : Unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_start_addr_offset_slice       : Unsigned(DBEAT_RESIDUE_WIDTH-1 downto 0) := (others => '0');
    signal sig_mbaa_addr_cntr_slice          : Unsigned(MBAA_ADDR_SLICE_WIDTH-1 downto 0) := (others => '0');
    signal sig_addr_aligned                  : std_logic := '0';
    
    -- S2MM DRE Support
    signal sig_cmd2dre_valid                 : std_logic := '0';
    signal sig_realigner_btt                 : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_realigner_btt2                 : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    
    -- Store and forward signals
    signal sig_ld_realigner_cmd              : std_logic := '0';
    signal sig_sf2pcc_xfer_valid             : std_logic := '0';
    signal sig_pcc2sf_xfer_ready             : std_logic := '0';
    signal sig_sf2pcc_cmd_cmplt              : std_logic := '0';
    signal sig_sf2pcc_xfer_bytes             : std_logic_vector(SF_BYTE_XFERED_WIDTH-1 downto 0) := (others => '0');
    signal sig_sf2pcc_packet_eop             : std_logic := '0';
    signal sig_push_realign_reg              : std_logic := '0';
    signal sig_pop_realign_reg               : std_logic := '0';
    signal sig_realign_reg_empty             : std_logic := '0';
    signal sig_realign_reg_full              : std_logic := '0';
    signal sig_first_realigner_cmd           : std_logic := '0';
    signal sig_realign_tag_reg               : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_realign_src_align_reg         : std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_realign_dest_align_reg        : std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_realign_btt_reg               : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_realign_drr_reg               : std_logic := '0';
    signal sig_realign_eof_reg               : std_logic := '0';
    signal sig_realign_cmd_cmplt_reg         : std_logic := '0';
    signal sig_realign_calc_err_reg          : std_logic := '0';
    signal sig_last_s_f_xfer_ld              : std_logic := '0';
    signal sig_skip_align2mbaa               : std_logic := '0';
    signal sig_skip_align2mbaa_s_h           : std_logic := '0';
    signal sig_dre_dest_align                : std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);
    signal sig_realign_btt_cntr_decr         : Unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_addr_reg                : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_input_addr_reg1                : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_push_child_cmd_reg            : std_logic := '0';
    signal sig_pop_child_cmd_reg             : std_logic := '0';
    signal sig_child_cmd_reg_empty           : std_logic := '0';
    signal sig_child_cmd_reg_full            : std_logic := '0';
    signal sig_child_burst_type_reg          : std_logic := '0';
    signal sig_child_cache_type_reg          : std_logic_vector (3 downto 0) := (others =>'0');
    signal sig_child_user_type_reg          : std_logic_vector (3 downto 0) := (others =>'0');
    signal sig_child_tag_reg                 : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_addr_reg                : std_logic_vector(C_ADDR_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_error_reg               : std_logic := '0';
    signal sig_ld_child_qual_reg             : std_logic := '0';
    signal sig_child_qual_tag_reg            : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
    signal sig_child_qual_burst_type         : std_logic := '0';
    signal sig_child_qual_cache_type         : std_logic_vector (3 downto 0)  := (others => '0');
    signal sig_child_qual_user_type         : std_logic_vector (3 downto 0)  := (others => '0');
    signal sig_child_qual_first_of_2         : std_logic := '0';
    signal sig_child_qual_error_reg          : std_logic := '0';
    signal sig_needed_2_realign_cmds         : std_logic := '0';
    signal sig_btt_upper_slice               : unsigned(BTT_UPPER_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_upper_eq_0                : std_logic := '0';
    
    signal sig_mmap_reset_reg                : std_logic := '0';
    
    signal sig_realign_strt_offset_reg       : std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
    signal sig_realign_strt_offset           : std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
  
      Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

  Attribute KEEP of sig_input_addr_reg1   : signal is "TRUE"; -- definition
  Attribute KEEP of sig_input_addr_reg : signal is "TRUE"; -- definition

  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_input_addr_reg1   : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_input_addr_reg : signal is "no";
 
  
  begin --(architecture implementation)
     
    
    -- sf Interface signals
    pcc2sf_xfer_ready        <=  sig_pcc2sf_xfer_ready  ;
    sig_sf2pcc_xfer_valid    <=  sf2pcc_xfer_valid      ;
    sig_sf2pcc_cmd_cmplt     <=  sf2pcc_cmd_cmplt       ;
    sig_sf2pcc_xfer_bytes    <=  sf2pcc_xfer_bytes      ;
    sig_sf2pcc_packet_eop    <=  sf2pcc_packet_eop      ;
    
    
    -- Assign calculation error output 
    calc_error               <= sig_calc_error_reg;
   
    -- Assign the ready output to the Command FIFO 
    mst2cmd_cmd_ready        <= not(sig_psm_halt)    and 
                                sig_input_reg_empty;
    
    -- Assign the Address Channel Controller Qualifiers
    mstr2addr_tag            <=  sig_xfer_tag_reg  ; 
    mstr2addr_addr           <=  sig_xfer_addr_reg ; 
    mstr2addr_len            <=  sig_xfer_len_reg  ; 
    mstr2addr_size           <=  sig_xfer_size     ;
    mstr2addr_burst          <=  '0' & sig_xfer_type_reg; -- only fixed or increment supported
    mstr2addr_cache          <=  sig_xfer_cache_reg; -- only fixed or increment supported
    mstr2addr_user           <=  sig_xfer_user_reg; -- only fixed or increment supported
    mstr2addr_cmd_valid      <=  sig_cmd2addr_valid     ;
    mstr2addr_calc_error     <=  sig_xfer_calc_err_reg  ;
    mstr2addr_cmd_cmplt      <=  sig_xfer_cmd_cmplt_reg ;
    
    -- Assign the Data Channel Controller Qualifiers
    mstr2data_tag            <= sig_xfer_tag_reg      ; 
    mstr2data_saddr_lsb      <= sig_xfer_addr_reg(C_SEL_ADDR_WIDTH-1 downto 0);
    mstr2data_len            <= sig_xfer_len_reg      ;
    mstr2data_strt_strb      <= sig_xfer_strt_strb_reg;
    mstr2data_last_strb      <= sig_xfer_end_strb_reg ;
    mstr2data_drr            <= sig_xfer_drr_reg      ;  
    mstr2data_eof            <= sig_xfer_eof_reg      ;  
    mstr2data_sequential     <= sig_xfer_is_seq_reg   ;  
    mstr2data_cmd_cmplt      <= sig_xfer_cmd_cmplt_reg;  
    mstr2data_cmd_valid      <= sig_cmd2data_valid    ;
    
    
    mstr2data_calc_error     <= sig_xfer_calc_err_reg ;   
    
    
    -- Assign the S2MM Realigner Qualifiers
    mstr2dre_cmd_valid       <= sig_cmd2dre_valid         ;   -- Used by S2MM DRE
    
    mstr2dre_tag             <= sig_realign_tag_reg       ;   -- Used by S2MM DRE
    mstr2dre_dre_src_align   <= sig_realign_src_align_reg ;   -- Used by S2MM DRE
    mstr2dre_dre_dest_align  <= sig_realign_dest_align_reg;   -- Used by S2MM DRE
    mstr2dre_btt             <= sig_realign_btt_reg       ;   -- Used by S2MM DRE
    mstr2dre_drr             <= sig_realign_drr_reg       ;   -- Used by S2MM DRE
    mstr2dre_eof             <= sig_realign_eof_reg       ;   -- Used by S2MM DRE
    mstr2dre_cmd_cmplt       <= sig_realign_cmd_cmplt_reg ;   -- Used by S2MM DRE
    mstr2dre_calc_error      <= sig_realign_calc_err_reg  ;   -- Used by S2MM DRE
    
    
    -- Store and Forward Support Start Offset (used by Packer/Unpacker logic)
    mstr2dre_strt_offset     <= sig_realign_strt_offset_reg;  
    
    

   
   -- Start internal logic.
   
    sig_cmd_user_slice       <= cache2mstr_command(7 downto 4);
    sig_cmd_cache_slice        <= cache2mstr_command(3 downto 0);
                
    sig_cmd_type_slice        <=  cmd2mstr_command(CMD_TYPE_INDEX);   -- always incrementing (per Interface_X guidelines)
    sig_cmd_addr_slice        <=  cmd2mstr_command(CMD_ADDR_MS_INDEX downto CMD_ADDR_LS_INDEX);  
    sig_cmd_tag_slice         <=  cmd2mstr_command(CMD_TAG_MS_INDEX downto CMD_TAG_LS_INDEX);
    sig_cmd_btt_slice         <=  cmd2mstr_command(CMD_BTT_MS_INDEX downto CMD_BTT_LS_INDEX);
    
    sig_cmd_dsa_slice         <=  cmd2mstr_command(CMD_DSA_MS_INDEX downto CMD_DSA_LS_INDEX);
    sig_cmd_drr_slice         <=  cmd2mstr_command(CMD_DRR_INDEX);
    sig_cmd_eof_slice         <=  cmd2mstr_command(CMD_EOF_INDEX);
     
     
     
    -- Check for a zero length BTT (error condition) 
    sig_btt_is_zero  <= '1'
      when  (sig_cmd_btt_slice = BTT_ZEROS)
      Else '0';
        
    sig_xfer_size <= SIZE_TO_USE;
    
    
    
    
    
    -----------------------------------------------------------------
    -- Reset fanout control
    -----------------------------------------------------------------
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_RESET_REG
    --
    -- Process Description:
    --  Registers the input reset to reduce fanout. This module
    --  has a high number of register bits to reset.
    --
    -------------------------------------------------------------
    IMP_RESET_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
        
          sig_mmap_reset_reg <= mmap_reset;
        
        end if;       
      end process IMP_RESET_REG; 

    
    
    
    
    
    
    

    -----------------------------------------------------------------
    -- Input Parent command Register design
    
    sig_push_input_reg  <=  not(sig_psm_halt)    and
                            cmd2mstr_cmd_valid   and                          
                            sig_input_reg_empty  and 
                            not(sig_calc_error_reg);                                
     
    sig_pop_input_reg   <= sig_psm_pop_input_cmd;
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_INPUT_QUAL
    --
    -- Process Description:
    --  Implements the input command qualifier holding register
    -- used by the parent Command calculation.
    -------------------------------------------------------------

HIGH_STREAM_WIDTH_REG_GEN : if (C_STREAM_DWIDTH >= 128) generate     
begin     

    REG_INPUT_DUP_QUAL : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg  = '1' or
                sig_pop_input_reg   = '1') then
            
              sig_input_addr_reg1                <=  (others => '0');
              
            elsif (sig_push_input_reg = '1') then
              
              sig_input_addr_reg1                <=  sig_cmd_addr_slice;
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process REG_INPUT_DUP_QUAL; 
     
end generate HIGH_STREAM_WIDTH_REG_GEN;


    REG_INPUT_QUAL : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg  = '1' or
                sig_pop_input_reg   = '1') then
            
              sig_input_cache_type_reg          <=  (others => '0');
              sig_input_user_type_reg           <=  (others => '0');
              sig_input_addr_reg                <=  (others => '0');
              sig_input_burst_type_reg          <=  '0';
              sig_input_tag_reg                 <=  (others => '0');
              sig_input_dsa_reg                 <=  (others => '0');
              sig_input_drr_reg                 <=  '0';
              sig_input_eof_reg                 <=  '0';
              
              sig_input_reg_empty               <=  '1';
              sig_input_reg_full                <=  '0';
            
            elsif (sig_push_input_reg = '1') then
              
              sig_input_cache_type_reg          <=  sig_cmd_cache_slice;
              sig_input_user_type_reg           <=  sig_cmd_user_slice;
              sig_input_addr_reg                <=  sig_cmd_addr_slice;
              sig_input_burst_type_reg          <=  sig_cmd_type_slice;
              sig_input_tag_reg                 <=  sig_cmd_tag_slice;
              sig_input_dsa_reg                 <=  sig_cmd_dsa_slice;
              sig_input_drr_reg                 <=  sig_cmd_drr_slice;
              sig_input_eof_reg                 <=  sig_cmd_eof_slice;
              
              sig_input_reg_empty               <=  '0';
              sig_input_reg_full                <=  '1';
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process REG_INPUT_QUAL; 
   
    
    
    
    


   
    -------------------------------------------------------------------------
    -- SFCC Parent State machine Logic
    
   
   
   
   
    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: PARENT_SM_COMBINATIONAL
    --
    -- Process Description:
    -- SFCC Parent State Machine combinational implementation,
    -- This state machine controls the loading of commands into
    -- the Realigner block. There is a maximum of two cmds per  
    -- DataMover input command to be loaded in the realigner.
    --
    -------------------------------------------------------------
    PARENT_SM_COMBINATIONAL : process (sig_psm_state           ,
                                       sig_push_input_reg      ,
                                       sig_calc_error_reg      ,
                                       sig_first_realigner_cmd ,
                                       sig_skip_align2mbaa     ,
                                       sig_skip_align2mbaa_s_h ,
                                       sig_realign_reg_empty   ,
                                       sig_child_cmd_reg_full)  
       begin
    
         -- SM Defaults  
         sig_psm_state_ns                 <=  P_INIT;
         sig_psm_halt_ns                  <=  '0'   ; 
         sig_psm_pop_input_cmd_ns         <=  '0'   ;
         sig_psm_ld_calc1_ns              <=  '0'   ;
         sig_psm_ld_calc2_ns              <=  '0'   ;
         sig_psm_ld_realigner_reg_ns      <=  '0'   ;
         sig_psm_ld_chcmd_reg_ns          <=  '0'   ;
         
         
         
     
         case sig_psm_state is
           
           --------------------------------------------
           when P_INIT => 
             
             sig_psm_state_ns  <=  P_WAIT_FOR_CMD;
             sig_psm_halt_ns   <=  '1'; 
             
           --------------------------------------------
           when P_WAIT_FOR_CMD => 
             
             If (sig_push_input_reg = '1') Then
    
               sig_psm_state_ns            <=  P_LD_FIRST_CMD;
             
             else
             
               sig_psm_state_ns <=  P_WAIT_FOR_CMD;
             
             End if;
             

           
           --------------------------------------------
           when P_LD_FIRST_CMD => -- (load first Realigner Command)
           
             If  (sig_realign_reg_empty = '1') Then
    
               sig_psm_state_ns            <=  P_LD_CHILD_CMD; --EXTRA;
               sig_psm_ld_realigner_reg_ns <= '1';
               sig_psm_ld_calc1_ns         <= '1';
             
             else
             
               sig_psm_state_ns <=  P_LD_FIRST_CMD;
             
             End if;
          
   --       when EXTRA =>
   --            sig_psm_state_ns            <=  P_LD_CHILD_CMD;
   --            sig_psm_ld_realigner_reg_ns <= '1';
   --            sig_psm_ld_calc1_ns         <= '1';
 
          
          --------------------------------------------
           when P_LD_CHILD_CMD => -- (load Child Command Register)
           
             If  (sig_child_cmd_reg_full = '1') Then
             
               sig_psm_state_ns         <=  P_LD_CHILD_CMD;
             
             
             Elsif (sig_calc_error_reg = '1') Then
    
               sig_psm_state_ns                 <=  P_ERROR_TRAP;
               sig_psm_ld_chcmd_reg_ns          <= '1' ;
             
             
             Elsif ((sig_skip_align2mbaa    = '1'  and
                    sig_first_realigner_cmd = '1') or
                    sig_skip_align2mbaa_s_h = '1') Then
             
               sig_psm_state_ns         <=  P_WAIT_FOR_CMD;
               sig_psm_ld_chcmd_reg_ns  <= '1' ;
               sig_psm_pop_input_cmd_ns <= '1' ;
             
             else
             
               sig_psm_state_ns         <=  P_LD_LAST_CMD;
               sig_psm_ld_chcmd_reg_ns  <= '1';
             
             End if;
           
           
           --------------------------------------------
           when P_LD_LAST_CMD => -- (load second Realigner Command if needed)
           
             If (sig_realign_reg_empty = '1') Then
             
               sig_psm_state_ns            <=  P_WAIT_FOR_CMD; --EXTRA2;
               sig_psm_ld_realigner_reg_ns <= '1' ;
               sig_psm_ld_calc2_ns         <= '1' ;
               sig_psm_pop_input_cmd_ns    <= '1' ;
             
             else
             
               sig_psm_state_ns            <=  P_LD_LAST_CMD;
             
             End if;
           
--           when EXTRA2 =>
 
--               sig_psm_state_ns            <=  P_WAIT_FOR_CMD;
--               sig_psm_ld_realigner_reg_ns <= '1' ;
--               sig_psm_ld_calc2_ns         <= '1' ;
--               sig_psm_pop_input_cmd_ns    <= '1' ;
           --------------------------------------------
           when P_ERROR_TRAP =>
           
             sig_psm_state_ns <=  P_ERROR_TRAP;
             sig_psm_halt_ns  <=  '1'; 
           
           --------------------------------------------
           when others =>
           
             sig_psm_state_ns <=  P_INIT;
             
         end case;
         

    
       end process PARENT_SM_COMBINATIONAL; 
    
      
  
     
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: SFCC_SM_REGISTERED
    --
    -- Process Description:
    -- SFCC State Machine registered implementation
    --
    -------------------------------------------------------------
    SFCC_SM_REGISTERED : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
            
              sig_psm_state                     <= P_INIT;
              sig_psm_halt                      <= '1' ; 
              sig_psm_pop_input_cmd             <= '0' ;
              sig_psm_ld_calc1                  <= '0' ;
              sig_psm_ld_calc2                  <= '0' ;
              sig_psm_ld_realigner_reg          <= '0' ;
              sig_psm_ld_chcmd_reg              <= '0' ;
            
            else
            
              sig_psm_state                     <=  sig_psm_state_ns                ;
              sig_psm_halt                      <=  sig_psm_halt_ns                 ; 
              sig_psm_pop_input_cmd             <=  sig_psm_pop_input_cmd_ns        ;
              sig_psm_ld_calc1                  <=  sig_psm_ld_calc1_ns             ;
              sig_psm_ld_calc2                  <=  sig_psm_ld_calc2_ns             ;
              sig_psm_ld_realigner_reg          <=  sig_psm_ld_realigner_reg_ns     ;
              sig_psm_ld_chcmd_reg              <=  sig_psm_ld_chcmd_reg_ns         ;
            
            end if; 
         end if;       
       end process SFCC_SM_REGISTERED; 
        
     
     
     
 
 
 
   
   
    
       
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: IMP_FIRST_REALIGNER_CMD
     --
     -- Process Description:
     --  Implements the register flop signalling the first realigner 
     -- transfer flag. The Realigner is loaded with 1 command if 
     -- the starting address is aligned to the mbaa, else two
     -- commands are required.
     --
     -------------------------------------------------------------
     IMP_FIRST_REALIGNER_CMD : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg        = '1' or
                 (sig_psm_ld_realigner_reg = '1' and
                  sig_push_input_reg       = '0')) then

               sig_first_realigner_cmd <= '0';
               
             elsif (sig_push_input_reg = '1') then

               sig_first_realigner_cmd <= '1';
               
             else
               null;  -- hold current state
             end if; 
          end if;       
        end process IMP_FIRST_REALIGNER_CMD; 
    






    
    
   --------------------------------------------------------------
   -- Parent BTT Counter Logic (for Realigner cmd calc)
   
   
   sig_ld_btt_cntr   <= sig_push_input_reg;
   
   sig_decr_btt_cntr <= sig_push_realign_reg;
   
                                               
   -- Rip the BTT residue field from the BTT counter value
   sig_btt_residue_slice   <=  sig_btt_cntr(BTT_RESIDUE_WIDTH-1 downto 0);
      
      
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_BTT_CNTR
   --
   -- Process Description:
   -- Bytes to transfer counter implementation. This is only used
   -- to set up the Realigner commands.
   --
   -------------------------------------------------------------
   IMP_BTT_CNTR : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then
             
             sig_btt_cntr <= (others => '0');
           
           elsif (sig_ld_btt_cntr = '1') then
             
             sig_btt_cntr <= UNSIGNED(sig_cmd_btt_slice);
           
           Elsif (sig_decr_btt_cntr = '1') Then
             
             sig_btt_cntr <= sig_btt_cntr-UNSIGNED(sig_realigner_btt2);
           
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_BTT_CNTR; 
  
 
   IMP_BTT_CNTR2 : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg = '1') then
             
             sig_realigner_btt2 <= (others => '0');
           
           Else
             
             sig_realigner_btt2 <= sig_realigner_btt;
           
           end if; 
        end if;       
      end process IMP_BTT_CNTR2; 
       
 
 
 
  
   
    -- Convert to logic vector for the S2MM DRE use
    -- The DRE will only use this value prior to the first 
    -- decrement of the BTT Counter. Using this saves a separate
    -- BTT register.
    --     sig_realigner_btt <=  STD_LOGIC_VECTOR(RESIZE(sig_child_addr_cntr_incr, CMD_BTT_WIDTH))
    sig_realigner_btt <=  STD_LOGIC_VECTOR(sig_realign_btt_cntr_decr)
      when (sig_first_realigner_cmd = '1' and 
            sig_skip_align2mbaa     = '0')
      else STD_LOGIC_VECTOR(sig_btt_cntr);
 
 
 
    
    
     
     ----------------- Parent Address Calculations ------------------------------
HIGH_STREAM_WIDTH : if (C_STREAM_DWIDTH >= 128) generate     
begin     
    sig_mbaa_addr_cntr_slice <= UNSIGNED(sig_input_addr_reg1(MBAA_ADDR_SLICE_WIDTH-1 downto 0)); 

end generate HIGH_STREAM_WIDTH;    


LOW_STREAM_WIDTH : if (C_STREAM_DWIDTH < 128) generate     
begin     
    sig_mbaa_addr_cntr_slice <= UNSIGNED(sig_input_addr_reg(MBAA_ADDR_SLICE_WIDTH-1 downto 0)); 

end generate LOW_STREAM_WIDTH;    
    
    -- Check to see if the starting address is already aligned to Max Burst byte aligned
    -- boubdary
    sig_addr_aligned <= '1'
      when (sig_mbaa_addr_cntr_slice = BTT_RESIDUE_0)
      Else '0';
    
    
    
    -- Calculate the distance in bytes from the starting address to the next max
    -- burst aligned address boundary
    sig_bytes_to_mbaa <= TO_UNSIGNED(BYTES_PER_MAX_BURST, ADDR_CNTR_WIDTH) 
    When (sig_addr_aligned = '1')
    else TO_UNSIGNED(BYTES_PER_MAX_BURST, ADDR_CNTR_WIDTH) -
                     RESIZE(sig_mbaa_addr_cntr_slice,ADDR_CNTR_WIDTH);
    
    
    
    
    sig_btt_upper_slice <= sig_btt_cntr(BTT_UPPER_MS_INDEX downto BTT_UPPER_LS_INDEX);
    
    
 
    sig_btt_upper_eq_0 <= '1'
      When (sig_btt_upper_slice = BTT_UPPER_ZERO) or
           (BTT_RESIDUE_WIDTH = CMD_BTT_WIDTH)
      Else '0';
 
 
    
    sig_btt_lt_b2mbaa <= '1'
      when ((RESIZE(sig_btt_residue_slice, ADDR_CNTR_WIDTH) < sig_bytes_to_mbaa) and
            (sig_first_realigner_cmd = '1') and
            (sig_btt_upper_eq_0      = '1')) 
      Else '0';
    


    
    sig_btt_eq_b2mbaa <= '1'
      when ((RESIZE(sig_btt_residue_slice, ADDR_CNTR_WIDTH) = sig_bytes_to_mbaa) and
            (sig_first_realigner_cmd = '1') and
            (sig_btt_upper_eq_0      = '1'))
      Else '0';


    
    
    
    -- This signal used to flag if the SFCC can skip the initial split and 
    -- align process to get subsequent burst starting addresses aligned to 
    -- the Max burst aligned address boundary (needed to support the 4k byte
    -- boundary crossing guard function).
    sig_skip_align2mbaa <= '1'
      when (sig_addr_aligned        = '1' or
            sig_btt_lt_b2mbaa       = '1' or
            sig_btt_eq_b2mbaa       = '1' or
            sig_calc_error_reg      = '1')
      Else '0';
    
    
   
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: SKIP_ALIGN_FLOP
    --
    -- Process Description:
    --  Just a FLOP to sample and hold the flag indicating that a 
    -- aligment to a Max Burst align address is not required. This
    -- is used by the parent command state machine.
    --
    -------------------------------------------------------------
    SKIP_ALIGN_FLOP : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg       = '1' or
               (sig_psm_ld_chcmd_reg    = '1' and
               sig_psm_ld_realigner_reg = '0')) then
    
             sig_skip_align2mbaa_s_h <= '0';
    
           elsif (sig_psm_ld_realigner_reg = '1') then
    
             sig_skip_align2mbaa_s_h <= sig_skip_align2mbaa;
    
           else
    
             null;  -- Hold current state
    
           end if; 
        end if;       
      end process SKIP_ALIGN_FLOP; 
   
   
   
   
    
                                        
    
    -- Select the Realigner BTT counter decrement value to use
    sig_realign_btt_cntr_decr <= RESIZE(sig_btt_residue_slice, CMD_BTT_WIDTH)
      When (sig_first_realigner_cmd = '1' and
           (sig_btt_lt_b2mbaa       = '1' or
            sig_btt_eq_b2mbaa       = '1'))
      else RESIZE(sig_bytes_to_mbaa, CMD_BTT_WIDTH)
      when (sig_first_realigner_cmd = '1' and 
            sig_skip_align2mbaa     = '0')
      else sig_btt_cntr;  
                                                                

  
  
 

 
 
     
 
 
 
     -----------------------------------------------------------------
     -- Realigner Qualifier Register design
     
     
     sig_dre_dest_align <= sig_input_addr_reg(C_DRE_ALIGN_WIDTH-1 downto 0)
       When (sig_psm_ld_calc1 = '1') -- Specified starting addr offset
       Else (others => '0');         -- Second command is always aligned to addr offset 0
     
     
     
     sig_realign_strt_offset <= sig_input_addr_reg(SF_OFFSET_MS_INDEX downto SF_OFFSET_LS_INDEX)
       When (sig_psm_ld_calc1 = '1') -- Specified starting addr offset used for IBTT Upsizer
       Else (others => '0');         -- Second command is always aligned to addr offset 0
     
     
     sig_cmd2dre_valid      <= sig_realign_reg_full;  
     
     sig_push_realign_reg   <= sig_psm_ld_realigner_reg;    -- a clock of latency
    
     sig_pop_realign_reg    <= sig_cmd2dre_valid  and 
                               dre2mstr_cmd_ready;       -- Realigner taking xfer
    


     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: REG_REALIGNER_QUAL
     --
     -- Process Description:
     --  Implements the output Realigner qualifier holding register 
     -- for the Realigner Block used with the Store and Forward
     -- module.
     --
     -------------------------------------------------------------
     REG_REALIGNER_QUAL : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg   = '1' or
              (sig_pop_realign_reg  = '1' and
               sig_push_realign_reg = '0')) then
           
             sig_realign_tag_reg         <=  (others => '0');
             sig_realign_src_align_reg   <=  (others => '0');
             sig_realign_dest_align_reg  <=  (others => '0');
             sig_realign_btt_reg         <=  (others => '0');
             sig_realign_drr_reg         <=  '0';
             sig_realign_eof_reg         <=  '0';
             sig_realign_cmd_cmplt_reg   <=  '0';
             sig_realign_calc_err_reg    <=  '0';
             sig_realign_strt_offset_reg <=  (others => '0');
                                                 
             
             sig_realign_reg_empty       <=  '1';
             sig_realign_reg_full        <=  '0';
           
           elsif (sig_push_realign_reg = '1') then
             
             sig_realign_tag_reg         <=  sig_input_tag_reg        ;
             sig_realign_src_align_reg   <=  sig_input_dsa_reg(C_DRE_ALIGN_WIDTH-1 downto 0);
             sig_realign_dest_align_reg  <=  sig_dre_dest_align       ;
             sig_realign_btt_reg         <=  sig_realigner_btt2        ;
             sig_realign_drr_reg         <=  sig_input_drr_reg and
                                             sig_first_realigner_cmd  ;
             
             sig_realign_eof_reg         <=  (sig_input_eof_reg         and 
                                              sig_skip_align2mbaa       and 
                                              sig_first_realigner_cmd)  or
                                             (sig_input_eof_reg         and
                                              not(sig_first_realigner_cmd)); 
             
             sig_realign_cmd_cmplt_reg   <=  (sig_skip_align2mbaa          and 
                                              sig_first_realigner_cmd)     or
                                              not(sig_first_realigner_cmd) or
                                              sig_calc_error_reg       ;
             sig_realign_calc_err_reg    <=  sig_calc_error_reg        ;
             
             sig_realign_strt_offset_reg <=  sig_realign_strt_offset;
   
             
             sig_realign_reg_empty       <=  '0';
             sig_realign_reg_full        <=  '1';
                        
           else
             null; -- Hold current State
           end if; 
         end if;       
       end process REG_REALIGNER_QUAL; 
   
     
     


 
 
  ----------------------------------------------------------------------
  -- Parent Calculation Error Logic




    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_CALC_ERROR_FLOP
    --
    -- Process Description:
    --   Implements the flop for the Calc Error flag, Once set,
    -- the flag cannot be cleared until a reset is issued.
    --
    -------------------------------------------------------------
    IMP_CALC_ERROR_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
              sig_calc_error_reg <= '0';
            elsif (sig_push_input_reg = '1' and
                   sig_calc_error_reg = '0') then
              sig_calc_error_reg <= sig_btt_is_zero;
            else
              Null;  -- hold the current state
            end if; 
         end if;       
       end process IMP_CALC_ERROR_FLOP; 
    
    
    








   
    -----------------------------------------------------------------
    -- Child transfer command register design
   
    
    sig_push_child_cmd_reg  <=  sig_psm_ld_chcmd_reg;                                
     
    sig_pop_child_cmd_reg   <= sig_csm_pop_child_cmd;
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CHILD_CMD_REG
    --
    -- Process Description:
    --  Implements the Child command holding register
    --  loaded by the Parent State Machine. This is a
    --  1 deep fifo-like command queue.
    -------------------------------------------------------------
    CHILD_CMD_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg    = '1' or
                sig_pop_child_cmd_reg = '1') then
            
              sig_child_tag_reg                 <=  (others => '0');
              sig_child_addr_reg                <=  (others => '0');
              sig_child_burst_type_reg          <=  '0';
              sig_child_cache_type_reg          <=  (others => '0');
              sig_child_user_type_reg          <=  (others => '0');
              sig_needed_2_realign_cmds         <=  '0';
              sig_child_error_reg               <=  '0';
              
              sig_child_cmd_reg_empty           <=  '1';
              sig_child_cmd_reg_full            <=  '0';
            
            elsif (sig_push_child_cmd_reg = '1') then
              
              sig_child_tag_reg                 <=  sig_input_tag_reg ;
              sig_child_addr_reg                <=  sig_input_addr_reg;
              sig_child_burst_type_reg          <=  sig_input_burst_type_reg;
              sig_child_cache_type_reg          <=  sig_input_cache_type_reg;
              sig_child_user_type_reg          <=  sig_input_user_type_reg;
              sig_needed_2_realign_cmds         <=  not(sig_skip_align2mbaa_s_h);
              sig_child_error_reg               <=  sig_calc_error_reg;
              
              sig_child_cmd_reg_empty           <=  '0';
              sig_child_cmd_reg_full            <=  '1';
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process CHILD_CMD_REG; 
   
    
    
 
 
 
    sig_ld_child_qual_reg  <= sig_pop_child_cmd_reg;
 
 
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CHILD_QUAL_REG
    --
    -- Process Description:
    --  Implements the child intermediate command qualifier holding 
    -- register. 
    --  
    -------------------------------------------------------------
    CHILD_QUAL_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
            
              sig_child_qual_tag_reg      <=  (others => '0');
              sig_child_qual_burst_type   <=  '0';
              sig_child_qual_cache_type   <=  (others => '0');
              sig_child_qual_user_type   <=  (others => '0');
              sig_child_qual_error_reg    <= '0';
              
            
            elsif (sig_ld_child_qual_reg = '1') then
              
              sig_child_qual_tag_reg      <=  sig_child_tag_reg        ;
              sig_child_qual_burst_type   <=  sig_child_burst_type_reg ;
              sig_child_qual_cache_type   <=  sig_child_cache_type_reg ;
              sig_child_qual_user_type   <=  sig_child_user_type_reg ;
              sig_child_qual_error_reg    <=  sig_child_error_reg;
              
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process CHILD_QUAL_REG; 
   
    
    
    
    
    
    
    
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CHILD_QUAL_DBL_CMD_REG
    --
    -- Process Description:
    --  Implements the child intermediate command qualifier holding 
    -- register. 
    --  
    -------------------------------------------------------------
    CHILD_QUAL_DBL_CMD_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg   = '1' or
               (sig_csm_pop_sf_fifo  = '1' and
                sig_sf2pcc_cmd_cmplt = '1')) then
            
              sig_child_qual_first_of_2  <=  '0';
              
            
            elsif (sig_ld_child_qual_reg = '1') then
              
              sig_child_qual_first_of_2  <=  sig_needed_2_realign_cmds;
              
            
            else
              null; -- Hold current State
            end if; 
         end if;       
       end process CHILD_QUAL_DBL_CMD_REG; 
   
    
    
 
 
 
    ------------------------------------------------------------------
    -- Data and Address Controller Transfer Register Load Enable logic
   
    sig_last_s_f_xfer_ld  <= sig_push_xfer_reg and 
                             sig_sf2pcc_cmd_cmplt;
    
    
 
 
 
 
    -------------------------------------------------------------------------
    -- SFCC Child State machine Logic
    
   
   
   
   
   
    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CHILD_STATE_MACHINE_COMB
    --
    -- Process Description:
    --  Implements the combinational portion of the Child Command 
    -- processing state machine.
    --
    -------------------------------------------------------------
    CHILD_STATE_MACHINE_COMB : process (sig_csm_state             ,
                                        sig_child_cmd_reg_full    ,
                                        sig_sf2pcc_xfer_valid     ,
                                        sig_child_error_reg       ,
                                        sig_cmd2data_valid        ,
                                        sig_cmd2addr_valid        ,
                                        sig_child_qual_first_of_2 ,
                                        sig_sf2pcc_cmd_cmplt      ,
                                        sig_sf2pcc_packet_eop)
       begin
    
         
         -- Set defaults
         sig_csm_state_ns          <= CH_INIT;
         sig_csm_ld_xfer_ns        <= '0';
         sig_csm_pop_sf_fifo_ns    <= '0';
         sig_csm_pop_child_cmd_ns  <= '0';
         
         

         case sig_csm_state is
           -----------------------------------------------------
           when CH_INIT =>
           
             sig_csm_state_ns <= WAIT_FOR_PCMD;
           
           
           -----------------------------------------------------
           when WAIT_FOR_PCMD =>
           
             If (sig_child_error_reg    = '1' and
                 sig_child_cmd_reg_full = '1') Then
    
               sig_csm_state_ns          <= CH_ERROR_TRAP1;
               sig_csm_pop_child_cmd_ns  <= '1';
             
             
             elsif (sig_child_cmd_reg_full = '1') Then
    
               sig_csm_state_ns          <= CH_WAIT_FOR_SF_CMD;
               sig_csm_pop_child_cmd_ns  <= '1';
             
             
             Else 
             
               sig_csm_state_ns <= WAIT_FOR_PCMD;
             
             End if;
           
                     
           -----------------------------------------------------
           when CH_WAIT_FOR_SF_CMD =>
           
             If (sig_sf2pcc_xfer_valid = '1') Then
    
               sig_csm_state_ns       <= CH_LD_CHILD_CMD;
             
             Else 
             
               sig_csm_state_ns <= CH_WAIT_FOR_SF_CMD;
             
             End if;
           
           
           
           -----------------------------------------------------
           when CH_LD_CHILD_CMD =>
           
             If (sig_cmd2data_valid    = '0' and
                 sig_cmd2addr_valid    = '0') Then
    
               sig_csm_state_ns       <= CH_CHK_IF_DONE;
               sig_csm_ld_xfer_ns     <= '1';
               sig_csm_pop_sf_fifo_ns <= '1';
             
             Else 
             
               sig_csm_state_ns <= CH_LD_CHILD_CMD;
             
             End if;
           
           
           
           -----------------------------------------------------
           when CH_CHK_IF_DONE =>
              
             If (sig_sf2pcc_cmd_cmplt      = '1' and
                (sig_child_qual_first_of_2 = '0' or
                 sig_sf2pcc_packet_eop     = '1')) Then  -- done
                
                sig_csm_state_ns          <= WAIT_FOR_PCMD;
                
              else  -- more SF child commands coming from the parent command
              
                sig_csm_state_ns <= CH_WAIT_FOR_SF_CMD;
              
              end if;
              
     
           
           -----------------------------------------------------
           when CH_ERROR_TRAP1 =>
           
             
             If (sig_cmd2data_valid    = '0' and
                 sig_cmd2addr_valid    = '0') Then
    
               sig_csm_state_ns          <= CH_ERROR_TRAP2;
               sig_csm_ld_xfer_ns        <= '1';
             
             Else 

               sig_csm_state_ns       <= CH_ERROR_TRAP1;
             
             
             End if;
              
   
     
           
           -----------------------------------------------------
           when CH_ERROR_TRAP2 =>
           
             sig_csm_state_ns       <= CH_ERROR_TRAP2;
              
     
           
           -----------------------------------------------------
           when others =>
           
             sig_csm_state_ns       <= CH_INIT;
           
           
         end case;
         


    
       end process CHILD_STATE_MACHINE_COMB; 
    
   
   
   
   
   
   
   
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CHILD_SM_REGISTERED
    --
    -- Process Description:
    -- Child State Machine registered implementation
    --
    -------------------------------------------------------------
    CHILD_SM_REGISTERED : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
            
              sig_csm_state              <= CH_INIT;
              sig_csm_ld_xfer            <= '0'    ;
              sig_csm_pop_sf_fifo        <= '0'    ;
              sig_csm_pop_child_cmd      <= '0'    ;
              
            else
            
              sig_csm_state              <=  sig_csm_state_ns          ;
              sig_csm_ld_xfer            <=  sig_csm_ld_xfer_ns        ;
              sig_csm_pop_sf_fifo        <=  sig_csm_pop_sf_fifo_ns    ;
              sig_csm_pop_child_cmd      <=  sig_csm_pop_child_cmd_ns  ;
            
            end if; 
         end if;       
       end process CHILD_SM_REGISTERED; 
        
     
     
     
 
 
 
 
 
 
 
 
 
 
 
 
 
    ----------------------------------------------------------------------------------------------------
    ----------------------------------------------------------------------------------------------------
    --
    -- General Address Counter Logic (applies to any address width of 32 or greater
    -- The address counter is divided into 2 16-bit segements for 32-bit address support. As the
    -- address gets wider, up to 2 more segements will be added via IfGens to provide for 64-bit 
    -- addressing.
    --
    ----------------------------------------------------------------------------------------------------
    


    --------------------------------------------------------------------------
    -- Address Counter logic
    
    sig_ld_child_addr_cntr   <= sig_ld_child_qual_reg;
    
    -- don't increment address cntr if type is '0' (non-incrementing)
    sig_incr_child_addr_cntr <= sig_push_xfer_reg and 
                                sig_child_qual_burst_type;  
    
    
    

    -- Unaligned address compensation
    -- Add the number of starting address offset byte positions to the
    -- final byte change value needed to calculate the AXI LEN field

    sig_start_addr_offset_slice <=  sig_child_addr_cntr_lsh(DBEAT_RESIDUE_WIDTH-1 downto 0);

    sig_adjusted_addr_incr      <=  RESIZE(UNSIGNED(sig_sf2pcc_xfer_bytes), ADDR_CNTR_WIDTH) +
                                    RESIZE(sig_start_addr_offset_slice, ADDR_CNTR_WIDTH);


    
    
    -- Select the address counter increment value to use
    sig_child_addr_cntr_incr <= RESIZE(UNSIGNED(sig_sf2pcc_xfer_bytes), ADDR_CNTR_WIDTH);  -- bytes received value plus the addr
                                                                                           -- offset.
                                                                                           

   
    -- adjust the address increment down by 1 byte to compensate
    -- for the LEN requirement of being N-1 data beats
    sig_byte_change_minus1 <=  sig_adjusted_addr_incr-ADDR_CNTR_ONE;


    

    -- Rip the new transfer length value
    sig_xfer_len <=  STD_LOGIC_VECTOR(
                         RESIZE(
                            sig_byte_change_minus1(BTT_RESIDUE_WIDTH-1 downto 
                                                   DBEAT_RESIDUE_WIDTH), 
                         LEN_WIDTH)
                     );
    


    
    -- calculate the next starting address after the current 
    -- xfer completes
    sig_predict_child_addr_lsh     <=  sig_child_addr_cntr_lsh + sig_child_addr_cntr_incr;
    sig_predict_child_addr_lsh_slv <= STD_LOGIC_VECTOR(sig_predict_child_addr_lsh);
    
    
    sig_child_addr_cntr_lsh_slv    <= STD_LOGIC_VECTOR(sig_child_addr_cntr_lsh);
    
    
    -- Determine if an address count lsh rollover is going to occur when 
    -- jumping to the next starting address by comparing the MS bit of the
    -- current address lsh to the MS bit of the predicted address lsh . 
    -- A transition of a '1' to a '0' is a rollover.
    sig_child_addr_lsh_rollover <= '1'
      when (
            (sig_child_addr_cntr_lsh_slv(ADDR_CNTR_WIDTH-1)    = '1') and
            (sig_predict_child_addr_lsh_slv(ADDR_CNTR_WIDTH-1) = '0')
           )
      Else '0';
    
    
    
   --  sig_child_addr_msh_eq_max <= '1'
   --     when (sig_child_addr_cntr_msh = ADDR_CNTR_MAX_VALUE)
   --     Else '0';
    
    
    -- sig_child_addr_msh_rollover <= sig_child_addr_msh_eq_max and 
    --                                sig_child_addr_lsh_rollover;
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_ADDR_STUFF
    --
    -- Process Description:
    --  Implements a general register for address counter related 
    -- things.
    --
    -------------------------------------------------------------
    REG_ADDR_STUFF : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
              
              sig_child_addr_lsh_rollover_reg  <= '0';
              --sig_child_addr_msh_rollover_reg  <= '0';
              --sig_child_addr_msh_eq_max_reg    <= '0';
              --sig_adjusted_child_addr_incr_reg <= (others => '0');
            
            else
              
              sig_child_addr_lsh_rollover_reg  <= sig_child_addr_lsh_rollover ;
              --sig_child_addr_msh_rollover_reg  <= sig_child_addr_msh_rollover ;
              --sig_child_addr_msh_eq_max_reg    <= sig_child_addr_msh_eq_max   ; 
              --sig_adjusted_child_addr_incr_reg <= sig_adjusted_addr_incr;
              
            end if; 
         end if;       
       end process REG_ADDR_STUFF; 
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_LSH_ADDR_CNTR
    --
    -- Process Description:
    -- Least Significant Half Address counter implementation. 
    --
    -------------------------------------------------------------
    IMP_LSH_ADDR_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
              
              sig_child_addr_cntr_lsh <= (others => '0');
            
            elsif (sig_ld_child_addr_cntr = '1') then
              
              sig_child_addr_cntr_lsh <= UNSIGNED(sig_child_addr_reg(ADDR_CNTR_WIDTH-1 downto 0));
            
            Elsif (sig_incr_child_addr_cntr = '1') Then
              
              sig_child_addr_cntr_lsh <= sig_predict_child_addr_lsh;
            
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process IMP_LSH_ADDR_CNTR; 
   
   
 
  
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_MSH_ADDR_CNTR
    --
    -- Process Description:
    -- Least Significant Half Address counter implementation. 
    --
    -------------------------------------------------------------
    IMP_MSH_ADDR_CNTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1') then
              
              sig_child_addr_cntr_msh <= (others => '0');
            
            elsif (sig_ld_child_addr_cntr = '1') then
              
              sig_child_addr_cntr_msh <= UNSIGNED(sig_child_addr_reg((2*ADDR_CNTR_WIDTH)-1 downto 
                                                                     ADDR_CNTR_WIDTH));
            
            Elsif (sig_incr_child_addr_cntr        = '1' and
                   sig_child_addr_lsh_rollover_reg = '1') Then
              
              sig_child_addr_cntr_msh <= sig_child_addr_cntr_msh+ADDR_CNTR_ONE;
            
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process IMP_MSH_ADDR_CNTR; 
   
   
 
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_FIRST_XFER_FLOP
   --
   -- Process Description:
   --  Implements the register flop for the first transfer flag.
   --
   -------------------------------------------------------------
   IMP_FIRST_XFER_FLOP : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (sig_mmap_reset_reg       = '1' or
               sig_incr_child_addr_cntr = '1') then

             sig_first_child_xfer <= '0';
             
           elsif (sig_ld_child_addr_cntr = '1') then

             sig_first_child_xfer <= '1';
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_FIRST_XFER_FLOP; 
  
  
  

  
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_32
    --
    -- If Generate Description:
    -- Implements the Address segment merge logic for the 32-bit
    -- address width case. The address counter segments are split 
    -- into two 16-bit sections to improve Fmax convergence.
    --
    --
    ------------------------------------------------------------
    GEN_ADDR_32 : if (C_ADDR_WIDTH = 32) generate
    
    
       begin
    
         
         -- Populate the transfer address value by concatonating the 
         -- address counter segments
         sig_xfer_address <= STD_LOGIC_VECTOR(sig_child_addr_cntr_msh) &
                             STD_LOGIC_VECTOR(sig_child_addr_cntr_lsh); 
         
         
         
       end generate GEN_ADDR_32;
    
    
    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_GT_32_LE_48
    --
    -- If Generate Description:
    -- Implements the additional Address Counter logic for the case 
    -- when the address width is greater than 32 bits and less than
    -- or equal to 48 bits. In this case, an additional counter segment
    -- is implemented (segment 3) that is variable width of 1
    -- to 16 bits.
    --
    ------------------------------------------------------------
    GEN_ADDR_GT_32_LE_48 : if (C_ADDR_WIDTH  > 32 and
                               C_ADDR_WIDTH <= 48) generate


      -- Local constants
      Constant ACNTR_SEG3_WIDTH    : integer  := C_ADDR_WIDTH-32;
      Constant ACNTR_SEG3_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG3_WIDTH);
      Constant ACNTR_MSH_MAX       : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      Constant SEG3_ADDR_RIP_MS_INDEX : integer := C_ADDR_WIDTH-1;
      Constant SEG3_ADDR_RIP_LS_INDEX : integer := 32;
      
      
      -- Local Signals
      signal lsig_seg3_addr_cntr       : unsigned(ACNTR_SEG3_WIDTH-1 downto 0) := (others => '0');
      signal lsig_acntr_msh_eq_max     : std_logic := '0';
      signal lsig_acntr_msh_eq_max_reg : std_logic := '0';
       
       
      begin

      
      
        -- Populate the transfer address value by concatonating the
        -- 3 address counter segments
        sig_xfer_address     <= STD_LOGIC_VECTOR(lsig_seg3_addr_cntr  ) &
                                STD_LOGIC_VECTOR(sig_child_addr_cntr_msh) &
                                STD_LOGIC_VECTOR(sig_child_addr_cntr_lsh);


       
        
        -- See if the MSH (Segment 2) of the Adress Counter is at a max value
        lsig_acntr_msh_eq_max <= '1'
          when (sig_child_addr_cntr_msh = ACNTR_MSH_MAX)
          Else '0';


  
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG2_EQ_MAX_REG
        --
        -- Process Description:
        --  Implements a register for the flag indicating the address
        -- counter MSH (Segment 2) is at max value and will rollover
        -- at the next increment interval for the counter. Registering 
        -- this signal and using it for the Seg 3 increment logic only
        -- works because there is always at least a 1 clock time gap 
        -- between the increment causing the segment 2 counter to go to 
        -- max and the next increment operation that can bump segment 3. 
        --
        -------------------------------------------------------------
        IMP_SEG2_EQ_MAX_REG : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (sig_mmap_reset_reg = '1') then
        
                 lsig_acntr_msh_eq_max_reg <= '0';
        
               else
        
                 lsig_acntr_msh_eq_max_reg <= lsig_acntr_msh_eq_max;
        
               end if; 
            end if;       
          end process IMP_SEG2_EQ_MAX_REG; 
  
        
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG3_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 3 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG3_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg3_addr_cntr <= (others => '0');

                elsif (sig_ld_child_addr_cntr = '1') then

                  lsig_seg3_addr_cntr <= UNSIGNED(sig_child_addr_reg(SEG3_ADDR_RIP_MS_INDEX downto 
                                                                     SEG3_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_child_addr_cntr    = '1' and
                       sig_child_addr_lsh_rollover = '1' and
                       lsig_acntr_msh_eq_max_reg   = '1') then

                  lsig_seg3_addr_cntr <= lsig_seg3_addr_cntr+ACNTR_SEG3_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG3_ADDR_CNTR;



  
  
      end generate GEN_ADDR_GT_32_LE_48;



     
     
     
     
     
     
     
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADDR_GT_48
    --
    -- If Generate Description:
    -- Implements the additional Address Counter logic for the case 
    -- when the address width is greater than 48 bits and less than
    -- or equal to 64. In this case, an additional 2 counter segments
    -- are implemented (segment 3 and 4). Segment 3 is a fixed 16-bits
    -- and segment 4 is variable width of 1 to 16 bits.
    --
    ------------------------------------------------------------
    GEN_ADDR_GT_48 : if (C_ADDR_WIDTH  > 48) generate


      -- Local constants
      Constant ACNTR_SEG3_WIDTH    : integer  := ADDR_CNTR_WIDTH;
      Constant ACNTR_SEG3_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG3_WIDTH);
      Constant ACNTR_SEG3_MAX      : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      Constant ACNTR_MSH_MAX       : unsigned(ADDR_CNTR_WIDTH-1 downto 0) := (others => '1');
      
      
      Constant ACNTR_SEG4_WIDTH    : integer  := C_ADDR_WIDTH-48;
      Constant ACNTR_SEG4_ONE      : unsigned := TO_UNSIGNED(1, ACNTR_SEG4_WIDTH);
      
      
      Constant SEG3_ADDR_RIP_MS_INDEX : integer := 47;
      Constant SEG3_ADDR_RIP_LS_INDEX : integer := 32;
      
      Constant SEG4_ADDR_RIP_MS_INDEX : integer := C_ADDR_WIDTH-1;
      Constant SEG4_ADDR_RIP_LS_INDEX : integer := 48;
      
      
      
      
      -- Local Signals
      signal lsig_seg3_addr_cntr        : unsigned(ACNTR_SEG3_WIDTH-1 downto 0) := (others => '0');
      signal lsig_acntr_msh_eq_max      : std_logic := '0';
      signal lsig_acntr_msh_eq_max_reg  : std_logic := '0';
 
      signal lsig_acntr_seg3_eq_max     : std_logic := '0';
      signal lsig_acntr_seg3_eq_max_reg : std_logic := '0';
      
      
      signal lsig_seg4_addr_cntr        : unsigned(ACNTR_SEG4_WIDTH-1 downto 0) := (others => '0');
 
       
       
      begin

      
      
        -- Populate the transfer address value by concatonating the
        -- 4 address counter segments
        sig_xfer_address     <= STD_LOGIC_VECTOR(lsig_seg4_addr_cntr  ) &
                                STD_LOGIC_VECTOR(lsig_seg3_addr_cntr  ) &
                                STD_LOGIC_VECTOR(sig_child_addr_cntr_msh) &
                                STD_LOGIC_VECTOR(sig_child_addr_cntr_lsh);


       
        
        -- See if the MSH (Segment 2) of the Address Counter is at a max value
        lsig_acntr_msh_eq_max <= '1'
          when (sig_child_addr_cntr_msh = ACNTR_MSH_MAX)
          Else '0';

        -- See if the Segment 3 of the Address Counter is at a max value
        lsig_acntr_seg3_eq_max <= '1'
          when (lsig_seg3_addr_cntr = ACNTR_SEG3_MAX)
          Else '0';


        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG2_3_EQ_MAX_REG
        --
        -- Process Description:
        --  Implements a register for the flag indicating the address
        -- counter segments 2 and 3 are at max value and will rollover
        -- at the next increment interval for the counter. Registering 
        -- these signals and using themt for the Seg 3/4 increment logic 
        -- only works because there is always at least a 1 clock time gap 
        -- between the increment causing the segment 2 or 3 counter to go  
        -- to max and the next increment operation. 
        --
        -------------------------------------------------------------
        IMP_SEG2_3_EQ_MAX_REG : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (sig_mmap_reset_reg = '1') then
        
                 lsig_acntr_msh_eq_max_reg  <= '0';
                 lsig_acntr_seg3_eq_max_reg <= '0';
                 
               else
        
                 lsig_acntr_msh_eq_max_reg  <= lsig_acntr_msh_eq_max;
                 lsig_acntr_seg3_eq_max_reg <= lsig_acntr_seg3_eq_max;
        
               end if; 
            end if;       
          end process IMP_SEG2_3_EQ_MAX_REG; 
  
        
        
        
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG3_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 3 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG3_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg3_addr_cntr <= (others => '0');

                elsif (sig_ld_child_addr_cntr = '1') then

                  lsig_seg3_addr_cntr <= UNSIGNED(sig_child_addr_reg(SEG3_ADDR_RIP_MS_INDEX downto 
                                                                     SEG3_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_child_addr_cntr    = '1' and
                       sig_child_addr_lsh_rollover = '1' and
                       lsig_acntr_msh_eq_max_reg   = '1') then

                  lsig_seg3_addr_cntr <= lsig_seg3_addr_cntr+ACNTR_SEG3_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG3_ADDR_CNTR;



        
  
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_SEG4_ADDR_CNTR
        --
        -- Process Description:
        -- Segment 4 of the Address counter implementation.
        --
        -------------------------------------------------------------
        IMP_SEG4_ADDR_CNTR : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (sig_mmap_reset_reg = '1') then

                  lsig_seg4_addr_cntr <= (others => '0');

                elsif (sig_ld_child_addr_cntr = '1') then

                  lsig_seg4_addr_cntr <= UNSIGNED(sig_child_addr_reg(SEG4_ADDR_RIP_MS_INDEX downto 
                                                                     SEG4_ADDR_RIP_LS_INDEX));

                Elsif (sig_incr_child_addr_cntr    = '1' and
                       sig_child_addr_lsh_rollover = '1' and
                       lsig_acntr_msh_eq_max_reg   = '1' and
                       lsig_acntr_seg3_eq_max_reg  = '1') then

                  lsig_seg4_addr_cntr <= lsig_seg4_addr_cntr+ACNTR_SEG4_ONE;

                else
                  null;  -- hold current state
                end if;
             end if;
           end process IMP_SEG4_ADDR_CNTR;



  
  
  
      end generate GEN_ADDR_GT_48;



     
     
     
     
     
     
     
     
    
    
    
    
    
    
    
    
     
      
    -- Child Addr and data Cntlr FIFO interface handshake logic ------------------------------
     
     sig_clr_cmd2data_valid    <= sig_cmd2data_valid and data2mstr_cmd_ready;
        
     sig_clr_cmd2addr_valid    <= sig_cmd2addr_valid and addr2mstr_cmd_ready;
        
     
      
     
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: CMD2DATA_VALID_FLOP
     --
     -- Process Description:
     --  Implements the set/reset flop for the Command Valid control
     -- to the Data Controller Module.
     --
     -------------------------------------------------------------
     CMD2DATA_VALID_FLOP : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg     = '1' or
                 sig_clr_cmd2data_valid = '1') then
     
               sig_cmd2data_valid <= '0';
               
             elsif (sig_push_xfer_reg = '1') then
     
               sig_cmd2data_valid <= '1';
               
             else
               null; -- hold current state
             end if; 
          end if;       
        end process CMD2DATA_VALID_FLOP; 
                                                   
       
       
       
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: CMD2ADDR_VALID_FLOP
     --
     -- Process Description:
     --  Implements the set/reset flop for the Command Valid control
     -- to the Address Controller Module.
     --
     -------------------------------------------------------------
     CMD2ADDR_VALID_FLOP : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
             if (sig_mmap_reset_reg     = '1' or
                 sig_clr_cmd2addr_valid = '1') then
     
               sig_cmd2addr_valid <= '0';
               
             elsif (sig_push_xfer_reg = '1') then
     
               sig_cmd2addr_valid <= '1';
               
             else
               null; -- hold current state
             end if; 
          end if;       
        end process CMD2ADDR_VALID_FLOP; 
       
  
  
  
  
  
  
  
     
     
     
    ------------------------------------------------------------------
    -- Sequential transfer flag logic
 
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_SEQ_FLAG
    --
    -- Process Description:
    --  Sequential transfer flag flop 
    -- The sequential flag is an indication to downstream modules
    -- (such as Data Controllers) that the following command in the
    -- transfer queue is address sequential to the current transfer.
    -- This is used to minimize/eliminate transfer bubbles between
    -- child transfer boundaries.
    --
    -------------------------------------------------------------
    IMP_SEQ_FLAG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
                sig_push_input_reg = '1') then

              sig_xfer_is_seq <= '0';
              
            elsif (sig_push_xfer_reg = '1') then

              sig_xfer_is_seq <= '1';
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process IMP_SEQ_FLAG; 
    
     
   
   
     
     
    
    
     -----------------------------------------------------------------
     -- Output xfer register design


     -- Pop the Store and Forward Xfer FIFO under command of the 
     -- Child State Machine
     sig_pcc2sf_xfer_ready <= sig_csm_pop_sf_fifo;
    
   
     
     sig_push_xfer_reg     <=  sig_csm_ld_xfer;
    
    
     sig_pop_xfer_reg      <= (sig_clr_cmd2data_valid and not(sig_cmd2addr_valid)) or  -- Data taking xfer after Addr
                              (sig_clr_cmd2addr_valid and not(sig_cmd2data_valid)) or  -- Addr taking xfer after Data
                              (sig_clr_cmd2data_valid and sig_clr_cmd2addr_valid);     -- Addr and Data both taking xfer
    
                                                     
     
     
     -- SFCC Simplifications
      
     --  sig_last_xfer_valid     <= sig_sf2pcc_cmd_cmplt;  
      
     sig_last_xfer_valid     <=  sig_sf2pcc_cmd_cmplt            and  -- from Store and forward
                                 (not(sig_child_qual_first_of_2) or
                                  sig_sf2pcc_packet_eop );
      
      
      
      
     -- DRE Stuff is sent via the Realigner command, 
     sig_xfer_drr_reg        <= '0';  -- not used here
      
     --  --------------------------------------------------------------------- 
     -- Strobe Generator Logic                                             
     -- Actual Strobes used are sent directly to the Data Controller from 
     -- Store and Forward module. Set these Strobe values to all ones in
     -- this module.
     sig_xfer_strt_strb_reg  <= (others => '1');
     sig_xfer_end_strb_reg   <= (others => '1');
                                         
    
    
    
                                                     
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: REG_CHILD_XFER_QUAL
     --
     -- Process Description:
     --  Implements the child command output xfer qualifier 
     -- holding register.
     --
     -------------------------------------------------------------
     REG_CHILD_XFER_QUAL : process (primary_aclk)
        begin
          if (primary_aclk'event and primary_aclk = '1') then
            if (sig_mmap_reset_reg = '1' or
               (sig_pop_xfer_reg   = '1' and
                sig_push_xfer_reg  = '0')) then
            
              sig_xfer_cache_reg      <=  (others => '0');
              sig_xfer_user_reg       <=  (others => '0');
              sig_xfer_tag_reg        <=  (others => '0');
              sig_xfer_addr_reg       <=  (others => '0');
              sig_xfer_len_reg        <=  (others => '0');
              sig_xfer_eof_reg        <=  '0';
              sig_xfer_is_seq_reg     <=  '0';
              sig_xfer_cmd_cmplt_reg  <=  '0';
              sig_xfer_calc_err_reg   <=  '0';
              sig_xfer_type_reg       <=  '0';                                        
              
              sig_xfer_reg_empty      <=  '1';
              sig_xfer_reg_full       <=  '0';
            
            elsif (sig_push_xfer_reg = '1') then
              
              sig_xfer_cache_reg      <=  sig_child_qual_cache_type     ;
              sig_xfer_user_reg       <=  sig_child_qual_user_type     ;
              sig_xfer_tag_reg        <=  sig_child_qual_tag_reg    ;
              sig_xfer_addr_reg       <=  sig_xfer_address          ;
              sig_xfer_len_reg        <=  sig_xfer_len              ;
              sig_xfer_eof_reg        <=  sf2pcc_packet_eop         ;
              sig_xfer_is_seq_reg     <=  not(sig_last_xfer_valid)  ;
              sig_xfer_cmd_cmplt_reg  <=  sig_last_xfer_valid or
                                          sig_child_qual_error_reg  ;
              sig_xfer_calc_err_reg   <=  sig_child_qual_error_reg  ;
              sig_xfer_type_reg       <=  sig_child_qual_burst_type ;
                                          
              sig_xfer_reg_empty      <=  '0';
              sig_xfer_reg_full       <=  '1';
                         
            else
              null; -- Hold current State
            end if; 
          end if;       
        end process REG_CHILD_XFER_QUAL; 
    
     
     

  
     
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_indet_btt.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_indet_btt.vhd
  --
  -- Description:     
  --    This file implements the DataMover S2MM Indeterminate BTT support module.                 
  --  This Module keeps track of the incoming data stream and generates a transfer                
  --  descriptor for each AXI MMap Burst worth of data loaded in the Data FIFO.                 
  --  This information is stored in a separate FIFO that the Predictive Transfer
  -- Calculator fetches sequentially as it is generating commands for the AXI MMap  
  -- bus.               
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  


  library lib_pkg_v1_0_2; 
  Use lib_pkg_v1_0_2.lib_pkg.clog2;
  
  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_sfifo_autord;
  use axi_datamover_v5_1_17.axi_datamover_skid_buf;
  Use axi_datamover_v5_1_17.axi_datamover_stbs_set;
  Use axi_datamover_v5_1_17.axi_datamover_stbs_set_nodre;

  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_indet_btt is
    generic (
      
      C_SF_FIFO_DEPTH          : integer range 128 to 8192 := 128;
        -- Sets the depth of the Data FIFO
      
      C_IBTT_XFER_BYTES_WIDTH  : Integer range   1 to   14 := 8;
        -- Sets the width of the sf2pcc_xfer_bytes port
  
      C_STRT_OFFSET_WIDTH      : Integer range   1 to 7 :=  2;
        -- Sets the bit width of the starting address offset port
        -- This should be set to log2(C_MMAP_DWIDTH/C_STREAM_DWIDTH)
        
      C_MAX_BURST_LEN          : Integer range  2 to  256 := 16;
        -- Indicates what is set as the allowed max burst length for AXI4
        -- transfers
      
      C_MMAP_DWIDTH            : Integer range   32  to 1024 := 32;
        -- Indicates the width of the AXI4 MMap data path
      
      C_STREAM_DWIDTH          : Integer range   8 to  1024 := 32;
        -- Indicates the width of the stream data path

      C_ENABLE_SKID_BUF                : string := "11111";
    C_ENABLE_S2MM_TKEEP             : integer range 0 to 1 := 1; 
      C_ENABLE_DRE                     : Integer range 0 to 1 := 0;
      
      C_FAMILY                 : String  := "virtex7"
        -- Specifies the target FPGA Family
      
      );
    port (
      
      -- Clock input --------------------------------------------
      primary_aclk              : in  std_logic;               --
         -- Primary synchronization clock for the Master side  --
         -- interface and internal logic. It is also used      --
         -- for the User interface synchronization when        --
         -- C_STSCMD_IS_ASYNC = 0.                             --
                                                               --
      -- Reset input                                           --
      mmap_reset                : in  std_logic;               --
         -- Reset used for the internal master logic           --
      -----------------------------------------------------------
      
     
      
     -- Write Data Controller I/O  ----------------------------------------------------------
                                                                                           --
      ibtt2wdc_stbs_asserted    : Out  std_logic_vector(7 downto 0);                       --
        -- Indicates the number of asserted WSTRB bits for the                             --
        -- associated output stream data beat                                              --
                                                                                           --
      ibtt2wdc_eop              : Out  std_logic;                                          --
        -- Write End of Packet flag output to Write Data Controller                        --
                                                                                           --
      ibtt2wdc_tdata            : Out  std_logic_vector(C_MMAP_DWIDTH-1 downto 0);         --
        -- Write DATA output to Write Data Controller                                      --
                                                                                           --
      ibtt2wdc_tstrb            : Out  std_logic_vector((C_MMAP_DWIDTH/8)-1 downto 0);     --
        -- Write DATA output to Write Data Controller                                      --
                                                                                           --
      ibtt2wdc_tlast            : Out  std_logic;                                          --
        -- Write LAST output to Write Data Controller                                      --
                                                                                           --
      ibtt2wdc_tvalid           : Out  std_logic;                                          --
        -- Write VALID output to Write Data Controller                                     --
                                                                                           --
      wdc2ibtt_tready           : In  std_logic;                                           --
        -- Write READY input from Write Data Controller                                    --
      ---------------------------------------------------------------------------------------
 
 
     -- DRE Stream In ----------------------------------------------------------------------
                                                                                          --
      dre2ibtt_tvalid           : In  std_logic;                                          --
        -- DRE Stream VALID Output                                                        --
                                                                                          --
      ibtt2dre_tready           : Out Std_logic;                                          --
        -- DRE  Stream READY input                                                        --
                                                                                          --
      dre2ibtt_tdata            : In  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);       --  
        -- DRE  Stream DATA input                                                         --
                                                                                          --
      dre2ibtt_tstrb            : In  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);   --     
        -- DRE  Stream STRB input                                                         --
                                                                                          --
      dre2ibtt_tlast            : In  std_logic;                                          --
        -- DRE  Xfer LAST input                                                           --
                                                                                          --
      dre2ibtt_eop              : In  std_logic;                                          --
        -- DRE  Stream end of Stream packet flag                                          --
      --------------------------------------------------------------------------------------          
  
 
  
      -- Starting Address Offset Input  ------------------------------------------------- 
                                                                                       --
      dre2ibtt_strt_addr_offset : In std_logic_vector(C_STRT_OFFSET_WIDTH-1 downto 0); -- 
        -- Used by Packing logic to set the initial data slice position for the        --
        -- packing operation. Packing is only needed if the MMap and Stream Data       --
        -- widths do not match. This input is sampled on the first valid DRE Stream In -- 
        -- input databeat of a packet.                                                 --
        --                                                                             -- 
      ----------------------------------------------------------------------------------- 
  
               
                
      -- Store and Forward Command Calculator Interface ---------------------------------------
                                                                                             --
      sf2pcc_xfer_valid         : Out std_logic;                                             --
        -- Indicates that at least 1 xfer descriptor entry is in in the XFER_DESCR_FIFO      --
                                                                                             --
      pcc2sf_xfer_ready         : in std_logic;                                              --
        -- Indicates that a full burst of data has been loaded into the data FIFO            --
                                                                                             --
                                                                                             --
      sf2pcc_cmd_cmplt          : Out std_logic;                                             --
        -- Indicates that this is the final xfer for an associated command loaded            --
        -- into the Realigner by the IBTTCC interface                                        --
                                                                                             --
                                                                                             --
      sf2pcc_packet_eop         : Out std_logic;                                             --
        -- Indicates the end of a Stream Packet corresponds to the pending                   --
        -- xfer data described by this xfer descriptor                                       --
                                                                                             --
      sf2pcc_xfer_bytes         : Out std_logic_vector(C_IBTT_XFER_BYTES_WIDTH-1 downto 0)   --
        -- This byte count is used by the IBTTCC for setting up the spawned child            --
        -- commands. The IBTTCC must use this count to generate the appropriate              --
        -- LEN value to put out on the AXI4 Write Addr Channel and the WSTRB on the AXI4     --
        -- Write Data Channel.                                                               --
      -----------------------------------------------------------------------------------------  
 
      );
  
  end entity axi_datamover_indet_btt;
  
  
  architecture implementation of axi_datamover_indet_btt is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Functions
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_cntr_width
    --
    -- Function Description:
    --  This function calculates the needed counter bit width from the 
    -- number of count sates needed (input).
    --
    -------------------------------------------------------------------
    function funct_get_cntr_width (num_cnt_values : integer) return integer is
    
      Variable temp_cnt_width : Integer := 0;
    
    begin
    
      
      if (num_cnt_values <= 2) then
      
        temp_cnt_width := 1;
      
      elsif (num_cnt_values <= 4) then
      
        temp_cnt_width := 2;
      
      elsif (num_cnt_values <= 8) then
      
        temp_cnt_width := 3;
      
      elsif (num_cnt_values <= 16) then
      
        temp_cnt_width := 4;
      
      elsif (num_cnt_values <= 32) then
      
        temp_cnt_width := 5;
      
      elsif (num_cnt_values <= 64) then
      
        temp_cnt_width := 6;
      
      elsif (num_cnt_values <= 128) then
      
        temp_cnt_width := 7;
      
      else
      
        temp_cnt_width := 8;
      
      end if;
      
      
      
      Return (temp_cnt_width);
      
      
    end function funct_get_cntr_width;
    
    
    
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_rnd2pwr_of_2
    --
    -- Function Description:
    --  Rounds the input value up to the nearest power of 2 between
    --  4 and 32. THis is used for sizing the SRL based XD FIFO.
    --
    -------------------------------------------------------------------
    function funct_rnd2pwr_of_2 (input_value : integer) return integer is

      Variable temp_pwr2 : Integer := 128;

    begin

      if (input_value <= 4) then

         temp_pwr2 := 16;

      elsif (input_value <= 8) then

         temp_pwr2 := 16;

      elsif (input_value <= 16) then

         temp_pwr2 := 16;

      else

         temp_pwr2 := 32;

      end if;


      Return (temp_pwr2);

    end function funct_rnd2pwr_of_2;
    -------------------------------------------------------------------
   
     
    
    
    
    
    
    
    -- Constants
    
    Constant LOGIC_LOW                 : std_logic := '0';
    Constant LOGIC_HIGH                : std_logic := '1';
    Constant BITS_PER_BYTE             : integer   := 8;
    
    Constant MMAP2STRM_WIDTH_RATO      : integer := C_MMAP_DWIDTH/C_STREAM_DWIDTH;
    
    Constant STRM_WSTB_WIDTH           : integer := C_STREAM_DWIDTH/BITS_PER_BYTE;
    Constant MMAP_WSTB_WIDTH           : integer := C_MMAP_DWIDTH/BITS_PER_BYTE;
    Constant STRM_STRBS_ASSERTED_WIDTH : integer := clog2(STRM_WSTB_WIDTH)+1;
   
   -- Constant DATA_FIFO_DFACTOR        : integer := 4; -- set buffer to 4 times the Max allowed Burst Length   
   -- Constant DATA_FIFO_DEPTH          : integer := C_MAX_BURST_LEN*DATA_FIFO_DFACTOR;
    Constant DATA_FIFO_DEPTH           : integer := C_SF_FIFO_DEPTH;
    Constant DATA_FIFO_WIDTH           : integer := C_MMAP_DWIDTH+MMAP_WSTB_WIDTH*C_ENABLE_S2MM_TKEEP+2;
    -- Constant DATA_FIFO_WIDTH           : integer := C_MMAP_DWIDTH+STRB_CNTR_WIDTH+2;
    Constant DATA_FIFO_CNT_WIDTH       : integer := clog2(DATA_FIFO_DEPTH)+1;
    
    Constant BURST_CNTR_WIDTH          : integer := clog2(C_MAX_BURST_LEN);
    Constant MAX_BURST_DBEATS          : Unsigned(BURST_CNTR_WIDTH-1 downto 0) :=  
                                         TO_UNSIGNED(C_MAX_BURST_LEN-1, BURST_CNTR_WIDTH);
    
    Constant DBC_ONE                   : Unsigned(BURST_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, BURST_CNTR_WIDTH);
    
    Constant BYTE_CNTR_WIDTH           : integer := C_IBTT_XFER_BYTES_WIDTH;
    
    Constant BYTES_PER_MMAP_DBEAT      : integer := C_MMAP_DWIDTH/BITS_PER_BYTE;
    Constant BYTES_PER_STRM_DBEAT      : integer := C_STREAM_DWIDTH/BITS_PER_BYTE;
    --Constant MAX_BYTE_CNT              : integer := C_MAX_BURST_LEN*BYTES_PER_DBEAT;
    --Constant NUM_STRB_BITS             : integer := BYTES_PER_DBEAT;
    Constant BCNTR_ONE                 : Unsigned(BYTE_CNTR_WIDTH-1 downto 0) := 
                                         TO_UNSIGNED(1, BYTE_CNTR_WIDTH);
    --Constant XD_FIFO_DEPTH             : integer := 16;
    Constant XD_FIFO_DEPTH             : integer := funct_rnd2pwr_of_2(DATA_FIFO_DEPTH/C_MAX_BURST_LEN);
    Constant XD_FIFO_CNT_WIDTH         : integer := clog2(XD_FIFO_DEPTH)+1;
    Constant XD_FIFO_WIDTH             : integer := BYTE_CNTR_WIDTH+2;
    
    Constant MMAP_STBS_ASSERTED_WIDTH  : integer := 8;
    Constant SKIDBUF2WDC_DWIDTH        : integer := C_MMAP_DWIDTH + MMAP_STBS_ASSERTED_WIDTH;
    Constant SKIDBUF2WDC_STRB_WIDTH    : integer := SKIDBUF2WDC_DWIDTH/BITS_PER_BYTE;
    --Constant NUM_ZEROS_WIDTH         : integer := MMAP_STBS_ASSERTED_WIDTH;
    
    Constant STRB_CNTR_WIDTH           : integer := MMAP_STBS_ASSERTED_WIDTH;
    
    
    
    
    
    
    -- Signals
    
    signal sig_wdc2ibtt_tready        : std_logic := '0';
    signal sig_ibtt2wdc_tvalid        : std_logic := '0';
    signal sig_ibtt2wdc_tdata         : std_logic_vector(C_MMAP_DWIDTH-1 downto 0) := (others => '0');
    signal sig_ibtt2wdc_tstrb         : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
    signal sig_ibtt2wdc_tlast         : std_logic := '0';
    signal sig_ibtt2wdc_eop           : std_logic := '0';
    signal sig_push_data_fifo         : std_logic := '0';
    signal sig_pop_data_fifo          : std_logic := '0';
    signal sig_data_fifo_data_in      : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_data_out     : std_logic_vector(DATA_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_dvalid       : std_logic := '0';
    signal sig_data_fifo_full         : std_logic := '0';
    signal sig_data_fifo_rd_cnt       : std_logic_vector(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_data_fifo_wr_cnt       : std_logic_vector(DATA_FIFO_CNT_WIDTH-1 downto 0) := (others => '0');
    signal sig_push_xd_fifo           : std_logic := '0';
    signal sig_pop_xd_fifo            : std_logic := '0';
    signal sig_xd_fifo_data_in        : std_logic_vector(XD_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_xd_fifo_data_out       : std_logic_vector(XD_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_xd_fifo_dvalid         : std_logic := '0';
    signal sig_xd_fifo_full           : std_logic := '0';
    signal sig_tmp           : std_logic := '0';
    signal sig_strm_in_ready          : std_logic := '0';
    signal sig_good_strm_dbeat        : std_logic := '0';
    signal sig_good_tlast_dbeat       : std_logic := '0';
    signal sig_dre2ibtt_tlast_reg     : std_logic := '0';
    signal sig_dre2ibtt_eop_reg       : std_logic := '0';
    signal sig_burst_dbeat_cntr       : Unsigned(BURST_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_incr_dbeat_cntr        : std_logic := '0';
    signal sig_clr_dbeat_cntr         : std_logic := '0';
    signal sig_clr_dbc_reg            : std_logic := '0';
    signal sig_dbc_max                : std_logic := '0';
    signal sig_pcc2ibtt_xfer_ready    : std_logic := '0';
    signal sig_byte_cntr              : unsigned(BYTE_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_byte_cntr_incr_value   : unsigned(BYTE_CNTR_WIDTH-1 downto 0) := (others => '0');
    signal sig_ld_byte_cntr           : std_logic := '0';
    signal sig_incr_byte_cntr         : std_logic := '0';
    signal sig_clr_byte_cntr          : std_logic := '0';
    signal sig_fifo_tstrb_out         : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
    signal sig_num_ls_zeros           : integer range 0 to STRM_WSTB_WIDTH := 0;
    signal sig_ls_assert_found        : std_logic := '0';
    signal sig_num_ms_zeros           : integer range 0 to STRM_WSTB_WIDTH := 0;
    signal sig_ms_assert_found        : std_logic := '0';
   -- signal sig_num_zeros              : unsigned(NUM_ZEROS_WIDTH-1 downto 0) := (others => '0');
   -- signal sig_num_ones               : unsigned(NUM_ZEROS_WIDTH-1 downto 0) := (others => '0');
    signal sig_stbs2sfcc_asserted     : std_logic_vector(MMAP_STBS_ASSERTED_WIDTH-1 downto 0) := (others => '0');
    signal sig_stbs2wdc_asserted      : std_logic_vector(MMAP_STBS_ASSERTED_WIDTH-1 downto 0) := (others => '0');
    signal sig_ibtt2wdc_stbs_asserted : std_logic_vector(MMAP_STBS_ASSERTED_WIDTH-1 downto 0) := (others => '0');
    signal sig_skidbuf_in_tready      : std_logic := '0';
    signal sig_skidbuf_in_tvalid      : std_logic := '0';
    signal sig_skidbuf_in_tdata       : std_logic_vector(SKIDBUF2WDC_DWIDTH-1 downto 0) := (others => '0');
    signal sig_skidbuf_in_tstrb       : std_logic_vector(SKIDBUF2WDC_STRB_WIDTH-1 downto 0) := (others => '0');
    signal sig_skidbuf_in_tlast       : std_logic := '0';
    signal sig_skidbuf_in_eop         : std_logic := '0';
    signal sig_skidbuf_out_tready     : std_logic := '0';
    signal sig_skidbuf_out_tvalid     : std_logic := '0';
    signal sig_skidbuf_out_tdata      : std_logic_vector(SKIDBUF2WDC_DWIDTH-1 downto 0) := (others => '0');
    signal sig_skidbuf_out_tstrb      : std_logic_vector(SKIDBUF2WDC_STRB_WIDTH-1 downto 0) := (others => '0');
    signal sig_skidbuf_out_tlast      : std_logic := '0';
    signal sig_skidbuf_out_eop        : std_logic := '0';

    signal sig_enable_dbcntr          : std_logic := '0';
    signal sig_good_fifo_write        : std_logic := '0';
    
    
    
    
  begin --(architecture implementation)
  
   -- Write Data Controller I/O 
   sig_wdc2ibtt_tready       <= wdc2ibtt_tready      ;
   
   ibtt2wdc_tvalid           <= sig_ibtt2wdc_tvalid  ;
   ibtt2wdc_tdata            <= sig_ibtt2wdc_tdata   ; 
   ibtt2wdc_tstrb            <= sig_ibtt2wdc_tstrb   ;
   ibtt2wdc_tlast            <= sig_ibtt2wdc_tlast   ;
   ibtt2wdc_eop              <= sig_ibtt2wdc_eop     ;
   
   ibtt2wdc_stbs_asserted    <= sig_ibtt2wdc_stbs_asserted;
   
   
    
   -- PCC I/O 
   sf2pcc_xfer_valid         <= sig_xd_fifo_dvalid;
   sig_pcc2ibtt_xfer_ready   <= pcc2sf_xfer_ready;
  
  
  
   
   sf2pcc_packet_eop         <= sig_xd_fifo_data_out(BYTE_CNTR_WIDTH+1); 
   sf2pcc_cmd_cmplt          <= sig_xd_fifo_data_out(BYTE_CNTR_WIDTH);
   sf2pcc_xfer_bytes         <= sig_xd_fifo_data_out(BYTE_CNTR_WIDTH-1 downto 0); 
 
    
    
    -- DRE Stream In 
    ibtt2dre_tready          <= sig_strm_in_ready;
    
    -- sig_strm_in_ready        <= not(sig_xd_fifo_full) and
    --                             not(sig_data_fifo_full);
    
    sig_good_strm_dbeat      <= dre2ibtt_tvalid and
                                sig_strm_in_ready;
                               
    sig_good_tlast_dbeat     <= sig_good_strm_dbeat and
                                dre2ibtt_tlast;
    
    
  
 -- Burst Packet Counter Logic ------------------------------- 
 
 
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: REG_DBC_STUFF
    --
    -- Process Description:
    -- Just a register for data beat counter signals.
    --
    -------------------------------------------------------------
    REG_DBC_STUFF : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then

              sig_dre2ibtt_tlast_reg    <= '0';
              sig_dre2ibtt_eop_reg      <= '0';
              sig_clr_dbc_reg           <= '0';
              
            else

              sig_dre2ibtt_tlast_reg    <= dre2ibtt_tlast;
              sig_dre2ibtt_eop_reg      <= dre2ibtt_eop;
              sig_clr_dbc_reg           <= sig_clr_dbeat_cntr;

            end if; 
         end if;       
       end process REG_DBC_STUFF; 
  
 
      --        sig_clr_dbc_reg           <= sig_clr_dbeat_cntr;
 
    
    -- Increment the dataBeat counter on a data fifo wide
    -- load condition. If packer logic is enabled, this will
    -- only occur when a full fifo data width has been collected
    -- from the Stream input.
    sig_incr_dbeat_cntr      <= sig_good_strm_dbeat and
                                sig_enable_dbcntr;
  
    -- Check to see if a max burst len of databeats have been
    -- loaded into the FIFO
    sig_dbc_max <= '1' 
     when (sig_burst_dbeat_cntr = MAX_BURST_DBEATS)
     Else '0';
  
    -- Start the counter over at a max burst len boundary or at  
    -- the end of the packet.
    sig_clr_dbeat_cntr <= '1' 
     when (sig_dbc_max          = '1' and
           sig_good_strm_dbeat  = '1' and
           sig_enable_dbcntr    = '1') or
          (sig_good_tlast_dbeat = '1' and
           sig_enable_dbcntr    = '1')
     Else '0';
  
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_DBC_CMTR
    --
    -- Process Description:
    -- The Databeat Counter keeps track of how many databeats have 
    -- been loaded into the Data FIFO. When a max burst worth of
    -- databeats have been loaded (or a TLAST encountered), the 
    -- XD FIFO can be loaded with a transfer data set to be sent
    -- to the IBTTCC.
    --
    -------------------------------------------------------------
    IMP_DBC_CMTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset  = '1' or
                sig_clr_dbeat_cntr = '1') then 

              sig_burst_dbeat_cntr <= (others => '0');
              
            elsif (sig_incr_dbeat_cntr = '1') then

              sig_burst_dbeat_cntr <= sig_burst_dbeat_cntr + DBC_ONE;
              
            else
              null;  -- hold current value
            end if; 
         end if;       
       end process IMP_DBC_CMTR; 
 
 
     
     
 
 
 
 
     -----  Byte Counter Logic -----------------------------------------------
 
  
  
    sig_clr_byte_cntr        <= sig_clr_dbc_reg and 
                                not(sig_good_strm_dbeat);
    
 
    sig_ld_byte_cntr         <= sig_clr_dbc_reg and 
                                sig_good_strm_dbeat;
    
    sig_incr_byte_cntr       <= sig_good_strm_dbeat;
    
    
    sig_byte_cntr_incr_value <= RESIZE(UNSIGNED(sig_stbs2sfcc_asserted), BYTE_CNTR_WIDTH);  
    
 
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_BYTE_CMTR
    --
    -- Process Description:
    -- Keeps a running byte count per burst packet loaded into the 
    -- xfer FIFO. It is based on the strobes set on the incoming
    -- Stream dbeat.
    --
    -------------------------------------------------------------
    IMP_BYTE_CMTR : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset        = '1' or
                sig_clr_byte_cntr = '1') then 

              sig_byte_cntr <= (others => '0');
              
            elsif (sig_ld_byte_cntr = '1') then

              sig_byte_cntr <= sig_byte_cntr_incr_value;
              
            elsif (sig_incr_byte_cntr = '1') then

              sig_byte_cntr <= sig_byte_cntr + sig_byte_cntr_incr_value;
              
            else
              null;  -- hold current value
            end if; 
         end if;       
       end process IMP_BYTE_CMTR; 
 
 
     
 
     
   
        
    ------------------------------------------------------------
    -- Instance: I_IBTTCC_STBS_SET 
    --
    -- Description:
    --   Instance of the asserted strobe counter for the IBTTCC
    -- interface.   
    --
    ------------------------------------------------------------

SAME_WIDTH_NO_DRE : if (C_ENABLE_DRE = 0 and (C_STREAM_DWIDTH = C_MMAP_DWIDTH)) generate
begin 

    I_IBTTCC_STBS_SET : entity axi_datamover_v5_1_17.axi_datamover_stbs_set_nodre
    generic map (
  
      C_STROBE_WIDTH      =>  STRM_WSTB_WIDTH   
  
      )
    port map (
  
      tstrb_in            =>  dre2ibtt_tstrb,
      num_stbs_asserted   =>  sig_stbs2sfcc_asserted  -- 8 bit wide slv
  
      );
  
end generate SAME_WIDTH_NO_DRE;    
    
   
DIFF_WIDTH_OR_DRE : if (C_ENABLE_DRE /= 0 or (C_STREAM_DWIDTH /= C_MMAP_DWIDTH)) generate
begin 

    I_IBTTCC_STBS_SET : entity axi_datamover_v5_1_17.axi_datamover_stbs_set
    generic map (
  
      C_STROBE_WIDTH      =>  STRM_WSTB_WIDTH   
  
      )
    port map (
  
      tstrb_in            =>  dre2ibtt_tstrb,
      num_stbs_asserted   =>  sig_stbs2sfcc_asserted  -- 8 bit wide slv
  
      );
  
end generate DIFF_WIDTH_OR_DRE;    
 
 


 
     
 
    -----  Xfer Descriptor FIFO Logic -----------------------------------------------
     
   
    sig_push_xd_fifo    <= sig_clr_dbc_reg ;
    
    sig_pop_xd_fifo     <= sig_pcc2ibtt_xfer_ready and
                           sig_xd_fifo_dvalid ;
   
    sig_xd_fifo_data_in <= sig_dre2ibtt_eop_reg   &         -- (TLAST for the input Stream)
                           sig_dre2ibtt_tlast_reg &         -- (TLAST for the IBTTCC command)
                           std_logic_vector(sig_byte_cntr); -- Number of bytes in this xfer
                              
                              
                                
    ------------------------------------------------------------
    -- Instance: I_XD_FIFO 
    --
    -- Description:
    -- Implement the Transfer Desciptor (XD) FIFO. This FIFO holds
    -- the individual child command xfer descriptors used by the
    -- IBTTCC to generate the commands sent to the Address Cntlr and
    -- the Data Cntlr.    
    --
    ------------------------------------------------------------
    I_XD_FIFO : entity axi_datamover_v5_1_17.axi_datamover_sfifo_autord
    generic map (

    C_DWIDTH                =>  XD_FIFO_WIDTH        ,  
    C_DEPTH                 =>  XD_FIFO_DEPTH        ,  
    C_DATA_CNT_WIDTH        =>  XD_FIFO_CNT_WIDTH    ,  
    C_NEED_ALMOST_EMPTY     =>  0                    ,  
    C_NEED_ALMOST_FULL      =>  1                    ,  
    C_USE_BLKMEM            =>  0                    ,  
    C_FAMILY                =>  C_FAMILY                

      )
    port map (

   -- Inputs 
    SFIFO_Sinit             =>  mmap_reset            , 
    SFIFO_Clk               =>  primary_aclk          , 
    SFIFO_Wr_en             =>  sig_push_xd_fifo      , 
    SFIFO_Din               =>  sig_xd_fifo_data_in   , 
    SFIFO_Rd_en             =>  sig_pop_xd_fifo       , 
    SFIFO_Clr_Rd_Data_Valid =>  LOGIC_LOW             , 
    
   -- Outputs
    SFIFO_DValid            =>  sig_xd_fifo_dvalid    , 
    SFIFO_Dout              =>  sig_xd_fifo_data_out  , 
    SFIFO_Full              =>  sig_xd_fifo_full      , 
    SFIFO_Empty             =>  open                  , 
    SFIFO_Almost_full       =>  sig_tmp                  , 
    SFIFO_Almost_empty      =>  open                  , 
    SFIFO_Rd_count          =>  open                  ,  
    SFIFO_Rd_count_minus1   =>  open                  ,  
    SFIFO_Wr_count          =>  open                  ,  
    SFIFO_Rd_ack            =>  open                    

    );


 
 
 
 
 
 
 
 
 
 
 
 ---------------------------------------------------------------- 
 -- Packing Logic      ------------------------------------------
 ---------------------------------------------------------------- 
 
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_PACKING
    --
    -- If Generate Description:
    --    Omits any packing logic in the Store and Forward module.
    -- The Stream and MMap data widths are the same.
    --
    ------------------------------------------------------------
    OMIT_PACKING : if (C_MMAP_DWIDTH = C_STREAM_DWIDTH) generate
    
       
       
       begin
    
        
         -- The data beat counter is always enabled when the packer
         -- is omitted.
         sig_enable_dbcntr     <= '1'; 
         
         sig_good_fifo_write   <= sig_good_strm_dbeat;
         
         sig_strm_in_ready     <= not(sig_xd_fifo_full) and
                                  not(sig_data_fifo_full) and
                                  not (sig_tmp);
         
  
GEN_S2MM_TKEEP_ENABLE5 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin

         -- Concatonate the Stream inputs into the single FIFO data 
         -- word input value 
         sig_data_fifo_data_in <= dre2ibtt_eop     &  -- end of packet marker
                                  dre2ibtt_tlast   &  -- Tlast marker
                                  dre2ibtt_tstrb   &  -- TSTRB Value
                                  dre2ibtt_tdata;     -- data value


end generate GEN_S2MM_TKEEP_ENABLE5;

GEN_S2MM_TKEEP_DISABLE5 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin
         -- Concatonate the Stream inputs into the single FIFO data 
         -- word input value 
         sig_data_fifo_data_in <= dre2ibtt_eop     &  -- end of packet marker
                                  dre2ibtt_tlast   &  -- Tlast marker
                                  --dre2ibtt_tstrb   &  -- TSTRB Value
                                  dre2ibtt_tdata;     -- data value
end generate GEN_S2MM_TKEEP_DISABLE5;


           
       end generate OMIT_PACKING;
     
     
    
    
  
  
  
  
  
  
  
  
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_PACKING
    --
    -- If Generate Description:
    --    Includes packing logic in the IBTT Store and Forward 
    -- module. The MMap Data bus is wider than the Stream width.
    --
    ------------------------------------------------------------
    INCLUDE_PACKING : if (C_MMAP_DWIDTH > C_STREAM_DWIDTH) generate
    
      
      Constant TLAST_WIDTH           : integer := 1; -- bit
      Constant EOP_WIDTH             : integer := 1; -- bit
      
      
      Constant DATA_SLICE_WIDTH      : integer := C_STREAM_DWIDTH;
      Constant STRB_SLICE_WIDTH      : integer := STRM_WSTB_WIDTH;
      
      Constant FLAG_SLICE_WIDTH      : integer := TLAST_WIDTH + 
                                                  EOP_WIDTH;
      
      
      Constant OFFSET_CNTR_WIDTH     : integer := funct_get_cntr_width(MMAP2STRM_WIDTH_RATO);
      
      Constant OFFSET_CNT_ONE        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(1, OFFSET_CNTR_WIDTH);
      
      Constant OFFSET_CNT_MAX        : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := 
                                       TO_UNSIGNED(MMAP2STRM_WIDTH_RATO-1, OFFSET_CNTR_WIDTH);
      
      
      
      
      -- Types -----------------------------------------------------------------------------
      type lsig_data_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(DATA_SLICE_WIDTH-1 downto 0);

      type lsig_strb_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(STRB_SLICE_WIDTH-1 downto 0);

      type lsig_flag_slice_type is array(MMAP2STRM_WIDTH_RATO-1 downto 0) of
                    std_logic_vector(FLAG_SLICE_WIDTH-1 downto 0);


       
      -- local signals
      
      signal lsig_data_slice_reg       : lsig_data_slice_type;
      signal lsig_strb_slice_reg       : lsig_strb_slice_type;
      signal lsig_flag_slice_reg       : lsig_flag_slice_type;
      
       
      signal lsig_reg_segment          : std_logic_vector(DATA_SLICE_WIDTH-1 downto 0)   := (others => '0');
      signal lsig_segment_ld           : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      signal lsig_segment_clr          : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      
      signal lsig_0ffset_to_to_use     : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := (others => '0');
      
      signal lsig_0ffset_cntr          : unsigned(OFFSET_CNTR_WIDTH-1 downto 0) := (others => '0');
      signal lsig_ld_offset            : std_logic := '0';
      signal lsig_incr_offset          : std_logic := '0';
      signal lsig_offset_cntr_eq_max   : std_logic := '0';
      
      signal lsig_combined_data        : std_logic_vector(C_MMAP_DWIDTH-1 downto 0) := (others => '0');
      signal lsig_combined_strb        : std_logic_vector(MMAP_WSTB_WIDTH-1 downto 0) := (others => '0');
      
      
      signal lsig_tlast_or             : std_logic := '0';
      signal lsig_eop_or               : std_logic := '0';
      
      signal lsig_partial_tlast_or     : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      signal lsig_partial_eop_or       : std_logic_vector(MMAP2STRM_WIDTH_RATO-1 downto 0) := (others => '0');
      
      signal lsig_packer_full          : std_logic := '0';
      signal lsig_packer_empty         : std_logic := '0';
      signal lsig_set_packer_full      : std_logic := '0';
      signal lsig_good_push2fifo       : std_logic := '0';
      signal lsig_first_dbeat          : std_logic := '0';
        
        
      begin
    

       -- Generate the stream ready
       sig_strm_in_ready       <= not(sig_xd_fifo_full) and
                                  not(sig_tmp) and
                                  (not(lsig_packer_full) or
                                  lsig_good_push2fifo) ;
    
        
        
       -- Enable the Data Beat counter when the packer is 
       -- going full
       sig_enable_dbcntr       <= lsig_set_packer_full; 

       
       -- Assign the flag indicating that a fifo write is going
       -- to occur at the next rising clock edge.
       sig_good_fifo_write     <=  lsig_good_push2fifo;
       
GEN_S2MM_TKEEP_ENABLE6 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin
     -- Format the composite FIFO input data word
       sig_data_fifo_data_in   <= lsig_eop_or        &   -- MS Bit
                                  lsig_tlast_or      &
                                  lsig_combined_strb &
                                  lsig_combined_data  ;  -- LS Bits
        

 
end generate GEN_S2MM_TKEEP_ENABLE6;

GEN_S2MM_TKEEP_DISABLE6 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin
     -- Format the composite FIFO input data word
       sig_data_fifo_data_in   <= lsig_eop_or        &   -- MS Bit
                                  lsig_tlast_or      &
                                  --lsig_combined_strb &
                                  lsig_combined_data  ;  -- LS Bits
        


end generate GEN_S2MM_TKEEP_DISABLE6;

       
         
       -- Generate a flag indicating a write to the DataFIFO 
       -- is going to complete 
       lsig_good_push2fifo    <=  lsig_packer_full and
                                  not(sig_data_fifo_full);
       
       -- Generate the control that loads the starting address
       -- offset for the next input packet
       lsig_ld_offset          <= lsig_first_dbeat and
                                  sig_good_strm_dbeat;
                                  
       -- Generate the control for incrementing the offset counter
       lsig_incr_offset        <= sig_good_strm_dbeat;
       
       
       -- Generate a flag indicating the packer input register
       -- array is full or has loaded the last data beat of
       -- the input paket
       lsig_set_packer_full    <=  sig_good_strm_dbeat  and
                                   (dre2ibtt_tlast      or 
                                    lsig_offset_cntr_eq_max);

       -- Check to see if the offset counter has reached its max
       -- value
       lsig_offset_cntr_eq_max <=  '1'
         --when  (lsig_0ffset_cntr = OFFSET_CNT_MAX)
         when  (lsig_0ffset_to_to_use = OFFSET_CNT_MAX)
         Else '0';
       
       
       -- Mux between the input start offset and the offset counter
       -- output to use for the packer slice load control.  
       lsig_0ffset_to_to_use <= UNSIGNED(dre2ibtt_strt_addr_offset) 
         when (lsig_first_dbeat = '1')
         Else lsig_0ffset_cntr;
       
        
        
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_OFFSET_LD_MARKER
       --
       -- Process Description:
       --  Implements the flop indicating the first databeat of
       -- an input data packet.
       --
       -------------------------------------------------------------
       IMP_OFFSET_LD_MARKER : process (primary_aclk)
         begin
           if (primary_aclk'event and primary_aclk = '1') then
              if (mmap_reset = '1') then
       
                lsig_first_dbeat <= '1';
       
              elsif (sig_good_strm_dbeat = '1' and
                     dre2ibtt_tlast      = '0') then
       
                lsig_first_dbeat <= '0';
       
              Elsif (sig_good_strm_dbeat = '1' and
                     dre2ibtt_tlast      = '1') Then
              
                lsig_first_dbeat <= '1';
              
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_OFFSET_LD_MARKER; 
       
       
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_OFFSET_CNTR
       --
       -- Process Description:
       --  Implements the address offset counter that is used to 
       -- steer the data loads into the packer register slices.
       -- Note that the counter has to be loaded with the starting
       -- offset plus one to sync up with the data input.
       -------------------------------------------------------------
       IMP_OFFSET_CNTR : process (primary_aclk)
         begin
           if (primary_aclk'event and primary_aclk = '1') then
              if (mmap_reset = '1') then
       
                lsig_0ffset_cntr <= (others => '0');
       
              Elsif (lsig_ld_offset = '1') Then
              
               lsig_0ffset_cntr <= UNSIGNED(dre2ibtt_strt_addr_offset) + OFFSET_CNT_ONE;
              
              elsif (lsig_incr_offset = '1') then
       
                lsig_0ffset_cntr <= lsig_0ffset_cntr + OFFSET_CNT_ONE;
       
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_OFFSET_CNTR; 
       
       
       
       
       
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: IMP_PACK_REG_FULL
       --
       -- Process Description:
       --   Implements the Packer Register full/empty flags
       --
       -------------------------------------------------------------
       IMP_PACK_REG_FULL : process (primary_aclk)
         begin
           if (primary_aclk'event and primary_aclk = '1') then
              if (mmap_reset = '1') then
       
                lsig_packer_full  <= '0';
                lsig_packer_empty <= '1';
       
              Elsif (lsig_set_packer_full = '1' and
                     lsig_packer_full     = '0') Then
              
                lsig_packer_full  <= '1';
                lsig_packer_empty <= '0';
       
              elsif (lsig_set_packer_full = '0' and
                     lsig_good_push2fifo  = '1') then
              
                lsig_packer_full  <= '0';
                lsig_packer_empty <= '1';
       
              else
       
                null;  -- Hold Current State
       
              end if; 
           end if;       
         end process IMP_PACK_REG_FULL; 
       
       
       
       
       
       
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_REG_SLICES
       --
       -- For Generate Description:
       --
       --  Implements the Packng Register Slices
       --
       --
       ------------------------------------------------------------
       DO_REG_SLICES : for slice_index in 0 to MMAP2STRM_WIDTH_RATO-1 generate


       
       begin
       
        
         -- generate the register load enable for each slice segment based
         -- on the address offset count value
         lsig_segment_ld(slice_index) <= '1'
           when (sig_good_strm_dbeat = '1' and
                TO_INTEGER(lsig_0ffset_to_to_use) = slice_index)
           Else '0';
         
         
        
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_DATA_SLICE
         --
         -- Process Description:
         --   Implement a data register slice abd Strobe register slice 
         -- for the packer (upsizer). 
         --
         -------------------------------------------------------------
         IMP_DATA_SLICE : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
               if (mmap_reset = '1') then
        
                 lsig_data_slice_reg(slice_index) <= (others => '0');
                 lsig_strb_slice_reg(slice_index) <= (others => '0');
                 
                 
               elsif (lsig_segment_ld(slice_index) = '1') then
        
                 lsig_data_slice_reg(slice_index) <= dre2ibtt_tdata;
                 lsig_strb_slice_reg(slice_index) <= dre2ibtt_tstrb;
        
               -- optional clear of slice reg 
               elsif (lsig_segment_ld(slice_index) = '0' and
                      lsig_good_push2fifo          = '1') then

                 lsig_data_slice_reg(slice_index) <= (others => '0');
                 lsig_strb_slice_reg(slice_index) <= (others => '0');
        
               else
        
                 null;  -- Hold Current State
        
               end if; 
             end if;       
           end process IMP_DATA_SLICE; 
        
        
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_FLAG_SLICE
         --
         -- Process Description:
         --   Implement a flag register slice for the packer.
         --
         -------------------------------------------------------------
         IMP_FLAG_SLICE : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
               if (mmap_reset = '1') then
        
                 lsig_flag_slice_reg(slice_index) <= (others => '0');
        
               elsif (lsig_segment_ld(slice_index) = '1') then
        
                 lsig_flag_slice_reg(slice_index) <= dre2ibtt_tlast & -- bit 1
                                                     dre2ibtt_eop;    -- bit 0
               
               elsif (lsig_segment_ld(slice_index) = '0' and
                      lsig_good_push2fifo          = '1') then

                 lsig_flag_slice_reg(slice_index) <= (others => '0');
        
               else
        
                 null;  -- Hold Current State
        
               end if; 
             end if;       
           end process IMP_FLAG_SLICE; 
        
        
        
         
       end generate DO_REG_SLICES;
       
       
        
        
        
        
                                                                                
       -- Do the OR functions of the Flags -------------------------------------
       lsig_tlast_or            <= lsig_partial_tlast_or(MMAP2STRM_WIDTH_RATO-1) ;
       lsig_eop_or              <= lsig_partial_eop_or(MMAP2STRM_WIDTH_RATO-1);
       
       lsig_partial_tlast_or(0) <= lsig_flag_slice_reg(0)(1);
       lsig_partial_eop_or(0)   <= lsig_flag_slice_reg(0)(0);
       

       
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_FLAG_OR
       --
       -- For Generate Description:
       --  Implement the OR of the TLAST and EOP Error flags.
       --
       --
       --
       ------------------------------------------------------------
       DO_FLAG_OR : for slice_index in 1 to MMAP2STRM_WIDTH_RATO-1 generate
       
       begin
     
          lsig_partial_tlast_or(slice_index) <= lsig_partial_tlast_or(slice_index-1) or
                                                --lsig_partial_tlast_or(slice_index);
                                                lsig_flag_slice_reg(slice_index)(1);
                                                  
                                                  
                                                  
                                                  
          lsig_partial_eop_or(slice_index)   <= lsig_partial_eop_or(slice_index-1) or
                                                --lsig_partial_eop_or(slice_index); 
                                                lsig_flag_slice_reg(slice_index)(0);
  
  
       end generate DO_FLAG_OR;
  
       
  
       
       

     
        
        
     
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: DO_DATA_COMBINER
       --
       -- For Generate Description:
       --   Combines the Data Slice register and Strobe slice register
       -- outputs into a single data and single strobe vector used for 
       -- input data to the Data FIFO.
       --
       --
       ------------------------------------------------------------
       DO_DATA_COMBINER : for slice_index in 1 to MMAP2STRM_WIDTH_RATO generate
       
       begin
        
         lsig_combined_data((slice_index*DATA_SLICE_WIDTH)-1 downto 
                            (slice_index-1)*DATA_SLICE_WIDTH) <=
                            lsig_data_slice_reg(slice_index-1);
        
         
         lsig_combined_strb((slice_index*STRB_SLICE_WIDTH)-1 downto 
                            (slice_index-1)*STRB_SLICE_WIDTH) <=
                            lsig_strb_slice_reg(slice_index-1);
        
        
       end generate DO_DATA_COMBINER;
     
     
     
     
     
     
     
       
      end generate INCLUDE_PACKING;
     
     
    
    
  
  
  
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 -- Data FIFO Logic ------------------------------------------
 
     --sig_push_data_fifo <= sig_good_strm_dbeat;
     sig_push_data_fifo <= sig_good_fifo_write;
     
     
     
     sig_pop_data_fifo  <= sig_skidbuf_in_tready and 
                           sig_data_fifo_dvalid;
     
     
     
    -- -- Concatonate the Stream inputs into the single FIFO data in value 
    --  sig_data_fifo_data_in <= dre2ibtt_eop   &  -- end of packet marker
    --                           dre2ibtt_tlast &
    --                           dre2ibtt_tstrb & 
    --                           dre2ibtt_tdata;
 
                                                     
    ------------------------------------------------------------
    -- Instance: I_DATA_FIFO 
    --
    -- Description:
    --  Implements the Store and Forward data FIFO   
    --
    ------------------------------------------------------------
    I_DATA_FIFO : entity axi_datamover_v5_1_17.axi_datamover_sfifo_autord
    generic map (

      C_DWIDTH                =>  DATA_FIFO_WIDTH       ,  
      C_DEPTH                 =>  DATA_FIFO_DEPTH       ,  
      C_DATA_CNT_WIDTH        =>  DATA_FIFO_CNT_WIDTH   ,  
      C_NEED_ALMOST_EMPTY     =>  0                     ,  
      C_NEED_ALMOST_FULL      =>  0                     ,  
      C_USE_BLKMEM            =>  1                     ,  
      C_FAMILY                =>  C_FAMILY                 

      )
    port map (

     -- Inputs 
      SFIFO_Sinit             =>  mmap_reset             , 
      SFIFO_Clk               =>  primary_aclk           , 
      SFIFO_Wr_en             =>  sig_push_data_fifo     , 
      SFIFO_Din               =>  sig_data_fifo_data_in  , 
      SFIFO_Rd_en             =>  sig_pop_data_fifo      , 
      SFIFO_Clr_Rd_Data_Valid =>  LOGIC_LOW              , 
      
     -- Outputs
      SFIFO_DValid            =>  sig_data_fifo_dvalid   , 
      SFIFO_Dout              =>  sig_data_fifo_data_out , 
      SFIFO_Full              =>  sig_data_fifo_full     , 
      SFIFO_Empty             =>  open                   , 
      SFIFO_Almost_full       =>  open                   , 
      SFIFO_Almost_empty      =>  open                   , 
      SFIFO_Rd_count          =>  sig_data_fifo_rd_cnt   ,  
      SFIFO_Rd_count_minus1   =>  open                   ,  
      SFIFO_Wr_count          =>  sig_data_fifo_wr_cnt   ,  
      SFIFO_Rd_ack            =>  open                     

    );



 
 
    
    
    
 
 
    -------------------------------------------------------------------------
    ----------------  Asserted TSTRB calculation logic  --------------------- 
    -------------------------------------------------------------------------
     
GEN_S2MM_TKEEP_ENABLE7 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin

    
     -- Rip the write strobe value from the FIFO output data
     sig_fifo_tstrb_out   <=  sig_data_fifo_data_out(DATA_FIFO_WIDTH-3 downto 
                                                     C_MMAP_DWIDTH);
                                

end generate GEN_S2MM_TKEEP_ENABLE7;

GEN_S2MM_TKEEP_DISBALE7 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin

     sig_fifo_tstrb_out   <= (others => '1');

end generate GEN_S2MM_TKEEP_DISBALE7;


   
        
    ------------------------------------------------------------
    -- Instance: I_WDC_STBS_SET 
    --
    -- Description:
    --   Instance of the asserted strobe counter for the WDC
    -- interface.   
    --
    ------------------------------------------------------------
SAME_WIDTH_NO_DRE_WDC : if (C_ENABLE_DRE = 0 and (C_STREAM_DWIDTH = C_MMAP_DWIDTH)) generate
begin
 

     I_WDC_STBS_SET : entity axi_datamover_v5_1_17.axi_datamover_stbs_set_nodre
     generic map (
    
       C_STROBE_WIDTH      =>  MMAP_WSTB_WIDTH   
    
       )
     port map (
    
       tstrb_in            =>  sig_fifo_tstrb_out,
       num_stbs_asserted   =>  sig_stbs2wdc_asserted
    
       );
    
end generate SAME_WIDTH_NO_DRE_WDC;    
    
   
DIFF_WIDTH_OR_DRE_WDC : if (C_ENABLE_DRE /= 0 or (C_STREAM_DWIDTH /= C_MMAP_DWIDTH)) generate
begin
 

     I_WDC_STBS_SET : entity axi_datamover_v5_1_17.axi_datamover_stbs_set
     generic map (
    
       C_STROBE_WIDTH      =>  MMAP_WSTB_WIDTH   
    
       )
     port map (
    
       tstrb_in            =>  sig_fifo_tstrb_out,
       num_stbs_asserted   =>  sig_stbs2wdc_asserted
    
       );
    
end generate DIFF_WIDTH_OR_DRE_WDC;    
    
    
     
     
    -------------------------------------------------------------------------
    -------  Isolation Skid Buffer Logic (needed for Fmax timing) ----------- 
    -------------------------------------------------------------------------
     
     
     -- Skid Buffer output assignments -----------
     sig_skidbuf_out_tready     <=  sig_wdc2ibtt_tready;
     sig_ibtt2wdc_tvalid        <=  sig_skidbuf_out_tvalid;
     sig_ibtt2wdc_tdata         <=  sig_skidbuf_out_tdata(C_MMAP_DWIDTH-1 downto 0) ;
     sig_ibtt2wdc_tstrb         <=  sig_skidbuf_out_tstrb(MMAP_WSTB_WIDTH-1 downto 0) ;
     sig_ibtt2wdc_tlast         <=  sig_skidbuf_out_tlast ;
                                                      
     -- Rip the EOP marker from the MS bit of the skid output strobes
     sig_ibtt2wdc_eop           <=  sig_skidbuf_out_tstrb(MMAP_WSTB_WIDTH) ;
     
     -- Rip the upper 8 bits of the skid output data for the strobes asserted value
     sig_ibtt2wdc_stbs_asserted <=  sig_skidbuf_out_tdata(SKIDBUF2WDC_DWIDTH-1 downto 
                                                          C_MMAP_DWIDTH);
     
     
    
     
     
     -- Skid Buffer input assignments -----------
    
     sig_skidbuf_in_tvalid <= sig_data_fifo_dvalid;
    
    
    
     sig_skidbuf_in_eop    <= sig_data_fifo_data_out(DATA_FIFO_WIDTH-1);
    
    
     
     sig_skidbuf_in_tlast  <= sig_data_fifo_data_out(DATA_FIFO_WIDTH-2);
     
    
     -- Steal the extra input strobe bit and use it for the EOP marker
----     sig_skidbuf_in_tstrb  <= sig_skidbuf_in_eop &
----                              sig_data_fifo_data_out(DATA_FIFO_WIDTH-3 downto 
----                                                     C_MMAP_DWIDTH);
---- 

     sig_skidbuf_in_tstrb  <= sig_skidbuf_in_eop &
                            sig_fifo_tstrb_out;
    
     -- Insert the Strobes Asserted count in the extra (MS) data byte 
     -- for the skid buffer
     sig_skidbuf_in_tdata <= sig_stbs2wdc_asserted &
                             sig_data_fifo_data_out(C_MMAP_DWIDTH-1 downto 0);
 

ENABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(2) = '1' generate
begin 


 
     ------------------------------------------------------------
     -- Instance: I_INDET_BTT_SKID_BUF 
     --
     -- Description:
     --   Instance for the Store and Forward isolation Skid Buffer
     -- which is required to achieve Fmax timing. Note that this 
     -- skid buffer is 1 byte wider than the stream data width to
     -- allow for the asserted strobes count to be passed through 
     -- it. The EOP marker is inserted in the extra strobe slot.
     --
     ------------------------------------------------------------
      I_INDET_BTT_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
      generic map (
         
        C_WDATA_WIDTH  =>  SKIDBUF2WDC_DWIDTH       
    
        )
      port map (
    
        -- System Ports
        aclk         =>  primary_aclk           ,  
        arst         =>  mmap_reset             ,  
     
        -- Shutdown control (assert for 1 clk pulse)
        skid_stop    =>  LOGIC_LOW              ,  
     
        -- Slave Side (Stream Data Input) 
        s_valid      =>  sig_skidbuf_in_tvalid  ,  
        s_ready      =>  sig_skidbuf_in_tready  ,  
        s_data       =>  sig_skidbuf_in_tdata   ,  
        s_strb       =>  sig_skidbuf_in_tstrb   ,  
        s_last       =>  sig_skidbuf_in_tlast   ,  

        -- Master Side (Stream Data Output 
        m_valid      =>  sig_skidbuf_out_tvalid ,  
        m_ready      =>  sig_skidbuf_out_tready ,  
        m_data       =>  sig_skidbuf_out_tdata  ,  
        m_strb       =>  sig_skidbuf_out_tstrb  ,  
        m_last       =>  sig_skidbuf_out_tlast     
    
        );
    
 
 
end generate ENABLE_AXIS_SKID;
  
    
DISABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(2) = '0' generate
begin 

     sig_skidbuf_out_tvalid <=   sig_skidbuf_in_tvalid;
     sig_skidbuf_in_tready  <=   sig_skidbuf_out_tready   ; 
     sig_skidbuf_out_tdata  <=   sig_skidbuf_in_tdata ;
     sig_skidbuf_out_tstrb  <=   sig_skidbuf_in_tstrb ;
     sig_skidbuf_out_tlast  <=   sig_skidbuf_in_tlast ;


end generate DISABLE_AXIS_SKID; 
 
 
 
 
  
  
  end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_dre_mux2_1_x_n.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_dre_mux2_1_x_n.vhd
--
-- Description:     
--                  
--  This VHDL file provides a 2 to 1 xn bit wide mux for the AXI Data Realignment 
--  Engine (DRE).                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use ieee.STD_LOGIC_UNSIGNED.all;
use ieee.std_logic_arith.all;

      



-------------------------------------------------------------------------------
-- Start 2 to 1 xN Mux
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------  
Entity axi_datamover_dre_mux2_1_x_n is
   generic (
      
      C_WIDTH : Integer := 8
        -- Sets the bit width of the 2x Mux slice
      
      ); 
   port ( 
       
       Sel    : In  std_logic;
         -- Mux select control
       
       I0     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 0 input
       
       I1     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 1 inputl
       
       Y      : Out std_logic_vector(C_WIDTH-1 downto 0)
         -- Mux output value
       
      );
end entity axi_datamover_dre_mux2_1_x_n; --  

Architecture implementation of axi_datamover_dre_mux2_1_x_n is

begin
    
   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: SELECT2_1
   --
   -- Process Description:
   --   This process implements an 2 to 1 mux.
   --
   -------------------------------------------------------------
   SELECT2_1 : process (Sel, I0, I1)
      begin
   
         case Sel is

           when '0' =>
               Y <= I0;
               
           when '1' =>
               Y <= I1;
                         
           when others =>
               Y <= I0;
         
         end case;
        
      end process SELECT2_1; 
    
end implementation; -- axi_datamover_dre_mux2_1_x_n
 
-------------------------------------------------------------------------------
-- End 2 to 1 xN Mux
-------------------------------------------------------------------------------
 


-------------------------------------------------------------------------------
-- axi_datamover_dre_mux4_1_x_n.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_dre_mux4_1_x_n.vhd
--
-- Description:     
--                  
--  This VHDL file provides a 4 to 1 by N bits wide mux for the AXI Data Realignment 
--  Engine (DRE).                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use ieee.STD_LOGIC_UNSIGNED.all;
use ieee.std_logic_arith.all;

         
         
-------------------------------------------------------------------------------
-- Start 4 to 1 xN Mux
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------  
Entity axi_datamover_dre_mux4_1_x_n is
   generic (
      
      C_WIDTH : Integer := 8
        -- Sets the bit width of the 4x Mux slice
      
      ); 
   port ( 
       Sel    : In  std_logic_vector(1 downto 0);
         -- Mux select control
       
       I0     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 0 input
       
       I1     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 1 input
       
       I2     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 2 input
       
       I3     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 3 input
       
       Y      : Out std_logic_vector(C_WIDTH-1 downto 0)
         -- Mux output value
       
      );
end entity axi_datamover_dre_mux4_1_x_n; --  

Architecture implementation of axi_datamover_dre_mux4_1_x_n is

begin
    
   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: SELECT4_1
   --
   -- Process Description:
   --   This process implements an 4 to 1 mux.
   --
   -------------------------------------------------------------
   SELECT4_1 : process (Sel, I0, I1, I2, I3)
      begin
   
         case Sel is

           when "00" =>
               Y <= I0;
               
           when "01" =>
               Y <= I1;
               
           when "10" =>
               Y <= I2;
               
           when "11" =>
               Y <= I3;
               
           when others =>
               Y <= I0;
               
         end case;
         
      end process SELECT4_1; 

end implementation; -- axi_datamover_dre_mux4_1_x_n
 
 
-------------------------------------------------------------------------------
-- End 4 to 1 xN Mux
-------------------------------------------------------------------------------
      





-------------------------------------------------------------------------------
-- axi_datamover_dre_mux8_1_x_n.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_dre_mux8_1_x_n.vhd
--
-- Description:     
--                  
--  This VHDL file provides a 8 to 1 xn bit wide mux for the AXI Data Realignment 
--  Engine (DRE).                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
---------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use ieee.STD_LOGIC_UNSIGNED.all;
use ieee.std_logic_arith.all;



-------------------------------------------------------------------------------
-- Start 8 to 1 xN Mux
-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
Entity axi_datamover_dre_mux8_1_x_n is
   generic (
      
      C_WIDTH : Integer := 8
        -- Sets the bit width of the 8x Mux slice
      
      ); 
   port ( 
       Sel    : In  std_logic_vector(2 downto 0);
         -- Mux select control
       
       I0     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 0 input
       
       I1     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 1 input
       
       I2     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 2 input
       
       I3     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 3 input
       
       I4     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 4 input
       
       I5     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 5 input
       
       I6     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 6 input
       
       I7     : In  std_logic_vector(C_WIDTH-1 downto 0);
         -- Select 7 input
       
       Y      : Out std_logic_vector(C_WIDTH-1 downto 0)
         -- Mux output value
       
      );
end entity axi_datamover_dre_mux8_1_x_n; --  

Architecture implementation of axi_datamover_dre_mux8_1_x_n is
    
    

begin
   
   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: SELECT8_1
   --
   -- Process Description:
   --   This process implements an 8 to 1 mux.
   --
   -------------------------------------------------------------
   SELECT8_1 : process (Sel, I0, I1, I2, I3,
                        I4, I5, I6, I7)
      begin
   
         case Sel is

           when "000" =>
               Y <= I0;
               
           when "001" =>
               Y <= I1;
               
           when "010" =>
               Y <= I2;
               
           when "011" =>
               Y <= I3;
               
           when "100" =>
               Y <= I4;
               
           when "101" =>
               Y <= I5;
               
           when "110" =>
               Y <= I6;
               
           when "111" =>
               Y <= I7;
               
           when others =>
               Y <= I0;
         end case;
        
      end process SELECT8_1; 

 
 
 
 
 
 
end implementation; -- axi_datamover_dre_mux8_1_x_n
 
 
-------------------------------------------------------------------------------
-- End 8 to 1 xN Mux
-------------------------------------------------------------------------------





-------------------------------------------------------------------------------
-- axi_datamover_mm2s_dre.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_mm2s_dre.vhd
--
-- Description:
--     This VHDL design implements a 64 bit wide (8 byte lane) function that
-- realigns an arbitrarily aligned input data stream to an arbitrarily aligned
-- output data stream.
--
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
---------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library axi_datamover_v5_1_17;
use axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n;
use axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n;
use axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n;


-------------------------------------------------------------------------------

entity axi_datamover_mm2s_dre is
  Generic (
    
    C_DWIDTH          : Integer := 64;
      -- Sets the native data width of the DRE
      
    C_ALIGN_WIDTH     : Integer :=  3
      -- Sets the alignment port widths. The value should be
      -- log2(C_DWIDTH)
     
    );
  port (
   
   -- Clock and Reset inputs ---------------
    dre_clk          : In  std_logic;     --
    dre_rst          : In  std_logic;     --
    ----------------------------------------
    
    
    -- Alignment Controls ------------------------------------------------ 
    dre_new_align    : In  std_logic;                                   --
    dre_use_autodest : In  std_logic;                                   --
    dre_src_align    : In  std_logic_vector(C_ALIGN_WIDTH-1 downto 0);  --
    dre_dest_align   : In  std_logic_vector(C_ALIGN_WIDTH-1 downto 0);  --
    dre_flush        : In  std_logic;                                   --
    ----------------------------------------------------------------------

                                                               
    -- Input Stream Interface --------------------------------------------
    dre_in_tstrb     : In  std_logic_vector((C_DWIDTH/8)-1 downto 0);   --
    dre_in_tdata     : In  std_logic_vector(C_DWIDTH-1 downto 0);       --
    dre_in_tlast     : In  std_logic;                                   --
    dre_in_tvalid    : In  std_logic;                                   --
    dre_in_tready    : Out std_logic;                                   --
    ----------------------------------------------------------------------

   
    -- Output Stream Interface -------------------------------------------
    dre_out_tstrb     : Out std_logic_vector((C_DWIDTH/8)-1 downto 0);  --
    dre_out_tdata     : Out std_logic_vector(C_DWIDTH-1 downto 0);      --
    dre_out_tlast     : Out std_logic;                                  --
    dre_out_tvalid    : Out std_logic;                                  --
    dre_out_tready    : In  std_logic                                   --
    ----------------------------------------------------------------------
    
    );

end entity axi_datamover_mm2s_dre;


architecture implementation of axi_datamover_mm2s_dre is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  
  -- Functions

     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_start_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the MSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_start_index (lane_index : integer;
                               lane_width : integer)
                               return integer is

        Variable bit_index_start : Integer := 0;

     begin

        bit_index_start := lane_index*lane_width;

        return(bit_index_start);

     end function get_start_index;


     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_end_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the LSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_end_index (lane_index : integer;
                             lane_width : integer)
                             return integer is

        Variable bit_index_end   : Integer := 0;

     begin

        bit_index_end   := (lane_index*lane_width) + (lane_width-1);

        return(bit_index_end);

     end function get_end_index;




  -- Constants

      Constant BYTE_WIDTH         : integer := 8; -- bits
      Constant DATA_WIDTH_BYTES   : integer := C_DWIDTH/BYTE_WIDTH;
      Constant SLICE_WIDTH        : integer := BYTE_WIDTH+2; -- 8 data bits plus Strobe plus TLAST bit
      Constant SLICE_STROBE_INDEX : integer := (BYTE_WIDTH-1)+1;
      Constant SLICE_TLAST_INDEX  : integer := SLICE_STROBE_INDEX+1;
      Constant ZEROED_SLICE       : std_logic_vector(SLICE_WIDTH-1 downto 0) := (others => '0');
      Constant NUM_BYTE_LANES     : integer := C_DWIDTH/BYTE_WIDTH;
      Constant ALIGN_VECT_WIDTH   : integer := C_ALIGN_WIDTH;
      Constant NO_STRB_SET_VALUE  : integer := 0;
  
      
  
  -- Types

      type sig_byte_lane_type is array(DATA_WIDTH_BYTES-1 downto 0) of
                    std_logic_vector(SLICE_WIDTH-1 downto 0);



  -- Signals

      signal sig_input_data_reg       : sig_byte_lane_type;
      signal sig_delay_data_reg       : sig_byte_lane_type;
      signal sig_output_data_reg      : sig_byte_lane_type;
      signal sig_pass_mux_bus         : sig_byte_lane_type;
      signal sig_delay_mux_bus        : sig_byte_lane_type;
      signal sig_final_mux_bus        : sig_byte_lane_type;
      Signal sig_dre_strb_out_i       : std_logic_vector(DATA_WIDTH_BYTES-1 downto 0) := (others => '0');
      Signal sig_dre_data_out_i       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
      Signal sig_dest_align_i         : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_dre_flush_i          : std_logic := '0';
      Signal sig_pipeline_halt        : std_logic := '0';
      Signal sig_dre_tvalid_i         : std_logic := '0';
      Signal sig_input_accept         : std_logic := '0';
      Signal sig_tlast_enables        : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      signal sig_final_mux_has_tlast  : std_logic := '0';
      signal sig_tlast_out            : std_logic := '0';
      Signal sig_tlast_strobes        : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      Signal sig_next_auto_dest       : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_current_dest_align   : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_last_written_strb    : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      Signal sig_auto_flush           : std_logic := '0';
      Signal sig_flush_db1            : std_logic := '0';
      Signal sig_flush_db2            : std_logic := '0';
      signal sig_flush_db1_complete   : std_logic := '0';
      signal sig_flush_db2_complete   : std_logic := '0';
      signal sig_output_xfer          : std_logic := '0';
      signal sig_advance_pipe_data    : std_logic := '0';
      Signal sig_flush_reg            : std_logic := '0';
      Signal sig_input_flush_stall    : std_logic := '0';
      signal sig_enable_input_rdy     : std_logic := '0';
      signal sig_input_ready          : std_logic := '0';

function func_ret_int_6 (slv : std_logic_vector (5 downto 0)) return integer is

 Variable number : Integer range 0 to 63 := 0;

begin

  case slv is
     when "000000" =>
        number := 0;
     when "000001" =>
        number := 1;
     when "000010" =>
        number := 2;
     when "000011" =>
        number := 3;
     when "000100" =>
        number := 4;
     when "000101" =>
        number := 5;
     when "000110" =>
        number := 6;
     when "000111" =>
        number := 7;
     when "001000" =>
        number := 8;
     when "001001" =>
        number := 9;
     when "001010" =>
        number := 10;
     when "001011" =>
        number := 11;
     when "001100" =>
        number := 12;
     when "001101" =>
        number := 13;
     when "001110" =>
        number := 14;
     when "001111" =>
        number := 15;
     when "010000" =>
        number := 16;
     when "010001" =>
        number := 17;
     when "010010" =>
        number := 18;
     when "010011" =>
        number := 19;
     when "010100" =>
        number := 20;
     when "010101" =>
        number := 21;
     when "010110" =>
        number := 22;
     when "010111" =>
        number := 23;
     when "011000" =>
        number := 24;
     when "011001" =>
        number := 25;
     when "011010" =>
        number := 26;
     when "011011" =>
        number := 27;
     when "011100" =>
        number := 28;
     when "011101" =>
        number := 29;
     when "011110" =>
        number := 30;
     when "011111" =>
        number := 31;
     when "100000" =>
        number := 32;
     when "100001" =>
        number := 33;
     when "100010" =>
        number := 34;
     when "100011" =>
        number := 35;
     when "100100" =>
        number := 36;
     when "100101" =>
        number := 37;
     when "100110" =>
        number := 38;
     when "100111" =>
        number := 39;
     when "101000" =>
        number := 40;
     when "101001" =>
        number := 41;
     when "101010" =>
        number := 42;
     when "101011" =>
        number := 43;
     when "101100" =>
        number := 44;
     when "101101" =>
        number := 45;
     when "101110" =>
        number := 46;
     when "101111" =>
        number := 47;
     when "110000" =>
        number := 48;
     when "110001" =>
        number := 49;
     when "110010" =>
        number := 50;
     when "110011" =>
        number := 51;
     when "110100" =>
        number := 52;
     when "110101" =>
        number := 53;
     when "110110" =>
        number := 54;
     when "110111" =>
        number := 55;
     when "111000" =>
        number := 56;
     when "111001" =>
        number := 57;
     when "111010" =>
        number := 58;
     when "111011" =>
        number := 59;
     when "111100" =>
        number := 60;
     when "111101" =>
        number := 61;
     when "111110" =>
        number := 62;
     when "111111" =>
        number := 63;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_6;
      
function func_ret_int_5 (slv : std_logic_vector (4 downto 0)) return integer is

 Variable number : Integer range 0 to 31 := 0;

begin

  case slv is
     when "00000" =>
        number := 0;
     when "00001" =>
        number := 1;
     when "00010" =>
        number := 2;
     when "00011" =>
        number := 3;
     when "00100" =>
        number := 4;
     when "00101" =>
        number := 5;
     when "00110" =>
        number := 6;
     when "00111" =>
        number := 7;
     when "01000" =>
        number := 8;
     when "01001" =>
        number := 9;
     when "01010" =>
        number := 10;
     when "01011" =>
        number := 11;
     when "01100" =>
        number := 12;
     when "01101" =>
        number := 13;
     when "01110" =>
        number := 14;
     when "01111" =>
        number := 15;
     when "10000" =>
        number := 16;
     when "10001" =>
        number := 17;
     when "10010" =>
        number := 18;
     when "10011" =>
        number := 19;
     when "10100" =>
        number := 20;
     when "10101" =>
        number := 21;
     when "10110" =>
        number := 22;
     when "10111" =>
        number := 23;
     when "11000" =>
        number := 24;
     when "11001" =>
        number := 25;
     when "11010" =>
        number := 26;
     when "11011" =>
        number := 27;
     when "11100" =>
        number := 28;
     when "11101" =>
        number := 29;
     when "11110" =>
        number := 30;
     when "11111" =>
        number := 31;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_5;


function func_ret_int_4 (slv : std_logic_vector (3 downto 0)) return integer is

 Variable number : Integer range 0 to 15 := 0;

begin

  case slv is
     when "0000" =>
        number := 0;
     when "0001" =>
        number := 1;
     when "0010" =>
        number := 2;
     when "0011" =>
        number := 3;
     when "0100" =>
        number := 4;
     when "0101" =>
        number := 5;
     when "0110" =>
        number := 6;
     when "0111" =>
        number := 7;
     when "1000" =>
        number := 8;
     when "1001" =>
        number := 9;
     when "1010" =>
        number := 10;
     when "1011" =>
        number := 11;
     when "1100" =>
        number := 12;
     when "1101" =>
        number := 13;
     when "1110" =>
        number := 14;
     when "1111" =>
        number := 15;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_4;
      
begin --(architecture implementation)

   
   
   
   
   
   -- Misc assignments

    --dre_in_tready            <= sig_input_accept   ;
    dre_in_tready            <= sig_input_ready    ;

    dre_out_tstrb            <= sig_dre_strb_out_i ;

    dre_out_tdata            <= sig_dre_data_out_i ;

    dre_out_tvalid           <= sig_dre_tvalid_i   ;
    
    dre_out_tlast            <= sig_tlast_out      ;

    sig_pipeline_halt        <= sig_dre_tvalid_i and not(dre_out_tready);


    sig_output_xfer          <= sig_dre_tvalid_i and dre_out_tready;
    
    
    sig_advance_pipe_data    <= (dre_in_tvalid or 
                                 sig_dre_flush_i) and
                                 not(sig_pipeline_halt) and
                                 sig_enable_input_rdy;
    
    sig_dre_flush_i          <= sig_auto_flush        ;
                                                                   

    sig_input_accept         <= dre_in_tvalid and
                                sig_input_ready;



    sig_flush_db1_complete   <= sig_flush_db1 and
                                not(sig_pipeline_halt);
    
                                                       
    sig_flush_db2_complete   <= sig_flush_db2 and
                                not(sig_pipeline_halt);

    sig_auto_flush           <= sig_flush_db1 or sig_flush_db2;
                            
                               
    sig_input_flush_stall    <= sig_auto_flush;     -- commanded flush needed for concatonation
    
    
    sig_last_written_strb    <= sig_dre_strb_out_i;
   
   
 
    sig_input_ready          <= sig_enable_input_rdy   and
                                not(sig_pipeline_halt) and
                                not(sig_input_flush_stall) ;
 
    
   
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_RESET_FLOP
   --
   -- Process Description:
   --   Just a flop for generating an input disable while reset
   -- is in progress.
   --
   -------------------------------------------------------------
   IMP_RESET_FLOP : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           
           if (dre_rst = '1') then
             
             sig_enable_input_rdy <= '0';
           
           else
             
             sig_enable_input_rdy <= '1';
           
           end if; 
        end if;       
      end process IMP_RESET_FLOP; 
   
   


   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_FLUSH_IN
   --
   -- Process Description:
   --  Register for the flush signal
   --
   -------------------------------------------------------------
   REG_FLUSH_IN : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           
           if (dre_rst       = '1' or
               sig_flush_db2 = '1') then
             
             sig_flush_reg <= '0';
           
           elsif (sig_input_accept = '1') then
             
             sig_flush_reg <= dre_flush;
           
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process REG_FLUSH_IN; 
   
   


   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: DO_FINAL_MUX_TLAST_OR
   --
   -- Process Description:
   -- Look at all associated tlast bits in the Final Mux output
   -- and detirmine if any are set.
   --  
   --
   -------------------------------------------------------------
   DO_FINAL_MUX_TLAST_OR : process (sig_final_mux_bus)
       
     Variable lvar_finalmux_or : std_logic_vector(NUM_BYTE_LANES-1 downto 0);
       
     begin
       
       lvar_finalmux_or(0) := sig_final_mux_bus(0)(SLICE_TLAST_INDEX);
       
       for tlast_index in 1 to NUM_BYTE_LANES-1 loop
       
          lvar_finalmux_or(tlast_index) := 
                       lvar_finalmux_or(tlast_index-1)   or
                       sig_final_mux_bus(tlast_index)(SLICE_TLAST_INDEX);
       
       end loop;
       
       
       sig_final_mux_has_tlast <= lvar_finalmux_or(NUM_BYTE_LANES-1);  
       
     
     end process DO_FINAL_MUX_TLAST_OR; 
  
    ------------------------------------------------------------------------
  
   
 
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: GEN_FLUSH_DB1
    --
    -- Process Description:
    --  Creates the first sequential flag indicating that the DRE needs to flush out
    -- current contents before allowing any new inputs. This is 
    -- triggered by the receipt of the TLAST.
    --
    -------------------------------------------------------------
    GEN_FLUSH_DB1 : process (dre_clk)
       begin

         if (dre_clk'event and dre_clk = '1') then

            If (dre_rst                = '1' or
                sig_flush_db2_complete = '1') Then
    
       
              sig_flush_db1   <= '0';

            Elsif (sig_input_accept = '1') Then
               
               sig_flush_db1  <= dre_flush or dre_in_tlast;

            else
              null;  -- hold state
            end if;
--         else
--           null;
         end if;
       end process GEN_FLUSH_DB1;


    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: GEN_FLUSH_DB2
    --
    -- Process Description:
    --  Creates a second sequential flag indicating that the DRE
    -- is flushing out current contents. This is 
    -- triggered by the assertion of the first sequential flush 
    -- flag.
    --
    -------------------------------------------------------------
    GEN_FLUSH_DB2 : process (dre_clk)
       begin

         if (dre_clk'event and dre_clk = '1') then

            If (dre_rst                = '1' or
                sig_flush_db2_complete = '1') Then
    
       
              sig_flush_db2   <= '0';

            elsif (sig_pipeline_halt = '0') then              

               sig_flush_db2  <= sig_flush_db1;

            else
              null;  -- hold state
            end if;
--         else
--           null;
         end if;
       end process GEN_FLUSH_DB2;



    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CALC_DEST_STRB_ALIGN
    --
    -- Process Description:
    --    This process calculates the byte lane position of the
    -- left-most STRB that is unasserted on the DRE output STRB bus.
    -- The resulting value is used as the Destination Alignment
    -- Vector for the DRE.
    --
    -------------------------------------------------------------
    CALC_DEST_STRB_ALIGN : process (sig_last_written_strb)

      Variable lvar_last_strb_hole_position : Integer range 0 to NUM_BYTE_LANES;
      Variable lvar_strb_hole_detected      : Boolean;
      Variable lvar_first_strb_assert_found : Boolean;
      Variable lvar_loop_count              : integer range 0 to NUM_BYTE_LANES;

      Begin

          lvar_loop_count               := NUM_BYTE_LANES;
          lvar_last_strb_hole_position  := 0;
          lvar_strb_hole_detected       := FALSE;
          lvar_first_strb_assert_found  := FALSE;

          -- Search through the output STRB bus starting with the MSByte
          while (lvar_loop_count > 0) loop

             If (sig_last_written_strb(lvar_loop_count-1) = '0' and
                 lvar_first_strb_assert_found  = FALSE) Then

                lvar_strb_hole_detected      := TRUE;
                lvar_last_strb_hole_position := lvar_loop_count-1;

             Elsif (sig_last_written_strb(lvar_loop_count-1) = '1') Then

                lvar_first_strb_assert_found  := true;

             else
                null; -- do nothing
             End if;

             lvar_loop_count := lvar_loop_count - 1;

          End loop;

          -- now assign the encoder output value to the bit position of the last Strobe encountered
          If (lvar_strb_hole_detected) Then
             
             sig_current_dest_align <= STD_LOGIC_VECTOR(TO_UNSIGNED(lvar_last_strb_hole_position, ALIGN_VECT_WIDTH));
             
          else
             
             sig_current_dest_align <= STD_LOGIC_VECTOR(TO_UNSIGNED(NO_STRB_SET_VALUE, ALIGN_VECT_WIDTH));
          
          End if;

       end process CALC_DEST_STRB_ALIGN;



   ------------------------------------------------------------
   ------------------------------------------------------------
   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: FORMAT_OUTPUT_DATA_STRB
   --
   -- For Generate Description:
   --   Connect the output Data and Strobe ports to the appropriate
   -- bits in the sig_output_data_reg.
   --
   ------------------------------------------------------------
   FORMAT_OUTPUT_DATA_STRB : for byte_lane_index in 0 to NUM_BYTE_LANES-1 generate

   begin

      sig_dre_data_out_i(get_end_index(byte_lane_index, BYTE_WIDTH) downto
               get_start_index(byte_lane_index, BYTE_WIDTH)) <=
               
           sig_output_data_reg(byte_lane_index)(BYTE_WIDTH-1 downto 0);

   
   
   
      sig_dre_strb_out_i(byte_lane_index)   <=
           sig_output_data_reg(byte_lane_index)(SLICE_WIDTH-2);


   end generate FORMAT_OUTPUT_DATA_STRB;
   ------------------------------------------------------------
   ------------------------------------------------------------
   ------------------------------------------------------------

   
   ---------------------------------------------------------------------------------
   -- Registers
   


   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_INPUT_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of input register slices.
   -- 
   --
   ------------------------------------------------------------
   GEN_INPUT_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
      
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: DO_INPUTREG_SLICE
       --
       -- Process Description:
       --  Implement a single register slice for the Input Register. 
       --
       -------------------------------------------------------------
       DO_INPUTREG_SLICE : process (dre_clk)
          begin
            if (dre_clk'event and dre_clk    = '1') then
               if (dre_rst                   = '1' or 
                   sig_flush_db1_complete    = '1' or      -- clear on reset or if
                  (dre_in_tvalid             = '1' and
                   sig_pipeline_halt         = '0' and     -- the pipe is being advanced and
                   dre_in_tstrb(slice_index) = '0')) then  -- no new valid data id being loaded
                 
                 sig_input_data_reg(slice_index) <= ZEROED_SLICE; 
               
               elsif (dre_in_tstrb(slice_index) = '1' and
                      sig_input_accept          = '1') then
                 
                 sig_input_data_reg(slice_index) <= sig_tlast_enables(slice_index) &
                                                    dre_in_tstrb(slice_index)      & 
                                                    dre_in_tdata((slice_index*8)+7 downto slice_index*8);
                 
               else
                 null; -- don't change state
               end if; 
            end if;       
          end process DO_INPUTREG_SLICE; 
      
      
      
      
   end generate GEN_INPUT_REG;
  
  

   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_DELAY_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of output register slices
   --
   --
   ------------------------------------------------------------
   GEN_DELAY_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
      
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: DO_DELAYREG_SLICE
       --
       -- Process Description:
       --  Implement a single register slice 
       --
       -------------------------------------------------------------
       DO_DELAYREG_SLICE : process (dre_clk)
          begin
            if (dre_clk'event and dre_clk = '1') then
               if (dre_rst = '1'    or                                              -- clear on reset or if
                  (sig_advance_pipe_data   = '1' and                                -- the pipe is being advanced and
                   sig_delay_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '0')) then  -- no new valid data id being loaded
                 
                 sig_delay_data_reg(slice_index) <= ZEROED_SLICE; 
               
               elsif (sig_delay_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '1' and
                      sig_advance_pipe_data   = '1') then
                 
                 sig_delay_data_reg(slice_index) <= sig_delay_mux_bus(slice_index);
                 
               else
                 null; -- don't change state
               end if; 
            end if;       
          end process DO_DELAYREG_SLICE; 
      
      
      
      
   end generate GEN_DELAY_REG;
  
  

   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_OUTPUT_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of output register slices
   --
   --
   ------------------------------------------------------------
   GEN_OUTPUT_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
      
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: DO_OUTREG_SLICE
       --
       -- Process Description:
       --  Implement a single register slice 
       --
       -------------------------------------------------------------
       DO_OUTREG_SLICE : process (dre_clk)
          begin
            if (dre_clk'event and dre_clk = '1') then
               if (dre_rst = '1'    or                                              -- clear on reset or if
                  (sig_output_xfer         = '1' and                                -- the output is being transfered and
                   sig_final_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '0')) then  -- no new valid data id being loaded
                 
                 sig_output_data_reg(slice_index) <= ZEROED_SLICE; 
               
               elsif (sig_final_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '1' and
                      sig_advance_pipe_data   = '1') then
                 
                 sig_output_data_reg(slice_index) <= sig_final_mux_bus(slice_index);
                 
               else
                 null; -- don't change state
               end if; 
            end if;       
          end process DO_OUTREG_SLICE; 
      
      
      
      
   end generate GEN_OUTPUT_REG;
  
  

   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: GEN_TVALID
   --
   -- Process Description:
   --   This sync process generates the Write request for the
   -- destination interface.
   --
   -------------------------------------------------------------
   GEN_TVALID : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           if (dre_rst        = '1') then

             sig_dre_tvalid_i <= '0';

           elsif (sig_advance_pipe_data = '1') then

              
              sig_dre_tvalid_i <= sig_final_mux_bus(NUM_BYTE_LANES-1)(SLICE_STROBE_INDEX) or -- MS Strobe is set or
                                  sig_final_mux_has_tlast;   -- the Last data beat of a packet
          
           Elsif (dre_out_tready   = '1' and    -- a completed write but no
                  sig_dre_tvalid_i = '1') Then  -- new input data so clear
                                                -- until more input data shows up
              sig_dre_tvalid_i <= '0';
          
           else
             null; -- hold state
           end if;
--        else
--          null;
        end if;
      end process GEN_TVALID;


   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: GEN_TLAST_OUT
   --
   -- Process Description:
   --   This sync process generates the TLAST output for the
   -- destination interface.
   --
   -------------------------------------------------------------
   GEN_TLAST_OUT : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           if (dre_rst        = '1') then

             sig_tlast_out <= '0';

           elsif (sig_advance_pipe_data = '1') then
              
              sig_tlast_out <= sig_final_mux_has_tlast;
          
           Elsif (dre_out_tready   = '1' and    -- a completed transfer 
                  sig_dre_tvalid_i = '1') Then  -- so clear tlast
                                               
              sig_tlast_out <= '0';
          
           else
             null; -- hold state
           end if;
--        else
--          null;
        end if;
      end process GEN_TLAST_OUT;


     GEN_MUXFARM_512 : if (C_DWIDTH = 512) generate
   
         signal sig_cntl_state_512    : std_logic_vector(11 downto 0) := (others => '0');
         Signal s_case_i_512          : Integer range 0 to 64 := 0;
         Signal sig_shift_case_i     : std_logic_vector(5 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(5 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(63 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_64
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_64 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(63 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(63) = '1') then
              
                sig_tlast_enables <= "1000000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(62) = '1') then
              
                sig_tlast_enables <= "0100000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(61) = '1') then
              
                sig_tlast_enables <= "0010000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(60) = '1') then
              
                sig_tlast_enables <= "0001000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(59) = '1') then
              
                sig_tlast_enables <= "0000100000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(58) = '1') then
              
                sig_tlast_enables <= "0000010000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(57) = '1') then
              
                sig_tlast_enables <= "0000001000000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(56) = '1') then
              
                sig_tlast_enables <= "0000000100000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(55) = '1') then
              
                sig_tlast_enables <= "0000000010000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(54) = '1') then
              
                sig_tlast_enables <= "0000000001000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(53) = '1') then
              
                sig_tlast_enables <= "0000000000100000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(52) = '1') then
              
                sig_tlast_enables <= "0000000000010000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(51) = '1') then
              
                sig_tlast_enables <= "0000000000001000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(50) = '1') then
              
                sig_tlast_enables <= "0000000000000100000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(49) = '1') then
              
                sig_tlast_enables <= "0000000000000010000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(48) = '1') then
              
                sig_tlast_enables <= "0000000000000001000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(47) = '1') then
              
                sig_tlast_enables <= "0000000000000000100000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(46) = '1') then
              
                sig_tlast_enables <= "0000000000000000010000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(45) = '1') then
              
                sig_tlast_enables <= "0000000000000000001000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(44) = '1') then
              
                sig_tlast_enables <= "0000000000000000000100000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(43) = '1') then
              
                sig_tlast_enables <= "0000000000000000000010000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(42) = '1') then
              
                sig_tlast_enables <= "0000000000000000000001000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(41) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000100000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(40) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000010000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(39) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000001000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(38) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000100000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(37) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000010000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(36) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000001000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(35) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000100000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(34) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000010000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(33) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000001000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(32) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000100000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(31) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000010000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(30) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000001000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(29) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000100000000000000000000000000000";
              
              elsif (sig_tlast_strobes(28) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000010000000000000000000000000000";
              
              elsif (sig_tlast_strobes(27) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000001000000000000000000000000000";
              
              elsif (sig_tlast_strobes(26) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000100000000000000000000000000";
              
              elsif (sig_tlast_strobes(25) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000010000000000000000000000000";

              elsif (sig_tlast_strobes(24) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000001000000000000000000000000";

              elsif (sig_tlast_strobes(23) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000100000000000000000000000";
              
              elsif (sig_tlast_strobes(22) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000010000000000000000000000";
              
              elsif (sig_tlast_strobes(21) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000001000000000000000000000";
              
              elsif (sig_tlast_strobes(20) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000100000000000000000000";
              
              elsif (sig_tlast_strobes(19) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000010000000000000000000";
              
              elsif (sig_tlast_strobes(18) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000001000000000000000000";
              
              elsif (sig_tlast_strobes(17) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000100000000000000000";
              
              elsif (sig_tlast_strobes(16) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000010000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000001000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000010";
              
              else
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_64; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_512, 6));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_512 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_512)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 128 and above.    
             
--             sig_cntl_state_512 <= dre_src_align (5 downto 0);-- & sig_dest_align_i (3 downto 0); 

             sig_cntl_state_512 <= dre_src_align (5 downto 0) & sig_dest_align_i (5 downto 0);
           --  sig_cntl_state_512 <= sig_dest_align_i (5 downto 0); 

           if (dre_src_align (5 downto 0) = sig_dest_align_i (5 downto 0)) then
               s_case_i_512 <= 0;
           elsif (dre_src_align (5 downto 0) < sig_dest_align_i (5 downto 0)) then
               s_case_i_512 <= 64 - (func_ret_int_6(sig_dest_align_i (5 downto 0)) - func_ret_int_6(dre_src_align (5 downto 0)));

           else
               s_case_i_512 <= func_ret_int_6(dre_src_align (5 downto 0)) - func_ret_int_6(sig_dest_align_i (5 downto 0));

           end if;

               
        
           end process DO_SHIFT_CASE_512; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_512 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 63 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "000000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "000001" =>
                  sig_pass_mux_bus(63) <= sig_input_data_reg(0);
               when "000010" =>
                  for i in 62 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-62);
                  end loop;
               when "000011" =>
                   for i in 61 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-61);
                  end loop;
               when "000100" =>
                   for i in 60 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-60);
                  end loop;
               when "000101" =>
                   for i in 59 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-59);
                  end loop;
               when "000110" =>
                   for i in 58 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-58);
                  end loop;
               when "000111" =>
                   for i in 57 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-57);
                  end loop;
               when "001000" =>
                   for i in 56 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-56);
                  end loop;
               when "001001" =>
                   for i in 55 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-55);
                  end loop;
               when "001010" =>
                   for i in 54 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-54);
                  end loop;
               when "001011" =>
                   for i in 53 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-53);
                  end loop;
               when "001100" =>
                   for i in 52 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-52);
                  end loop;
               when "001101" =>
                   for i in 51 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-51);
                  end loop;
               when "001110" =>
                   for i in 50 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-50);
                  end loop;
               when "001111" =>
                   for i in 49 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-49);
                  end loop;
               when "010000" =>
                   for i in 48 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-48);
                  end loop;
               when "010001" =>
                   for i in 47 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-47);
                  end loop;
               when "010010" =>
                   for i in 46 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-46);
                  end loop;
               when "010011" =>
                   for i in 45 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-45);
                  end loop;
               when "010100" =>
                   for i in 44 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-44);
                  end loop;
               when "010101" =>
                   for i in 43 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-43);
                  end loop;
               when "010110" =>
                   for i in 42 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-42);
                  end loop;
               when "010111" =>
                   for i in 41 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-41);
                  end loop;
               when "011000" =>
                   for i in 40 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-40);
                  end loop;
               when "011001" =>
                   for i in 39 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-39);
                  end loop;
               when "011010" =>
                   for i in 38 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-38);
                  end loop;
               when "011011" =>
                   for i in 37 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-37);
                  end loop;
               when "011100" =>
                   for i in 36 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-36);
                  end loop;
               when "011101" =>
                   for i in 35 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-35);
                  end loop;
               when "011110" =>
                   for i in 34 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-34);
                  end loop;
               when "011111" =>
                   for i in 33 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-33);
                  end loop;
               when "100000" =>
                   for i in 32 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-32);
                  end loop;
               when "100001" =>
                   for i in 31 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-31);
                  end loop;
               when "100010" =>
                   for i in 30 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-30);
                  end loop;
               when "100011" =>
                   for i in 29 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-29);
                  end loop;
               when "100100" =>
                   for i in 28 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-28);
                  end loop;
               when "100101" =>
                   for i in 27 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-27);
                  end loop;
               when "100110" =>
                   for i in 26 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-26);
                  end loop;
               when "100111" =>
                   for i in 25 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-25);
                  end loop;
               when "101000" =>
                   for i in 24 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-24);
                  end loop;
               when "101001" =>
                   for i in 23 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-23);
                  end loop;
               when "101010" =>
                   for i in 22 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-22);
                  end loop;
               when "101011" =>
                   for i in 21 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-21);
                  end loop;
               when "101100" =>
                   for i in 20 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-20);
                  end loop;
               when "101101" =>
                   for i in 19 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-19);
                  end loop;
               when "101110" =>
                   for i in 18 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-18);
                  end loop;
               when "101111" =>
                   for i in 17 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-17);
                  end loop;
               when "110000" =>
                   for i in 16 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-16);
                  end loop;
               when "110001" =>
                   for i in 15 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-15);
                  end loop;
               when "110010" =>
                   for i in 14 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-14);
                  end loop;
               when "110011" =>
                   for i in 13 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-13);
                  end loop;
               when "110100" =>
                   for i in 12 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-12);
                  end loop;
               when "110101" =>
                   for i in 11 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-11);
                  end loop;
               when "110110" =>
                   for i in 10 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-10);
                  end loop;
               when "110111" =>
                  for i in 9 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-9);
                  end loop;
               when "111000" =>
                  for i in 8 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-8);
                  end loop;
               when "111001" =>
                  for i in 7 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-7);
                  end loop;
               when "111010" =>
                  for i in 6 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-6);
                  end loop;
               when "111011" =>
                  for i in 5 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-5);
                  end loop;
               when "111100" =>
                  for i in 4 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-4);
                  end loop;
               when "111101" =>
                  for i in 3 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-3);
                  end loop;
               when "111110" =>
                  for i in 2 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-2);
                  end loop;
               when "111111" =>
                  for i in 1 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-1);
                  end loop;
               when   others =>
                  null;
             end case;   
         end process PASS_MUX_512;


         DELAY_MUX_512 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 63 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;

             case sig_shift_case_reg is
               when "000000" =>
                   
               when "000001" =>
                  for i in 1 to 63 loop
                      sig_delay_mux_bus(i-1) <= sig_input_data_reg(i);
                  end loop;
               when "000010" =>
                  for i in 2 to 63 loop
                      sig_delay_mux_bus(i-2) <= sig_input_data_reg(i);
                  end loop;
               when "000011" =>
                  for i in 3 to 63 loop
                      sig_delay_mux_bus(i-3) <= sig_input_data_reg(i);
                  end loop;
               when "000100" =>
                  for i in 4 to 63 loop
                      sig_delay_mux_bus(i-4) <= sig_input_data_reg(i);
                  end loop;
               when "000101" =>
                  for i in 5 to 63 loop
                      sig_delay_mux_bus(i-5) <= sig_input_data_reg(i);
                  end loop;
               when "000110" =>
                  for i in 6 to 63 loop
                      sig_delay_mux_bus(i-6) <= sig_input_data_reg(i);
                  end loop;
               when "000111" =>
                  for i in 7 to 63 loop
                      sig_delay_mux_bus(i-7) <= sig_input_data_reg(i);
                  end loop;
               when "001000" =>
                  for i in 8 to 63 loop
                      sig_delay_mux_bus(i-8) <= sig_input_data_reg(i);
                  end loop;
               when "001001" =>
                  for i in 9 to 63 loop
                      sig_delay_mux_bus(i-9) <= sig_input_data_reg(i);
                  end loop;
               when "001010" =>
                   for i in 10 to 63 loop
                      sig_delay_mux_bus(i-10) <= sig_input_data_reg(i);
                  end loop;
               when "001011" =>
                   for i in 11 to 63 loop
                      sig_delay_mux_bus(i-11) <= sig_input_data_reg(i);
                  end loop;
               when "001100" =>
                   for i in 12 to 63 loop
                      sig_delay_mux_bus(i-12) <= sig_input_data_reg(i);
                  end loop;
               when "001101" =>
                   for i in 13 to 63 loop
                      sig_delay_mux_bus(i-13) <= sig_input_data_reg(i);
                  end loop;
               when "001110" =>
                   for i in 14 to 63 loop
                      sig_delay_mux_bus(i-14) <= sig_input_data_reg(i);
                  end loop;
               when "001111" =>
                   for i in 15 to 63 loop
                      sig_delay_mux_bus(i-15) <= sig_input_data_reg(i);
                  end loop;
               when "010000" =>
                   for i in 16 to 63 loop
                      sig_delay_mux_bus(i-16) <= sig_input_data_reg(i);
                  end loop;
               when "010001" =>
                   for i in 17 to 63 loop
                      sig_delay_mux_bus(i-17) <= sig_input_data_reg(i);
                  end loop;
               when "010010" =>
                   for i in 18 to 63 loop
                      sig_delay_mux_bus(i-18) <= sig_input_data_reg(i);
                  end loop;
               when "010011" =>
                   for i in 19 to 63 loop
                      sig_delay_mux_bus(i-19) <= sig_input_data_reg(i);
                  end loop;
               when "010100" =>
                   for i in 20 to 63 loop
                      sig_delay_mux_bus(i-20) <= sig_input_data_reg(i);
                  end loop;
               when "010101" =>
                   for i in 21 to 63 loop
                      sig_delay_mux_bus(i-21) <= sig_input_data_reg(i);
                  end loop;
               when "010110" =>
                   for i in 22 to 63 loop
                      sig_delay_mux_bus(i-22) <= sig_input_data_reg(i);
                  end loop;
               when "010111" =>
                   for i in 23 to 63 loop
                      sig_delay_mux_bus(i-23) <= sig_input_data_reg(i);
                  end loop;
               when "011000" =>
                   for i in 24 to 63 loop
                      sig_delay_mux_bus(i-24) <= sig_input_data_reg(i);
                  end loop;
               when "011001" =>
                   for i in 25 to 63 loop
                      sig_delay_mux_bus(i-25) <= sig_input_data_reg(i);
                  end loop;
               when "011010" =>
                   for i in 26 to 63 loop
                      sig_delay_mux_bus(i-26) <= sig_input_data_reg(i);
                  end loop;
               when "011011" =>
                   for i in 27 to 63 loop
                      sig_delay_mux_bus(i-27) <= sig_input_data_reg(i);
                  end loop;
               when "011100" =>
                   for i in 28 to 63 loop
                      sig_delay_mux_bus(i-28) <= sig_input_data_reg(i);
                  end loop;
               when "011101" =>
                   for i in 29 to 63 loop
                      sig_delay_mux_bus(i-29) <= sig_input_data_reg(i);
                  end loop;
               when "011110" =>
                   for i in 30 to 63 loop
                      sig_delay_mux_bus(i-30) <= sig_input_data_reg(i);
                  end loop;
               when "011111" =>
                   for i in 31 to 63 loop
                      sig_delay_mux_bus(i-31) <= sig_input_data_reg(i);
                  end loop;
               when "100000" =>
                   for i in 32 to 63 loop
                      sig_delay_mux_bus(i-32) <= sig_input_data_reg(i);
                  end loop;
               when "100001" =>
                   for i in 33 to 63 loop
                      sig_delay_mux_bus(i-33) <= sig_input_data_reg(i);
                  end loop;
               when "100010" =>
                   for i in 34 to 63 loop
                      sig_delay_mux_bus(i-34) <= sig_input_data_reg(i);
                  end loop;
               when "100011" =>
                   for i in 35 to 63 loop
                      sig_delay_mux_bus(i-35) <= sig_input_data_reg(i);
                  end loop;
               when "100100" =>
                   for i in 36 to 63 loop
                      sig_delay_mux_bus(i-36) <= sig_input_data_reg(i);
                  end loop;
               when "100101" =>
                   for i in 37 to 63 loop
                      sig_delay_mux_bus(i-37) <= sig_input_data_reg(i);
                  end loop;
               when "100110" =>
                   for i in 38 to 63 loop
                      sig_delay_mux_bus(i-38) <= sig_input_data_reg(i);
                  end loop;
               when "100111" =>
                   for i in 39 to 63 loop
                      sig_delay_mux_bus(i-39) <= sig_input_data_reg(i);
                  end loop;
               when "101000" =>
                   for i in 40 to 63 loop
                      sig_delay_mux_bus(i-40) <= sig_input_data_reg(i);
                  end loop;
               when "101001" =>
                   for i in 41 to 63 loop
                      sig_delay_mux_bus(i-41) <= sig_input_data_reg(i);
                  end loop;
               when "101010" =>
                   for i in 42 to 63 loop
                      sig_delay_mux_bus(i-42) <= sig_input_data_reg(i);
                  end loop;
               when "101011" =>
                   for i in 43 to 63 loop
                      sig_delay_mux_bus(i-43) <= sig_input_data_reg(i);
                  end loop;
               when "101100" =>
                   for i in 44 to 63 loop
                      sig_delay_mux_bus(i-44) <= sig_input_data_reg(i);
                  end loop;
               when "101101" =>
                   for i in 45 to 63 loop
                      sig_delay_mux_bus(i-45) <= sig_input_data_reg(i);
                  end loop;
               when "101110" =>
                   for i in 46 to 63 loop
                      sig_delay_mux_bus(i-46) <= sig_input_data_reg(i);
                  end loop;
               when "101111" =>
                   for i in 47 to 63 loop
                      sig_delay_mux_bus(i-47) <= sig_input_data_reg(i);
                  end loop;
               when "110000" =>
                   for i in 48 to 63 loop
                      sig_delay_mux_bus(i-48) <= sig_input_data_reg(i);
                  end loop;
               when "110001" =>
                   for i in 49 to 63 loop
                      sig_delay_mux_bus(i-49) <= sig_input_data_reg(i);
                  end loop;
               when "110010" =>
                   for i in 50 to 63 loop
                      sig_delay_mux_bus(i-50) <= sig_input_data_reg(i);
                  end loop;
               when "110011" =>
                   for i in 51 to 63 loop
                      sig_delay_mux_bus(i-51) <= sig_input_data_reg(i);
                  end loop;
               when "110100" =>
                   for i in 52 to 63 loop
                      sig_delay_mux_bus(i-52) <= sig_input_data_reg(i);
                  end loop;
               when "110101" =>
                   for i in 53 to 63 loop
                      sig_delay_mux_bus(i-53) <= sig_input_data_reg(i);
                  end loop;
               when "110110" =>
                   for i in 54 to 63 loop
                      sig_delay_mux_bus(i-54) <= sig_input_data_reg(i);
                  end loop;
               when "110111" =>
                   for i in 55 to 63 loop
                      sig_delay_mux_bus(i-55) <= sig_input_data_reg(i);
                  end loop;
               when "111000" =>
                   for i in 56 to 63 loop
                      sig_delay_mux_bus(i-56) <= sig_input_data_reg(i);
                  end loop;
               when "111001" =>
                   for i in 57 to 63 loop
                      sig_delay_mux_bus(i-57) <= sig_input_data_reg(i);
                  end loop;
               when "111010" =>
                   for i in 58 to 63 loop
                      sig_delay_mux_bus(i-58) <= sig_input_data_reg(i);
                  end loop;
               when "111011" =>
                   for i in 59 to 63 loop
                      sig_delay_mux_bus(i-59) <= sig_input_data_reg(i);
                  end loop;
               when "111100" =>
                   for i in 60 to 63 loop
                      sig_delay_mux_bus(i-60) <= sig_input_data_reg(i);
                  end loop;
               when "111101" =>
                   for i in 61 to 63 loop
                      sig_delay_mux_bus(i-61) <= sig_input_data_reg(i);
                  end loop;
               when "111110" =>
                   for i in 62 to 63 loop
                      sig_delay_mux_bus(i-62) <= sig_input_data_reg(i);
                  end loop;
               when "111111" =>
                      sig_delay_mux_bus(0) <= sig_input_data_reg(63);
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_512;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000000"; -- select all pass
                when "000001" =>
                    sig_final_mux_sel <= "0111111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000010" =>
                    sig_final_mux_sel <= "0011111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000011" =>
                    sig_final_mux_sel <= "0001111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000100" =>
                    sig_final_mux_sel <= "0000111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000101" =>
                    sig_final_mux_sel <= "0000011111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000110" =>
                    sig_final_mux_sel <= "0000001111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000111" =>
                    sig_final_mux_sel <= "0000000111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001000" =>
                    sig_final_mux_sel <= "0000000011111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001001" =>
                    sig_final_mux_sel <= "0000000001111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001010" =>
                    sig_final_mux_sel <= "0000000000111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001011" =>
                    sig_final_mux_sel <= "0000000000011111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001100" =>
                    sig_final_mux_sel <= "0000000000001111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001101" =>
                    sig_final_mux_sel <= "0000000000000111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001110" =>
                    sig_final_mux_sel <= "0000000000000011111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001111" =>
                    sig_final_mux_sel <= "0000000000000001111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010000" =>
                    sig_final_mux_sel <= "0000000000000000111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010001" =>
                    sig_final_mux_sel <= "0000000000000000011111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010010" =>
                    sig_final_mux_sel <= "0000000000000000001111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010011" =>
                    sig_final_mux_sel <= "0000000000000000000111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010100" =>
                    sig_final_mux_sel <= "0000000000000000000011111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010101" =>
                    sig_final_mux_sel <= "0000000000000000000001111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010110" =>
                    sig_final_mux_sel <= "0000000000000000000000111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010111" =>
                    sig_final_mux_sel <= "0000000000000000000000011111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011000" =>
                    sig_final_mux_sel <= "0000000000000000000000001111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011001" =>
                    sig_final_mux_sel <= "0000000000000000000000000111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011010" =>
                    sig_final_mux_sel <= "0000000000000000000000000011111111111111111111111111111111111111"; -- only MSB from Pass
                when "011011" =>
                    sig_final_mux_sel <= "0000000000000000000000000001111111111111111111111111111111111111"; -- only MSB from Pass
                when "011100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000111111111111111111111111111111111111"; -- only MSB from Pass
                when "011101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000011111111111111111111111111111111111"; -- only MSB from Pass
                when "011110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000001111111111111111111111111111111111"; -- only MSB from Pass
                when "011111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000111111111111111111111111111111111"; -- only MSB from Pass

               when "100000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000011111111111111111111111111111111"; -- only MSB from Pass
               when "100001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000001111111111111111111111111111111"; -- only MSB from Pass
               when "100010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000111111111111111111111111111111"; -- only MSB from Pass
               when "100011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000011111111111111111111111111111"; -- only MSB from Pass
               when "100100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000001111111111111111111111111111"; -- only MSB from Pass
               when "100101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000111111111111111111111111111"; -- only MSB from Pass
               when "100110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000011111111111111111111111111"; -- only MSB from Pass
               when "100111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000001111111111111111111111111"; -- only MSB from Pass
               when "101000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000111111111111111111111111"; -- only MSB from Pass
               when "101001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000011111111111111111111111"; -- only MSB from Pass
               when "101010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000001111111111111111111111"; -- only MSB from Pass
               when "101011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000111111111111111111111"; -- only MSB from Pass
               when "101100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000011111111111111111111"; -- only MSB from Pass
               when "101101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000001111111111111111111"; -- only MSB from Pass
               when "101110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000111111111111111111"; -- only MSB from Pass
               when "101111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000011111111111111111"; -- only MSB from Pass
               when "110000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000001111111111111111"; -- only MSB from Pass
               when "110001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000111111111111111"; -- only MSB from Pass
               when "110010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000011111111111111"; -- only MSB from Pass
               when "110011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000001111111111111"; -- only MSB from Pass
               when "110100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000111111111111"; -- only MSB from Pass
               when "110101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000011111111111"; -- only MSB from Pass
               when "110110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000001111111111"; -- only MSB from Pass
               when "110111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000111111111"; -- only MSB from Pass
               when "111000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000011111111"; -- only MSB from Pass
               when "111001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000001111111"; -- only MSB from Pass
               when "111010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000111111"; -- only MSB from Pass
               when "111011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000011111"; -- only MSB from Pass
               when "111100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000001111"; -- only MSB from Pass
               when "111101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000111"; -- only MSB from Pass
               when "111110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000011"; -- only MSB from Pass
               when "111111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 63 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_512;



     GEN_MUXFARM_256 : if (C_DWIDTH = 256) generate
   
         signal sig_cntl_state_256    : std_logic_vector(9 downto 0) := (others => '0');
         Signal s_case_i_256          : Integer range 0 to 32 := 0;
         Signal sig_shift_case_i     : std_logic_vector(4 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(4 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(31 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_32
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_32 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(31 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00000000000000000000000000000000";

              elsif (sig_tlast_strobes(31) = '1') then
              
                sig_tlast_enables <= "10000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(30) = '1') then
              
                sig_tlast_enables <= "01000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(29) = '1') then
              
                sig_tlast_enables <= "00100000000000000000000000000000";
              
              elsif (sig_tlast_strobes(28) = '1') then
              
                sig_tlast_enables <= "00010000000000000000000000000000";
              
              elsif (sig_tlast_strobes(27) = '1') then
              
                sig_tlast_enables <= "00001000000000000000000000000000";
              
              elsif (sig_tlast_strobes(26) = '1') then
              
                sig_tlast_enables <= "00000100000000000000000000000000";
              
              elsif (sig_tlast_strobes(25) = '1') then
              
                sig_tlast_enables <= "00000010000000000000000000000000";

              elsif (sig_tlast_strobes(24) = '1') then
              
                sig_tlast_enables <= "00000001000000000000000000000000";

              elsif (sig_tlast_strobes(23) = '1') then
              
                sig_tlast_enables <= "00000000100000000000000000000000";
              
              elsif (sig_tlast_strobes(22) = '1') then
              
                sig_tlast_enables <= "00000000010000000000000000000000";
              
              elsif (sig_tlast_strobes(21) = '1') then
              
                sig_tlast_enables <= "00000000001000000000000000000000";
              
              elsif (sig_tlast_strobes(20) = '1') then
              
                sig_tlast_enables <= "00000000000100000000000000000000";
              
              elsif (sig_tlast_strobes(19) = '1') then
              
                sig_tlast_enables <= "00000000000010000000000000000000";
              
              elsif (sig_tlast_strobes(18) = '1') then
              
                sig_tlast_enables <= "00000000000001000000000000000000";
              
              elsif (sig_tlast_strobes(17) = '1') then
              
                sig_tlast_enables <= "00000000000000100000000000000000";
              
              elsif (sig_tlast_strobes(16) = '1') then
              
                sig_tlast_enables <= "00000000000000010000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "00000000000000001000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "00000000000000000100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "00000000000000000010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "00000000000000000001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "00000000000000000000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "00000000000000000000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "00000000000000000000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000000010";
              
              else
              
                sig_tlast_enables <= "00000000000000000000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_32; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_256, 5));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_256 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_256)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 256 and above.    
             
           --  sig_cntl_state_256 <= dre_src_align (4 downto 0);-- & sig_dest_align_i (3 downto 0); 
             sig_cntl_state_256 <= dre_src_align (4 downto 0) & sig_dest_align_i (4 downto 0); 
             --sig_cntl_state_256 <= sig_dest_align_i (4 downto 0); 
               
           if (dre_src_align (4 downto 0) = sig_dest_align_i (4 downto 0)) then
               s_case_i_256 <= 0; 
           elsif (dre_src_align (4 downto 0) < sig_dest_align_i (4 downto 0)) then
               s_case_i_256 <= 32 - (func_ret_int_5(sig_dest_align_i (4 downto 0)) - func_ret_int_5(dre_src_align (4 downto 0))); 
  
           else
               s_case_i_256 <= func_ret_int_5(dre_src_align (4 downto 0)) - func_ret_int_5(sig_dest_align_i (4 downto 0)); 

           end if;
               

         
        
           end process DO_SHIFT_CASE_256; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_256 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 31 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "00000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "00001" =>
                  sig_pass_mux_bus(31) <= sig_input_data_reg(0);
               when "00010" =>
                  sig_pass_mux_bus(30) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(1);
               when "00011" =>
                  sig_pass_mux_bus(29) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(2);
               when "00100" =>
                  sig_pass_mux_bus(28) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(3);
               when "00101" =>
                  sig_pass_mux_bus(27) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(4);
               when "00110" =>
                  sig_pass_mux_bus(26) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(5);
               when "00111" =>
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(6);
               when "01000" =>
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(7);
               when "01001" =>
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(8);
               when "01010" =>
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(9);
               when "01011" =>
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(10);
               when "01100" =>
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(11);
               when "01101" =>
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(12);
               when "01110" =>
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(13);
               when "01111" =>
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(14);
               when "10000" =>
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(25) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(14);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(15);
               when "10001" =>
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(16);
               when "10010" =>
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(17);
               when "10011" =>
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(18);
               when "10100" =>
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(19);
               when "10101" =>
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(20);
               when "10110" =>
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(21);
               when "10111" =>
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(22);
               when "11000" =>
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(23);
               when "11001" =>
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(24);
               when "11010" =>
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(25);
               when "11011" =>
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(26);
               when "11100" =>
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(27);
               when "11101" =>
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(28);
               when "11110" =>
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(28);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(29);
               when "11111" =>
                  sig_pass_mux_bus(1)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(28);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(29);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(30);
               when others =>
                  null;   

             end case;   
         end process PASS_MUX_256;


         DELAY_MUX_256 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 31 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;

             case sig_shift_case_reg is
               when "00000" =>
                   
               when "00001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(1); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(29) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(30) <= sig_input_data_reg(31); 
               when "00010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(29) <= sig_input_data_reg(31); 
               when "00011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(31); 
               when "00100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(31); 
               when "00101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(31); 
               when "00110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(31); 
               when "00111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(31); 
               when "01000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(31); 
               when "01001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(31); 
               when "01010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(31); 
               when "01011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(31); 
               when "01100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(31); 
               when "01101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(31); 
               when "01110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(31); 
               when "01111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(31); 

               when "10000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(31); 
               when "10001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(31); 
               when "10010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(31); 
               when "10011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(31); 
               when "10100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(31); 
               when "10101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(31); 
               when "10110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(31); 
               when "10111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(31); 
               when "11000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(31); 
               when "11001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(31); 
               when "11010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(31); 
               when "11011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(31); 
               when "11100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(31); 
               when "11101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(31); 
               when "11110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(31); 
               when "11111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(31); 
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_256;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00000" =>
                    sig_final_mux_sel <= "00000000000000000000000000000000"; -- select all pass
                when "00001" =>
                    sig_final_mux_sel <= "01111111111111111111111111111111"; -- only MSB from Pass
                when "00010" =>
                    sig_final_mux_sel <= "00111111111111111111111111111111"; -- only MSB from Pass
                when "00011" =>
                    sig_final_mux_sel <= "00011111111111111111111111111111"; -- only MSB from Pass
                when "00100" =>
                    sig_final_mux_sel <= "00001111111111111111111111111111"; -- only MSB from Pass
                when "00101" =>
                    sig_final_mux_sel <= "00000111111111111111111111111111"; -- only MSB from Pass
                when "00110" =>
                    sig_final_mux_sel <= "00000011111111111111111111111111"; -- only MSB from Pass
                when "00111" =>
                    sig_final_mux_sel <= "00000001111111111111111111111111"; -- only MSB from Pass
                when "01000" =>
                    sig_final_mux_sel <= "00000000111111111111111111111111"; -- only MSB from Pass
                when "01001" =>
                    sig_final_mux_sel <= "00000000011111111111111111111111"; -- only MSB from Pass
                when "01010" =>
                    sig_final_mux_sel <= "00000000001111111111111111111111"; -- only MSB from Pass
                when "01011" =>
                    sig_final_mux_sel <= "00000000000111111111111111111111"; -- only MSB from Pass
                when "01100" =>
                    sig_final_mux_sel <= "00000000000011111111111111111111"; -- only MSB from Pass
                when "01101" =>
                    sig_final_mux_sel <= "00000000000001111111111111111111"; -- only MSB from Pass
                when "01110" =>
                    sig_final_mux_sel <= "00000000000000111111111111111111"; -- only MSB from Pass
                when "01111" =>
                    sig_final_mux_sel <= "00000000000000011111111111111111"; -- only MSB from Pass
                when "10000" =>
                    sig_final_mux_sel <= "00000000000000001111111111111111"; -- only MSB from Pass
                when "10001" =>
                    sig_final_mux_sel <= "00000000000000000111111111111111"; -- only MSB from Pass
                when "10010" =>
                    sig_final_mux_sel <= "00000000000000000011111111111111"; -- only MSB from Pass
                when "10011" =>
                    sig_final_mux_sel <= "00000000000000000001111111111111"; -- only MSB from Pass
                when "10100" =>
                    sig_final_mux_sel <= "00000000000000000000111111111111"; -- only MSB from Pass
                when "10101" =>
                    sig_final_mux_sel <= "00000000000000000000011111111111"; -- only MSB from Pass
                when "10110" =>
                    sig_final_mux_sel <= "00000000000000000000001111111111"; -- only MSB from Pass
                when "10111" =>
                    sig_final_mux_sel <= "00000000000000000000000111111111"; -- only MSB from Pass
                when "11000" =>
                    sig_final_mux_sel <= "00000000000000000000000011111111"; -- only MSB from Pass
                when "11001" =>
                    sig_final_mux_sel <= "00000000000000000000000001111111"; -- only MSB from Pass
                when "11010" =>
                    sig_final_mux_sel <= "00000000000000000000000000111111"; -- only MSB from Pass
                when "11011" =>
                    sig_final_mux_sel <= "00000000000000000000000000011111"; -- only MSB from Pass
                when "11100" =>
                    sig_final_mux_sel <= "00000000000000000000000000001111"; -- only MSB from Pass
                when "11101" =>
                    sig_final_mux_sel <= "00000000000000000000000000000111"; -- only MSB from Pass
                when "11110" =>
                    sig_final_mux_sel <= "00000000000000000000000000000011"; -- only MSB from Pass
                when "11111" =>
                    sig_final_mux_sel <= "00000000000000000000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 31 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_256;





     GEN_MUXFARM_128 : if (C_DWIDTH = 128) generate
   
         signal sig_cntl_state_128    : std_logic_vector(7 downto 0) := (others => '0');
         Signal s_case_i_128          : Integer range 0 to 16 := 0;
         Signal sig_shift_case_i     : std_logic_vector(3 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(3 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(15 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_8
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_16 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(15 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "1000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "0100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "0010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "0001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "0000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "0000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "0000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "0000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "0000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "0000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "0000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "0000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "0000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0000000000000010";
              
              else
              
                sig_tlast_enables <= "0000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_16; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_128, 4));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_128 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_128)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 128 and above.    
             
            -- sig_cntl_state_128 <= dre_src_align (3 downto 0);-- & sig_dest_align_i (3 downto 0); 
             sig_cntl_state_128 <= dre_src_align (3 downto 0) & sig_dest_align_i (3 downto 0); 
             --sig_cntl_state_128 <= sig_dest_align_i (3 downto 0); 

           if (dre_src_align (3 downto 0) = sig_dest_align_i (3 downto 0)) then
               s_case_i_128 <= 0;
           elsif (dre_src_align (3 downto 0) < sig_dest_align_i (3 downto 0)) then
               s_case_i_128 <= 16 - (func_ret_int_4(sig_dest_align_i (3 downto 0)) - func_ret_int_4(dre_src_align (3 downto 0)));

           else
               s_case_i_128 <= func_ret_int_4(dre_src_align (3 downto 0)) - func_ret_int_4(sig_dest_align_i (3 downto 0));

           end if;
               
        
           end process DO_SHIFT_CASE_128; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_128 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 15 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "0000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "0001" =>
                  sig_pass_mux_bus(15) <= sig_input_data_reg(0);
               when "0010" =>
                  sig_pass_mux_bus(14) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(1);
               when "0011" =>
                  sig_pass_mux_bus(13) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(2);
               when "0100" =>
                  sig_pass_mux_bus(12) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(3);
               when "0101" =>
                  sig_pass_mux_bus(11) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(4);
               when "0110" =>
                  sig_pass_mux_bus(10) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(5);
               when "0111" =>
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(6);
               when "1000" =>
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(7);
               when "1001" =>
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(8);
               when "1010" =>
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(9);
               when "1011" =>
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(10);
               when "1100" =>
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(11);
               when "1101" =>
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(12);
               when "1110" =>
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(13);
               when "1111" =>
                  sig_pass_mux_bus(1)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(14);
               when others =>
                  null;   

             end case;   
         end process PASS_MUX_128;


         DELAY_MUX_128 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 15 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;

             case sig_shift_case_reg is
               when "0000" =>
                   
               when "0001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(1); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(15); 
               when "0010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(15); 
               when "0011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(15); 
               when "0100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(15); 
               when "0101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(15); 
               when "0110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(15); 
               when "0111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(15); 
               when "1000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(15); 
               when "1001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(15); 
               when "1010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(15); 
               when "1011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(15); 
               when "1100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(15); 
               when "1101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(15); 
               when "1110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(15); 
               when "1111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(15); 
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_128;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "0000" =>
                    sig_final_mux_sel <= "0000000000000000"; -- select all pass
                when "0001" =>
                    sig_final_mux_sel <= "0111111111111111"; -- only MSB from Pass
                when "0010" =>
                    sig_final_mux_sel <= "0011111111111111"; -- only MSB from Pass
                when "0011" =>
                    sig_final_mux_sel <= "0001111111111111"; -- only MSB from Pass
                when "0100" =>
                    sig_final_mux_sel <= "0000111111111111"; -- only MSB from Pass
                when "0101" =>
                    sig_final_mux_sel <= "0000011111111111"; -- only MSB from Pass
                when "0110" =>
                    sig_final_mux_sel <= "0000001111111111"; -- only MSB from Pass
                when "0111" =>
                    sig_final_mux_sel <= "0000000111111111"; -- only MSB from Pass
                when "1000" =>
                    sig_final_mux_sel <= "0000000011111111"; -- only MSB from Pass
                when "1001" =>
                    sig_final_mux_sel <= "0000000001111111"; -- only MSB from Pass
                when "1010" =>
                    sig_final_mux_sel <= "0000000000111111"; -- only MSB from Pass
                when "1011" =>
                    sig_final_mux_sel <= "0000000000011111"; -- only MSB from Pass
                when "1100" =>
                    sig_final_mux_sel <= "0000000000001111"; -- only MSB from Pass
                when "1101" =>
                    sig_final_mux_sel <= "0000000000000111"; -- only MSB from Pass
                when "1110" =>
                    sig_final_mux_sel <= "0000000000000011"; -- only MSB from Pass
                when "1111" =>
                    sig_final_mux_sel <= "0000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 15 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_128;
     
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_64
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 64-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_64 : if (C_DWIDTH = 64) generate
   
         signal sig_cntl_state_64    : std_logic_vector(5 downto 0) := (others => '0');
         Signal s_case_i_64          : Integer range 0 to 7 := 0;
         Signal sig_shift_case_i     : std_logic_vector(2 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(2 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(7 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_8
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_8 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(7 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00000000";
              
              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "10000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "01000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "00100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "00010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "00001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "00000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "00000010";
              
              else
              
                sig_tlast_enables <= "00000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_8; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_64, 3));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_64 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_64)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
             
             sig_cntl_state_64 <= dre_src_align & sig_dest_align_i; 
               
             case sig_cntl_state_64 is
               when "000000" =>
                  s_case_i_64 <= 0;
               when "000001" => 
                  s_case_i_64 <= 7;
               when "000010" =>
                  s_case_i_64 <= 6;
               when "000011" => 
                  s_case_i_64 <= 5;
               when "000100" => 
                  s_case_i_64 <= 4;
               when "000101" => 
                  s_case_i_64 <= 3;
               when "000110" => 
                  s_case_i_64 <= 2;
               when "000111" => 
                  s_case_i_64 <= 1;
               
               when "001000" =>
                  s_case_i_64 <= 1;
               when "001001" => 
                  s_case_i_64 <= 0;
               when "001010" =>
                  s_case_i_64 <= 7;
               when "001011" => 
                  s_case_i_64 <= 6;
               when "001100" => 
                  s_case_i_64 <= 5;
               when "001101" => 
                  s_case_i_64 <= 4;
               when "001110" => 
                  s_case_i_64 <= 3;
               when "001111" => 
                  s_case_i_64 <= 2;
               
               when "010000" =>
                  s_case_i_64 <= 2;
               when "010001" => 
                  s_case_i_64 <= 1;
               when "010010" =>
                  s_case_i_64 <= 0;
               when "010011" => 
                  s_case_i_64 <= 7;
               when "010100" => 
                  s_case_i_64 <= 6;
               when "010101" => 
                  s_case_i_64 <= 5;
               when "010110" => 
                  s_case_i_64 <= 4;
               when "010111" => 
                  s_case_i_64 <= 3;
               
               when "011000" =>
                  s_case_i_64 <= 3;
               when "011001" => 
                  s_case_i_64 <= 2;
               when "011010" =>
                  s_case_i_64 <= 1;
               when "011011" => 
                  s_case_i_64 <= 0;
               when "011100" => 
                  s_case_i_64 <= 7;
               when "011101" => 
                  s_case_i_64 <= 6;
               when "011110" => 
                  s_case_i_64 <= 5;
               when "011111" => 
                  s_case_i_64 <= 4;
               
               when "100000" =>
                  s_case_i_64 <= 4;
               when "100001" => 
                  s_case_i_64 <= 3;
               when "100010" =>
                  s_case_i_64 <= 2;
               when "100011" => 
                  s_case_i_64 <= 1;
               when "100100" => 
                  s_case_i_64 <= 0;
               when "100101" => 
                  s_case_i_64 <= 7;
               when "100110" => 
                  s_case_i_64 <= 6;
               when "100111" => 
                  s_case_i_64 <= 5;
               
               when "101000" =>
                  s_case_i_64 <= 5;
               when "101001" => 
                  s_case_i_64 <= 4;
               when "101010" =>
                  s_case_i_64 <= 3;
               when "101011" => 
                  s_case_i_64 <= 2;
               when "101100" => 
                  s_case_i_64 <= 1;
               when "101101" => 
                  s_case_i_64 <= 0;
               when "101110" => 
                  s_case_i_64 <= 7;
               when "101111" => 
                  s_case_i_64 <= 6;
               
               when "110000" =>
                  s_case_i_64 <= 6;
               when "110001" => 
                  s_case_i_64 <= 5;
               when "110010" =>
                  s_case_i_64 <= 4;
               when "110011" => 
                  s_case_i_64 <= 3;
               when "110100" => 
                  s_case_i_64 <= 2;
               when "110101" => 
                  s_case_i_64 <= 1;
               when "110110" => 
                  s_case_i_64 <= 0;
               when "110111" => 
                  s_case_i_64 <= 7;
               
               when "111000" =>
                  s_case_i_64 <= 7;
               when "111001" => 
                  s_case_i_64 <= 6;
               when "111010" => 
                  s_case_i_64 <= 5;
               when "111011" => 
                  s_case_i_64 <= 4;
               when "111100" => 
                  s_case_i_64 <= 3;
               when "111101" => 
                  s_case_i_64 <= 2;
               when "111110" => 
                  s_case_i_64 <= 1;
               when "111111" => 
                  s_case_i_64 <= 0;
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_64; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;

 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....

        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(                                   
              Sel    =>  sig_shift_case_reg(0)         ,  
              I0     =>  sig_input_data_reg(1)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              Y      =>  sig_pass_mux_bus(1)              
             );                                       


        -- Pass Mux Byte 2 (4-1 x8 Mux)

        I_MUX4_1_PASS_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(2)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              Y      =>  sig_pass_mux_bus(2)              
             );


        -- Pass Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_PASS_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(3)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              Y      =>  sig_pass_mux_bus(3)              
             );


        -- Pass Mux Byte 4 (8-1 x8 Mux)

        I_MUX8_1_PASS_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(4)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  ZEROED_SLICE                  ,  
              I3     =>  ZEROED_SLICE                  ,  
              I4     =>  sig_input_data_reg(0)         ,  
              I5     =>  sig_input_data_reg(1)         ,  
              I6     =>  sig_input_data_reg(2)         ,  
              I7     =>  sig_input_data_reg(3)         ,  
              Y      =>  sig_pass_mux_bus(4)              
             );


        -- Pass Mux Byte 5 (8-1 x8 Mux)

        I_MUX8_1_PASS_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(5)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  ZEROED_SLICE                  ,  
              I3     =>  sig_input_data_reg(0)         ,  
              I4     =>  sig_input_data_reg(1)         ,  
              I5     =>  sig_input_data_reg(2)         ,  
              I6     =>  sig_input_data_reg(3)         ,  
              I7     =>  sig_input_data_reg(4)         ,  
              Y      =>  sig_pass_mux_bus(5)              
             );


        -- Pass Mux Byte 6 (8-1 x8 Mux)

        I_MUX8_1_PASS_B6 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(6)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              I4     =>  sig_input_data_reg(2)         ,  
              I5     =>  sig_input_data_reg(3)         ,  
              I6     =>  sig_input_data_reg(4)         ,  
              I7     =>  sig_input_data_reg(5)         ,  
              Y      =>  sig_pass_mux_bus(6)              
             );


        -- Pass Mux Byte 7 (8-1 x8 Mux)

        I_MUX8_1_PASS_B7 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(7)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              I4     =>  sig_input_data_reg(3)         ,  
              I5     =>  sig_input_data_reg(4)         ,  
              I6     =>  sig_input_data_reg(5)         ,  
              I7     =>  sig_input_data_reg(6)         ,  
              Y      =>  sig_pass_mux_bus(7)              
             );



        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------


        -- Delay Mux Byte 0 (8-1 x8 Mux)

        I_MUX8_1_DLY_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0) ,  
              I0     =>  ZEROED_SLICE                   ,  
              I1     =>  sig_input_data_reg(1)          ,  
              I2     =>  sig_input_data_reg(2)          ,  
              I3     =>  sig_input_data_reg(3)          ,  
              I4     =>  sig_input_data_reg(4)          ,  
              I5     =>  sig_input_data_reg(5)          ,  
              I6     =>  sig_input_data_reg(6)          ,  
              I7     =>  sig_input_data_reg(7)          ,  
              Y      =>  sig_delay_mux_bus(0)              
             );


        -- Delay Mux Byte 1 (8-1 x8 Mux)

        I_MUX8_1_DLY_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(2)         ,  
              I2     =>  sig_input_data_reg(3)         ,  
              I3     =>  sig_input_data_reg(4)         ,  
              I4     =>  sig_input_data_reg(5)         ,  
              I5     =>  sig_input_data_reg(6)         ,  
              I6     =>  sig_input_data_reg(7)         ,  
              I7     =>  ZEROED_SLICE                  ,  
              Y      =>  sig_delay_mux_bus(1)             
             );


        -- Delay Mux Byte 2 (8-1 x8 Mux)

        I_MUX8_1_DLY_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(3)         ,  
              I2     =>  sig_input_data_reg(4)         ,  
              I3     =>  sig_input_data_reg(5)         ,  
              I4     =>  sig_input_data_reg(6)         ,  
              I5     =>  sig_input_data_reg(7)         ,  
              I6     =>  ZEROED_SLICE                  ,  
              I7     =>  ZEROED_SLICE                  ,  
              Y      =>  sig_delay_mux_bus(2)             
             );


        -- Delay Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_DLY_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(7)         ,  
              I1     =>  sig_input_data_reg(4)         ,  
              I2     =>  sig_input_data_reg(5)         ,  
              I3     =>  sig_input_data_reg(6)         ,  
              Y      =>  sig_delay_mux_bus(3)             
             );


        -- Delay Mux Byte 4 (4-1 x8 Mux)

        I_MUX4_1_DLY_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(5)         ,  
              I2     =>  sig_input_data_reg(6)         ,  
              I3     =>  sig_input_data_reg(7)         ,  
              Y      =>  sig_delay_mux_bus(4)             
             );


        -- Delay Mux Byte 5 (2-1 x8 Mux)

        I_MUX2_1_DLY_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  --  : Integer := 8
             )
          port map(
              Sel    =>  sig_shift_case_reg(0), 
              I0     =>  sig_input_data_reg(7), 
              I1     =>  sig_input_data_reg(6), 
              Y      =>  sig_delay_mux_bus(5)   
             );



        -- Delay Mux Byte 6 (Wire)

        sig_delay_mux_bus(6) <= sig_input_data_reg(7);



        -- Delay Mux Byte 7 (Zeroed)

        sig_delay_mux_bus(7) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------

        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        



        -- Final Mux Byte 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(0) <= '0';
                when "001" =>
                    sig_final_mux_sel(0) <= '1';
                when "010" =>
                    sig_final_mux_sel(0) <= '1';
                when "011" =>
                    sig_final_mux_sel(0) <= '1';
                when "100" =>
                    sig_final_mux_sel(0) <= '1';
                when "101" =>
                    sig_final_mux_sel(0) <= '1';
                when "110" =>
                    sig_final_mux_sel(0) <= '1';
                when "111" =>
                    sig_final_mux_sel(0) <= '1';
                when others =>
                    sig_final_mux_sel(0) <= '0';
              end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) ,  
              I0     =>  sig_input_data_reg(0),  
              I1     =>  sig_delay_data_reg(0),  
              Y      =>  sig_final_mux_bus(0)    
             );



        -- Final Mux Byte 1 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B1_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 1 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B1_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(1) <= '0';
                when "001" =>
                    sig_final_mux_sel(1) <= '1';
                when "010" =>
                    sig_final_mux_sel(1) <= '1';
                when "011" =>
                    sig_final_mux_sel(1) <= '1';
                when "100" =>
                    sig_final_mux_sel(1) <= '1';
                when "101" =>
                    sig_final_mux_sel(1) <= '1';
                when "110" =>
                    sig_final_mux_sel(1) <= '1';
                when "111" =>
                    sig_final_mux_sel(1) <= '0';
                when others =>
                    sig_final_mux_sel(1) <= '0';
              end case;

           end process MUX2_1_FINAL_B1_CNTL;



        I_MUX2_1_FINAL_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(1) , 
              I0     =>  sig_pass_mux_bus(1)  , 
              I1     =>  sig_delay_data_reg(1), 
              Y      =>  sig_final_mux_bus(1)   
             );




        -- Final Mux Byte 2 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B2_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 2 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B2_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(2) <= '0';
                when "001" =>
                    sig_final_mux_sel(2) <= '1';
                when "010" =>
                    sig_final_mux_sel(2) <= '1';
                when "011" =>
                    sig_final_mux_sel(2) <= '1';
                when "100" =>
                    sig_final_mux_sel(2) <= '1';
                when "101" =>
                    sig_final_mux_sel(2) <= '1';
                when "110" =>
                    sig_final_mux_sel(2) <= '0';
                when "111" =>
                    sig_final_mux_sel(2) <= '0';
                when others =>
                    sig_final_mux_sel(2) <= '0';
              end case;

           end process MUX2_1_FINAL_B2_CNTL;



        I_MUX2_1_FINAL_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(2) , 
              I0     =>  sig_pass_mux_bus(2)  , 
              I1     =>  sig_delay_data_reg(2), 
              Y      =>  sig_final_mux_bus(2)   
             );




        -- Final Mux Byte 3 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B3_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 3 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B3_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(3) <= '0';
                when "001" =>
                    sig_final_mux_sel(3) <= '1';
                when "010" =>
                    sig_final_mux_sel(3) <= '1';
                when "011" =>
                    sig_final_mux_sel(3) <= '1';
                when "100" =>
                    sig_final_mux_sel(3) <= '1';
                when "101" =>
                    sig_final_mux_sel(3) <= '0';
                when "110" =>
                    sig_final_mux_sel(3) <= '0';
                when "111" =>
                    sig_final_mux_sel(3) <= '0';
                when others =>
                    sig_final_mux_sel(3) <= '0';
              end case;

           end process MUX2_1_FINAL_B3_CNTL;



        I_MUX2_1_FINAL_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(3) ,
              I0     =>  sig_pass_mux_bus(3)  ,
              I1     =>  sig_delay_data_reg(3),
              Y      =>  sig_final_mux_bus(3)  
             );




        -- Final Mux Byte 4 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B4_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 4 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B4_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(4) <= '0';
                when "001" =>
                    sig_final_mux_sel(4) <= '1';
                when "010" =>
                    sig_final_mux_sel(4) <= '1';
                when "011" =>
                    sig_final_mux_sel(4) <= '1';
                when "100" =>
                    sig_final_mux_sel(4) <= '0';
                when "101" =>
                    sig_final_mux_sel(4) <= '0';
                when "110" =>
                    sig_final_mux_sel(4) <= '0';
                when "111" =>
                    sig_final_mux_sel(4) <= '0';
                when others =>
                    sig_final_mux_sel(4) <= '0';
              end case;

           end process MUX2_1_FINAL_B4_CNTL;



        I_MUX2_1_FINAL_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(4) ,
              I0     =>  sig_pass_mux_bus(4)  ,
              I1     =>  sig_delay_data_reg(4),
              Y      =>  sig_final_mux_bus(4)  
             );




        -- Final Mux Byte 5 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B5_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 5 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B5_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(5) <= '0';
                when "001" =>
                    sig_final_mux_sel(5) <= '1';
                when "010" =>
                    sig_final_mux_sel(5) <= '1';
                when "011" =>
                    sig_final_mux_sel(5) <= '0';
                when "100" =>
                    sig_final_mux_sel(5) <= '0';
                when "101" =>
                    sig_final_mux_sel(5) <= '0';
                when "110" =>
                    sig_final_mux_sel(5) <= '0';
                when "111" =>
                    sig_final_mux_sel(5) <= '0';
                when others =>
                    sig_final_mux_sel(5) <= '0';
              end case;

           end process MUX2_1_FINAL_B5_CNTL;



        I_MUX2_1_FINAL_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(5) , 
              I0     =>  sig_pass_mux_bus(5)  , 
              I1     =>  sig_delay_data_reg(5), 
              Y      =>  sig_final_mux_bus(5)   
             );




        -- Final Mux Byte 6 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B6_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 6 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B6_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(6) <= '0';
                when "001" =>
                    sig_final_mux_sel(6) <= '1';
                when "010" =>
                    sig_final_mux_sel(6) <= '0';
                when "011" =>
                    sig_final_mux_sel(6) <= '0';
                when "100" =>
                    sig_final_mux_sel(6) <= '0';
                when "101" =>
                    sig_final_mux_sel(6) <= '0';
                when "110" =>
                    sig_final_mux_sel(6) <= '0';
                when "111" =>
                    sig_final_mux_sel(6) <= '0';
                when others =>
                    sig_final_mux_sel(6) <= '0';
              end case;

           end process MUX2_1_FINAL_B6_CNTL;



        I_MUX2_1_FINAL_B6 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(6) , 
              I0     =>  sig_pass_mux_bus(6)  , 
              I1     =>  sig_delay_data_reg(6), 
              Y      =>  sig_final_mux_bus(6)   
             );



        -- Final Mux Byte 7 (wire)

        sig_final_mux_sel(7) <= '0';
        sig_final_mux_bus(7) <= sig_pass_mux_bus(7);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_64;
 
 
 
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_32
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 32-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_32 : if (C_DWIDTH = 32) generate
         
         signal sig_cntl_state_32    : std_logic_vector(3 downto 0);
         Signal s_case_i_32          : Integer range 0 to 3;
         Signal sig_shift_case_i     : std_logic_vector(1 downto 0);
         Signal sig_shift_case_reg   : std_logic_vector(1 downto 0);
         Signal sig_final_mux_sel    : std_logic_vector(3 downto 0);
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_4
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_4 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(3 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "1000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0010";
              
              else
              
                sig_tlast_enables <= "0001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_4; 
         
 
 
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_32, 2);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_32, 2));
         
             
             
                               

         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_32
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_32 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_32)
           
           begin
        
             
             
             
             sig_cntl_state_32 <= dre_src_align(1 downto 0) & sig_dest_align_i(1 downto 0); 
               
             case sig_cntl_state_32 is
               when "0000" =>
                  s_case_i_32 <= 0;
               when "0001" => 
                  s_case_i_32 <= 3;
               when "0010" =>
                  s_case_i_32 <= 2;
               when "0011" => 
                  s_case_i_32 <= 1;
               
               when "0100" =>
                  s_case_i_32 <= 1;
               when "0101" => 
                  s_case_i_32 <= 0;
               when "0110" =>
                  s_case_i_32 <= 3;
               when "0111" => 
                  s_case_i_32 <= 2;
               
               when "1000" =>
                  s_case_i_32 <= 2;
               when "1001" => 
                  s_case_i_32 <= 1;
               when "1010" =>
                  s_case_i_32 <= 0;
               when "1011" => 
                  s_case_i_32 <= 3;
               
               when "1100" =>
                  s_case_i_32 <= 3;
               when "1101" => 
                  s_case_i_32 <= 2;
               when "1110" =>
                  s_case_i_32 <= 1;
               when "1111" => 
                  s_case_i_32 <= 0;
               
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_32; 
         
          
          
          
          
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;


 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....
        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(0),  
              I0     =>  sig_input_data_reg(1),  
              I1     =>  sig_input_data_reg(0),  
              Y      =>  sig_pass_mux_bus(1)     
             );


        -- Pass Mux Byte 2 (4-1 x8 Mux)

        I_MUX4_1_PASS_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(2)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              Y      =>  sig_pass_mux_bus(2)              
             );


        -- Pass Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_PASS_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(3)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              Y      =>  sig_pass_mux_bus(3)              
             );



        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------



        -- Delay Mux Byte 0 (4-1 x8 Mux)

        I_MUX4_1_DLY_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(1)         ,  
              I2     =>  sig_input_data_reg(2)         ,  
              I3     =>  sig_input_data_reg(3)         ,  
              Y      =>  sig_delay_mux_bus(0)             
             );


        -- Delay Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_DLY_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(0),       
              I0     =>  sig_input_data_reg(3),       
              I1     =>  sig_input_data_reg(2),       
              Y      =>  sig_delay_mux_bus(1)         
             );



        -- Delay Mux Byte 2 (Wire)

        sig_delay_mux_bus(2) <= sig_input_data_reg(3);



        -- Delay Mux Byte 3 (Zeroed)

        sig_delay_mux_bus(3) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        



        -- Final Mux Slice 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(0) <= '0';
                when "01" =>
                    sig_final_mux_sel(0) <= '1';
                when "10" =>
                    sig_final_mux_sel(0) <= '1';
                when "11" =>
                    sig_final_mux_sel(0) <= '1';
                when others =>
                    sig_final_mux_sel(0) <= '0';
              end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) , 
              I0     =>  sig_pass_mux_bus(0)  , 
              I1     =>  sig_delay_data_reg(0), 
              Y      =>  sig_final_mux_bus(0)   
             );




        -- Final Mux Slice 1 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B1_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for slice 1 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B1_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(1) <= '0';
                when "01" =>
                    sig_final_mux_sel(1) <= '1';
                when "10" =>
                    sig_final_mux_sel(1) <= '1';
                when "11" =>
                    sig_final_mux_sel(1) <= '0';
                when others =>
                    sig_final_mux_sel(1) <= '0';
              end case;

           end process MUX2_1_FINAL_B1_CNTL;



        I_MUX2_1_FINAL_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(1) ,
              I0     =>  sig_pass_mux_bus(1)  ,
              I1     =>  sig_delay_data_reg(1),
              Y      =>  sig_final_mux_bus(1)  
             );




        -- Final Mux Slice 2 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B2_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 2 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B2_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(2) <= '0';
                when "01" =>
                    sig_final_mux_sel(2) <= '1';
                when "10" =>
                    sig_final_mux_sel(2) <= '0';
                when "11" =>
                    sig_final_mux_sel(2) <= '0';
                when others =>
                    sig_final_mux_sel(2) <= '0';
              end case;

           end process MUX2_1_FINAL_B2_CNTL;



        I_MUX2_1_FINAL_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(2) , 
              I0     =>  sig_pass_mux_bus(2)  , 
              I1     =>  sig_delay_data_reg(2), 
              Y      =>  sig_final_mux_bus(2)   
             );



        -- Final Mux Slice 3 (wire)

        sig_final_mux_sel(3) <= '0';
        sig_final_mux_bus(3) <= sig_pass_mux_bus(3);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_32;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_16
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 16-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_16 : if (C_DWIDTH = 16) generate
         
         signal sig_cntl_state_16    : std_logic_vector(1 downto 0);
         Signal s_case_i_16          : Integer range 0 to 1;
         Signal sig_shift_case_i     : std_logic;
         Signal sig_shift_case_reg   : std_logic;
         Signal sig_final_mux_sel    : std_logic_vector(1 downto 0);
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_2
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_2 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(1 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "10";
              
              else
              
                sig_tlast_enables <= "01";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_2; 
         




   
   
   
   
 
 
 
 
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                           
         -- Convert shift case to std_logic
         sig_shift_case_i <= '1'
           When s_case_i_16 = 1
           Else '0';
         
         
                           

         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_16
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_16 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_16)
           
           begin
        
             
             
             sig_cntl_state_16 <= dre_src_align(0) & sig_dest_align_i(0); 
               
             case sig_cntl_state_16 is
               when "00" =>
                  s_case_i_16 <= 0;
               when "01" => 
                  s_case_i_16 <= 1;
               when "10" =>
                  s_case_i_16 <= 1;
               when "11" => 
                  s_case_i_16 <= 0;
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_16; 
         
          
          
          
          
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= '0';

               elsif (dre_new_align    = '1' and
                      sig_input_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;





        
        
        
        
        
        
        
        
   
   
 
 
 
 
 
 
 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....
        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg,  
              I0     =>  sig_input_data_reg(1),  
              I1     =>  sig_input_data_reg(0),  
              Y      =>  sig_pass_mux_bus(1)     
             );




        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------






        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------




        -- Delay Mux Slice 0 (Wire)

        sig_delay_mux_bus(0) <= sig_input_data_reg(1);



        -- Delay Mux Slice 1 (Zeroed)

        sig_delay_mux_bus(1) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------








        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        


        -- Final Mux Slice 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

             case sig_shift_case_reg is
               when '0' =>
                   sig_final_mux_sel(0) <= '0';
               when others =>
                   sig_final_mux_sel(0) <= '1';
             end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) , 
              I0     =>  sig_pass_mux_bus(0)  , 
              I1     =>  sig_delay_data_reg(0), 
              Y      =>  sig_final_mux_bus(0)   
             );



        -- Final Mux Slice 1 (wire)

        sig_final_mux_sel(1) <= '0';
        sig_final_mux_bus(1) <= sig_pass_mux_bus(1);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_16;
 
 
 
 
 
 



end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_s2mm_dre.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_s2mm_dre.vhd
--
-- Description:
--     This VHDL design implements a 64 bit wide (8 byte lane) function that
-- realigns an arbitrarily aligned input data stream to an arbitrarily aligned
-- output data stream.
--
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library axi_datamover_v5_1_17;
use axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n;
use axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n;
use axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n;


-------------------------------------------------------------------------------

entity axi_datamover_s2mm_dre is
  Generic (
    C_DWIDTH          : Integer := 64;
      -- Sets the native data width of the DRE
    
    C_ALIGN_WIDTH     : Integer :=  3 
      -- Sets the width of the alignment control inputs
      -- Should be log2(C_DWIDTH)
    
    );
  port (
   
   -- Clock and Reset Input ----------------------------------------------
                                                                        --
    dre_clk          : In  std_logic;                                   --
    dre_rst          : In  std_logic;                                   --
    ----------------------------------------------------------------------
    
                                  
    -- Alignment Control (Independent from Stream Input timing) ----------
                                                                        --
    dre_align_ready  : Out std_logic;                                   --
    dre_align_valid  : In  std_logic;                                   --
    dre_use_autodest : In  std_logic;                                   --
    dre_src_align    : In  std_logic_vector(C_ALIGN_WIDTH-1 downto 0);  --
    dre_dest_align   : In  std_logic_vector(C_ALIGN_WIDTH-1 downto 0);  --
    ----------------------------------------------------------------------
    
   
    
    -- Flush Control (Aligned to input Stream timing) --------------------
                                                                        --
    dre_flush        : In  std_logic;                                   --
    ----------------------------------------------------------------------

   
     
    -- Stream Input Channel ----------------------------------------------
                                                                        --
    dre_in_tstrb     : In  std_logic_vector((C_DWIDTH/8)-1 downto 0);   --
    dre_in_tdata     : In  std_logic_vector(C_DWIDTH-1 downto 0);       --
    dre_in_tlast     : In  std_logic;                                   --
    dre_in_tvalid    : In  std_logic;                                   --
    dre_in_tready    : Out std_logic;                                   --
    ----------------------------------------------------------------------
   
    
    
    -- Stream Output Channel ---------------------------------------------
                                                                        --
    dre_out_tstrb     : Out std_logic_vector((C_DWIDTH/8)-1 downto 0);  --
    dre_out_tdata     : Out std_logic_vector(C_DWIDTH-1 downto 0);      --
    dre_out_tlast     : Out std_logic;                                  --
    dre_out_tvalid    : Out std_logic;                                  --
    dre_out_tready    : In  std_logic                                   --
    ----------------------------------------------------------------------
    
    
    );

end entity axi_datamover_s2mm_dre;


architecture implementation of axi_datamover_s2mm_dre is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  
  -- Functions

     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_start_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the MSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_start_index (lane_index : integer;
                               lane_width : integer)
                               return integer is

        Variable bit_index_start : Integer := 0;

     begin

        bit_index_start := lane_index*lane_width;

        return(bit_index_start);

     end function get_start_index;


     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_end_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the LSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_end_index (lane_index : integer;
                             lane_width : integer)
                             return integer is

        Variable bit_index_end   : Integer := 0;

     begin

        bit_index_end   := (lane_index*lane_width) + (lane_width-1);

        return(bit_index_end);

     end function get_end_index;


function func_ret_int_6 (slv : std_logic_vector (5 downto 0)) return integer is

 Variable number : Integer range 0 to 63 := 0;

begin

  case slv is
     when "000000" =>
        number := 0;
     when "000001" =>
        number := 1;
     when "000010" =>
        number := 2;
     when "000011" =>
        number := 3;
     when "000100" =>
        number := 4;
     when "000101" =>
        number := 5;
     when "000110" =>
        number := 6;
     when "000111" =>
        number := 7;
     when "001000" =>
        number := 8;
     when "001001" =>
        number := 9;
     when "001010" =>
        number := 10;
     when "001011" =>
        number := 11;
     when "001100" =>
        number := 12;
     when "001101" =>
        number := 13;
     when "001110" =>
        number := 14;
     when "001111" =>
        number := 15;
     when "010000" =>
        number := 16;
     when "010001" =>
        number := 17;
     when "010010" =>
        number := 18;
     when "010011" =>
        number := 19;
     when "010100" =>
        number := 20;
     when "010101" =>
        number := 21;
     when "010110" =>
        number := 22;
     when "010111" =>
        number := 23;
     when "011000" =>
        number := 24;
     when "011001" =>
        number := 25;
     when "011010" =>
        number := 26;
     when "011011" =>
        number := 27;
     when "011100" =>
        number := 28;
     when "011101" =>
        number := 29;
     when "011110" =>
        number := 30;
     when "011111" =>
        number := 31;
     when "100000" =>
        number := 32;
     when "100001" =>
        number := 33;
     when "100010" =>
        number := 34;
     when "100011" =>
        number := 35;
     when "100100" =>
        number := 36;
     when "100101" =>
        number := 37;
     when "100110" =>
        number := 38;
     when "100111" =>
        number := 39;
     when "101000" =>
        number := 40;
     when "101001" =>
        number := 41;
     when "101010" =>
        number := 42;
     when "101011" =>
        number := 43;
     when "101100" =>
        number := 44;
     when "101101" =>
        number := 45;
     when "101110" =>
        number := 46;
     when "101111" =>
        number := 47;
     when "110000" =>
        number := 48;
     when "110001" =>
        number := 49;
     when "110010" =>
        number := 50;
     when "110011" =>
        number := 51;
     when "110100" =>
        number := 52;
     when "110101" =>
        number := 53;
     when "110110" =>
        number := 54;
     when "110111" =>
        number := 55;
     when "111000" =>
        number := 56;
     when "111001" =>
        number := 57;
     when "111010" =>
        number := 58;
     when "111011" =>
        number := 59;
     when "111100" =>
        number := 60;
     when "111101" =>
        number := 61;
     when "111110" =>
        number := 62;
     when "111111" =>
        number := 63;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_6;




function func_ret_int_5 (slv : std_logic_vector (4 downto 0)) return integer is

 Variable number : Integer range 0 to 31 := 0;

begin

  case slv is
     when "00000" =>
        number := 0;
     when "00001" =>
        number := 1;
     when "00010" =>
        number := 2;
     when "00011" =>
        number := 3;
     when "00100" =>
        number := 4;
     when "00101" =>
        number := 5;
     when "00110" =>
        number := 6;
     when "00111" =>
        number := 7;
     when "01000" =>
        number := 8;
     when "01001" =>
        number := 9;
     when "01010" =>
        number := 10;
     when "01011" =>
        number := 11;
     when "01100" =>
        number := 12;
     when "01101" =>
        number := 13;
     when "01110" =>
        number := 14;
     when "01111" =>
        number := 15;
     when "10000" =>
        number := 16;
     when "10001" =>
        number := 17;
     when "10010" =>
        number := 18;
     when "10011" =>
        number := 19;
     when "10100" =>
        number := 20;
     when "10101" =>
        number := 21;
     when "10110" =>
        number := 22;
     when "10111" =>
        number := 23;
     when "11000" =>
        number := 24;
     when "11001" =>
        number := 25;
     when "11010" =>
        number := 26;
     when "11011" =>
        number := 27;
     when "11100" =>
        number := 28;
     when "11101" =>
        number := 29;
     when "11110" =>
        number := 30;
     when "11111" =>
        number := 31;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_5;


function func_ret_int_4 (slv : std_logic_vector (3 downto 0)) return integer is

 Variable number : Integer range 0 to 15 := 0;

begin

  case slv is
     when "0000" =>
        number := 0;
     when "0001" =>
        number := 1;
     when "0010" =>
        number := 2;
     when "0011" =>
        number := 3;
     when "0100" =>
        number := 4;
     when "0101" =>
        number := 5;
     when "0110" =>
        number := 6;
     when "0111" =>
        number := 7;
     when "1000" =>
        number := 8;
     when "1001" =>
        number := 9;
     when "1010" =>
        number := 10;
     when "1011" =>
        number := 11;
     when "1100" =>
        number := 12;
     when "1101" =>
        number := 13;
     when "1110" =>
        number := 14;
     when "1111" =>
        number := 15;
     when others =>
        number := 0;

  end case;

  Return (number);

end function func_ret_int_4;

  -- Constants

      Constant BYTE_WIDTH         : integer := 8; -- bits
      Constant DATA_WIDTH_BYTES   : integer := C_DWIDTH/BYTE_WIDTH;
      Constant SLICE_WIDTH        : integer := BYTE_WIDTH+2; -- 8 data bits plus Strobe plus TLAST bit
      Constant SLICE_STROBE_INDEX : integer := (BYTE_WIDTH-1)+1;
      Constant SLICE_TLAST_INDEX  : integer := SLICE_STROBE_INDEX+1;
      Constant ZEROED_SLICE       : std_logic_vector(SLICE_WIDTH-1 downto 0) := (others => '0');
      Constant NUM_BYTE_LANES     : integer := C_DWIDTH/BYTE_WIDTH;
      Constant ALIGN_VECT_WIDTH   : integer := C_ALIGN_WIDTH;
      Constant NO_STRB_SET_VALUE  : integer := 0;
  
  -- Types

      type sig_byte_lane_type is array(DATA_WIDTH_BYTES-1 downto 0) of
                    std_logic_vector(SLICE_WIDTH-1 downto 0);

  -- Signals

      signal sig_input_data_reg       : sig_byte_lane_type;
      signal sig_delay_data_reg       : sig_byte_lane_type;
      signal sig_output_data_reg      : sig_byte_lane_type;
      signal sig_pass_mux_bus         : sig_byte_lane_type;
      signal sig_delay_mux_bus        : sig_byte_lane_type;
      signal sig_final_mux_bus        : sig_byte_lane_type;
      Signal sig_dre_strb_out_i       : std_logic_vector(DATA_WIDTH_BYTES-1 downto 0) := (others => '0');
      Signal sig_dre_data_out_i       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
      Signal sig_dest_align_i         : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_dre_flush_i          : std_logic := '0';
      Signal sig_pipeline_halt        : std_logic := '0';
      Signal sig_dre_tvalid_i         : std_logic := '0';
      Signal sig_input_accept         : std_logic := '0';
      Signal sig_tlast_enables        : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      signal sig_final_mux_has_tlast  : std_logic := '0';
      signal sig_tlast_out            : std_logic := '0';
      Signal sig_tlast_strobes        : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      Signal sig_next_auto_dest       : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_current_dest_align   : std_logic_vector(ALIGN_VECT_WIDTH-1 downto 0) := (others => '0');
      Signal sig_last_written_strb    : std_logic_vector(NUM_BYTE_LANES-1 downto 0) := (others => '0');
      Signal sig_auto_flush           : std_logic := '0';
      Signal sig_flush_db1            : std_logic := '0';
      Signal sig_flush_db2            : std_logic := '0';
      signal sig_flush_db1_complete   : std_logic := '0';
      signal sig_flush_db2_complete   : std_logic := '0';
      signal sig_output_xfer          : std_logic := '0';
      signal sig_advance_pipe_data    : std_logic := '0';
      Signal sig_flush_reg            : std_logic := '0';
      Signal sig_input_flush_stall    : std_logic := '0';
      Signal sig_cntl_accept          : std_logic := '0';
      Signal sig_dre_halted           : std_logic := '0';

      
      
begin --(architecture implementation)

   
   -- Misc port assignments
   
    dre_align_ready          <= sig_dre_halted or
                                sig_flush_db2_complete ;

    dre_in_tready            <= sig_input_accept   ;

    dre_out_tstrb            <= sig_dre_strb_out_i ;

    dre_out_tdata            <= sig_dre_data_out_i ;

    dre_out_tvalid           <= sig_dre_tvalid_i   ;
    
    dre_out_tlast            <= sig_tlast_out      ;

    
    
    
    
   -- Internal logic
    
    sig_cntl_accept          <= dre_align_valid and 
                                (sig_dre_halted or
                                sig_flush_db2_complete);
                                
    
    sig_pipeline_halt        <= sig_dre_halted    or
                                (sig_dre_tvalid_i and 
                                not(dre_out_tready));

    

    sig_output_xfer          <= sig_dre_tvalid_i and 
                                dre_out_tready;
    
    
    sig_advance_pipe_data    <= (dre_in_tvalid or 
                                 sig_dre_flush_i) and
                                 not(sig_pipeline_halt);
    
    sig_dre_flush_i          <= sig_auto_flush        ;
                                                                   

    sig_input_accept         <= dre_in_tvalid and
                                not(sig_pipeline_halt) and
                                not(sig_input_flush_stall);


    sig_flush_db1_complete   <= sig_flush_db1 and
                                not(sig_pipeline_halt);
    
                                                       
    sig_flush_db2_complete   <= sig_flush_db2 and
                                not(sig_pipeline_halt);

    sig_auto_flush           <= sig_flush_db1 or 
                                sig_flush_db2;
                            
                               
    sig_input_flush_stall    <= sig_auto_flush;     -- commanded flush needed for concatonation
    
    
    sig_last_written_strb    <= sig_dre_strb_out_i;
   
   
    
    
    
    ------------------------------------------------------------------------------------
    -- DRE Halted logic
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_DRE_HALTED_FLOP
    --
    -- Process Description:
    --  Implements a flop for the Halted state flag. All DRE 
    -- operation is halted until a new alignment control is 
    -- loaded. The DRE automatically goes into halted state
    -- at reset and at completion of a flush operation.
    --
    -------------------------------------------------------------
    IMP_DRE_HALTED_FLOP : process (dre_clk)
       begin
         if (dre_clk'event and dre_clk = '1') then
            if (dre_rst                = '1' or
               (sig_flush_db2_complete = '1' and
                dre_align_valid        = '0'))then
              
              sig_dre_halted <= '1'; -- default to halted state
            
            elsif (sig_cntl_accept = '1') then
              
              sig_dre_halted <= '0';
            
            else
              null;  -- hold current state
            end if; 
         end if;       
       end process IMP_DRE_HALTED_FLOP; 
    
    
    
    
    
    
    
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_FLUSH_IN
   --
   -- Process Description:
   --  Input Register for the flush command
   --
   -------------------------------------------------------------
   REG_FLUSH_IN : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           
           if (dre_rst       = '1' or
               sig_flush_db2 = '1') then
             
             sig_flush_reg <= '0';
           
           elsif (sig_input_accept = '1') then
             
             sig_flush_reg <= dre_flush;
           
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process REG_FLUSH_IN; 
   
   


   -------------------------------------------------------------
   -- Combinational Process
   --
   -- Label: DO_FINAL_MUX_TLAST_OR
   --
   -- Process Description:
   -- Look at all associated tlast bits in the Final Mux output
   -- and detirmine if any are set.
   --  
   --
   -------------------------------------------------------------
   DO_FINAL_MUX_TLAST_OR : process (sig_final_mux_bus)
       
     Variable lvar_finalmux_or : std_logic_vector(NUM_BYTE_LANES-1 downto 0);
       
     begin
       
       lvar_finalmux_or(0) := sig_final_mux_bus(0)(SLICE_TLAST_INDEX);
       
       for tlast_index in 1 to NUM_BYTE_LANES-1 loop
       
          lvar_finalmux_or(tlast_index) := 
                       lvar_finalmux_or(tlast_index-1)   or
                       sig_final_mux_bus(tlast_index)(SLICE_TLAST_INDEX);
       
       end loop;
       
       
       sig_final_mux_has_tlast <= lvar_finalmux_or(NUM_BYTE_LANES-1);  
       
     
     end process DO_FINAL_MUX_TLAST_OR; 
  
    ------------------------------------------------------------------------
  
   
 
   
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: GEN_FLUSH_DB1
    --
    -- Process Description:
    --  Creates the first sequential flag indicating that the DRE needs to flush out
    -- current contents before allowing any new inputs. This is 
    -- triggered by the receipt of the TLAST.
    --
    -------------------------------------------------------------
    GEN_FLUSH_DB1 : process (dre_clk)
       begin

         if (dre_clk'event and dre_clk = '1') then

            If (dre_rst                = '1' or
                sig_flush_db2_complete = '1') Then
    
       
              sig_flush_db1   <= '0';

            Elsif (sig_input_accept = '1') Then
               
               sig_flush_db1  <= dre_flush or dre_in_tlast;

            else
              null;  -- hold state
            end if;
--         else
--           null;
         end if;
       end process GEN_FLUSH_DB1;

   

    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: GEN_FLUSH_DB2
    --
    -- Process Description:
    --  Creates a second sequential flag indicating that the DRE
    -- is flushing out current contents. This is 
    -- triggered by the assertion of the first sequential flush 
    -- flag.
    --
    -------------------------------------------------------------
    GEN_FLUSH_DB2 : process (dre_clk)
       begin

         if (dre_clk'event and dre_clk = '1') then

            If (dre_rst                = '1' or
                sig_flush_db2_complete = '1') Then
    
       
              sig_flush_db2   <= '0';

            elsif (sig_pipeline_halt = '0') then              

               sig_flush_db2  <= sig_flush_db1;

            else
              null;  -- hold state
            end if;
--         else
--           null;
         end if;
       end process GEN_FLUSH_DB2;



    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CALC_DEST_STRB_ALIGN
    --
    -- Process Description:
    --    This process calculates the byte lane position of the
    -- left-most STRB that is unasserted on the DRE output STRB bus.
    -- The resulting value is used as the Destination Alignment
    -- Vector for the DRE.
    --
    -------------------------------------------------------------
    CALC_DEST_STRB_ALIGN : process (sig_last_written_strb)

      Variable lvar_last_strb_hole_position : Integer range 0 to NUM_BYTE_LANES;
      Variable lvar_strb_hole_detected      : Boolean;
      Variable lvar_first_strb_assert_found : Boolean;
      Variable lvar_loop_count              : integer range 0 to NUM_BYTE_LANES;

      Begin

          lvar_loop_count               := NUM_BYTE_LANES;
          lvar_last_strb_hole_position  := 0;
          lvar_strb_hole_detected       := FALSE;
          lvar_first_strb_assert_found  := FALSE;

          -- Search through the output STRB bus starting with the MSByte
          while (lvar_loop_count > 0) loop

             If (sig_last_written_strb(lvar_loop_count-1) = '0' and
                 lvar_first_strb_assert_found  = FALSE) Then

                lvar_strb_hole_detected      := TRUE;
                lvar_last_strb_hole_position := lvar_loop_count-1;

             Elsif (sig_last_written_strb(lvar_loop_count-1) = '1') Then

                lvar_first_strb_assert_found  := true;

             else
                null; -- do nothing
             End if;

             lvar_loop_count := lvar_loop_count - 1;

          End loop;

          -- now assign the encoder output value to the bit position of the last Strobe encountered
          If (lvar_strb_hole_detected) Then
             
             sig_current_dest_align <= STD_LOGIC_VECTOR(TO_UNSIGNED(lvar_last_strb_hole_position, ALIGN_VECT_WIDTH));
             
          else
             
             sig_current_dest_align <= STD_LOGIC_VECTOR(TO_UNSIGNED(NO_STRB_SET_VALUE, ALIGN_VECT_WIDTH));
          
          End if;

       end process CALC_DEST_STRB_ALIGN;



   ------------------------------------------------------------
   ------------------------------------------------------------
   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: FORMAT_OUTPUT_DATA_STRB
   --
   -- For Generate Description:
   --   Connect the output Data and Strobe ports to the appropriate
   -- bits in the sig_output_data_reg.
   --
   ------------------------------------------------------------
   FORMAT_OUTPUT_DATA_STRB : for byte_lane_index in 0 to NUM_BYTE_LANES-1 generate

   begin

      sig_dre_data_out_i(get_end_index(byte_lane_index, BYTE_WIDTH) downto
               get_start_index(byte_lane_index, BYTE_WIDTH)) <=
               
           sig_output_data_reg(byte_lane_index)(BYTE_WIDTH-1 downto 0);

   
   
   
      sig_dre_strb_out_i(byte_lane_index)   <=
           sig_output_data_reg(byte_lane_index)(SLICE_WIDTH-2);


   end generate FORMAT_OUTPUT_DATA_STRB;
   ------------------------------------------------------------
   ------------------------------------------------------------
   ------------------------------------------------------------

   
   
   ---------------------------------------------------------------------------------
   -- Registers
   


   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_INPUT_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of input register slices.
   -- 
   --
   ------------------------------------------------------------
   GEN_INPUT_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
      
       -------------------------------------------------------------
       -- Synchronous Process with Sync Reset
       --
       -- Label: DO_INPUTREG_SLICE
       --
       -- Process Description:
       --  Implement a single register slice for the Input Register. 
       --
       -------------------------------------------------------------
       DO_INPUTREG_SLICE : process (dre_clk)
          begin
            if (dre_clk'event and dre_clk    = '1') then
               if (dre_rst                   = '1' or 
                   sig_flush_db1_complete    = '1' or      -- clear on reset or if
                  (dre_in_tvalid             = '1' and
                   sig_pipeline_halt         = '0' and     -- the pipe is being advanced and
                   dre_in_tstrb(slice_index) = '0')) then  -- no new valid data id being loaded
                 
                 sig_input_data_reg(slice_index) <= ZEROED_SLICE; 
               
               elsif (dre_in_tstrb(slice_index) = '1' and
                      sig_input_accept          = '1') then
                 
                 sig_input_data_reg(slice_index) <= sig_tlast_enables(slice_index) &
                                                    dre_in_tstrb(slice_index)      & 
                                                    dre_in_tdata((slice_index*8)+7 downto slice_index*8);
                 
               else
                 null; -- don't change state
               end if; 
            end if;       
          end process DO_INPUTREG_SLICE; 
      
      
      
      
   end generate GEN_INPUT_REG;
  
  
   

   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_DELAY_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of output register slices
   --
   --
   ------------------------------------------------------------
   GEN_DELAY_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
    
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: DO_DELAYREG_SLICE
     --
     -- Process Description:
     --  Implement a single register slice 
     --
     -------------------------------------------------------------
     DO_DELAYREG_SLICE : process (dre_clk)
        begin
          if (dre_clk'event and dre_clk = '1') then
             if (dre_rst = '1'    or                                             -- clear on reset or if
                (sig_advance_pipe_data   = '1' and                               -- the pipe is being advanced and
                 sig_delay_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '0')) then -- no new valid data id being loaded
               
               sig_delay_data_reg(slice_index) <= ZEROED_SLICE; 
             
             elsif (sig_delay_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '1' and
                    sig_advance_pipe_data   = '1') then
               
               sig_delay_data_reg(slice_index) <= sig_delay_mux_bus(slice_index);
               
             else
               null; -- don't change state
             end if; 
          end if;       
        end process DO_DELAYREG_SLICE; 
    
    
      
      
   end generate GEN_DELAY_REG;
  
  
 

   ------------------------------------------------------------
   -- For Generate
   --
   -- Label: GEN_OUTPUT_REG
   --
   -- For Generate Description:
   --
   --   Implements a programble number of output register slices
   --
   --
   ------------------------------------------------------------
   GEN_OUTPUT_REG : for slice_index in 0 to NUM_BYTE_LANES-1 generate
   
   begin
   
    
     -------------------------------------------------------------
     -- Synchronous Process with Sync Reset
     --
     -- Label: DO_OUTREG_SLICE
     --
     -- Process Description:
     --  Implement a single register slice 
     --
     -------------------------------------------------------------
     DO_OUTREG_SLICE : process (dre_clk)
        begin
          if (dre_clk'event and dre_clk = '1') then
             if (dre_rst = '1'    or                                             -- clear on reset or if
                (sig_output_xfer         = '1' and                               -- the output is being transfered and
                 sig_final_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '0')) then -- no new valid data id being loaded
               
               sig_output_data_reg(slice_index) <= ZEROED_SLICE; 
             
             elsif (sig_final_mux_bus(slice_index)(SLICE_STROBE_INDEX) = '1' and
                    sig_advance_pipe_data   = '1') then
               
               sig_output_data_reg(slice_index) <= sig_final_mux_bus(slice_index);
               
             else
               null; -- don't change state
             end if; 
          end if;       
        end process DO_OUTREG_SLICE; 
    
    
    
      
   end generate GEN_OUTPUT_REG;
  

   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: GEN_TVALID
   --
   -- Process Description:
   --   This sync process generates the Write request for the
   -- destination interface.
   --
   -------------------------------------------------------------
   GEN_TVALID : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           if (dre_rst        = '1') then

             sig_dre_tvalid_i <= '0';

           elsif (sig_advance_pipe_data = '1') then

              
              sig_dre_tvalid_i <= sig_final_mux_bus(NUM_BYTE_LANES-1)(SLICE_STROBE_INDEX) or -- MS Strobe is set or
                                  sig_final_mux_has_tlast;   -- the Last data beat of a packet
          
           Elsif (dre_out_tready   = '1' and    -- a completed write but no
                  sig_dre_tvalid_i = '1') Then  -- new input data so clear
                                                -- until more input data shows up
              sig_dre_tvalid_i <= '0';
          
           else
             null; -- hold state
           end if;
--        else
--          null;
        end if;
      end process GEN_TVALID;

   

   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: GEN_TLAST_OUT
   --
   -- Process Description:
   --   This sync process generates the TLAST output for the
   -- destination interface.
   --
   -------------------------------------------------------------
   GEN_TLAST_OUT : process (dre_clk)
      begin
        if (dre_clk'event and dre_clk = '1') then
           if (dre_rst        = '1') then

             sig_tlast_out <= '0';

           elsif (sig_advance_pipe_data = '1') then
              
              sig_tlast_out <= sig_final_mux_has_tlast;
          
           Elsif (dre_out_tready   = '1' and    -- a completed transfer 
                  sig_dre_tvalid_i = '1') Then  -- so clear tlast
                                               
              sig_tlast_out <= '0';
          
           else
             null; -- hold state
           end if;
--        else
--          null;
        end if;
      end process GEN_TLAST_OUT;


     GEN_MUXFARM_512 : if (C_DWIDTH = 512) generate
   
         signal sig_cntl_state_512    : std_logic_vector(11 downto 0) := (others => '0');
         Signal s_case_i_512          : Integer range 0 to 128 := 0; --128 to avoid sim overflow
         Signal sig_shift_case_i     : std_logic_vector(5 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(5 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(63 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_64
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_64 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(63 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(63) = '1') then
              
                sig_tlast_enables <= "1000000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(62) = '1') then
              
                sig_tlast_enables <= "0100000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(61) = '1') then
              
                sig_tlast_enables <= "0010000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(60) = '1') then
              
                sig_tlast_enables <= "0001000000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(59) = '1') then
              
                sig_tlast_enables <= "0000100000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(58) = '1') then
              
                sig_tlast_enables <= "0000010000000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(57) = '1') then
              
                sig_tlast_enables <= "0000001000000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(56) = '1') then
              
                sig_tlast_enables <= "0000000100000000000000000000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(55) = '1') then
              
                sig_tlast_enables <= "0000000010000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(54) = '1') then
              
                sig_tlast_enables <= "0000000001000000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(53) = '1') then
              
                sig_tlast_enables <= "0000000000100000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(52) = '1') then
              
                sig_tlast_enables <= "0000000000010000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(51) = '1') then
              
                sig_tlast_enables <= "0000000000001000000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(50) = '1') then
              
                sig_tlast_enables <= "0000000000000100000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(49) = '1') then
              
                sig_tlast_enables <= "0000000000000010000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(48) = '1') then
              
                sig_tlast_enables <= "0000000000000001000000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(47) = '1') then
              
                sig_tlast_enables <= "0000000000000000100000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(46) = '1') then
              
                sig_tlast_enables <= "0000000000000000010000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(45) = '1') then
              
                sig_tlast_enables <= "0000000000000000001000000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(44) = '1') then
              
                sig_tlast_enables <= "0000000000000000000100000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(43) = '1') then
              
                sig_tlast_enables <= "0000000000000000000010000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(42) = '1') then
              
                sig_tlast_enables <= "0000000000000000000001000000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(41) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000100000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(40) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000010000000000000000000000000000000000000000";

              elsif (sig_tlast_strobes(39) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000001000000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(38) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000100000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(37) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000010000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(36) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000001000000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(35) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000100000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(34) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000010000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(33) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000001000000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(32) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000100000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(31) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000010000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(30) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000001000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(29) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000100000000000000000000000000000";
              
              elsif (sig_tlast_strobes(28) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000010000000000000000000000000000";
              
              elsif (sig_tlast_strobes(27) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000001000000000000000000000000000";
              
              elsif (sig_tlast_strobes(26) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000100000000000000000000000000";
              
              elsif (sig_tlast_strobes(25) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000010000000000000000000000000";

              elsif (sig_tlast_strobes(24) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000001000000000000000000000000";

              elsif (sig_tlast_strobes(23) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000100000000000000000000000";
              
              elsif (sig_tlast_strobes(22) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000010000000000000000000000";
              
              elsif (sig_tlast_strobes(21) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000001000000000000000000000";
              
              elsif (sig_tlast_strobes(20) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000100000000000000000000";
              
              elsif (sig_tlast_strobes(19) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000010000000000000000000";
              
              elsif (sig_tlast_strobes(18) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000001000000000000000000";
              
              elsif (sig_tlast_strobes(17) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000100000000000000000";
              
              elsif (sig_tlast_strobes(16) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000010000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000001000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000010";
              
              else
              
                sig_tlast_enables <= "0000000000000000000000000000000000000000000000000000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_64; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_512, 6));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_512 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_512)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 128 and above.    
             
             sig_cntl_state_512 <= dre_src_align (5 downto 0) & sig_dest_align_i (5 downto 0); 
           --  sig_cntl_state_512 <= sig_dest_align_i (5 downto 0); 

           if (dre_src_align (5 downto 0) = sig_dest_align_i (5 downto 0)) then
               s_case_i_512 <= 0; 
           elsif (dre_src_align (5 downto 0) < sig_dest_align_i (5 downto 0)) then
               s_case_i_512 <= 64 - (func_ret_int_6(sig_dest_align_i (5 downto 0)) - func_ret_int_6(dre_src_align (5 downto 0))); 
  
           else
               s_case_i_512 <= func_ret_int_6(dre_src_align (5 downto 0)) - func_ret_int_6(sig_dest_align_i (5 downto 0)); 

           end if;
               
         
        
           end process DO_SHIFT_CASE_512; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

  --             elsif (dre_new_align    = '1' and
  --                    sig_input_accept = '1') then
               elsif (sig_cntl_accept = '1') then 
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_512 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 63 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "000000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "000001" =>
                  sig_pass_mux_bus(63) <= sig_input_data_reg(0);
               when "000010" =>
                  for i in 62 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-62);
                  end loop;
               when "000011" =>
                   for i in 61 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-61);
                  end loop;
               when "000100" =>
                   for i in 60 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-60);
                  end loop;
               when "000101" =>
                   for i in 59 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-59);
                  end loop;
               when "000110" =>
                   for i in 58 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-58);
                  end loop;
               when "000111" =>
                   for i in 57 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-57);
                  end loop;
               when "001000" =>
                   for i in 56 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-56);
                  end loop;
               when "001001" =>
                   for i in 55 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-55);
                  end loop;
               when "001010" =>
                   for i in 54 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-54);
                  end loop;
               when "001011" =>
                   for i in 53 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-53);
                  end loop;
               when "001100" =>
                   for i in 52 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-52);
                  end loop;
               when "001101" =>
                   for i in 51 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-51);
                  end loop;
               when "001110" =>
                   for i in 50 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-50);
                  end loop;
               when "001111" =>
                   for i in 49 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-49);
                  end loop;
               when "010000" =>
                   for i in 48 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-48);
                  end loop;
               when "010001" =>
                   for i in 47 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-47);
                  end loop;
               when "010010" =>
                   for i in 46 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-46);
                  end loop;
               when "010011" =>
                   for i in 45 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-45);
                  end loop;
               when "010100" =>
                   for i in 44 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-44);
                  end loop;
               when "010101" =>
                   for i in 43 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-43);
                  end loop;
               when "010110" =>
                   for i in 42 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-42);
                  end loop;
               when "010111" =>
                   for i in 41 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-41);
                  end loop;
               when "011000" =>
                   for i in 40 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-40);
                  end loop;
               when "011001" =>
                   for i in 39 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-39);
                  end loop;
               when "011010" =>
                   for i in 38 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-38);
                  end loop;
               when "011011" =>
                   for i in 37 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-37);
                  end loop;
               when "011100" =>
                   for i in 36 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-36);
                  end loop;
               when "011101" =>
                   for i in 35 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-35);
                  end loop;
               when "011110" =>
                   for i in 34 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-34);
                  end loop;
               when "011111" =>
                   for i in 33 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-33);
                  end loop;
               when "100000" =>
                   for i in 32 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-32);
                  end loop;
               when "100001" =>
                   for i in 31 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-31);
                  end loop;
               when "100010" =>
                   for i in 30 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-30);
                  end loop;
               when "100011" =>
                   for i in 29 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-29);
                  end loop;
               when "100100" =>
                   for i in 28 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-28);
                  end loop;
               when "100101" =>
                   for i in 27 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-27);
                  end loop;
               when "100110" =>
                   for i in 26 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-26);
                  end loop;
               when "100111" =>
                   for i in 25 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-25);
                  end loop;
               when "101000" =>
                   for i in 24 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-24);
                  end loop;
               when "101001" =>
                   for i in 23 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-23);
                  end loop;
               when "101010" =>
                   for i in 22 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-22);
                  end loop;
               when "101011" =>
                   for i in 21 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-21);
                  end loop;
               when "101100" =>
                   for i in 20 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-20);
                  end loop;
               when "101101" =>
                   for i in 19 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-19);
                  end loop;
               when "101110" =>
                   for i in 18 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-18);
                  end loop;
               when "101111" =>
                   for i in 17 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-17);
                  end loop;
               when "110000" =>
                   for i in 16 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-16);
                  end loop;
               when "110001" =>
                   for i in 15 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-15);
                  end loop;
               when "110010" =>
                   for i in 14 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-14);
                  end loop;
               when "110011" =>
                   for i in 13 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-13);
                  end loop;
               when "110100" =>
                   for i in 12 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-12);
                  end loop;
               when "110101" =>
                   for i in 11 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-11);
                  end loop;
               when "110110" =>
                   for i in 10 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-10);
                  end loop;
               when "110111" =>
                  for i in 9 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-9);
                  end loop;
               when "111000" =>
                  for i in 8 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-8);
                  end loop;
               when "111001" =>
                  for i in 7 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-7);
                  end loop;
               when "111010" =>
                  for i in 6 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-6);
                  end loop;
               when "111011" =>
                  for i in 5 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-5);
                  end loop;
               when "111100" =>
                  for i in 4 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-4);
                  end loop;
               when "111101" =>
                  for i in 3 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-3);
                  end loop;
               when "111110" =>
                  for i in 2 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-2);
                  end loop;
               when "111111" =>
                  for i in 1 to 63 loop
                      sig_pass_mux_bus(i) <= sig_input_data_reg(i-1);
                  end loop;
               when   others =>
                  null;
             end case;   
         end process PASS_MUX_512;


         DELAY_MUX_512 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 63 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;
             case sig_shift_case_reg is
               when "000000" =>
                   
               when "000001" =>
                  for i in 1 to 63 loop
                      sig_delay_mux_bus(i-1) <= sig_input_data_reg(i);
                  end loop;
               when "000010" =>
                  for i in 2 to 63 loop
                      sig_delay_mux_bus(i-2) <= sig_input_data_reg(i);
                  end loop;
               when "000011" =>
                  for i in 3 to 63 loop
                      sig_delay_mux_bus(i-3) <= sig_input_data_reg(i);
                  end loop;
               when "000100" =>
                  for i in 4 to 63 loop
                      sig_delay_mux_bus(i-4) <= sig_input_data_reg(i);
                  end loop;
               when "000101" =>
                  for i in 5 to 63 loop
                      sig_delay_mux_bus(i-5) <= sig_input_data_reg(i);
                  end loop;
               when "000110" =>
                  for i in 6 to 63 loop
                      sig_delay_mux_bus(i-6) <= sig_input_data_reg(i);
                  end loop;
               when "000111" =>
                  for i in 7 to 63 loop
                      sig_delay_mux_bus(i-7) <= sig_input_data_reg(i);
                  end loop;
               when "001000" =>
                  for i in 8 to 63 loop
                      sig_delay_mux_bus(i-8) <= sig_input_data_reg(i);
                  end loop;
               when "001001" =>
                  for i in 9 to 63 loop
                      sig_delay_mux_bus(i-9) <= sig_input_data_reg(i);
                  end loop;
               when "001010" =>
                   for i in 10 to 63 loop
                      sig_delay_mux_bus(i-10) <= sig_input_data_reg(i);
                  end loop;
               when "001011" =>
                   for i in 11 to 63 loop
                      sig_delay_mux_bus(i-11) <= sig_input_data_reg(i);
                  end loop;
               when "001100" =>
                   for i in 12 to 63 loop
                      sig_delay_mux_bus(i-12) <= sig_input_data_reg(i);
                  end loop;
               when "001101" =>
                   for i in 13 to 63 loop
                      sig_delay_mux_bus(i-13) <= sig_input_data_reg(i);
                  end loop;
               when "001110" =>
                   for i in 14 to 63 loop
                      sig_delay_mux_bus(i-14) <= sig_input_data_reg(i);
                  end loop;
               when "001111" =>
                   for i in 15 to 63 loop
                      sig_delay_mux_bus(i-15) <= sig_input_data_reg(i);
                  end loop;
               when "010000" =>
                   for i in 16 to 63 loop
                      sig_delay_mux_bus(i-16) <= sig_input_data_reg(i);
                  end loop;
               when "010001" =>
                   for i in 17 to 63 loop
                      sig_delay_mux_bus(i-17) <= sig_input_data_reg(i);
                  end loop;
               when "010010" =>
                   for i in 18 to 63 loop
                      sig_delay_mux_bus(i-18) <= sig_input_data_reg(i);
                  end loop;
               when "010011" =>
                   for i in 19 to 63 loop
                      sig_delay_mux_bus(i-19) <= sig_input_data_reg(i);
                  end loop;
               when "010100" =>
                   for i in 20 to 63 loop
                      sig_delay_mux_bus(i-20) <= sig_input_data_reg(i);
                  end loop;
               when "010101" =>
                   for i in 21 to 63 loop
                      sig_delay_mux_bus(i-21) <= sig_input_data_reg(i);
                  end loop;
               when "010110" =>
                   for i in 22 to 63 loop
                      sig_delay_mux_bus(i-22) <= sig_input_data_reg(i);
                  end loop;
               when "010111" =>
                   for i in 23 to 63 loop
                      sig_delay_mux_bus(i-23) <= sig_input_data_reg(i);
                  end loop;
               when "011000" =>
                   for i in 24 to 63 loop
                      sig_delay_mux_bus(i-24) <= sig_input_data_reg(i);
                  end loop;
               when "011001" =>
                   for i in 25 to 63 loop
                      sig_delay_mux_bus(i-25) <= sig_input_data_reg(i);
                  end loop;
               when "011010" =>
                   for i in 26 to 63 loop
                      sig_delay_mux_bus(i-26) <= sig_input_data_reg(i);
                  end loop;
               when "011011" =>
                   for i in 27 to 63 loop
                      sig_delay_mux_bus(i-27) <= sig_input_data_reg(i);
                  end loop;
               when "011100" =>
                   for i in 28 to 63 loop
                      sig_delay_mux_bus(i-28) <= sig_input_data_reg(i);
                  end loop;
               when "011101" =>
                   for i in 29 to 63 loop
                      sig_delay_mux_bus(i-29) <= sig_input_data_reg(i);
                  end loop;
               when "011110" =>
                   for i in 30 to 63 loop
                      sig_delay_mux_bus(i-30) <= sig_input_data_reg(i);
                  end loop;
               when "011111" =>
                   for i in 31 to 63 loop
                      sig_delay_mux_bus(i-31) <= sig_input_data_reg(i);
                  end loop;
               when "100000" =>
                   for i in 32 to 63 loop
                      sig_delay_mux_bus(i-32) <= sig_input_data_reg(i);
                  end loop;
               when "100001" =>
                   for i in 33 to 63 loop
                      sig_delay_mux_bus(i-33) <= sig_input_data_reg(i);
                  end loop;
               when "100010" =>
                   for i in 34 to 63 loop
                      sig_delay_mux_bus(i-34) <= sig_input_data_reg(i);
                  end loop;
               when "100011" =>
                   for i in 35 to 63 loop
                      sig_delay_mux_bus(i-35) <= sig_input_data_reg(i);
                  end loop;
               when "100100" =>
                   for i in 36 to 63 loop
                      sig_delay_mux_bus(i-36) <= sig_input_data_reg(i);
                  end loop;
               when "100101" =>
                   for i in 37 to 63 loop
                      sig_delay_mux_bus(i-37) <= sig_input_data_reg(i);
                  end loop;
               when "100110" =>
                   for i in 38 to 63 loop
                      sig_delay_mux_bus(i-38) <= sig_input_data_reg(i);
                  end loop;
               when "100111" =>
                   for i in 39 to 63 loop
                      sig_delay_mux_bus(i-39) <= sig_input_data_reg(i);
                  end loop;
               when "101000" =>
                   for i in 40 to 63 loop
                      sig_delay_mux_bus(i-40) <= sig_input_data_reg(i);
                  end loop;
               when "101001" =>
                   for i in 41 to 63 loop
                      sig_delay_mux_bus(i-41) <= sig_input_data_reg(i);
                  end loop;
               when "101010" =>
                   for i in 42 to 63 loop
                      sig_delay_mux_bus(i-42) <= sig_input_data_reg(i);
                  end loop;
               when "101011" =>
                   for i in 43 to 63 loop
                      sig_delay_mux_bus(i-43) <= sig_input_data_reg(i);
                  end loop;
               when "101100" =>
                   for i in 44 to 63 loop
                      sig_delay_mux_bus(i-44) <= sig_input_data_reg(i);
                  end loop;
               when "101101" =>
                   for i in 45 to 63 loop
                      sig_delay_mux_bus(i-45) <= sig_input_data_reg(i);
                  end loop;
               when "101110" =>
                   for i in 46 to 63 loop
                      sig_delay_mux_bus(i-46) <= sig_input_data_reg(i);
                  end loop;
               when "101111" =>
                   for i in 47 to 63 loop
                      sig_delay_mux_bus(i-47) <= sig_input_data_reg(i);
                  end loop;
               when "110000" =>
                   for i in 48 to 63 loop
                      sig_delay_mux_bus(i-48) <= sig_input_data_reg(i);
                  end loop;
               when "110001" =>
                   for i in 49 to 63 loop
                      sig_delay_mux_bus(i-49) <= sig_input_data_reg(i);
                  end loop;
               when "110010" =>
                   for i in 50 to 63 loop
                      sig_delay_mux_bus(i-50) <= sig_input_data_reg(i);
                  end loop;
               when "110011" =>
                   for i in 51 to 63 loop
                      sig_delay_mux_bus(i-51) <= sig_input_data_reg(i);
                  end loop;
               when "110100" =>
                   for i in 52 to 63 loop
                      sig_delay_mux_bus(i-52) <= sig_input_data_reg(i);
                  end loop;
               when "110101" =>
                   for i in 53 to 63 loop
                      sig_delay_mux_bus(i-53) <= sig_input_data_reg(i);
                  end loop;
               when "110110" =>
                   for i in 54 to 63 loop
                      sig_delay_mux_bus(i-54) <= sig_input_data_reg(i);
                  end loop;
               when "110111" =>
                   for i in 55 to 63 loop
                      sig_delay_mux_bus(i-55) <= sig_input_data_reg(i);
                  end loop;
               when "111000" =>
                   for i in 56 to 63 loop
                      sig_delay_mux_bus(i-56) <= sig_input_data_reg(i);
                  end loop;
               when "111001" =>
                   for i in 57 to 63 loop
                      sig_delay_mux_bus(i-57) <= sig_input_data_reg(i);
                  end loop;
               when "111010" =>
                   for i in 58 to 63 loop
                      sig_delay_mux_bus(i-58) <= sig_input_data_reg(i);
                  end loop;
               when "111011" =>
                   for i in 59 to 63 loop
                      sig_delay_mux_bus(i-59) <= sig_input_data_reg(i);
                  end loop;
               when "111100" =>
                   for i in 60 to 63 loop
                      sig_delay_mux_bus(i-60) <= sig_input_data_reg(i);
                  end loop;
               when "111101" =>
                   for i in 61 to 63 loop
                      sig_delay_mux_bus(i-61) <= sig_input_data_reg(i);
                  end loop;
               when "111110" =>
                   for i in 62 to 63 loop
                      sig_delay_mux_bus(i-62) <= sig_input_data_reg(i);
                  end loop;
               when "111111" =>
                      sig_delay_mux_bus(0) <= sig_input_data_reg(63);
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_512;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000000"; -- select all pass
                when "000001" =>
                    sig_final_mux_sel <= "0111111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000010" =>
                    sig_final_mux_sel <= "0011111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000011" =>
                    sig_final_mux_sel <= "0001111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000100" =>
                    sig_final_mux_sel <= "0000111111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000101" =>
                    sig_final_mux_sel <= "0000011111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000110" =>
                    sig_final_mux_sel <= "0000001111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "000111" =>
                    sig_final_mux_sel <= "0000000111111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001000" =>
                    sig_final_mux_sel <= "0000000011111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001001" =>
                    sig_final_mux_sel <= "0000000001111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001010" =>
                    sig_final_mux_sel <= "0000000000111111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001011" =>
                    sig_final_mux_sel <= "0000000000011111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001100" =>
                    sig_final_mux_sel <= "0000000000001111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001101" =>
                    sig_final_mux_sel <= "0000000000000111111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001110" =>
                    sig_final_mux_sel <= "0000000000000011111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "001111" =>
                    sig_final_mux_sel <= "0000000000000001111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010000" =>
                    sig_final_mux_sel <= "0000000000000000111111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010001" =>
                    sig_final_mux_sel <= "0000000000000000011111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010010" =>
                    sig_final_mux_sel <= "0000000000000000001111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010011" =>
                    sig_final_mux_sel <= "0000000000000000000111111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010100" =>
                    sig_final_mux_sel <= "0000000000000000000011111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010101" =>
                    sig_final_mux_sel <= "0000000000000000000001111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010110" =>
                    sig_final_mux_sel <= "0000000000000000000000111111111111111111111111111111111111111111"; -- only MSB from Pass
                when "010111" =>
                    sig_final_mux_sel <= "0000000000000000000000011111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011000" =>
                    sig_final_mux_sel <= "0000000000000000000000001111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011001" =>
                    sig_final_mux_sel <= "0000000000000000000000000111111111111111111111111111111111111111"; -- only MSB from Pass
                when "011010" =>
                    sig_final_mux_sel <= "0000000000000000000000000011111111111111111111111111111111111111"; -- only MSB from Pass
                when "011011" =>
                    sig_final_mux_sel <= "0000000000000000000000000001111111111111111111111111111111111111"; -- only MSB from Pass
                when "011100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000111111111111111111111111111111111111"; -- only MSB from Pass
                when "011101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000011111111111111111111111111111111111"; -- only MSB from Pass
                when "011110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000001111111111111111111111111111111111"; -- only MSB from Pass
                when "011111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000111111111111111111111111111111111"; -- only MSB from Pass

               when "100000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000011111111111111111111111111111111"; -- only MSB from Pass
               when "100001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000001111111111111111111111111111111"; -- only MSB from Pass
               when "100010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000111111111111111111111111111111"; -- only MSB from Pass
               when "100011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000011111111111111111111111111111"; -- only MSB from Pass
               when "100100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000001111111111111111111111111111"; -- only MSB from Pass
               when "100101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000111111111111111111111111111"; -- only MSB from Pass
               when "100110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000011111111111111111111111111"; -- only MSB from Pass
               when "100111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000001111111111111111111111111"; -- only MSB from Pass
               when "101000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000111111111111111111111111"; -- only MSB from Pass
               when "101001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000011111111111111111111111"; -- only MSB from Pass
               when "101010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000001111111111111111111111"; -- only MSB from Pass
               when "101011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000111111111111111111111"; -- only MSB from Pass
               when "101100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000011111111111111111111"; -- only MSB from Pass
               when "101101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000001111111111111111111"; -- only MSB from Pass
               when "101110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000111111111111111111"; -- only MSB from Pass
               when "101111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000011111111111111111"; -- only MSB from Pass
               when "110000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000001111111111111111"; -- only MSB from Pass
               when "110001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000111111111111111"; -- only MSB from Pass
               when "110010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000011111111111111"; -- only MSB from Pass
               when "110011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000001111111111111"; -- only MSB from Pass
               when "110100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000111111111111"; -- only MSB from Pass
               when "110101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000011111111111"; -- only MSB from Pass
               when "110110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000001111111111"; -- only MSB from Pass
               when "110111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000111111111"; -- only MSB from Pass
               when "111000" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000011111111"; -- only MSB from Pass
               when "111001" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000001111111"; -- only MSB from Pass
               when "111010" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000111111"; -- only MSB from Pass
               when "111011" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000011111"; -- only MSB from Pass
               when "111100" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000001111"; -- only MSB from Pass
               when "111101" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000111"; -- only MSB from Pass
               when "111110" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000011"; -- only MSB from Pass
               when "111111" =>
                    sig_final_mux_sel <= "0000000000000000000000000000000000000000000000000000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 63 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_512;



     GEN_MUXFARM_256 : if (C_DWIDTH = 256) generate
   
         signal sig_cntl_state_256    : std_logic_vector(9 downto 0) := (others => '0');
         Signal s_case_i_256          : Integer range 0 to 64 := 0; -- 64 to avoid sim overflow
         Signal sig_shift_case_i     : std_logic_vector(4 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(4 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(31 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_32
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_32 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(31 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00000000000000000000000000000000";

              elsif (sig_tlast_strobes(31) = '1') then
              
                sig_tlast_enables <= "10000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(30) = '1') then
              
                sig_tlast_enables <= "01000000000000000000000000000000";
              
              elsif (sig_tlast_strobes(29) = '1') then
              
                sig_tlast_enables <= "00100000000000000000000000000000";
              
              elsif (sig_tlast_strobes(28) = '1') then
              
                sig_tlast_enables <= "00010000000000000000000000000000";
              
              elsif (sig_tlast_strobes(27) = '1') then
              
                sig_tlast_enables <= "00001000000000000000000000000000";
              
              elsif (sig_tlast_strobes(26) = '1') then
              
                sig_tlast_enables <= "00000100000000000000000000000000";
              
              elsif (sig_tlast_strobes(25) = '1') then
              
                sig_tlast_enables <= "00000010000000000000000000000000";

              elsif (sig_tlast_strobes(24) = '1') then
              
                sig_tlast_enables <= "00000001000000000000000000000000";

              elsif (sig_tlast_strobes(23) = '1') then
              
                sig_tlast_enables <= "00000000100000000000000000000000";
              
              elsif (sig_tlast_strobes(22) = '1') then
              
                sig_tlast_enables <= "00000000010000000000000000000000";
              
              elsif (sig_tlast_strobes(21) = '1') then
              
                sig_tlast_enables <= "00000000001000000000000000000000";
              
              elsif (sig_tlast_strobes(20) = '1') then
              
                sig_tlast_enables <= "00000000000100000000000000000000";
              
              elsif (sig_tlast_strobes(19) = '1') then
              
                sig_tlast_enables <= "00000000000010000000000000000000";
              
              elsif (sig_tlast_strobes(18) = '1') then
              
                sig_tlast_enables <= "00000000000001000000000000000000";
              
              elsif (sig_tlast_strobes(17) = '1') then
              
                sig_tlast_enables <= "00000000000000100000000000000000";
              
              elsif (sig_tlast_strobes(16) = '1') then
              
                sig_tlast_enables <= "00000000000000010000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "00000000000000001000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "00000000000000000100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "00000000000000000010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "00000000000000000001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "00000000000000000000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "00000000000000000000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "00000000000000000000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "00000000000000000000000000000010";
              
              else
              
                sig_tlast_enables <= "00000000000000000000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_32; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_256, 5));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_256 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_256)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 256 and above.    
             
             sig_cntl_state_256 <= dre_src_align (4 downto 0) & sig_dest_align_i (4 downto 0); 
             --sig_cntl_state_256 <= sig_dest_align_i (4 downto 0); 
               
           if (dre_src_align (4 downto 0) = sig_dest_align_i (4 downto 0)) then
               s_case_i_256 <= 0; 
           elsif (dre_src_align (4 downto 0) < sig_dest_align_i (4 downto 0)) then
               s_case_i_256 <= 32 - (func_ret_int_5(sig_dest_align_i (4 downto 0)) - func_ret_int_5(dre_src_align (4 downto 0))); 
  
           else
               s_case_i_256 <= func_ret_int_5(dre_src_align (4 downto 0)) - func_ret_int_5(sig_dest_align_i (4 downto 0)); 

           end if;

         
        
           end process DO_SHIFT_CASE_256; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               --elsif (dre_new_align    = '1' and
               --       sig_input_accept = '1') then
               elsif (sig_cntl_accept = '1') then 
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_256 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 31 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "00000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "00001" =>
                  sig_pass_mux_bus(31) <= sig_input_data_reg(0);
               when "00010" =>
                  sig_pass_mux_bus(30) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(1);
               when "00011" =>
                  sig_pass_mux_bus(29) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(2);
               when "00100" =>
                  sig_pass_mux_bus(28) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(3);
               when "00101" =>
                  sig_pass_mux_bus(27) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(4);
               when "00110" =>
                  sig_pass_mux_bus(26) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(5);
               when "00111" =>
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(6);
               when "01000" =>
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(7);
               when "01001" =>
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(8);
               when "01010" =>
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(9);
               when "01011" =>
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(10);
               when "01100" =>
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(11);
               when "01101" =>
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(12);
               when "01110" =>
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(13);
               when "01111" =>
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(14);
               when "10000" =>
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(25) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(26) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(27) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(28) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(29) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(30) <= sig_input_data_reg(14);
                  sig_pass_mux_bus(31) <= sig_input_data_reg(15);
               when "10001" =>
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(16);
               when "10010" =>
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(17);
               when "10011" =>
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(18);
               when "10100" =>
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(19);
               when "10101" =>
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(20);
               when "10110" =>
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(21);
               when "10111" =>
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(22);
               when "11000" =>
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(23);
               when "11001" =>
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(24);
               when "11010" =>
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(25);
               when "11011" =>
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(26);
               when "11100" =>
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(27);
               when "11101" =>
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(28);
               when "11110" =>
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(28);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(29);
               when "11111" =>
                  sig_pass_mux_bus(1)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(10)  <= sig_input_data_reg(9);
                  sig_pass_mux_bus(11)  <= sig_input_data_reg(10);
                  sig_pass_mux_bus(12)  <= sig_input_data_reg(11);
                  sig_pass_mux_bus(13)  <= sig_input_data_reg(12);
                  sig_pass_mux_bus(14)  <= sig_input_data_reg(13);
                  sig_pass_mux_bus(15)  <= sig_input_data_reg(14);
                  sig_pass_mux_bus(16)  <= sig_input_data_reg(15);
                  sig_pass_mux_bus(17)  <= sig_input_data_reg(16);
                  sig_pass_mux_bus(18)  <= sig_input_data_reg(17);
                  sig_pass_mux_bus(19)  <= sig_input_data_reg(18);
                  sig_pass_mux_bus(20)  <= sig_input_data_reg(19);
                  sig_pass_mux_bus(21)  <= sig_input_data_reg(20);
                  sig_pass_mux_bus(22)  <= sig_input_data_reg(21);
                  sig_pass_mux_bus(23)  <= sig_input_data_reg(22);
                  sig_pass_mux_bus(24)  <= sig_input_data_reg(23);
                  sig_pass_mux_bus(25)  <= sig_input_data_reg(24);
                  sig_pass_mux_bus(26)  <= sig_input_data_reg(25);
                  sig_pass_mux_bus(27)  <= sig_input_data_reg(26);
                  sig_pass_mux_bus(28)  <= sig_input_data_reg(27);
                  sig_pass_mux_bus(29)  <= sig_input_data_reg(28);
                  sig_pass_mux_bus(30)  <= sig_input_data_reg(29);
                  sig_pass_mux_bus(31)  <= sig_input_data_reg(30);
               when others =>
                  null;   

             end case;   
         end process PASS_MUX_256;


         DELAY_MUX_256 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 31 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;
             case sig_shift_case_reg is
               when "00000" =>
                   
               when "00001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(1); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(29) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(30) <= sig_input_data_reg(31); 
               when "00010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(29) <= sig_input_data_reg(31); 
               when "00011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(28) <= sig_input_data_reg(31); 
               when "00100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(27) <= sig_input_data_reg(31); 
               when "00101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(26) <= sig_input_data_reg(31); 
               when "00110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(25) <= sig_input_data_reg(31); 
               when "00111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(24) <= sig_input_data_reg(31); 
               when "01000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(23) <= sig_input_data_reg(31); 
               when "01001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(22) <= sig_input_data_reg(31); 
               when "01010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(21) <= sig_input_data_reg(31); 
               when "01011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(20) <= sig_input_data_reg(31); 
               when "01100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(19) <= sig_input_data_reg(31); 
               when "01101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(18) <= sig_input_data_reg(31); 
               when "01110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(17) <= sig_input_data_reg(31); 
               when "01111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(15); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(16) <= sig_input_data_reg(31); 

               when "10000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(16); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(15) <= sig_input_data_reg(31); 
               when "10001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(17); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(31); 
               when "10010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(18); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(31); 
               when "10011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(19); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(31); 
               when "10100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(20); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(31); 
               when "10101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(21); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(31); 
               when "10110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(22); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(31); 
               when "10111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(23); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(31); 
               when "11000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(24); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(31); 
               when "11001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(25); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(31); 
               when "11010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(26); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(31); 
               when "11011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(27); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(31); 
               when "11100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(28); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(31); 
               when "11101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(29); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(31); 
               when "11110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(30); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(31); 
               when "11111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(31); 
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_256;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00000" =>
                    sig_final_mux_sel <= "00000000000000000000000000000000"; -- select all pass
                when "00001" =>
                    sig_final_mux_sel <= "01111111111111111111111111111111"; -- only MSB from Pass
                when "00010" =>
                    sig_final_mux_sel <= "00111111111111111111111111111111"; -- only MSB from Pass
                when "00011" =>
                    sig_final_mux_sel <= "00011111111111111111111111111111"; -- only MSB from Pass
                when "00100" =>
                    sig_final_mux_sel <= "00001111111111111111111111111111"; -- only MSB from Pass
                when "00101" =>
                    sig_final_mux_sel <= "00000111111111111111111111111111"; -- only MSB from Pass
                when "00110" =>
                    sig_final_mux_sel <= "00000011111111111111111111111111"; -- only MSB from Pass
                when "00111" =>
                    sig_final_mux_sel <= "00000001111111111111111111111111"; -- only MSB from Pass
                when "01000" =>
                    sig_final_mux_sel <= "00000000111111111111111111111111"; -- only MSB from Pass
                when "01001" =>
                    sig_final_mux_sel <= "00000000011111111111111111111111"; -- only MSB from Pass
                when "01010" =>
                    sig_final_mux_sel <= "00000000001111111111111111111111"; -- only MSB from Pass
                when "01011" =>
                    sig_final_mux_sel <= "00000000000111111111111111111111"; -- only MSB from Pass
                when "01100" =>
                    sig_final_mux_sel <= "00000000000011111111111111111111"; -- only MSB from Pass
                when "01101" =>
                    sig_final_mux_sel <= "00000000000001111111111111111111"; -- only MSB from Pass
                when "01110" =>
                    sig_final_mux_sel <= "00000000000000111111111111111111"; -- only MSB from Pass
                when "01111" =>
                    sig_final_mux_sel <= "00000000000000011111111111111111"; -- only MSB from Pass
                when "10000" =>
                    sig_final_mux_sel <= "00000000000000001111111111111111"; -- only MSB from Pass
                when "10001" =>
                    sig_final_mux_sel <= "00000000000000000111111111111111"; -- only MSB from Pass
                when "10010" =>
                    sig_final_mux_sel <= "00000000000000000011111111111111"; -- only MSB from Pass
                when "10011" =>
                    sig_final_mux_sel <= "00000000000000000001111111111111"; -- only MSB from Pass
                when "10100" =>
                    sig_final_mux_sel <= "00000000000000000000111111111111"; -- only MSB from Pass
                when "10101" =>
                    sig_final_mux_sel <= "00000000000000000000011111111111"; -- only MSB from Pass
                when "10110" =>
                    sig_final_mux_sel <= "00000000000000000000001111111111"; -- only MSB from Pass
                when "10111" =>
                    sig_final_mux_sel <= "00000000000000000000000111111111"; -- only MSB from Pass
                when "11000" =>
                    sig_final_mux_sel <= "00000000000000000000000011111111"; -- only MSB from Pass
                when "11001" =>
                    sig_final_mux_sel <= "00000000000000000000000001111111"; -- only MSB from Pass
                when "11010" =>
                    sig_final_mux_sel <= "00000000000000000000000000111111"; -- only MSB from Pass
                when "11011" =>
                    sig_final_mux_sel <= "00000000000000000000000000011111"; -- only MSB from Pass
                when "11100" =>
                    sig_final_mux_sel <= "00000000000000000000000000001111"; -- only MSB from Pass
                when "11101" =>
                    sig_final_mux_sel <= "00000000000000000000000000000111"; -- only MSB from Pass
                when "11110" =>
                    sig_final_mux_sel <= "00000000000000000000000000000011"; -- only MSB from Pass
                when "11111" =>
                    sig_final_mux_sel <= "00000000000000000000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 31 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_256;





     GEN_MUXFARM_128 : if (C_DWIDTH = 128) generate
   
         signal sig_cntl_state_128    : std_logic_vector(7 downto 0) := (others => '0');
         Signal s_case_i_128          : Integer range 0 to 32 := 0; -- 32 to avoid simulation overflow
         Signal sig_shift_case_i     : std_logic_vector(3 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(3 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(15 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_8
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_16 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(15 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000000000000000";
              
              elsif (sig_tlast_strobes(15) = '1') then
              
                sig_tlast_enables <= "1000000000000000";
              
              elsif (sig_tlast_strobes(14) = '1') then
              
                sig_tlast_enables <= "0100000000000000";
              
              elsif (sig_tlast_strobes(13) = '1') then
              
                sig_tlast_enables <= "0010000000000000";
              
              elsif (sig_tlast_strobes(12) = '1') then
              
                sig_tlast_enables <= "0001000000000000";
              
              elsif (sig_tlast_strobes(11) = '1') then
              
                sig_tlast_enables <= "0000100000000000";
              
              elsif (sig_tlast_strobes(10) = '1') then
              
                sig_tlast_enables <= "0000010000000000";
              
              elsif (sig_tlast_strobes(9) = '1') then
              
                sig_tlast_enables <= "0000001000000000";

              elsif (sig_tlast_strobes(8) = '1') then
              
                sig_tlast_enables <= "0000000100000000";

              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "0000000010000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "0000000001000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "0000000000100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "0000000000010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "0000000000001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0000000000000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0000000000000010";
              
              else
              
                sig_tlast_enables <= "0000000000000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_16; 
         
   
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_128, 4));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_128 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_128)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
         -- Not planning to have DSA alignment for 128 and above.    
             
             sig_cntl_state_128 <= dre_src_align (3 downto 0) & sig_dest_align_i (3 downto 0); 
             --sig_cntl_state_128 <= sig_dest_align_i (3 downto 0); 

           if (dre_src_align (3 downto 0) = sig_dest_align_i (3 downto 0)) then
               s_case_i_128 <= 0;
           elsif (dre_src_align (3 downto 0) < sig_dest_align_i (3 downto 0)) then
               s_case_i_128 <= 16 - (func_ret_int_4(sig_dest_align_i (3 downto 0)) - func_ret_int_4(dre_src_align (3 downto 0)));

           else
               s_case_i_128 <= func_ret_int_4(dre_src_align (3 downto 0)) - func_ret_int_4(sig_dest_align_i (3 downto 0));

           end if;


         
        
           end process DO_SHIFT_CASE_128; 
         
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               --elsif (dre_new_align    = '1' and
               --       sig_input_accept = '1') then
               elsif (sig_cntl_accept = '1') then 
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;



         PASS_MUX_128 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 15 loop
                      sig_pass_mux_bus(i) <= (others => '0');
                  end loop;
               
             case sig_shift_case_reg is
               when "0000" =>
                  sig_pass_mux_bus <= sig_input_data_reg;
               when "0001" =>
                  sig_pass_mux_bus(15) <= sig_input_data_reg(0);
               when "0010" =>
                  sig_pass_mux_bus(14) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(1);
               when "0011" =>
                  sig_pass_mux_bus(13) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(2);
               when "0100" =>
                  sig_pass_mux_bus(12) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(3);
               when "0101" =>
                  sig_pass_mux_bus(11) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(4);
               when "0110" =>
                  sig_pass_mux_bus(10) <= sig_input_data_reg(0);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(5);
               when "0111" =>
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(1);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(6);
               when "1000" =>
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(2);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(7);
               when "1001" =>
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(3);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(8);
               when "1010" =>
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(4);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(9);
               when "1011" =>
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(5);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(10);
               when "1100" =>
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(6);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(11);
               when "1101" =>
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(7);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(12);
               when "1110" =>
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(8);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(13);
               when "1111" =>
                  sig_pass_mux_bus(1)  <= sig_input_data_reg(0);
                  sig_pass_mux_bus(2)  <= sig_input_data_reg(1);
                  sig_pass_mux_bus(3)  <= sig_input_data_reg(2);
                  sig_pass_mux_bus(4)  <= sig_input_data_reg(3);
                  sig_pass_mux_bus(5)  <= sig_input_data_reg(4);
                  sig_pass_mux_bus(6)  <= sig_input_data_reg(5);
                  sig_pass_mux_bus(7)  <= sig_input_data_reg(6);
                  sig_pass_mux_bus(8)  <= sig_input_data_reg(7);
                  sig_pass_mux_bus(9)  <= sig_input_data_reg(8);
                  sig_pass_mux_bus(10) <= sig_input_data_reg(9);
                  sig_pass_mux_bus(11) <= sig_input_data_reg(10);
                  sig_pass_mux_bus(12) <= sig_input_data_reg(11);
                  sig_pass_mux_bus(13) <= sig_input_data_reg(12);
                  sig_pass_mux_bus(14) <= sig_input_data_reg(13);
                  sig_pass_mux_bus(15) <= sig_input_data_reg(14);
               when others =>
                  null;   

             end case;   
         end process PASS_MUX_128;


         DELAY_MUX_128 : process (sig_shift_case_reg,
                                 sig_input_data_reg)
           
           -- signal sig_cntl_state_64 : std_logic_vector(5 downto 0);
           -- Signal s_case_i_64   : Integer range 0 to 7;
           
           
           begin
             
                  for i in 0 to 15 loop
                      sig_delay_mux_bus(i) <= (others => '0');
                  end loop;
             case sig_shift_case_reg is
               when "0000" =>
                   
               when "0001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(1); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(14) <= sig_input_data_reg(15); 
               when "0010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(2); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(13) <= sig_input_data_reg(15); 
               when "0011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(3); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(12) <= sig_input_data_reg(15); 
               when "0100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(4); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(11) <= sig_input_data_reg(15); 
               when "0101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(5); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(10) <= sig_input_data_reg(15); 
               when "0110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(6); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(9) <= sig_input_data_reg(15); 
               when "0111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(7); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(8) <= sig_input_data_reg(15); 
               when "1000" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(8); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(7) <= sig_input_data_reg(15); 
               when "1001" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(9); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(6) <= sig_input_data_reg(15); 
               when "1010" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(10); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(5) <= sig_input_data_reg(15); 
               when "1011" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(11); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(4) <= sig_input_data_reg(15); 
               when "1100" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(12); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(3) <= sig_input_data_reg(15); 
               when "1101" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(13); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(2) <= sig_input_data_reg(15); 
               when "1110" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(14); 
                  sig_delay_mux_bus(1) <= sig_input_data_reg(15); 
               when "1111" =>
                  sig_delay_mux_bus(0) <= sig_input_data_reg(15); 
               when others =>
                  null;   

             end case;   
         end process DELAY_MUX_128;

       FINAL_MUX_SEL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "0000" =>
                    sig_final_mux_sel <= "0000000000000000"; -- select all pass
                when "0001" =>
                    sig_final_mux_sel <= "0111111111111111"; -- only MSB from Pass
                when "0010" =>
                    sig_final_mux_sel <= "0011111111111111"; -- only MSB from Pass
                when "0011" =>
                    sig_final_mux_sel <= "0001111111111111"; -- only MSB from Pass
                when "0100" =>
                    sig_final_mux_sel <= "0000111111111111"; -- only MSB from Pass
                when "0101" =>
                    sig_final_mux_sel <= "0000011111111111"; -- only MSB from Pass
                when "0110" =>
                    sig_final_mux_sel <= "0000001111111111"; -- only MSB from Pass
                when "0111" =>
                    sig_final_mux_sel <= "0000000111111111"; -- only MSB from Pass
                when "1000" =>
                    sig_final_mux_sel <= "0000000011111111"; -- only MSB from Pass
                when "1001" =>
                    sig_final_mux_sel <= "0000000001111111"; -- only MSB from Pass
                when "1010" =>
                    sig_final_mux_sel <= "0000000000111111"; -- only MSB from Pass
                when "1011" =>
                    sig_final_mux_sel <= "0000000000011111"; -- only MSB from Pass
                when "1100" =>
                    sig_final_mux_sel <= "0000000000001111"; -- only MSB from Pass
                when "1101" =>
                    sig_final_mux_sel <= "0000000000000111"; -- only MSB from Pass
                when "1110" =>
                    sig_final_mux_sel <= "0000000000000011"; -- only MSB from Pass
                when "1111" =>
                    sig_final_mux_sel <= "0000000000000001"; -- only MSB from Pass
                when others =>
                    null;
              end case;

           end process FINAL_MUX_SEL;

           FINAL_MUX : for i in 0 to 15 generate

              I_MUX2_1_FINAL : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
                generic map(
                  C_WIDTH =>  SLICE_WIDTH
                )
                port map(
                  Sel    =>  sig_final_mux_sel(i) ,
                  I0     =>  sig_pass_mux_bus(i)  ,
                  I1     =>  sig_delay_data_reg(i),
                  Y      =>  sig_final_mux_bus(i)
             );


           end generate FINAL_MUX;


     end generate GEN_MUXFARM_128;
     
     
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_64
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 64-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_64 : if (C_DWIDTH = 64) generate
   
         Signal s_case_i_64          : Integer range 0 to 7 := 0;
         signal sig_cntl_state_64    : std_logic_vector(5 downto 0) := (others => '0');
         Signal sig_shift_case_i     : std_logic_vector(2 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(2 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(7 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_8
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_8 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(7 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00000000";
              
              elsif (sig_tlast_strobes(7) = '1') then
              
                sig_tlast_enables <= "10000000";
              
              elsif (sig_tlast_strobes(6) = '1') then
              
                sig_tlast_enables <= "01000000";
              
              elsif (sig_tlast_strobes(5) = '1') then
              
                sig_tlast_enables <= "00100000";
              
              elsif (sig_tlast_strobes(4) = '1') then
              
                sig_tlast_enables <= "00010000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "00001000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "00000100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "00000010";
              
              else
              
                sig_tlast_enables <= "00000001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_8; 
         

  
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
                               

         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_64, 3);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_64, 3));
         
         

          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_64
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_64 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_64)
           
           
           begin
             
             
             sig_cntl_state_64 <= dre_src_align & sig_dest_align_i; 
               
             case sig_cntl_state_64 is
               when "000000" =>
                  s_case_i_64 <= 0;
               when "000001" => 
                  s_case_i_64 <= 7;
               when "000010" =>
                  s_case_i_64 <= 6;
               when "000011" => 
                  s_case_i_64 <= 5;
               when "000100" => 
                  s_case_i_64 <= 4;
               when "000101" => 
                  s_case_i_64 <= 3;
               when "000110" => 
                  s_case_i_64 <= 2;
               when "000111" => 
                  s_case_i_64 <= 1;
               
               when "001000" =>
                  s_case_i_64 <= 1;
               when "001001" => 
                  s_case_i_64 <= 0;
               when "001010" =>
                  s_case_i_64 <= 7;
               when "001011" => 
                  s_case_i_64 <= 6;
               when "001100" => 
                  s_case_i_64 <= 5;
               when "001101" => 
                  s_case_i_64 <= 4;
               when "001110" => 
                  s_case_i_64 <= 3;
               when "001111" => 
                  s_case_i_64 <= 2;
               
               when "010000" =>
                  s_case_i_64 <= 2;
               when "010001" => 
                  s_case_i_64 <= 1;
               when "010010" =>
                  s_case_i_64 <= 0;
               when "010011" => 
                  s_case_i_64 <= 7;
               when "010100" => 
                  s_case_i_64 <= 6;
               when "010101" => 
                  s_case_i_64 <= 5;
               when "010110" => 
                  s_case_i_64 <= 4;
               when "010111" => 
                  s_case_i_64 <= 3;
               
               when "011000" =>
                  s_case_i_64 <= 3;
               when "011001" => 
                  s_case_i_64 <= 2;
               when "011010" =>
                  s_case_i_64 <= 1;
               when "011011" => 
                  s_case_i_64 <= 0;
               when "011100" => 
                  s_case_i_64 <= 7;
               when "011101" => 
                  s_case_i_64 <= 6;
               when "011110" => 
                  s_case_i_64 <= 5;
               when "011111" => 
                  s_case_i_64 <= 4;
               
               when "100000" =>
                  s_case_i_64 <= 4;
               when "100001" => 
                  s_case_i_64 <= 3;
               when "100010" =>
                  s_case_i_64 <= 2;
               when "100011" => 
                  s_case_i_64 <= 1;
               when "100100" => 
                  s_case_i_64 <= 0;
               when "100101" => 
                  s_case_i_64 <= 7;
               when "100110" => 
                  s_case_i_64 <= 6;
               when "100111" => 
                  s_case_i_64 <= 5;
               
               when "101000" =>
                  s_case_i_64 <= 5;
               when "101001" => 
                  s_case_i_64 <= 4;
               when "101010" =>
                  s_case_i_64 <= 3;
               when "101011" => 
                  s_case_i_64 <= 2;
               when "101100" => 
                  s_case_i_64 <= 1;
               when "101101" => 
                  s_case_i_64 <= 0;
               when "101110" => 
                  s_case_i_64 <= 7;
               when "101111" => 
                  s_case_i_64 <= 6;
               
               when "110000" =>
                  s_case_i_64 <= 6;
               when "110001" => 
                  s_case_i_64 <= 5;
               when "110010" =>
                  s_case_i_64 <= 4;
               when "110011" => 
                  s_case_i_64 <= 3;
               when "110100" => 
                  s_case_i_64 <= 2;
               when "110101" => 
                  s_case_i_64 <= 1;
               when "110110" => 
                  s_case_i_64 <= 0;
               when "110111" => 
                  s_case_i_64 <= 7;
               
               when "111000" =>
                  s_case_i_64 <= 7;
               when "111001" => 
                  s_case_i_64 <= 6;
               when "111010" => 
                  s_case_i_64 <= 5;
               when "111011" => 
                  s_case_i_64 <= 4;
               when "111100" => 
                  s_case_i_64 <= 3;
               when "111101" => 
                  s_case_i_64 <= 2;
               when "111110" => 
                  s_case_i_64 <= 1;
               when "111111" => 
                  s_case_i_64 <= 0;
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_64; 
         
          
          
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (sig_cntl_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;


 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....

        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(0),  
              I0     =>  sig_input_data_reg(1),  
              I1     =>  sig_input_data_reg(0),  
              Y      =>  sig_pass_mux_bus(1)     
             );


        -- Pass Mux Byte 2 (4-1 x8 Mux)

        I_MUX4_1_PASS_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(2)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              Y      =>  sig_pass_mux_bus(2)              
             );


        -- Pass Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_PASS_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(3)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              Y      =>  sig_pass_mux_bus(3)              
             );


        -- Pass Mux Byte 4 (8-1 x8 Mux)

        I_MUX8_1_PASS_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(4)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  ZEROED_SLICE                  ,  
              I3     =>  ZEROED_SLICE                  ,  
              I4     =>  sig_input_data_reg(0)         ,  
              I5     =>  sig_input_data_reg(1)         ,  
              I6     =>  sig_input_data_reg(2)         ,  
              I7     =>  sig_input_data_reg(3)         ,  
              Y      =>  sig_pass_mux_bus(4)              
             );


        -- Pass Mux Byte 5 (8-1 x8 Mux)

        I_MUX8_1_PASS_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(5)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  ZEROED_SLICE                  ,  
              I3     =>  sig_input_data_reg(0)         ,  
              I4     =>  sig_input_data_reg(1)         ,  
              I5     =>  sig_input_data_reg(2)         ,  
              I6     =>  sig_input_data_reg(3)         ,  
              I7     =>  sig_input_data_reg(4)         ,  
              Y      =>  sig_pass_mux_bus(5)              
             );


        -- Pass Mux Byte 6 (8-1 x8 Mux)

        I_MUX8_1_PASS_B6 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(6)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              I4     =>  sig_input_data_reg(2)         ,  
              I5     =>  sig_input_data_reg(3)         ,  
              I6     =>  sig_input_data_reg(4)         ,  
              I7     =>  sig_input_data_reg(5)         ,  
              Y      =>  sig_pass_mux_bus(6)              
             );


        -- Pass Mux Byte 7 (8-1 x8 Mux)

        I_MUX8_1_PASS_B7 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  sig_input_data_reg(7)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              I4     =>  sig_input_data_reg(3)         ,  
              I5     =>  sig_input_data_reg(4)         ,  
              I6     =>  sig_input_data_reg(5)         ,  
              I7     =>  sig_input_data_reg(6)         ,  
              Y      =>  sig_pass_mux_bus(7)              
             );



        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------


        -- Delay Mux Byte 0 (8-1 x8 Mux)

        I_MUX8_1_DLY_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0) ,  
              I0     =>  ZEROED_SLICE                   ,  
              I1     =>  sig_input_data_reg(1)          ,  
              I2     =>  sig_input_data_reg(2)          ,  
              I3     =>  sig_input_data_reg(3)          ,  
              I4     =>  sig_input_data_reg(4)          ,  
              I5     =>  sig_input_data_reg(5)          ,  
              I6     =>  sig_input_data_reg(6)          ,  
              I7     =>  sig_input_data_reg(7)          ,  
              Y      =>  sig_delay_mux_bus(0)              
             );


        -- Delay Mux Byte 1 (8-1 x8 Mux)

        I_MUX8_1_DLY_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(2)         ,  
              I2     =>  sig_input_data_reg(3)         ,  
              I3     =>  sig_input_data_reg(4)         ,  
              I4     =>  sig_input_data_reg(5)         ,  
              I5     =>  sig_input_data_reg(6)         ,  
              I6     =>  sig_input_data_reg(7)         ,  
              I7     =>  ZEROED_SLICE                  ,  
              Y      =>  sig_delay_mux_bus(1)             
             );


        -- Delay Mux Byte 2 (8-1 x8 Mux)

        I_MUX8_1_DLY_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux8_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(2 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(3)         ,  
              I2     =>  sig_input_data_reg(4)         ,  
              I3     =>  sig_input_data_reg(5)         ,  
              I4     =>  sig_input_data_reg(6)         ,  
              I5     =>  sig_input_data_reg(7)         ,  
              I6     =>  ZEROED_SLICE                  ,  
              I7     =>  ZEROED_SLICE                  ,  
              Y      =>  sig_delay_mux_bus(2)             
             );


        -- Delay Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_DLY_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(7)         ,  
              I1     =>  sig_input_data_reg(4)         ,  
              I2     =>  sig_input_data_reg(5)         ,  
              I3     =>  sig_input_data_reg(6)         ,  
              Y      =>  sig_delay_mux_bus(3)             
             );


        -- Delay Mux Byte 4 (4-1 x8 Mux)

        I_MUX4_1_DLY_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(5)         ,  
              I2     =>  sig_input_data_reg(6)         ,  
              I3     =>  sig_input_data_reg(7)         ,  
              Y      =>  sig_delay_mux_bus(4)             
             );


        -- Delay Mux Byte 5 (2-1 x8 Mux)

        I_MUX2_1_DLY_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  --  : Integer := 8
             )
          port map(
              Sel    =>  sig_shift_case_reg(0), 
              I0     =>  sig_input_data_reg(7), 
              I1     =>  sig_input_data_reg(6), 
              Y      =>  sig_delay_mux_bus(5)   
             );



        -- Delay Mux Byte 6 (Wire)

        sig_delay_mux_bus(6) <= sig_input_data_reg(7);



        -- Delay Mux Byte 7 (Zeroed)

        sig_delay_mux_bus(7) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        



        -- Final Mux Byte 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(0) <= '0';
                when "001" =>
                    sig_final_mux_sel(0) <= '1';
                when "010" =>
                    sig_final_mux_sel(0) <= '1';
                when "011" =>
                    sig_final_mux_sel(0) <= '1';
                when "100" =>
                    sig_final_mux_sel(0) <= '1';
                when "101" =>
                    sig_final_mux_sel(0) <= '1';
                when "110" =>
                    sig_final_mux_sel(0) <= '1';
                when "111" =>
                    sig_final_mux_sel(0) <= '1';
                when others =>
                    sig_final_mux_sel(0) <= '0';
              end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) ,  
              I0     =>  sig_input_data_reg(0),  
              I1     =>  sig_delay_data_reg(0),  
              Y      =>  sig_final_mux_bus(0)    
             );




        -- Final Mux Byte 1 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B1_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 1 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B1_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(1) <= '0';
                when "001" =>
                    sig_final_mux_sel(1) <= '1';
                when "010" =>
                    sig_final_mux_sel(1) <= '1';
                when "011" =>
                    sig_final_mux_sel(1) <= '1';
                when "100" =>
                    sig_final_mux_sel(1) <= '1';
                when "101" =>
                    sig_final_mux_sel(1) <= '1';
                when "110" =>
                    sig_final_mux_sel(1) <= '1';
                when "111" =>
                    sig_final_mux_sel(1) <= '0';
                when others =>
                    sig_final_mux_sel(1) <= '0';
              end case;

           end process MUX2_1_FINAL_B1_CNTL;



        I_MUX2_1_FINAL_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(1) , 
              I0     =>  sig_pass_mux_bus(1)  , 
              I1     =>  sig_delay_data_reg(1), 
              Y      =>  sig_final_mux_bus(1)   
             );




        -- Final Mux Byte 2 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B2_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 2 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B2_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(2) <= '0';
                when "001" =>
                    sig_final_mux_sel(2) <= '1';
                when "010" =>
                    sig_final_mux_sel(2) <= '1';
                when "011" =>
                    sig_final_mux_sel(2) <= '1';
                when "100" =>
                    sig_final_mux_sel(2) <= '1';
                when "101" =>
                    sig_final_mux_sel(2) <= '1';
                when "110" =>
                    sig_final_mux_sel(2) <= '0';
                when "111" =>
                    sig_final_mux_sel(2) <= '0';
                when others =>
                    sig_final_mux_sel(2) <= '0';
              end case;

           end process MUX2_1_FINAL_B2_CNTL;



        I_MUX2_1_FINAL_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(2) , 
              I0     =>  sig_pass_mux_bus(2)  , 
              I1     =>  sig_delay_data_reg(2), 
              Y      =>  sig_final_mux_bus(2)   
             );




        -- Final Mux Byte 3 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B3_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 3 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B3_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(3) <= '0';
                when "001" =>
                    sig_final_mux_sel(3) <= '1';
                when "010" =>
                    sig_final_mux_sel(3) <= '1';
                when "011" =>
                    sig_final_mux_sel(3) <= '1';
                when "100" =>
                    sig_final_mux_sel(3) <= '1';
                when "101" =>
                    sig_final_mux_sel(3) <= '0';
                when "110" =>
                    sig_final_mux_sel(3) <= '0';
                when "111" =>
                    sig_final_mux_sel(3) <= '0';
                when others =>
                    sig_final_mux_sel(3) <= '0';
              end case;

           end process MUX2_1_FINAL_B3_CNTL;



        I_MUX2_1_FINAL_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(3) ,
              I0     =>  sig_pass_mux_bus(3)  ,
              I1     =>  sig_delay_data_reg(3),
              Y      =>  sig_final_mux_bus(3)  
             );




        -- Final Mux Byte 4 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B4_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 4 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B4_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(4) <= '0';
                when "001" =>
                    sig_final_mux_sel(4) <= '1';
                when "010" =>
                    sig_final_mux_sel(4) <= '1';
                when "011" =>
                    sig_final_mux_sel(4) <= '1';
                when "100" =>
                    sig_final_mux_sel(4) <= '0';
                when "101" =>
                    sig_final_mux_sel(4) <= '0';
                when "110" =>
                    sig_final_mux_sel(4) <= '0';
                when "111" =>
                    sig_final_mux_sel(4) <= '0';
                when others =>
                    sig_final_mux_sel(4) <= '0';
              end case;

           end process MUX2_1_FINAL_B4_CNTL;



        I_MUX2_1_FINAL_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(4) ,
              I0     =>  sig_pass_mux_bus(4)  ,
              I1     =>  sig_delay_data_reg(4),
              Y      =>  sig_final_mux_bus(4)  
             );




        -- Final Mux Byte 5 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B5_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 5 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B5_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(5) <= '0';
                when "001" =>
                    sig_final_mux_sel(5) <= '1';
                when "010" =>
                    sig_final_mux_sel(5) <= '1';
                when "011" =>
                    sig_final_mux_sel(5) <= '0';
                when "100" =>
                    sig_final_mux_sel(5) <= '0';
                when "101" =>
                    sig_final_mux_sel(5) <= '0';
                when "110" =>
                    sig_final_mux_sel(5) <= '0';
                when "111" =>
                    sig_final_mux_sel(5) <= '0';
                when others =>
                    sig_final_mux_sel(5) <= '0';
              end case;

           end process MUX2_1_FINAL_B5_CNTL;



        I_MUX2_1_FINAL_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(5) , 
              I0     =>  sig_pass_mux_bus(5)  , 
              I1     =>  sig_delay_data_reg(5), 
              Y      =>  sig_final_mux_bus(5)   
             );




        -- Final Mux Byte 6 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B6_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Byte 6 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B6_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "000" =>
                    sig_final_mux_sel(6) <= '0';
                when "001" =>
                    sig_final_mux_sel(6) <= '1';
                when "010" =>
                    sig_final_mux_sel(6) <= '0';
                when "011" =>
                    sig_final_mux_sel(6) <= '0';
                when "100" =>
                    sig_final_mux_sel(6) <= '0';
                when "101" =>
                    sig_final_mux_sel(6) <= '0';
                when "110" =>
                    sig_final_mux_sel(6) <= '0';
                when "111" =>
                    sig_final_mux_sel(6) <= '0';
                when others =>
                    sig_final_mux_sel(6) <= '0';
              end case;

           end process MUX2_1_FINAL_B6_CNTL;



        I_MUX2_1_FINAL_B6 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(6) , 
              I0     =>  sig_pass_mux_bus(6)  , 
              I1     =>  sig_delay_data_reg(6), 
              Y      =>  sig_final_mux_bus(6)   
             );



        -- Final Mux Byte 7 (wire)

        sig_final_mux_sel(7) <= '0';
        sig_final_mux_bus(7) <= sig_pass_mux_bus(7);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_64;
 
 
 
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_32
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 32-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_32 : if (C_DWIDTH = 32) generate
         
         Signal s_case_i_32          : Integer range 0 to 3 := 0;
         signal sig_cntl_state_32    : std_logic_vector(3 downto 0) := (others => '0');
         Signal sig_shift_case_i     : std_logic_vector(1 downto 0) := (others => '0');
         Signal sig_shift_case_reg   : std_logic_vector(1 downto 0) := (others => '0');
         Signal sig_final_mux_sel    : std_logic_vector(3 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_4
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_4 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(3 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "0000";
              
              elsif (sig_tlast_strobes(3) = '1') then
              
                sig_tlast_enables <= "1000";
              
              elsif (sig_tlast_strobes(2) = '1') then
              
                sig_tlast_enables <= "0100";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "0010";
              
              else
              
                sig_tlast_enables <= "0001";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_4; 
         

 
 
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                               
         -- Convert shift case to sld_logic_vector
         --sig_shift_case_i <= CONV_STD_LOGIC_VECTOR(s_case_i_32, 2);
         
         sig_shift_case_i <= STD_LOGIC_VECTOR(TO_UNSIGNED(s_case_i_32, 2));
         
             
             
                               

         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_32
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_32 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_32)
           
           begin
        
             
             
             
             sig_cntl_state_32 <= dre_src_align(1 downto 0) & sig_dest_align_i(1 downto 0); 
               
             case sig_cntl_state_32 is
               when "0000" =>
                  s_case_i_32 <= 0;
               when "0001" => 
                  s_case_i_32 <= 3;
               when "0010" =>
                  s_case_i_32 <= 2;
               when "0011" => 
                  s_case_i_32 <= 1;
               
               when "0100" =>
                  s_case_i_32 <= 1;
               when "0101" => 
                  s_case_i_32 <= 0;
               when "0110" =>
                  s_case_i_32 <= 3;
               when "0111" => 
                  s_case_i_32 <= 2;
               
               when "1000" =>
                  s_case_i_32 <= 2;
               when "1001" => 
                  s_case_i_32 <= 1;
               when "1010" =>
                  s_case_i_32 <= 0;
               when "1011" => 
                  s_case_i_32 <= 3;
               
               when "1100" =>
                  s_case_i_32 <= 3;
               when "1101" => 
                  s_case_i_32 <= 2;
               when "1110" =>
                  s_case_i_32 <= 1;
               when "1111" => 
                  s_case_i_32 <= 0;
               
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_32; 
         
          
          
          
          
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= (others => '0');

               elsif (sig_cntl_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;

 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....
        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(0),  
              I0     =>  sig_input_data_reg(1),  
              I1     =>  sig_input_data_reg(0),  
              Y      =>  sig_pass_mux_bus(1)     
             );


        -- Pass Mux Byte 2 (4-1 x8 Mux)

        I_MUX4_1_PASS_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(2)         ,  
              I1     =>  ZEROED_SLICE                  ,  
              I2     =>  sig_input_data_reg(0)         ,  
              I3     =>  sig_input_data_reg(1)         ,  
              Y      =>  sig_pass_mux_bus(2)              
             );


        -- Pass Mux Byte 3 (4-1 x8 Mux)

        I_MUX4_1_PASS_B3 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  sig_input_data_reg(3)         ,  
              I1     =>  sig_input_data_reg(0)         ,  
              I2     =>  sig_input_data_reg(1)         ,  
              I3     =>  sig_input_data_reg(2)         ,  
              Y      =>  sig_pass_mux_bus(3)              
             );



        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------



        -- Delay Mux Byte 0 (4-1 x8 Mux)

        I_MUX4_1_DLY_B4 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux4_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(1 downto 0),  
              I0     =>  ZEROED_SLICE                  ,  
              I1     =>  sig_input_data_reg(1)         ,  
              I2     =>  sig_input_data_reg(2)         ,  
              I3     =>  sig_input_data_reg(3)         ,  
              Y      =>  sig_delay_mux_bus(0)             
             );


        -- Delay Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_DLY_B5 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg(0),       
              I0     =>  sig_input_data_reg(3),       
              I1     =>  sig_input_data_reg(2),       
              Y      =>  sig_delay_mux_bus(1)         
             );



        -- Delay Mux Byte 2 (Wire)

        sig_delay_mux_bus(2) <= sig_input_data_reg(3);



        -- Delay Mux Byte 3 (Zeroed)

        sig_delay_mux_bus(3) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------



        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        



        -- Final Mux Slice 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(0) <= '0';
                when "01" =>
                    sig_final_mux_sel(0) <= '1';
                when "10" =>
                    sig_final_mux_sel(0) <= '1';
                when "11" =>
                    sig_final_mux_sel(0) <= '1';
                when others =>
                    sig_final_mux_sel(0) <= '0';
              end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) , 
              I0     =>  sig_pass_mux_bus(0)  , 
              I1     =>  sig_delay_data_reg(0), 
              Y      =>  sig_final_mux_bus(0)   
             );




        -- Final Mux Slice 1 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B1_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for slice 1 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B1_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(1) <= '0';
                when "01" =>
                    sig_final_mux_sel(1) <= '1';
                when "10" =>
                    sig_final_mux_sel(1) <= '1';
                when "11" =>
                    sig_final_mux_sel(1) <= '0';
                when others =>
                    sig_final_mux_sel(1) <= '0';
              end case;

           end process MUX2_1_FINAL_B1_CNTL;



        I_MUX2_1_FINAL_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(1) ,
              I0     =>  sig_pass_mux_bus(1)  ,
              I1     =>  sig_delay_data_reg(1),
              Y      =>  sig_final_mux_bus(1)  
             );




        -- Final Mux Slice 2 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B2_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 2 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B2_CNTL : process (sig_shift_case_reg)
           begin

              case sig_shift_case_reg is
                when "00" =>
                    sig_final_mux_sel(2) <= '0';
                when "01" =>
                    sig_final_mux_sel(2) <= '1';
                when "10" =>
                    sig_final_mux_sel(2) <= '0';
                when "11" =>
                    sig_final_mux_sel(2) <= '0';
                when others =>
                    sig_final_mux_sel(2) <= '0';
              end case;

           end process MUX2_1_FINAL_B2_CNTL;



        I_MUX2_1_FINAL_B2 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(2) , 
              I0     =>  sig_pass_mux_bus(2)  , 
              I1     =>  sig_delay_data_reg(2), 
              Y      =>  sig_final_mux_bus(2)   
             );



        -- Final Mux Slice 3 (wire)

        sig_final_mux_sel(3) <= '0';
        sig_final_mux_bus(3) <= sig_pass_mux_bus(3);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_32;
 
 
 
 
     -------------------------------------------------------------------------------
     -------------------------------------------------------------------------------
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_MUXFARM_16
     --
     -- If Generate Description:
     -- Support Logic and Mux Farm for 16-bit data path case 
     --
     --
     ------------------------------------------------------------
     GEN_MUXFARM_16 : if (C_DWIDTH = 16) generate
         
         Signal s_case_i_16          : Integer range 0 to 1 := 0;
         signal sig_cntl_state_16    : std_logic_vector(1 downto 0) := (others => '0');
         Signal sig_shift_case_i     : std_logic := '0';
         Signal sig_shift_case_reg   : std_logic := '0';
         Signal sig_final_mux_sel    : std_logic_vector(1 downto 0) := (others => '0');
           
       begin
     
     
     
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: FIND_MS_STRB_SET_2
         --
         -- Process Description:
         --    This process finds the most significant asserted strobe  
         -- position. This position is used to enable the input flop    
         -- for TLAST that is associated with that byte position. The   
         -- TLAST can then flow through the DRE pipe with the last      
         -- valid byte of data.                                         
         --
         -------------------------------------------------------------
         FIND_MS_STRB_SET_2 : process (dre_in_tlast, 
                                       dre_in_tstrb,
                                       sig_tlast_strobes)
            begin
       
              sig_tlast_strobes  <= dre_in_tstrb(1 downto 0); -- makes case choice locally static
              
              
              if (dre_in_tlast = '0') then
              
                sig_tlast_enables <= "00";
              
              elsif (sig_tlast_strobes(1) = '1') then
              
                sig_tlast_enables <= "10";
              
              else
              
                sig_tlast_enables <= "01";
              
              end if;
              
              
            end process FIND_MS_STRB_SET_2; 
         

 
 
        ---------------------------------------------------------------------------------
        -- Shift Case logic
        
                               
                               
         -- The new auto-destination alignment is based on the last
         -- strobe alignment written into the output register.
         sig_next_auto_dest <= sig_current_dest_align;                      
                               
         
         -- Select the destination alignment to use                      
         sig_dest_align_i <= sig_next_auto_dest
           When (dre_use_autodest = '1')
           Else dre_dest_align;
                               
                               
                           
         -- Convert shift case to std_logic
         sig_shift_case_i <= '1'
           When s_case_i_16 = 1
           Else '0';
         
         
                           

         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: DO_SHIFT_CASE_16
         --
         -- Process Description:
         -- Implements the DRE Control State Calculator
         --
         -------------------------------------------------------------
         DO_SHIFT_CASE_16 : process (dre_src_align   ,
                                     sig_dest_align_i,
                                     sig_cntl_state_16)
           
           begin
        
             
             
             sig_cntl_state_16 <= dre_src_align(0) & sig_dest_align_i(0); 
               
             case sig_cntl_state_16 is
               when "00" =>
                  s_case_i_16 <= 0;
               when "01" => 
                  s_case_i_16 <= 1;
               when "10" =>
                  s_case_i_16 <= 1;
               when "11" => 
                  s_case_i_16 <= 0;
               
               when others => 
                  NULL;
             end case;   
         
        
           end process DO_SHIFT_CASE_16; 
         
          
          
          
          
          
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: REG_SHIFT_CASE
         --
         -- Process Description:
         --     This process registers the Shift Case output from the
         -- Shift Case Generator. This will be used to control the
         -- select inputs of the Shift Muxes for the duration of the
         -- data transfer session. If Pass Through is requested, then
         -- Shift Case 0 is forced regardless of source and destination
         -- alignment values.
         --
         -------------------------------------------------------------
         REG_SHIFT_CASE : process (dre_clk)
           begin
             if (dre_clk'event and dre_clk = '1') then

               if (dre_rst = '1') then

                 sig_shift_case_reg <= '0';

               elsif (sig_cntl_accept = '1') then
                  
                 sig_shift_case_reg <= sig_shift_case_i;
                  
               else
                 null;  -- hold state
               end if;
--             else
--               null;
             end if;
           end process REG_SHIFT_CASE;


 
 
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start PASS Mux Farm Design-------------------------------------------------


        -- Pass Mux Byte 0 (wire)

        -- This is a wire so.....
        sig_pass_mux_bus(0) <= sig_input_data_reg(0);


        -- Pass Mux Byte 1 (2-1 x8 Mux)

        I_MUX2_1_PASS_B1 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_shift_case_reg,  
              I0     =>  sig_input_data_reg(1),  
              I1     =>  sig_input_data_reg(0),  
              Y      =>  sig_pass_mux_bus(1)     
             );




        -- End PASS Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------






        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Delay Mux Farm Design-------------------------------------------------




        -- Delay Mux Slice 0 (Wire)

        sig_delay_mux_bus(0) <= sig_input_data_reg(1);



        -- Delay Mux Slice 1 (Zeroed)

        sig_delay_mux_bus(1) <= ZEROED_SLICE;





        -- End Delay Mux Farm  Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------


        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
        -- Start Final Mux Farm Design-------------------------------------------------
        


        -- Final Mux Slice 0 (2-1 x8 Mux)


        -------------------------------------------------------------
        -- Combinational Process
        --
        -- Label: MUX2_1_FINAL_B0_CNTL
        --
        -- Process Description:
        --  This process generates the Select Control for Slice 0 of
        -- the Final 2-1 Mux of the DRE.
        --
        -------------------------------------------------------------
        MUX2_1_FINAL_B0_CNTL : process (sig_shift_case_reg)
           begin

             case sig_shift_case_reg is
               when '0' =>
                   sig_final_mux_sel(0) <= '0';
               when others =>
                   sig_final_mux_sel(0) <= '1';
             end case;

           end process MUX2_1_FINAL_B0_CNTL;



        I_MUX2_1_FINAL_B0 : entity axi_datamover_v5_1_17.axi_datamover_dre_mux2_1_x_n
          generic map(
             C_WIDTH =>  SLICE_WIDTH  
             )
          port map(
              Sel    =>  sig_final_mux_sel(0) , 
              I0     =>  sig_pass_mux_bus(0)  , 
              I1     =>  sig_delay_data_reg(0), 
              Y      =>  sig_final_mux_bus(0)   
             );



        -- Final Mux Slice 1 (wire)

        sig_final_mux_sel(1) <= '0';
        sig_final_mux_bus(1) <= sig_pass_mux_bus(1);




        -- End Final Mux Farm Design---------------------------------------------------
        -------------------------------------------------------------------------------
        -------------------------------------------------------------------------------
 
 
    end generate GEN_MUXFARM_16;
 
 
 
 
 
 



end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_ms_strb_set.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_ms_strb_set.vhd
--
-- Description:     
--   This module implements a function to detect the most significant strobe 
--  bit asserted and outputs the index value of that strobe bit. It can only 
--  be used in applications where the asserted strobe bits are contiguous and
--  always asserted from LS to MS bit positions,
--  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;




-------------------------------------------------------------------------------

entity axi_datamover_ms_strb_set is
  generic (
    
    C_STRB_WIDTH     : Integer := 8; 
    -- Sets the width of the input strobe port
    
    C_INDEX_WIDTH    : Integer := 3 
    -- Sets the  width of the ms_strb_index output port 
    -- Should be log2(C_STRB_WIDTH)
    
    );
  port (
    
    -- Input strobe value ------------------------------------------------
    strbs_in         : in  std_logic_vector(C_STRB_WIDTH-1 downto 0);   --
    ----------------------------------------------------------------------
    
      
    -- Specifies the index of the most significant strobe set ------------
    ms_strb_index    : out std_logic_vector(C_INDEX_WIDTH-1 downto 0);  --
    ----------------------------------------------------------------------
      
      
    -- Invalid strobe input Indcation ------------------------------------
    strb_error       : Out std_logic                                    --
      -- Indicates an error with the strobe input, either a hole in the --
      -- asserted strobes or not asserted from LS bits upwards.         --
    ----------------------------------------------------------------------
    
    );

end entity axi_datamover_ms_strb_set;


architecture implementation of axi_datamover_ms_strb_set is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_2
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 2-bit wide strobe value.
  --
  -------------------------------------------------------------------
  function get_ms_index_2 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value : std_logic_vector(1 downto 0);
    
  begin
  
    var_strb_value := input_strobe(1 downto 0);
    
    
    case var_strb_value is
      when "01" =>
        var_ms_strb_index := 0;
      when "11" | "10" =>
        var_ms_strb_index := 1;
      when others =>
        var_ms_strb_index := 2;
    end case;
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_2; 
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_4
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 4-bit wide strobe value.
  --
  -------------------------------------------------------------------
  function get_ms_index_4 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value : std_logic_vector(3 downto 0);
  
  begin

    var_strb_value := input_strobe(3 downto 0);

  
    case var_strb_value is
      when "0001" =>
        var_ms_strb_index := 0;
      when "0011" | "0010" =>
        var_ms_strb_index := 1;
      when "0111" | "0110" | "0100" =>
        var_ms_strb_index := 2;
      when "1111" | "1110" | "1100" | "1000"=>
        var_ms_strb_index := 3;
      when others =>
        var_ms_strb_index := 4;
    end case;
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_4; 
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_8
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 8-bit wide strobe value.
  --
  -- Note that this function expects an input vector marking the
  -- assertion/deassertion boundaries, not the actual strobe vector.
  --
  -------------------------------------------------------------------
  function get_ms_index_8 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value    : std_logic_vector(7 downto 0);
  
  begin
  
    var_strb_value := input_strobe(7 downto 0);
    
    
    case var_strb_value is
      when "00000001" =>
        var_ms_strb_index := 0;
      when "00000010" =>
        var_ms_strb_index := 1;
      when "00000100" =>
        var_ms_strb_index := 2;
      when "00001000" =>
        var_ms_strb_index := 3;
      when "00010000" =>
        var_ms_strb_index := 4;
      when "00100000" =>
        var_ms_strb_index := 5;
      when "01000000" =>
        var_ms_strb_index := 6;
      when "10000000" =>
        var_ms_strb_index := 7;
      when others =>
        var_ms_strb_index := 8;
    end case;
   
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_8; 
  
  
  
  
  
  
  
  
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_16
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 16-bit wide strobe value.
  --
  --
  -- Note that this function expects an input vector marking the
  -- assertion/deassertion boundaries, not the actual strobe vector.
  --
  -------------------------------------------------------------------
  function get_ms_index_16 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value : std_logic_vector(15 downto 0);
    
  begin
  
    var_strb_value := input_strobe(15 downto 0);
    
    
    case var_strb_value is
      when "0000000000000001" =>
        var_ms_strb_index :=  0;
      when "0000000000000010" =>
        var_ms_strb_index :=  1;
      when "0000000000000100" =>
        var_ms_strb_index :=  2;
      when "0000000000001000" =>
        var_ms_strb_index :=  3;
      when "0000000000010000" =>
        var_ms_strb_index :=  4;
      when "0000000000100000" =>
        var_ms_strb_index :=  5;
      when "0000000001000000" =>
        var_ms_strb_index :=  6;
      when "0000000010000000" =>
        var_ms_strb_index :=  7;
      when "0000000100000000" =>
        var_ms_strb_index :=  8;
      when "0000001000000000" =>
        var_ms_strb_index :=  9;
      when "0000010000000000" =>
        var_ms_strb_index := 10;
      when "0000100000000000" =>
        var_ms_strb_index := 11;
      when "0001000000000000" =>
        var_ms_strb_index := 12;
      when "0010000000000000" =>
        var_ms_strb_index := 13;
      when "0100000000000000" =>
        var_ms_strb_index := 14;
      when "1000000000000000" =>
        var_ms_strb_index := 15;
      when others =>
        var_ms_strb_index := 16;
    end case;
   
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_16;
  
  
  
  
  
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_32
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 32-bit wide strobe value.
  --
  --
  -- Note that this function expects an input vector marking the
  -- assertion/deassertion boundaries, not the actual strobe vector.
  --
  -------------------------------------------------------------------
  function get_ms_index_32 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value : std_logic_vector(31 downto 0);
    
  begin
  
    var_strb_value := input_strobe(31 downto 0);
    
    
    case var_strb_value is
      when "00000000000000000000000000000001" =>
        var_ms_strb_index := 0;
      when "00000000000000000000000000000010" =>            
        var_ms_strb_index := 1;
      when "00000000000000000000000000000100" =>
        var_ms_strb_index := 2;
      when "00000000000000000000000000001000" =>
        var_ms_strb_index := 3;
      when "00000000000000000000000000010000" =>
        var_ms_strb_index := 4;
      when "00000000000000000000000000100000" =>
        var_ms_strb_index := 5;
      when "00000000000000000000000001000000" =>
        var_ms_strb_index := 6;
      when "00000000000000000000000010000000" =>
        var_ms_strb_index := 7;
      when "00000000000000000000000100000000" =>
        var_ms_strb_index := 8;
      when "00000000000000000000001000000000" =>
        var_ms_strb_index := 9;
      when "00000000000000000000010000000000" =>
        var_ms_strb_index := 10;
      when "00000000000000000000100000000000" =>
        var_ms_strb_index := 11;
      when "00000000000000000001000000000000" =>
        var_ms_strb_index := 12;
      when "00000000000000000010000000000000" =>
        var_ms_strb_index := 13;
      when "00000000000000000100000000000000" =>
        var_ms_strb_index := 14;
      when "00000000000000001000000000000000" =>
        var_ms_strb_index := 15;
      when "00000000000000010000000000000000" =>
        var_ms_strb_index := 16;
      when "00000000000000100000000000000000" =>
        var_ms_strb_index := 17;
      when "00000000000001000000000000000000" =>
        var_ms_strb_index := 18;
      when "00000000000010000000000000000000" =>
        var_ms_strb_index := 19;
      when "00000000000100000000000000000000" =>
        var_ms_strb_index := 20;
      when "00000000001000000000000000000000" =>
        var_ms_strb_index := 21;
      when "00000000010000000000000000000000" =>
        var_ms_strb_index := 22;
      when "00000000100000000000000000000000" =>
        var_ms_strb_index := 23;
      when "00000001000000000000000000000000" =>
        var_ms_strb_index := 24;
      when "00000010000000000000000000000000" =>
        var_ms_strb_index := 25;
      when "00000100000000000000000000000000" =>
        var_ms_strb_index := 26;
      when "00001000000000000000000000000000" =>
        var_ms_strb_index := 27;
      when "00010000000000000000000000000000" =>
        var_ms_strb_index := 28;
      when "00100000000000000000000000000000" =>
        var_ms_strb_index := 29;
      when "01000000000000000000000000000000" =>
        var_ms_strb_index := 30;
      when "10000000000000000000000000000000" =>
        var_ms_strb_index := 31;
      when others =>
        var_ms_strb_index := 32;
    end case;
   
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_32;
  
  
 
 
 
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_64
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 64-bit wide strobe value.
  --
  --
  -- Note that this function expects an input vector marking the
  -- assertion/deassertion boundaries, not the actual strobe vector.
  --
  -------------------------------------------------------------------
  function get_ms_index_64 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value    : std_logic_vector(63 downto 0);
    
  begin
  
    var_strb_value := input_strobe(63 downto 0);
    
    
    case var_strb_value is
      
      when "0000000000000000000000000000000000000000000000000000000000000001" =>
        var_ms_strb_index := 0;
      when "0000000000000000000000000000000000000000000000000000000000000010" =>            
        var_ms_strb_index := 1;
      when "0000000000000000000000000000000000000000000000000000000000000100" =>
        var_ms_strb_index := 2;
      when "0000000000000000000000000000000000000000000000000000000000001000" =>
        var_ms_strb_index := 3;
      when "0000000000000000000000000000000000000000000000000000000000010000" =>
        var_ms_strb_index := 4;
      when "0000000000000000000000000000000000000000000000000000000000100000" =>
        var_ms_strb_index := 5;
      when "0000000000000000000000000000000000000000000000000000000001000000" =>
        var_ms_strb_index := 6;
      when "0000000000000000000000000000000000000000000000000000000010000000" =>
        var_ms_strb_index := 7;
      when "0000000000000000000000000000000000000000000000000000000100000000" =>
        var_ms_strb_index := 8;
      when "0000000000000000000000000000000000000000000000000000001000000000" =>
        var_ms_strb_index := 9;
      when "0000000000000000000000000000000000000000000000000000010000000000" =>
        var_ms_strb_index := 10;
      when "0000000000000000000000000000000000000000000000000000100000000000" =>
        var_ms_strb_index := 11;
      when "0000000000000000000000000000000000000000000000000001000000000000" =>
        var_ms_strb_index := 12;
      when "0000000000000000000000000000000000000000000000000010000000000000" =>
        var_ms_strb_index := 13;
      when "0000000000000000000000000000000000000000000000000100000000000000" =>
        var_ms_strb_index := 14;
      when "0000000000000000000000000000000000000000000000001000000000000000" =>
        var_ms_strb_index := 15;
      when "0000000000000000000000000000000000000000000000010000000000000000" =>
        var_ms_strb_index := 16;
      when "0000000000000000000000000000000000000000000000100000000000000000" =>
        var_ms_strb_index := 17;
      when "0000000000000000000000000000000000000000000001000000000000000000" =>
        var_ms_strb_index := 18;
      when "0000000000000000000000000000000000000000000010000000000000000000" =>
        var_ms_strb_index := 19;
      when "0000000000000000000000000000000000000000000100000000000000000000" =>
        var_ms_strb_index := 20;
      when "0000000000000000000000000000000000000000001000000000000000000000" =>
        var_ms_strb_index := 21;
      when "0000000000000000000000000000000000000000010000000000000000000000" =>
        var_ms_strb_index := 22;
      when "0000000000000000000000000000000000000000100000000000000000000000" =>
        var_ms_strb_index := 23;
      when "0000000000000000000000000000000000000001000000000000000000000000" =>
        var_ms_strb_index := 24;
      when "0000000000000000000000000000000000000010000000000000000000000000" =>
        var_ms_strb_index := 25;
      when "0000000000000000000000000000000000000100000000000000000000000000" =>
        var_ms_strb_index := 26;
      when "0000000000000000000000000000000000001000000000000000000000000000" =>
        var_ms_strb_index := 27;
      when "0000000000000000000000000000000000010000000000000000000000000000" =>
        var_ms_strb_index := 28;
      when "0000000000000000000000000000000000100000000000000000000000000000" =>
        var_ms_strb_index := 29;
      when "0000000000000000000000000000000001000000000000000000000000000000" =>
        var_ms_strb_index := 30;
      when "0000000000000000000000000000000010000000000000000000000000000000" =>
        var_ms_strb_index := 31;
      
      when "0000000000000000000000000000000100000000000000000000000000000000" =>          
        var_ms_strb_index := 32;
      when "0000000000000000000000000000001000000000000000000000000000000000" =>            
        var_ms_strb_index := 33;
      when "0000000000000000000000000000010000000000000000000000000000000000" =>
        var_ms_strb_index := 34;
      when "0000000000000000000000000000100000000000000000000000000000000000" =>
        var_ms_strb_index := 35;
      when "0000000000000000000000000001000000000000000000000000000000000000" =>
        var_ms_strb_index := 36;
      when "0000000000000000000000000010000000000000000000000000000000000000" =>
        var_ms_strb_index := 37;
      when "0000000000000000000000000100000000000000000000000000000000000000" =>
        var_ms_strb_index := 38;
      when "0000000000000000000000001000000000000000000000000000000000000000" =>
        var_ms_strb_index := 39;
      when "0000000000000000000000010000000000000000000000000000000000000000" =>
        var_ms_strb_index := 40;
      when "0000000000000000000000100000000000000000000000000000000000000000" =>
        var_ms_strb_index := 41;
      when "0000000000000000000001000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 42;
      when "0000000000000000000010000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 43;
      when "0000000000000000000100000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 44;
      when "0000000000000000001000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 45;
      when "0000000000000000010000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 46;
      when "0000000000000000100000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 47;
      when "0000000000000001000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 48;
      when "0000000000000010000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 49;
      when "0000000000000100000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 50;
      when "0000000000001000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 51;
      when "0000000000010000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 52;
      when "0000000000100000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 53;
      when "0000000001000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 54;
      when "0000000010000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 55;
      when "0000000100000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 56;
      when "0000001000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 57;
      when "0000010000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 58;
      when "0000100000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 59;
      when "0001000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 60;
      when "0010000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 61;
      when "0100000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 62;
      when "1000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 63;
      
      when others =>
        var_ms_strb_index := 64;
    end case;
   
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_64;
  
  
  
 
 
 
 
  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: get_ms_index_128
  --
  -- Function Description:
  --   Returns the index of the most significant strobe set in a 
  -- 64-bit wide strobe value.
  --
  --
  -- Note that this function expects an input vector marking the
  -- assertion/deassertion boundaries, not the actual strobe vector.
  --
  -------------------------------------------------------------------
  function get_ms_index_128 (input_strobe : std_logic_vector) return natural is
  
    Variable var_ms_strb_index : natural := 0;
    Variable var_strb_value    : std_logic_vector(127 downto 0);
    
  begin
  
    var_strb_value := input_strobe(127 downto 0);
    
    
    case var_strb_value is
      
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001" =>         
        var_ms_strb_index := 0;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010" =>            
        var_ms_strb_index := 1;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100" =>
        var_ms_strb_index := 2;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000" =>
        var_ms_strb_index := 3;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000" =>
        var_ms_strb_index := 4;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000" =>
        var_ms_strb_index := 5;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000" =>
        var_ms_strb_index := 6;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000" =>
        var_ms_strb_index := 7;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000" =>
        var_ms_strb_index := 8;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000" =>
        var_ms_strb_index := 9;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000" =>
        var_ms_strb_index := 10;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000" =>
        var_ms_strb_index := 11;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000" =>
        var_ms_strb_index := 12;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000" =>
        var_ms_strb_index := 13;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000" =>
        var_ms_strb_index := 14;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000" =>
        var_ms_strb_index := 15;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000" =>
        var_ms_strb_index := 16;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000" =>
        var_ms_strb_index := 17;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000" =>
        var_ms_strb_index := 18;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000" =>
        var_ms_strb_index := 19;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000" =>
        var_ms_strb_index := 20;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000" =>
        var_ms_strb_index := 21;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000" =>
        var_ms_strb_index := 22;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000" =>
        var_ms_strb_index := 23;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000" =>
        var_ms_strb_index := 24;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000" =>
        var_ms_strb_index := 25;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000" =>
        var_ms_strb_index := 26;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000" =>
        var_ms_strb_index := 27;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000" =>
        var_ms_strb_index := 28;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000" =>
        var_ms_strb_index := 29;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000" =>
        var_ms_strb_index := 30;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000" =>
        var_ms_strb_index := 31;
      
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000" =>          
        var_ms_strb_index := 32;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000" =>            
        var_ms_strb_index := 33;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000" =>
        var_ms_strb_index := 34;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000" =>
        var_ms_strb_index := 35;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000" =>
        var_ms_strb_index := 36;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000" =>
        var_ms_strb_index := 37;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000" =>
        var_ms_strb_index := 38;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000" =>
        var_ms_strb_index := 39;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000" =>
        var_ms_strb_index := 40;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000" =>
        var_ms_strb_index := 41;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 42;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 43;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 44;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 45;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 46;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 47;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 48;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 49;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 50;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 51;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 52;
      when "00000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 53;
      when "00000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 54;
      when "00000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 55;
      when "00000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 56;
      when "00000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 57;
      when "00000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 58;
      when "00000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 59;
      when "00000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 60;
      when "00000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 61;
      when "00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 62;
      when "00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 63;
      
      
      
      when "00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000" =>                   
        var_ms_strb_index := 64;
      when "00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000" =>            
        var_ms_strb_index := 65;
      when "00000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 66;
      when "00000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 67;
      when "00000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 68;
      when "00000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 69;
      when "00000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 70;
      when "00000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 71;
      when "00000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 72;
      when "00000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 73;
      when "00000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 74;
      when "00000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 75;
      when "00000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 76;
      when "00000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 77;
      when "00000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 78;
      when "00000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 79;
      when "00000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 80;
      when "00000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 81;
      when "00000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 82;
      when "00000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 83;
      when "00000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 84;
      when "00000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 85;
      when "00000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 86;
      when "00000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 87;
      when "00000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 88;
      when "00000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 89;
      when "00000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 90;
      when "00000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 91;
      when "00000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 92;
      when "00000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 93;
      when "00000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 94;
      when "00000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 95;
      
      when "00000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>          
        var_ms_strb_index := 96;
      when "00000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>            
        var_ms_strb_index := 97;
      when "00000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 98;
      when "00000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 99;
      when "00000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 100;
      when "00000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 101;
      when "00000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 102;
      when "00000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 103;
      when "00000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 104;
      when "00000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 105;
      when "00000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 106;
      when "00000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 107;
      when "00000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 108;
      when "00000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 109;
      when "00000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 110;
      when "00000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 111;
      when "00000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 112;
      when "00000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 113;
      when "00000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 114;
      when "00000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 115;
      when "00000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 116;
      when "00000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 117;
      when "00000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 118;
      when "00000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 119;
      when "00000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 120;
      when "00000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 121;
      when "00000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 122;
      when "00001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 123;
      when "00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 124;
      when "00100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 125;
      when "01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 126;
      when "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" =>
        var_ms_strb_index := 127;
      
      when others =>
        var_ms_strb_index := 128;
    end case;
   
   
    Return (var_ms_strb_index);
   
  end function get_ms_index_128;
  
  
  
 
 
 
 
 
 
  
  -- Constants 
  Constant ERROR_INDEX   : natural := C_STRB_WIDTH;
  Constant TEMP_NAT_MAX  : natural := 255;  -- allows for a 0 to 255 strobe index value
  Constant TEMP_UN_WIDTH : natural :=   8;  -- 8 bits allows for a 0 to 255 index value
   
   
  
  
  -- Signals
  
  signal sig_input_stbs            : std_logic_vector(C_STRB_WIDTH-1 downto 0) := (others => '0');
  
  signal sig_ms_asserted_index_un  : unsigned(C_INDEX_WIDTH-1 downto 0) := (others => '0');
  
  signal sig_strb_error            : std_logic := '0';
 
  signal sig_temp_ms_index_un      : unsigned(TEMP_UN_WIDTH-1 downto 0) := (others => '0');
  
  signal sig_temp_ms_index_nat     : natural range 0 to TEMP_NAT_MAX := 0;




begin --(architecture implementation)

 
  -- Assign the ms asserted strobe value
  ms_strb_index  <= STD_LOGIC_VECTOR(sig_ms_asserted_index_un);
                                      
  
  -- Assign the input strobe
  sig_input_stbs <= strbs_in       ; -- assign input strobes
  
  -- Assign the strobe eror output
  strb_error     <= sig_strb_error ; -- assign the strobe error output
  
   
  
  
  
  
  -- Rip the valid index bits
  sig_ms_asserted_index_un   <= sig_temp_ms_index_un(C_INDEX_WIDTH-1 downto 0);
  
  
  
  -- Assert the Strobe Error output if an out of range index is returned
  
  sig_temp_ms_index_nat      <= TO_INTEGER(sig_ms_asserted_index_un) ;
  
  
  sig_strb_error <= '1'
    When (sig_temp_ms_index_nat >= ERROR_INDEX)
    else '0';


  
  
  
  
   






  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_1BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 1-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_1BIT_CASE : if (C_STRB_WIDTH = 1) generate
 
    
    begin
  
      sig_temp_ms_index_un   <= TO_UNSIGNED( 0, TEMP_UN_WIDTH);
      
    
    end generate GEN_1BIT_CASE;
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_2BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 2-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_2BIT_CASE : if (C_STRB_WIDTH = 2) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    begin
  
      
      lsig_ms_asserted_index_nat <= get_ms_index_2(sig_input_stbs);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_2BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_4BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 4-bit strobe width case.
  --
  ------------------------------------------------------------
  GEN_4BIT_CASE : if (C_STRB_WIDTH = 4) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    begin
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_4(sig_input_stbs);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_4BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_8BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 8-bit strobe width case.
  --
  ------------------------------------------------------------
  GEN_8BIT_CASE : if (C_STRB_WIDTH = 8) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat  : natural range 0 to TEMP_NAT_MAX := 0;
    
    Signal lsig_strb_last_assert_vect  : std_logic_vector(C_STRB_WIDTH downto 0);
    Signal lsig_strb_test_vect         : std_logic_vector(C_STRB_WIDTH downto 0);
    
    
    begin
  
       -- Create a strobe vector with the most significant bit zeroed.
       lsig_strb_test_vect <=  '0' & sig_input_stbs;
       
       
      
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: GEN_ASSERT_BNDRY_CHK
       --
       -- For Generate Description:
       --  Find the assertion/deassertion boundaries in the input
       -- Strobe vector in the least to most significant index 
       -- direction.
       --
       --
       ------------------------------------------------------------
       GEN_ASSERT_BNDRY_CHK : for strb_index in 1 to C_STRB_WIDTH generate
       
       begin
       
         
          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_FIND_DEASSERTION
         --
         -- Process Description:
         --  Detects the case when two adjoining strobe bits have an 
         -- assertion transition from asserted to deasserted moving
         -- from lower to higher bit ordering.
         --
         -------------------------------------------------------------
         IMP_FIND_DEASSERTION : process (lsig_strb_test_vect)
            begin
         
              if ((lsig_strb_test_vect(strb_index-1) = '1') and
                   (lsig_strb_test_vect(strb_index) = '0')) then
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '1';
               
              else
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '0';
               
              end if;
         
            end process IMP_FIND_DEASSERTION; 
         
         
         
       end generate GEN_ASSERT_BNDRY_CHK;
      
      
      
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_8(lsig_strb_last_assert_vect);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_8BIT_CASE;
  
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_16BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 16-bit strobe width case.
  --
  --
  ------------------------------------------------------------
  GEN_16BIT_CASE : if (C_STRB_WIDTH = 16) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    Signal lsig_strb_last_assert_vect  : std_logic_vector(C_STRB_WIDTH downto 0);
    Signal lsig_strb_test_vect         : std_logic_vector(C_STRB_WIDTH downto 0);
    
    
    begin
  
       -- Create a strobe vector with the most significant bit zeroed.
       lsig_strb_test_vect <=  '0' & sig_input_stbs;
       
       
      
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: GEN_ASSERT_BNDRY_CHK
       --
       -- For Generate Description:
       --  Find the assertion/deassertion boundaries in the input
       -- Strobe vector in the least to most significant index 
       -- direction.
       --
       --
       ------------------------------------------------------------
       GEN_ASSERT_BNDRY_CHK : for strb_index in 1 to C_STRB_WIDTH generate
       
       begin
       
         
          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_FIND_DEASSERTION
         --
         -- Process Description:
         --  Detects the case when two adjoining strobe bits have an 
         -- assertion transition from asserted to deasserted moving
         -- from lower to higher bit ordering.
         --
         -------------------------------------------------------------
         IMP_FIND_DEASSERTION : process (lsig_strb_test_vect)
            begin
         
              if ((lsig_strb_test_vect(strb_index-1) = '1') and
                   (lsig_strb_test_vect(strb_index) = '0')) then
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '1';
               
              else
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '0';
               
              end if;
         
            end process IMP_FIND_DEASSERTION; 
         
         
         
       end generate GEN_ASSERT_BNDRY_CHK;
      
      
      
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_16(lsig_strb_last_assert_vect);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_16BIT_CASE;
  
  
  
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_32BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 32-bit strobe width case.
  --
  ------------------------------------------------------------
  GEN_32BIT_CASE : if (C_STRB_WIDTH = 32) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    Signal lsig_strb_last_assert_vect  : std_logic_vector(C_STRB_WIDTH downto 0);
    Signal lsig_strb_test_vect         : std_logic_vector(C_STRB_WIDTH downto 0);
    
    
    begin
  
       -- Create a strobe vector with the most significant bit zeroed.
       lsig_strb_test_vect <=  '0' & sig_input_stbs;
       
       
      
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: GEN_ASSERT_BNDRY_CHK
       --
       -- For Generate Description:
       --  Find the assertion/deassertion boundaries in the input
       -- Strobe vector in the least to most significant index 
       -- direction.
       --
       --
       ------------------------------------------------------------
       GEN_ASSERT_BNDRY_CHK : for strb_index in 1 to C_STRB_WIDTH generate
       
       begin
       
         
          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_FIND_DEASSERTION
         --
         -- Process Description:
         --  Detects the case when two adjoining strobe bits have an 
         -- assertion transition from asserted to deasserted moving
         -- from lower to higher bit ordering.
         --
         -------------------------------------------------------------
         IMP_FIND_DEASSERTION : process (lsig_strb_test_vect)
            begin
         
              if ((lsig_strb_test_vect(strb_index-1) = '1') and
                   (lsig_strb_test_vect(strb_index) = '0')) then
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '1';
               
              else
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '0';
               
              end if;
         
            end process IMP_FIND_DEASSERTION; 
         
         
         
       end generate GEN_ASSERT_BNDRY_CHK;
      
      
      
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_32(lsig_strb_last_assert_vect);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_32BIT_CASE;
  
  
  
  
  
 
 
 
 
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_64BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 64-bit strobe width case.
  --
  ------------------------------------------------------------
  GEN_64BIT_CASE : if (C_STRB_WIDTH = 64) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    Signal lsig_strb_last_assert_vect  : std_logic_vector(C_STRB_WIDTH downto 0);
    Signal lsig_strb_test_vect         : std_logic_vector(C_STRB_WIDTH downto 0);
    
    
    begin
  
       -- Create a strobe vector with the most significant bit zeroed.
       lsig_strb_test_vect <=  '0' & sig_input_stbs;
       
       
      
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: GEN_ASSERT_BNDRY_CHK
       --
       -- For Generate Description:
       --  Find the assertion/deassertion boundaries in the input
       -- Strobe vector in the least to most significant index 
       -- direction.
       --
       --
       ------------------------------------------------------------
       GEN_ASSERT_BNDRY_CHK : for strb_index in 1 to C_STRB_WIDTH generate
       
       begin
       
         
          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_FIND_DEASSERTION
         --
         -- Process Description:
         --  Detects the case when two adjoining strobe bits have an 
         -- assertion transition from asserted to deasserted moving
         -- from lower to higher bit ordering.
         --
         -------------------------------------------------------------
         IMP_FIND_DEASSERTION : process (lsig_strb_test_vect)
            begin
         
              if ((lsig_strb_test_vect(strb_index-1) = '1') and
                   (lsig_strb_test_vect(strb_index) = '0')) then
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '1';
               
              else
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '0';
               
              end if;
         
            end process IMP_FIND_DEASSERTION; 
         
         
         
       end generate GEN_ASSERT_BNDRY_CHK;
      
      
      
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_64(lsig_strb_last_assert_vect);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_64BIT_CASE;
  
  
  
  
  
 
 
 
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_128BIT_CASE
  --
  -- If Generate Description:
  --  Generates the MS asserted strobe index for the 
  -- 128-bit strobe width case.
  --
  ------------------------------------------------------------
  GEN_128BIT_CASE : if (C_STRB_WIDTH = 128) generate
    
    -- local signals
    Signal lsig_ms_asserted_index_nat : natural range 0 to TEMP_NAT_MAX := 0;
    
    Signal lsig_strb_last_assert_vect  : std_logic_vector(C_STRB_WIDTH downto 0);
    Signal lsig_strb_test_vect         : std_logic_vector(C_STRB_WIDTH downto 0);
    
    
    begin
  
       -- Create a strobe vector with the most significant bit zeroed.
       lsig_strb_test_vect <=  '0' & sig_input_stbs;
       
       
      
       ------------------------------------------------------------
       -- For Generate
       --
       -- Label: GEN_ASSERT_BNDRY_CHK
       --
       -- For Generate Description:
       --  Find the assertion/deassertion boundaries in the input
       -- Strobe vector in the least to most significant index 
       -- direction.
       --
       --
       ------------------------------------------------------------
       GEN_ASSERT_BNDRY_CHK : for strb_index in 1 to C_STRB_WIDTH generate
       
       begin
       
         
          
         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: IMP_FIND_DEASSERTION
         --
         -- Process Description:
         --  Detects the case when two adjoining strobe bits have an 
         -- assertion transition from asserted to deasserted moving
         -- from lower to higher bit ordering.
         --
         -------------------------------------------------------------
         IMP_FIND_DEASSERTION : process (lsig_strb_test_vect)
            begin
         
              if ((lsig_strb_test_vect(strb_index-1) = '1') and
                   (lsig_strb_test_vect(strb_index) = '0')) then
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '1';
               
              else
              
                 lsig_strb_last_assert_vect(strb_index-1) <= '0';
               
              end if;
         
            end process IMP_FIND_DEASSERTION; 
         
         
         
       end generate GEN_ASSERT_BNDRY_CHK;
      
      
      
      
      
      lsig_ms_asserted_index_nat <= get_ms_index_128(lsig_strb_last_assert_vect);
      
      sig_temp_ms_index_un       <= TO_UNSIGNED(lsig_ms_asserted_index_nat, TEMP_UN_WIDTH);

  
    end generate GEN_128BIT_CASE;
  
  
  
  
  
 
 
 
 


 


end implementation;


-------------------------------------------------------------------------------
-- axi_datamover_mssai_skid_buf.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover_mssai_skid_buf.vhd
--
-- Description:     
--  Implements the AXi Skid Buffer in the Option 2 (Registerd outputs) mode that
--  also incorporates the MS Strobe Asserted detection function needed by the  
--  module. This provides a register isolation of the MS asserted strobe index               
--  Scatter needed to improve Fmax.                
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library axi_datamover_v5_1_17;
Use axi_datamover_v5_1_17.axi_datamover_ms_strb_set;

-------------------------------------------------------------------------------

entity axi_datamover_mssai_skid_buf is
  generic (
    C_WDATA_WIDTH : INTEGER range 8 to 1024 := 32 ; 
       --  Width of the Stream Data bus (in bits)
    
    C_INDEX_WIDTH : Integer range 1 to 8 := 2 
      -- Sets the width of the MS asserted strobe index output value
               
    );
  port (
  
     -- Clock and Reset Ports -----------------------
     aclk          : In  std_logic ;               --
     arst          : In  std_logic ;               --
     ------------------------------------------------
     
                                                    
     -- Shutdown control (assert for 1 clk pulse) ---
     skid_stop     : In std_logic  ;               --
     ------------------------------------------------
     
                                          
     -- Slave Side (Stream Data Input) ------------------------------------
     s_valid       : In  std_logic ;                                     --
     s_ready       : Out std_logic ;                                     --
     s_data        : In  std_logic_vector(C_WDATA_WIDTH-1 downto 0);     --
     s_strb        : In  std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0); --
     s_last        : In  std_logic ;                                     --
     ----------------------------------------------------------------------
     

     -- Master Side (Stream Data Output -----------------------------------
     m_valid       : Out std_logic ;                                     --
     m_ready       : In  std_logic ;                                     --
     m_data        : Out std_logic_vector(C_WDATA_WIDTH-1 downto 0);     --
     m_strb        : Out std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0); --
     m_last        : Out std_logic ;                                     --
                                                                         --
     m_mssa_index  : Out std_logic_vector(C_INDEX_WIDTH-1 downto 0);     --
     m_strb_error  : Out std_logic                                       --
     ----------------------------------------------------------------------
    
    );

end entity axi_datamover_mssai_skid_buf;


architecture implementation of axi_datamover_mssai_skid_buf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



-- Constant declarations -------------------------
  Constant STROBE_WIDTH       : integer := C_WDATA_WIDTH/8;
  
  
  

-- Signals declarations -------------------------

  Signal sig_reset_reg           : std_logic := '0';
  signal sig_spcl_s_ready_set    : std_logic := '0';
  signal sig_data_skid_reg       : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_reg       : std_logic_vector(STROBE_WIDTH-1 downto 0) := (others => '0');
  signal sig_last_skid_reg       : std_logic := '0';
  signal sig_skid_reg_en         : std_logic := '0';
  signal sig_data_skid_mux_out   : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_mux_out   : std_logic_vector(STROBE_WIDTH-1 downto 0) := (others => '0');
  signal sig_last_skid_mux_out   : std_logic := '0';
  signal sig_data_reg_out        : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_reg_out        : std_logic_vector(STROBE_WIDTH-1 downto 0) := (others => '0');
  signal sig_last_reg_out        : std_logic := '0';
  signal sig_data_reg_out_en     : std_logic := '0';
  signal sig_m_valid_out         : std_logic := '0';
  signal sig_m_valid_dup         : std_logic := '0';
  signal sig_m_valid_comb        : std_logic := '0';
  signal sig_s_ready_out         : std_logic := '0';
  signal sig_s_ready_comb        : std_logic := '0';
  signal sig_stop_request        : std_logic := '0';
  signal sig_stopped             : std_logic := '0';
  signal sig_sready_stop         : std_logic := '0';
  signal sig_sready_early_stop   : std_logic := '0';
  signal sig_sready_stop_set     : std_logic := '0';
  signal sig_sready_stop_reg     : std_logic := '0';
  signal sig_mvalid_stop_reg     : std_logic := '0';
  signal sig_mvalid_stop         : std_logic := '0';
  signal sig_mvalid_early_stop   : std_logic := '0';
  signal sig_mvalid_stop_set     : std_logic := '0';
  signal sig_slast_with_stop     : std_logic := '0';
  signal sig_sstrb_stop_mask     : std_logic_vector(STROBE_WIDTH-1 downto 0) := (others => '0');
  signal sig_sstrb_with_stop     : std_logic_vector(STROBE_WIDTH-1 downto 0) := (others => '0');
  
  signal sig_mssa_index_out      : std_logic_vector(C_INDEX_WIDTH-1 downto 0) := (others => '0');
  signal sig_mssa_index_reg_out  : std_logic_vector(C_INDEX_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_error          : std_logic := '0';
  signal sig_strb_error_reg_out  : std_logic := '0';
 
  -- Fmax improvements
  signal sig_s_ready_dup         : std_logic := '0';
  signal sig_s_ready_dup2        : std_logic := '0';
  signal sig_s_ready_dup3        : std_logic := '0';
  signal sig_s_ready_dup4        : std_logic := '0';
 
  signal sig_skid_mux_sel        : std_logic := '0';
  signal sig_skid_mux_sel2       : std_logic := '0';
  signal sig_skid_mux_sel3       : std_logic := '0';
  signal sig_skid_mux_sel4       : std_logic := '0';
 
 
-- Register duplication attribute assignments to control fanout
-- on handshake output signals  
  
  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration
  
  Attribute KEEP of sig_m_valid_out  : signal is "TRUE"; -- definition
  Attribute KEEP of sig_m_valid_dup  : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_out  : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup  : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup2 : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup3 : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup4 : signal is "TRUE"; -- definition
  
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_out  : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_dup  : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_out  : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup  : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup2 : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup3 : signal is "no"; 
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup4 : signal is "no"; 
  
  
  

begin --(architecture implementation)

   m_valid       <= sig_m_valid_out;         
   s_ready       <= sig_s_ready_out; 
    
   m_strb        <= sig_strb_reg_out;
   m_last        <= sig_last_reg_out;                
   m_data        <= sig_data_reg_out;    
            
   m_mssa_index  <= sig_mssa_index_reg_out;
   m_strb_error  <= sig_strb_error_reg_out;
  
                                        
  
   -- Special shutdown logic version of Slast.
   -- A halt request forces a tlast through the skig buffer
   sig_slast_with_stop <= s_last or sig_stop_request;
   sig_sstrb_with_stop <= s_strb or sig_sstrb_stop_mask;
  
  
   -- Assign the special s_ready FLOP set signal
   sig_spcl_s_ready_set <= sig_reset_reg;
  
            
   -- Generate the ouput register load enable control
   sig_data_reg_out_en <= m_ready or not(sig_m_valid_dup);

   -- Generate the skid input register load enable control
   sig_skid_reg_en     <= sig_s_ready_dup;
  
   -- Generate the skid mux select control
   sig_skid_mux_sel2    <= not(sig_s_ready_dup2);
   sig_skid_mux_sel3    <= not(sig_s_ready_dup3);
   sig_skid_mux_sel4    <= not(sig_s_ready_dup4);
   
   
   -- Skid Mux  
   sig_data_skid_mux_out <=  sig_data_skid_reg
     When (sig_skid_mux_sel2 = '1')
     Else  s_data;
  
   sig_strb_skid_mux_out <=  sig_strb_skid_reg
     When (sig_skid_mux_sel3 = '1')
     Else  sig_sstrb_with_stop;
  
   sig_last_skid_mux_out <=  sig_last_skid_reg
     When (sig_skid_mux_sel4 = '1')
     Else  sig_slast_with_stop;
  
   
   -- m_valid combinational logic        
   sig_m_valid_comb <= s_valid or
                      (sig_m_valid_dup and
                      (not(sig_s_ready_dup) or
                       not(m_ready)));
   
   
   
   -- s_ready combinational logic        
   sig_s_ready_comb <= m_ready or
                      (sig_s_ready_dup and
                      (not(sig_m_valid_dup) or
                       not(s_valid)));
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_THE_RST
   --
   -- Process Description:
   -- Register input reset
   --
   -------------------------------------------------------------
   REG_THE_RST : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           
            sig_reset_reg <= arst;
           
        end if;       
      end process REG_THE_RST; 
   
   
   
   
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: S_READY_FLOP
   --
   -- Process Description:
   -- Registers s_ready handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   S_READY_FLOP : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst                  = '1' or
               sig_sready_stop       = '1' or
               sig_sready_early_stop = '1') then  -- Special stop condition

             sig_s_ready_out  <= '0';
             sig_s_ready_dup  <= '0';
             sig_s_ready_dup2 <= '0';
             sig_s_ready_dup3 <= '0';
             sig_s_ready_dup4 <= '0';
            
           Elsif (sig_spcl_s_ready_set = '1') Then
           
             sig_s_ready_out  <= '1';
             sig_s_ready_dup  <= '1';
             sig_s_ready_dup2 <= '1';
             sig_s_ready_dup3 <= '1';
             sig_s_ready_dup4 <= '1';
           
           else

             sig_s_ready_out  <= sig_s_ready_comb;
             sig_s_ready_dup  <= sig_s_ready_comb;
             sig_s_ready_dup2 <= sig_s_ready_comb;
             sig_s_ready_dup3 <= sig_s_ready_comb;
             sig_s_ready_dup4 <= sig_s_ready_comb;
            
           end if; 
        end if;       
      end process S_READY_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: M_VALID_FLOP
   --
   -- Process Description:
   -- Registers m_valid handshake signals per Skid Buffer 
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   M_VALID_FLOP : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst                  = '1' or
               sig_spcl_s_ready_set  = '1' or    -- Fix from AXI DMA
               sig_mvalid_stop       = '1' or
               sig_mvalid_stop_set   = '1') then -- Special stop condition

             sig_m_valid_out  <= '0';
             sig_m_valid_dup  <= '0';
            
           else

             sig_m_valid_out  <= sig_m_valid_comb;
             sig_m_valid_dup  <= sig_m_valid_comb;
            
           end if; 
        end if;       
      end process M_VALID_FLOP; 
   
   
   
   
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_DATA_REG
   --
   -- Process Description:
   -- This process implements the skid register for the 
   -- Skid Buffer Data signals. Note that reset has been removed
   -- to reduce route of resets for very wide data buses.
   --
   -------------------------------------------------------------
   SKID_DATA_REG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           
           if  (sig_skid_reg_en = '1') then
             
             sig_data_skid_reg <= s_data;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process SKID_DATA_REG; 
            
            
   
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_CNTL_REG
   --
   -- Process Description:
   -- This process implements the skid registers for the 
   -- Skid Buffer control signals
   --
   -------------------------------------------------------------
   SKID_CNTL_REG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst = '1') then
             
             sig_strb_skid_reg <= (others => '0');
             sig_last_skid_reg <= '0';
             
           elsif (sig_skid_reg_en = '1') then
             
             sig_strb_skid_reg <= sig_sstrb_with_stop;
             sig_last_skid_reg <= sig_slast_with_stop;
             
           else
             null;  -- hold current state
           end if;
            
        end if;       
      end process SKID_CNTL_REG; 
            
            
   
            
            
            
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_DATA_REG
   --
   -- Process Description:
   -- This process implements the output register for the 
   -- Skid Buffer Data signals. Note that reset has been removed
   -- to reduce route of resets for very wide data buses.
   --
   -------------------------------------------------------------
   OUTPUT_DATA_REG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           
           if (sig_data_reg_out_en = '1') then
             
             sig_data_reg_out <= sig_data_skid_mux_out;
             
           else
             null;  -- hold current state
           end if;
            
        end if;       
      end process OUTPUT_DATA_REG; 
            
            
  
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_CNTL_REG
   --
   -- Process Description:
   -- This process implements the output registers for the 
   -- Skid Buffer Control signals.
   --
   -------------------------------------------------------------
   OUTPUT_CNTL_REG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst                = '1' or
               sig_mvalid_stop_reg = '1') then
             
             sig_strb_reg_out        <= (others => '0');
             sig_last_reg_out        <= '0';
             
           elsif (sig_data_reg_out_en = '1') then
             
             sig_strb_reg_out        <= sig_strb_skid_mux_out;
             sig_last_reg_out        <= sig_last_skid_mux_out;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process OUTPUT_CNTL_REG; 
            
            
  
  
  
  
  
  
  
  
  
  
  
  
  
   -------- Special Stop Logic --------------------------------------
   
   
   sig_sready_stop        <= sig_sready_stop_reg; 
  
  
   sig_sready_early_stop  <= skid_stop; -- deassert S_READY immediately
   
  
   sig_sready_stop_set    <= sig_sready_early_stop;
   
                                     
   sig_mvalid_stop        <=  sig_mvalid_stop_reg;
                                     
                                     
   sig_mvalid_early_stop  <= sig_m_valid_dup and
                            m_ready and
                            skid_stop;
  
    
   sig_mvalid_stop_set    <=  sig_mvalid_early_stop or
                              (sig_stop_request and 
                               not(sig_m_valid_dup)) or
                              (sig_m_valid_dup and
                               m_ready         and
                               sig_stop_request);
   
   
   
                             
    
    
                                     
                                     
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_STOP_REQ_FLOP
   --
   -- Process Description:
   -- This process implements the Stop request flop. It is a 
   -- sample and hold register that can only be cleared by reset.
   --
   -------------------------------------------------------------
   IMP_STOP_REQ_FLOP : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst = '1') then
             
             sig_stop_request    <= '0';
             sig_sstrb_stop_mask <= (others => '0');
             
           elsif (skid_stop = '1') then
             
             sig_stop_request    <= '1';
             sig_sstrb_stop_mask <= (others => '1');
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_STOP_REQ_FLOP; 
            
            
  
  
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_SREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the s_ready 
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_SREADY_FLOP : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst = '1') then
             
             sig_sready_stop_reg <= '0';
             
           elsif (sig_sready_stop_set  = '1') then
             
             sig_sready_stop_reg <= '1';
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_CLR_SREADY_FLOP; 
            
            
  
  
  
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_MVALID_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the m_valid 
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_MVALID_FLOP : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst = '1') then
             
             sig_mvalid_stop_reg <= '0';
             
           elsif (sig_mvalid_stop_set  = '1') then
             
             sig_mvalid_stop_reg <= '1';
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_CLR_MVALID_FLOP; 
            
 
 
 
 
 
 
 
 
   ----------------------------------------------------------------------------
   -- Logic for the detection of the most significant asserted strobe bit and
   -- the formulation of the index of that strobe bit.
   ----------------------------------------------------------------------------
   
   
   
  
   ------------------------------------------------------------
   -- Instance: I_MSSAI_DETECTION 
   --
   -- Description:
   --  This module detects the most significant asserted strobe 
   -- and outputs the bit index of the strobe.  
   --
   ------------------------------------------------------------
   I_MSSAI_DETECTION : entity axi_datamover_v5_1_17.axi_datamover_ms_strb_set
   generic map (
 
     C_STRB_WIDTH  => STROBE_WIDTH  ,
     C_INDEX_WIDTH => C_INDEX_WIDTH  
 
     )
   port map (
 
     -- Input Stream Strobes
     strbs_in          =>  sig_strb_skid_mux_out ,  

     -- Index of the most significant strobe asserted
     ms_strb_index     =>  sig_mssa_index_out    ,  
     
     -- Output flag for a detected error associated Strobe assertions
     strb_error        =>  sig_strb_error                 
 
     );
 


  
    
   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_MSSAI_REG
   --
   -- Process Description:
   -- This process implements the output register for the 
   -- Skid Buffer's MSSAI value and the strobe error bit
   -- that is needed by the Scatter module.
   --
   -------------------------------------------------------------
   IMP_MSSAI_REG : process (aclk)
      begin
        if (aclk'event and aclk = '1') then
           if (arst                = '1' or
               sig_mvalid_stop_reg = '1') then
             
             sig_mssa_index_reg_out <= (others => '0');
             sig_strb_error_reg_out <= '0';
             
           elsif (sig_data_reg_out_en = '1') then
             
             sig_mssa_index_reg_out <= sig_mssa_index_out;
             sig_strb_error_reg_out <= sig_strb_error;
             
           else
             null;  -- hold current state
           end if; 
        end if;       
      end process IMP_MSSAI_REG; 
            
            
  
  
  
  
  
  
  



end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;



   entity axi_datamover_slice is
   generic (
           C_DATA_WIDTH : Integer range 1 to 200 := 64
           );
   port (

   ACLK : in std_logic;
   ARESET : in std_logic;

   -- Slave side
   S_PAYLOAD_DATA : in std_logic_vector (C_DATA_WIDTH-1 downto 0);
   S_VALID : in std_logic;
   S_READY : out std_logic;

   -- Master side
   M_PAYLOAD_DATA : out std_logic_vector (C_DATA_WIDTH-1 downto 0);
   M_VALID : out std_logic;
   M_READY : in std_logic
   );
   end entity axi_datamover_slice;

   architecture working of axi_datamover_slice is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of working : architecture is "yes";

      signal storage_data : std_logic_vector (C_DATA_WIDTH-1 downto 0);
      signal s_ready_i : std_logic;
      signal m_valid_i : std_logic;
      signal areset_d  : std_logic_vector (1 downto 0);
   begin
      -- assign local signal to its output signal
      S_READY <= s_ready_i; 
      M_VALID <= m_valid_i;

      process (ACLK) begin
        if (ACLK'event and ACLK = '1') then
          areset_d(0) <= ARESET;
          areset_d(1) <= areset_d(0);
        end if;
      end process;

      -- Save payload data whenever we have a transaction on the slave side
      process (ACLK) begin
        if (ACLK'event and ACLK = '1') then
           if (S_VALID = '1' and s_ready_i = '1') then
              storage_data <= S_PAYLOAD_DATA;
           else
              storage_data <= storage_data;
           end if;
        end if;
      end process;

      M_PAYLOAD_DATA <= storage_data;

      -- M_Valid set to high when we have a completed transfer on slave side
      -- Is removed on a M_READY except if we have a new transfer on the slave side
      process (ACLK) begin
        if (ACLK'event and ACLK = '1') then
          if (areset_d (1) = '1') then
             m_valid_i <= '0';
          elsif (S_VALID = '1') then
             m_valid_i <= '1';
          elsif (M_READY = '1') then
             m_valid_i <= '0';
          else
             m_valid_i <= m_valid_i;
          end if; 
        end if;
      end process;

      -- Slave Ready is either when Master side drives M_Ready or we have space in our storage data
      s_ready_i <= (M_READY or (not m_valid_i)) and not (areset_d(1) or areset_d(0));
     end working;


  -------------------------------------------------------------------------------
  -- axi_datamover_s2mm_scatter.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_s2mm_scatter.vhd
  --
  -- Description:     
  --    This file implements the S2MM Scatter support module. Scatter requires 
  --    the input Stream to be stopped and disected at command boundaries. The 
  --    Scatter module splits the input stream data at the command boundaries 
  --    and force feeds the S2MM DRE with data and source alignment.                   
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_strb_gen2;
  use axi_datamover_v5_1_17.axi_datamover_mssai_skid_buf;
  use axi_datamover_v5_1_17.axi_datamover_fifo;
  use axi_datamover_v5_1_17.axi_datamover_slice;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_s2mm_scatter is
    generic (
      
      C_ENABLE_INDET_BTT     : Integer range  0 to   1 :=  0;
        -- Indicates if the IBTT Indeterminate BTT is enabled
        -- (external to this module)
      
      C_DRE_ALIGN_WIDTH      : Integer range  1 to   6 :=  2;
        -- Sets the width of the S2MM DRE alignment control ports
      
      C_BTT_USED             : Integer range  8 to  26 := 16;
        -- Sets the width of the BTT input port 
      
      C_STREAM_DWIDTH        : Integer range  8 to 1024 := 32;
        -- Sets the width of the input and output data streams
    C_ENABLE_S2MM_TKEEP             : integer range 0 to 1 := 1;       
      C_FAMILY               : String  := "virtex7"
        -- Specifies the target FPGA device family
      
      
      );
    port (
      
      -- Clock and Reset inputs --------------------------------------------------
                                                                                --
      primary_aclk          : in  std_logic;                                    --
         -- Primary synchronization clock for the Master side                   --
         -- interface and internal logic. It is also used                       --
         -- for the User interface synchronization when                         --
         -- C_STSCMD_IS_ASYNC = 0.                                              --
                                                                                --
      -- Reset input                                                            --
      mmap_reset            : in  std_logic;                                    --
         -- Reset used for the internal master logic                            --
      ----------------------------------------------------------------------------
      
     
      
     -- DRE Realign Controller I/O  ----------------------------------------------
                                                                                --
      scatter2drc_cmd_ready : Out std_logic;                                    --
        -- Indicates the Scatter Engine is ready to accept a new command        --
                                                                                --
      drc2scatter_push_cmd  : In  std_logic;                                    --
        -- Indicates a new command is being read from the command que           --
                                                                                --
      drc2scatter_btt       : In  std_logic_vector(C_BTT_USED-1 downto 0);      --
        -- Indicates the new command's BTT value                                --
                                                                                --
      drc2scatter_eof       : In  std_logic;                                    --
        -- Indicates that the input command is also the last of a packet        --
        -- This input is ignored when C_ENABLE_INDET_BTT = 1                    --
      ----------------------------------------------------------------------------
     
 
 
     -- DRE Source Alignment ---------------------------------------------------------
                                                                                    --
      scatter2drc_src_align : Out  std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);  --
        -- Indicates the next source alignment to the DRE control                   --
      --------------------------------------------------------------------------------
     
     
 
      
     -- AXI Slave Stream In ----------------------------------------------------------
                                                                                    --
      s2mm_strm_tready      : Out  Std_logic;                                       --
        -- AXI Stream READY input                                                   --
                                                                                    --
      s2mm_strm_tvalid      : In  std_logic;                                        --
        -- AXI Stream VALID Output                                                  --
                                                                                    --
      s2mm_strm_tdata       : In  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);     --    
        -- AXI Stream data output                                                   --
                                                                                    --
      s2mm_strm_tstrb       : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);  --       
        -- AXI Stream STRB output                                                   --
                                                                                    --
      s2mm_strm_tlast       : In std_logic;                                         --
        -- AXI Stream LAST output                                                   --
      --------------------------------------------------------------------------------
               
                
                
     -- Stream Out to S2MM DRE -------------------------------------------------------
                                                                                    --
      drc2scatter_tready    : In  Std_logic;                                        --
        -- S2MM DRE Stream READY input                                              --
                                                                                    --
      scatter2drc_tvalid    : Out  std_logic;                                       --
        -- S2MM DRE VALID Output                                                    --
                                                                                    --
      scatter2drc_tdata     : Out  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);    --     
        -- S2MM DRE data output                                                     --
                                                                                    --
      scatter2drc_tstrb     : Out std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0); --        
        -- S2MM DRE STRB output                                                     --
                                                                                    --
      scatter2drc_tlast     : Out std_logic;                                        --
        -- S2MM DRE LAST output                                                     --
                                                                                    --
      scatter2drc_flush     : Out std_logic;                                        --
        -- S2MM DRE LAST output                                                     --
                                                                                    --
      scatter2drc_eop       : Out std_logic;                                        --
        -- S2MM DRE End of Packet marker                                            --
      --------------------------------------------------------------------------------
      
      
               
                
      -- Premature TLAST assertion error flag ---------------------------------------
                                                                                   --
      scatter2drc_tlast_error  : Out std_logic                                     --
         -- When asserted, this indicates the scatter Engine detected              --
         -- a Early/Late TLAST assertion on the incoming data stream               --
         -- relative to the commands given to the DataMover Cmd FIFO.              --
      -------------------------------------------------------------------------------      
      
      
      );
  
  end entity axi_datamover_s2mm_scatter;
  
  
  architecture implementation of axi_datamover_s2mm_scatter  is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Function declaration   ----------------------------------------
    
     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_start_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the MSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_start_index (lane_index : integer;
                               lane_width : integer)
                               return integer is

        Variable bit_index_start : Integer := 0;

     begin

        bit_index_start := lane_index*lane_width;

        return(bit_index_start);

     end function get_start_index;


     -------------------------------------------------------------------
     -- Function
     --
     -- Function Name: get_end_index
     --
     -- Function Description:
     --      This function calculates the bus bit index corresponding
     -- to the LSB of the Slice lane index input and the Slice width.
     --
     -------------------------------------------------------------------
     function get_end_index (lane_index : integer;
                             lane_width : integer)
                             return integer is

        Variable bit_index_end   : Integer := 0;

     begin

        bit_index_end   := (lane_index*lane_width) + (lane_width-1);

        return(bit_index_end);

     end function get_end_index;



    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_num_offset_bits
    --
    -- Function Description:
    --  This function calculates the number of bits needed for specifying 
    -- a byte lane offset for the input transfer data width. 
    --
    -------------------------------------------------------------------
    function func_num_offset_bits (stream_dwidth_value : integer) return integer is
    
      Variable num_offset_bits_needed : Integer range 1 to 7 := 1;
    
    begin
    
      case stream_dwidth_value is
        when 8 => -- 1 byte lanes
          num_offset_bits_needed := 1;
        when 16 => -- 2 byte lanes
          num_offset_bits_needed := 1;
        when 32 => -- 4 byte lanes
          num_offset_bits_needed := 2;
        when 64 => -- 8 byte lanes
          num_offset_bits_needed := 3;
        when 128 => -- 16 byte lanes
          num_offset_bits_needed := 4;
        when 256 => -- 32 byte lanes
          num_offset_bits_needed := 5;
        when 512 => -- 64 byte lanes
          num_offset_bits_needed := 6;
        
        when others => -- 1024 bits with 128 byte lanes
          num_offset_bits_needed := 7;
      end case;
      
      Return (num_offset_bits_needed);
       
    end function func_num_offset_bits;
    
   
    function func_fifo_prim (stream_dwidth_value : integer) return integer is
    
      Variable prim_needed : Integer range 0 to 2 := 1;
    
    begin
    
      case stream_dwidth_value is
        when 8 => -- 1 byte lanes
          prim_needed := 2;
        when 16 => -- 2 byte lanes
          prim_needed := 2;
        when 32 => -- 4 byte lanes
          prim_needed := 2;
        when 64 => -- 8 byte lanes
          prim_needed := 2;
        when 128 => -- 16 byte lanes
          prim_needed := 0;
        when others => -- 256 bits and above
          prim_needed := 0;
      end case;
      
      Return (prim_needed);
       
    end function func_fifo_prim;
     
    
    -- Constant Declarations  -------------------------------------------------
   
    Constant LOGIC_LOW           : std_logic := '0';
    Constant LOGIC_HIGH          : std_logic := '0';
    
    Constant BYTE_WIDTH          : integer := 8; -- bits
    Constant STRM_NUM_BYTE_LANES : integer := C_STREAM_DWIDTH/BYTE_WIDTH;
    Constant STRM_STRB_WIDTH     : integer := STRM_NUM_BYTE_LANES;
    Constant SLICE_WIDTH         : integer := BYTE_WIDTH+2; -- 8 data bits plus Strobe plus TLAST bit
    Constant SLICE_STROBE_INDEX  : integer := (BYTE_WIDTH-1)+1;
    Constant SLICE_TLAST_INDEX   : integer := SLICE_STROBE_INDEX+1;
    Constant ZEROED_SLICE        : std_logic_vector(SLICE_WIDTH-1 downto 0) := (others => '0');
    Constant CMD_BTT_WIDTH       : Integer := C_BTT_USED;
    Constant BTT_OF_ZERO         : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0'); 
    Constant MAX_BTT_INCR        : integer := C_STREAM_DWIDTH/8;
    Constant NUM_OFFSET_BITS     : integer := func_num_offset_bits(C_STREAM_DWIDTH);
      -- Minimum Number of bits needed to represent the byte lane position within the Stream Data
    Constant NUM_INCR_BITS       : integer := NUM_OFFSET_BITS+1;
      -- Minimum Number of bits needed to represent the maximum per dbeat increment value
    
    Constant OFFSET_ONE          : unsigned(NUM_OFFSET_BITS-1 downto 0) := TO_UNSIGNED(1 , NUM_OFFSET_BITS);
    Constant OFFSET_MAX          : unsigned(NUM_OFFSET_BITS-1 downto 0) := TO_UNSIGNED(STRM_STRB_WIDTH - 1 , NUM_OFFSET_BITS);
    Constant INCR_MAX            : unsigned(NUM_INCR_BITS-1 downto 0) := TO_UNSIGNED(MAX_BTT_INCR , NUM_INCR_BITS);

    
    
    
    Constant MSSAI_INDEX_WIDTH   : integer := NUM_OFFSET_BITS;
    
    Constant TSTRB_FIFO_DEPTH    : integer := 16;
    
    Constant TSTRB_FIFO_DWIDTH   : integer := 1                 +    -- TLAST Bit
                                              1                 +    -- EOF Bit
                                              1                 +    -- Freeze Bit
                                              MSSAI_INDEX_WIDTH +    -- MSSAI Value
                                              STRM_STRB_WIDTH*C_ENABLE_S2MM_TKEEP ;      -- Strobe Value
    
    
    
    
    
    Constant USE_SYNC_FIFO       : integer := 0;
    Constant REG_FIFO_PRIM       : integer := 0; 
    Constant BRAM_FIFO_PRIM      : integer := 1; 
    Constant SRL_FIFO_PRIM       : integer := 2; 
    Constant FIFO_PRIM           : integer := func_fifo_prim(C_STREAM_DWIDTH);   
   
    Constant FIFO_TLAST_INDEX    : integer := TSTRB_FIFO_DWIDTH-1;
    Constant FIFO_EOF_INDEX      : integer := FIFO_TLAST_INDEX-1;
    Constant FIFO_FREEZE_INDEX   : integer := FIFO_EOF_INDEX-1;
    Constant FIFO_MSSAI_MS_INDEX : integer := FIFO_FREEZE_INDEX-1;
    Constant FIFO_MSSAI_LS_INDEX : integer := FIFO_MSSAI_MS_INDEX - (MSSAI_INDEX_WIDTH-1);
    Constant FIFO_TSTRB_MS_INDEX : integer := FIFO_MSSAI_LS_INDEX-1;
    Constant FIFO_TSTRB_LS_INDEX : integer := 0;
    
    

    -- Types ------------------------------------------------------------------
    
    type byte_lane_type is array(STRM_NUM_BYTE_LANES-1 downto 0) of
                    std_logic_vector(SLICE_WIDTH-1 downto 0);

      
    
    
    -- Signal Declarations  ---------------------------------------------------

    signal sig_good_strm_dbeat         : std_logic := '0';
    signal sig_strm_tready             : std_logic := '0';
    signal sig_strm_tvalid             : std_logic := '0';
    signal sig_strm_tdata              : std_logic_vector(C_STREAM_DWIDTH-1 downto 0) := (others => '0');
    signal sig_strm_tstrb              : std_logic_vector(STRM_NUM_BYTE_LANES-1 downto 0) := (others => '0');
    signal sig_strm_tlast              : std_logic := '0';
    signal sig_drc2scatter_tready      : std_logic := '0';
    signal sig_scatter2drc_tvalid      : std_logic := '0';
    signal sig_scatter2drc_tdata       : std_logic_vector(C_STREAM_DWIDTH-1 downto 0) := (others => '0');
    signal sig_scatter2drc_tstrb       : std_logic_vector(STRM_NUM_BYTE_LANES-1 downto 0) := (others => '0');
    signal sig_scatter2drc_tlast       : std_logic := '0';
    signal sig_scatter2drc_flush       : std_logic := '0';
    signal sig_valid_dre_output_dbeat  : std_logic := '0';
    signal sig_ld_cmd                  : std_logic := '0';
    signal sig_cmd_full                : std_logic := '0';
    signal sig_cmd_empty               : std_logic := '0';
    signal sig_drc2scatter_push_cmd    : std_logic := '0';
    signal sig_drc2scatter_btt         : std_logic_vector(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_drc2scatter_eof         : std_logic := '0';
    signal sig_btt_offset_slice        : unsigned(NUM_OFFSET_BITS-1 downto 0) := (others => '0');
    signal sig_curr_strt_offset        : unsigned(NUM_OFFSET_BITS-1 downto 0) := (others => '0');
    signal sig_next_strt_offset        : unsigned(NUM_OFFSET_BITS-1 downto 0) := (others => '0');
    signal sig_next_dre_src_align      : std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_curr_dbeat_offset       : std_logic_vector(NUM_OFFSET_BITS-1 downto 0) := (others => '0');
    signal sig_cmd_sof                 : std_logic := '0';
    signal sig_curr_eof_reg            : std_logic := '0';
    signal sig_btt_cntr                : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_cntr_dup                : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    Attribute KEEP : string; -- declaration
    Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration
    Attribute KEEP of sig_btt_cntr_dup : signal is "TRUE"; -- definition
    Attribute EQUIVALENT_REGISTER_REMOVAL of sig_btt_cntr_dup : signal is "no";
    signal sig_ld_btt_cntr             : std_logic := '0';
    signal sig_decr_btt_cntr           : std_logic := '0';
    signal sig_btt_cntr_decr_value     : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_stb_gen_slice       : std_logic_vector(NUM_INCR_BITS-1 downto 0) := (others => '0');
    signal sig_btt_eq_0                : std_logic := '0';
    signal sig_btt_lteq_max_first_incr : std_logic := '0';
    signal sig_btt_gteq_max_incr       : std_logic := '0';
    signal sig_max_first_increment     : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_cntr_prv            : unsigned(CMD_BTT_WIDTH-1 downto 0) := (others => '0');
    signal sig_btt_eq_0_pre_reg        : std_logic := '0';
    signal sig_set_tlast_error         : std_logic := '0';
    signal sig_tlast_error_over        : std_logic := '0';
    signal sig_tlast_error_under       : std_logic := '0';
    signal sig_tlast_error_exact       : std_logic := '0';
    signal sig_tlast_error_reg         : std_logic := '0';
    signal sig_stbgen_tstrb            : std_logic_vector(STRM_NUM_BYTE_LANES-1 downto 0) := (others => '0');
    signal sig_tlast_error_out         : std_logic := '0';
    signal sig_freeze_it               : std_logic := '0';
    signal sig_tstrb_fifo_data_in      : std_logic_vector(TSTRB_FIFO_DWIDTH-1 downto 0);
    signal sig_tstrb_fifo_data_out     : std_logic_vector(TSTRB_FIFO_DWIDTH-1 downto 0);
    signal slice_insert_data     : std_logic_vector(TSTRB_FIFO_DWIDTH-1 downto 0);
    signal slice_insert_ready          : std_logic := '0';
    signal slice_insert_valid        : std_logic := '0';
    signal sig_tstrb_fifo_rdy          : std_logic := '0';
    signal sig_tstrb_fifo_valid        : std_logic := '0';
    signal sig_valid_fifo_ld           : std_logic := '0';
    signal sig_fifo_tlast_out          : std_logic := '0';
    signal sig_fifo_eof_out            : std_logic := '0';
    signal sig_fifo_freeze_out         : std_logic := '0';
    signal sig_fifo_tstrb_out          : std_logic_vector(STRM_STRB_WIDTH-1 downto 0);
    signal sig_tstrb_valid             : std_logic := '0';
    signal sig_get_tstrb               : std_logic := '0';
    signal sig_tstrb_fifo_empty        : std_logic := '0';
    signal sig_clr_fifo_ld_regs        : std_logic := '0';
    signal ld_btt_cntr_reg1            : std_logic := '0';
    signal ld_btt_cntr_reg2            : std_logic := '0';
    signal ld_btt_cntr_reg3            : std_logic := '0';
    signal sig_btt_eq_0_reg            : std_logic := '0';
    signal sig_tlast_ld_beat           : std_logic := '0';
    signal sig_eof_ld_dbeat            : std_logic := '0';
    signal sig_strb_error              : std_logic := '0';
    signal sig_mssa_index              : std_logic_vector(MSSAI_INDEX_WIDTH-1 downto 0) := (others => '0');
    signal sig_tstrb_fifo_mssai_in     : std_logic_vector(MSSAI_INDEX_WIDTH-1 downto 0);
    signal sig_tstrb_fifo_mssai_out    : std_logic_vector(MSSAI_INDEX_WIDTH-1 downto 0);
    signal sig_fifo_mssai              : unsigned(NUM_OFFSET_BITS-1 downto 0) := (others => '0');
    signal sig_clr_tstrb_fifo          : std_logic := '0';
    signal sig_eop_sent                : std_logic := '0';
    signal sig_eop_sent_reg            : std_logic := '0';
    signal sig_scatter2drc_eop         : std_logic := '0';
    signal sig_set_packet_done         : std_logic := '0';
    signal sig_tlast_sent              : std_logic := '0';
    signal sig_gated_fifo_freeze_out   : std_logic := '0';
    signal sig_cmd_side_ready          : std_logic := '0';
    signal sig_eop_halt_xfer           : std_logic := '0';
    signal sig_err_underflow_reg       : std_logic := '0';
    signal sig_assert_valid_out        : std_logic := '0';
--   Attribute KEEP : string; -- declaration
--  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

--  Attribute KEEP of sig_btt_cntr_dup   : signal is "TRUE"; -- definition

--  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_btt_cntr_dup   : signal is "no";
 
                                     
  begin --(architecture implementation)
  
    
    
    -- Output stream assignments (to DRE) -----------------
    sig_drc2scatter_tready   <= drc2scatter_tready     ;             
    scatter2drc_tvalid       <= sig_scatter2drc_tvalid ;
    scatter2drc_tdata        <= sig_scatter2drc_tdata  ;
    scatter2drc_tstrb        <= sig_scatter2drc_tstrb  ;
    scatter2drc_tlast        <= sig_scatter2drc_tlast  ;
    scatter2drc_flush        <= sig_scatter2drc_flush  ;
    scatter2drc_eop          <= sig_scatter2drc_eop    ;
    
    -- DRC Control ----------------------------------------
    
    scatter2drc_cmd_ready    <= sig_cmd_empty;
    
    sig_drc2scatter_push_cmd <= drc2scatter_push_cmd ;
    sig_drc2scatter_btt      <= drc2scatter_btt      ;
    sig_drc2scatter_eof      <= drc2scatter_eof      ;
    
    
    -- Next source alignment control to the S2Mm DRE ------
    scatter2drc_src_align    <= sig_next_dre_src_align; 
    
    
    -- TLAST error flag output ----------------------------
    scatter2drc_tlast_error  <= sig_tlast_error_out;
    
    
    
    -- Data to DRE output ---------------------------------
    sig_scatter2drc_tdata    <= sig_strm_tdata ;
    
    
    
    sig_scatter2drc_tvalid   <=  sig_assert_valid_out and -- Asserting the valid output       
                                 sig_cmd_side_ready;      -- and the tstrb fifo has an entry pending
    
    
    -- Create flag indicating a qualified output stream data beat to the DRE
    sig_valid_dre_output_dbeat <= sig_drc2scatter_tready and
                                  sig_scatter2drc_tvalid;
    
     
    
    
    
    -- Databeat DRE FLUSH output --------------------------
    sig_scatter2drc_flush    <= '0';
    
    
    
    
    sig_ld_cmd               <=  sig_drc2scatter_push_cmd and
                                 not(sig_cmd_full);
    
    
    sig_next_dre_src_align   <= STD_LOGIC_VECTOR(RESIZE(sig_next_strt_offset,
                                                      C_DRE_ALIGN_WIDTH));
    
    
    sig_good_strm_dbeat      <=  sig_strm_tready and
                                 sig_assert_valid_out ;
    
    

    -- Set the valid out flag
    sig_assert_valid_out     <= (sig_strm_tvalid        or  -- there is valid data in the Skid buffer output register
                                 sig_err_underflow_reg);    -- or an underflow error has been detected and needs to flush
    




                                                      
    --- Input Stream Skid Buffer with Special Functions ------------------------------
    
        
    ------------------------------------------------------------
    -- Instance: I_MSSAI_SKID_BUF 
    --
    -- Description:
    -- Instance for the MSSAI Skid Buffer needed for Fmax 
    -- closure when the Scatter Module is included in the DataMover
    -- S2MM.    
    --
    ------------------------------------------------------------
    I_MSSAI_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_mssai_skid_buf
    generic map (
  
      C_WDATA_WIDTH  =>  C_STREAM_DWIDTH   ,   
      C_INDEX_WIDTH  =>  MSSAI_INDEX_WIDTH   
  
      )
    port map (
  
      -- System Ports
      aclk          => primary_aclk     ,  
      arst          => mmap_reset       ,  
      
      -- Shutdown control (assert for 1 clk pulse)
      skid_stop     => LOGIC_LOW        ,  
      
      -- Slave Side (Stream Data Input) 
      s_valid       => s2mm_strm_tvalid ,  
      s_ready       => s2mm_strm_tready ,  
      s_data        => s2mm_strm_tdata  ,  
      s_strb        => s2mm_strm_tstrb  ,  
      s_last        => s2mm_strm_tlast  ,  

      -- Master Side (Stream Data Output 
      m_valid       => sig_strm_tvalid  ,  
      m_ready       => sig_strm_tready  ,  
      m_data        => sig_strm_tdata   ,  
      m_strb        => sig_strm_tstrb   ,  
      m_last        => sig_strm_tlast   ,  
      
      m_mssa_index  => sig_mssa_index   ,  
      m_strb_error  => sig_strb_error      
      
      );
  
                   
                     
                     
                     
                     
                     
    -------------------------------------------------------------
    -- packet Done Logic
    -------------------------------------------------------------
                     
                                                    
                              
    sig_set_packet_done    <= sig_eop_sent_reg;      
                              
                                                      
                                                      
                     
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_CMD_FLAG_REG
    --
    -- Process Description:
    --   Implement the Scatter transfer command full/empty tracking
    -- flops 
    --
    -------------------------------------------------------------
    IMP_CMD_FLAG_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset         = '1' or
                sig_tlast_sent     = '1') then
              
              sig_cmd_full   <= '0';
              sig_cmd_empty  <= '1';
              
              
            elsif (sig_ld_cmd = '1') then
              
              sig_cmd_full   <= '1';
              sig_cmd_empty  <= '0';
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process IMP_CMD_FLAG_REG; 
    
    
    
    


    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_CURR_OFFSET_REG
    --
    -- Process Description:
    --  Implements the register holding the current starting
    -- byte position offset of the first byte of the current
    -- command. This implementation assumes that only the first
    -- databeat can be unaligned from Byte position 0.
    --
    -------------------------------------------------------------
    IMP_CURR_OFFSET_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset          = '1' or
                sig_set_packet_done = '1' or
                sig_valid_fifo_ld   = '1') then
              
              sig_curr_strt_offset <= (others => '0');
            
            elsif (sig_ld_cmd = '1') then
              
              sig_curr_strt_offset <= sig_next_strt_offset;
              
            else
              null;  -- Hold current state
            end if; 
         end if;       
       end process IMP_CURR_OFFSET_REG; 
    
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_NEXT_OFFSET_REG
    --
    -- Process Description:
    --  Implements the register holding the predicted byte position
    -- offset of the first byte of the next command. If the current 
    -- command has EOF set, then the next command's first data input
    -- byte offset must be at byte lane 0 in the input stream.
    --
    -------------------------------------------------------------
    IMP_NEXT_OFFSET_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset           = '1' or
                sig_set_packet_done  = '1' or
                STRM_NUM_BYTE_LANES  = 1) then
              
              sig_next_strt_offset <= (others => '0');
            
            elsif (sig_ld_cmd = '1') then
              
              sig_next_strt_offset <= sig_next_strt_offset + sig_btt_offset_slice;
              
            else
              null;  -- Hold current state
            end if; 
         end if;       
       end process IMP_NEXT_OFFSET_REG; 
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_FIFO_MSSAI_REG
    --
    -- Process Description:
    --  Implements the register holding the predicted byte position
    -- offset of the last valid byte defined by the current command.
    --
    -------------------------------------------------------------
    IMP_FIFO_MSSAI_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset          = '1' or
                sig_set_packet_done = '1' or
                STRM_NUM_BYTE_LANES = 1 ) then
              
              sig_fifo_mssai <= (others => '0');
            
            elsif (ld_btt_cntr_reg1 = '1' and
                   ld_btt_cntr_reg2 = '0') then
              
              sig_fifo_mssai <= sig_next_strt_offset - OFFSET_ONE;
              
            else
              null;  -- Hold current state
            end if; 
         end if;       
       end process IMP_FIFO_MSSAI_REG; 
    
    
    
    
    
    
    
    
    
    
    -- Strobe Generation Logic ------------------------------------------------
    
    
    
    
    sig_curr_dbeat_offset  <= STD_LOGIC_VECTOR(sig_curr_strt_offset);
    
  
  
         
    ------------------------------------------------------------
    -- Instance: I_SCATTER_STROBE_GEN 
    --
    -- Description:
    --  Strobe generator instance. Generates strobe bits for
    -- a designated starting byte lane and the number of bytes
    -- to be transfered (for that data beat).    
    --
    ------------------------------------------------------------
     I_SCATTER_STROBE_GEN : entity axi_datamover_v5_1_17.axi_datamover_strb_gen2
     generic map (
                           
       C_OP_MODE            =>  0                     , -- 0 = Offset/Length mode
       C_STRB_WIDTH         =>  STRM_NUM_BYTE_LANES   ,   
       C_OFFSET_WIDTH       =>  NUM_OFFSET_BITS       ,   
       C_NUM_BYTES_WIDTH    =>  NUM_INCR_BITS           
   
       )
     port map (
       
       start_addr_offset    =>  sig_curr_dbeat_offset , 
       end_addr_offset      =>  sig_curr_dbeat_offset , -- not used in op mode 0
       num_valid_bytes      =>  sig_btt_stb_gen_slice , -- not used in op mode 1
       strb_out             =>  sig_stbgen_tstrb   
   
       );
                                
   


    
     
     
    
    
    
    
    -- BTT Counter stuff ------------------------------------------------------
    
    sig_btt_stb_gen_slice     <= STD_LOGIC_VECTOR(INCR_MAX) 
     when (sig_btt_gteq_max_incr = '1')
     else '0' & STD_LOGIC_VECTOR(sig_btt_cntr(NUM_OFFSET_BITS-1 downto 0));     
    
    
    sig_btt_offset_slice      <= UNSIGNED(sig_drc2scatter_btt(NUM_OFFSET_BITS-1 downto 0));
    
    
    sig_btt_lteq_max_first_incr <= '1'
      when (sig_btt_cntr_dup <= RESIZE(sig_max_first_increment, CMD_BTT_WIDTH))     -- more timing improv
      Else '0';                                                                 -- more timing improv
                                                                                -- more timing improv
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_MAX_FIRST_INCR_REG
    --
    -- Process Description:
    --   Implements the Max first increment register value. 
    --
    -------------------------------------------------------------
    IMP_MAX_FIRST_INCR_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset  = '1') then
              
              sig_max_first_increment <= (others => '0');
              
            Elsif (sig_ld_cmd = '1') Then
            
              sig_max_first_increment <= RESIZE(TO_UNSIGNED(MAX_BTT_INCR,NUM_INCR_BITS) - 
                                                     RESIZE(sig_next_strt_offset,NUM_INCR_BITS), 
                                                     CMD_BTT_WIDTH);
            
            Elsif (sig_valid_fifo_ld = '1') Then
              
              sig_max_first_increment <= RESIZE(TO_UNSIGNED(MAX_BTT_INCR,NUM_INCR_BITS), CMD_BTT_WIDTH);
              
            else

              null;  -- hold current value  
                
            end if; 
         end if;       
       end process IMP_MAX_FIRST_INCR_REG; 
    
    
    
    
    
    
    
    sig_btt_cntr_decr_value <= sig_btt_cntr
      When (sig_btt_lteq_max_first_incr = '1')
      Else sig_max_first_increment;
   
   
    sig_ld_btt_cntr   <= sig_ld_cmd ;
    
    sig_decr_btt_cntr <= not(sig_btt_eq_0) and 
                         sig_valid_fifo_ld;
   
    
    
    
    -- New intermediate value for reduced Timing path
    sig_btt_cntr_prv <= UNSIGNED(sig_drc2scatter_btt)
      when (sig_ld_btt_cntr = '1')
--      Else sig_btt_cntr_dup-sig_btt_cntr_decr_value;
      Else sig_btt_cntr_dup-sig_btt_cntr_decr_value;
    
    
    sig_btt_eq_0_pre_reg <= '1'
      when (sig_btt_cntr_prv = BTT_OF_ZERO)
      Else '0';
    
--    sig_btt_eq_0 <= '1'
--      when (sig_btt_cntr = BTT_OF_ZERO)
--      Else '0';
    
    sig_btt_gteq_max_incr  <= '1'
      when (sig_btt_cntr >= TO_UNSIGNED(MAX_BTT_INCR, CMD_BTT_WIDTH))
      Else '0';
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_BTT_CNTR_REG
    --
    -- Process Description:
    --  Implements the registered portion of the BTT Counter. The
    -- BTT Counter has been recoded this way to minimize long
    -- timing paths in the btt -> strobgen-> EOP Demux path.
    --
    -------------------------------------------------------------
    IMP_BTT_CNTR_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset   = '1' or
               sig_eop_sent = '1') then
  
             sig_btt_cntr                <= (others => '0');
             sig_btt_cntr_dup                <= (others => '0');
             sig_btt_eq_0                <= '1';
  
           elsif (sig_ld_btt_cntr   = '1' or
                  sig_decr_btt_cntr = '1') then
  
             sig_btt_cntr                <= sig_btt_cntr_prv;
             sig_btt_cntr_dup                <= sig_btt_cntr_prv;
             sig_btt_eq_0                <= sig_btt_eq_0_pre_reg;
           
           else
  
             Null;  -- Hold current state
  
           end if; 
        end if;       
      end process IMP_BTT_CNTR_REG; 
    
    
--    IMP_BTT_CNTR_REG : process (primary_aclk)
--      begin
--        if (primary_aclk'event and primary_aclk = '1') then
--           if (mmap_reset   = '1' or
--               sig_eop_sent = '1') then
    
--             sig_btt_cntr                <= (others => '0');
----             sig_btt_eq_0                <= '1';
    
--           elsif (sig_ld_btt_cntr   = '1') then
                  
    
--             sig_btt_cntr                <= UNSIGNED(sig_drc2scatter_btt); --sig_btt_cntr_prv;
----             sig_btt_eq_0                <= sig_btt_eq_0_pre_reg;

--           elsif (sig_decr_btt_cntr = '1') then
--             sig_btt_cntr                <= sig_btt_cntr-sig_btt_cntr_decr_value; --sig_btt_cntr_prv;
----             sig_btt_eq_0                <= sig_btt_eq_0_pre_reg;
             
--           else
    
--             Null;  -- Hold current state
    
--           end if; 
--        end if;       
--      end process IMP_BTT_CNTR_REG; 
    
     
    
    
    
     
     
    
    ------------------------------------------------------------------------
    -- DRE TVALID Gating logic
    ------------------------------------------------------------------------
    
    
    
    sig_cmd_side_ready     <= not(sig_tstrb_fifo_empty) and
                              not(sig_eop_halt_xfer); 
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_EOP_HALT_FLOP
    --
    -- Process Description:
    -- Implements a flag that is set when an end of packet is sent
    -- to the DRE and cleared after the TSTRB FIFO has been reset.
    -- This flag inhibits the TVALID sent to the DRE.
    -------------------------------------------------------------
    IMP_EOP_HALT_FLOP : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset   = '1' or
                sig_eop_sent = '1') then
              
              sig_eop_halt_xfer <= '1';
            
            Elsif (sig_valid_fifo_ld = '1') Then
              
              sig_eop_halt_xfer <= '0';
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process IMP_EOP_HALT_FLOP; 
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
     
    
    ------------------------------------------------------------------------
    -- TSTRB FIFO Logic
    ------------------------------------------------------------------------
    
     
    sig_tlast_ld_beat        <= sig_btt_lteq_max_first_incr;
    
    
    sig_eof_ld_dbeat         <= sig_curr_eof_reg and sig_tlast_ld_beat;
    
    
    -- Set the MSSAI offset value to the maximum for non-tlast dbeat
    -- case, otherwise use the calculated value for the TLSAT case. 
    sig_tstrb_fifo_mssai_in  <= STD_LOGIC_VECTOR(sig_fifo_mssai)
      when (sig_tlast_ld_beat = '1')
      else STD_LOGIC_VECTOR(OFFSET_MAX);
    


 
GEN_S2MM_TKEEP_ENABLE3 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin
   
    -- Merge the various pieces to go through the TSTRB FIFO into a single vector
    sig_tstrb_fifo_data_in   <= sig_tlast_ld_beat       & -- the last beat of this sub-packet
                                sig_eof_ld_dbeat        & -- the end of the whole packet
                                sig_freeze_it           & -- A sub-packet boundary
                                sig_tstrb_fifo_mssai_in & -- the index of EOF byte position
                                sig_stbgen_tstrb;         -- The calculated strobes



  
end generate GEN_S2MM_TKEEP_ENABLE3;

GEN_S2MM_TKEEP_DISABLE3 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin

   
    -- Merge the various pieces to go through the TSTRB FIFO into a single vector
    sig_tstrb_fifo_data_in   <= sig_tlast_ld_beat       & -- the last beat of this sub-packet
                                sig_eof_ld_dbeat        & -- the end of the whole packet
                                sig_freeze_it           & -- A sub-packet boundary
                                sig_tstrb_fifo_mssai_in; --& -- the index of EOF byte position
                                --sig_stbgen_tstrb;         -- The calculated strobes



end generate GEN_S2MM_TKEEP_DISABLE3;





    
    -- FIFO Load control
    sig_valid_fifo_ld        <= sig_tstrb_fifo_valid and
                                sig_tstrb_fifo_rdy;
    
    
     
GEN_S2MM_TKEEP_ENABLE4 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin

    -- Rip the various pieces from the FIFO output
    sig_fifo_tlast_out       <= sig_tstrb_fifo_data_out(FIFO_TLAST_INDEX) ;
    
    sig_fifo_eof_out         <= sig_tstrb_fifo_data_out(FIFO_EOF_INDEX)   ;
    
    sig_fifo_freeze_out      <= sig_tstrb_fifo_data_out(FIFO_FREEZE_INDEX);
    
    sig_tstrb_fifo_mssai_out <= sig_tstrb_fifo_data_out(FIFO_MSSAI_MS_INDEX downto FIFO_MSSAI_LS_INDEX);
    
    sig_fifo_tstrb_out       <= sig_tstrb_fifo_data_out(FIFO_TSTRB_MS_INDEX downto FIFO_TSTRB_LS_INDEX);
    
    

 
end generate GEN_S2MM_TKEEP_ENABLE4;

GEN_S2MM_TKEEP_DISABLE4 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin

   -- Rip the various pieces from the FIFO output
    sig_fifo_tlast_out       <= sig_tstrb_fifo_data_out(FIFO_TLAST_INDEX) ;
    
    sig_fifo_eof_out         <= sig_tstrb_fifo_data_out(FIFO_EOF_INDEX)   ;
    
    sig_fifo_freeze_out      <= sig_tstrb_fifo_data_out(FIFO_FREEZE_INDEX);
    
    sig_tstrb_fifo_mssai_out <= sig_tstrb_fifo_data_out(FIFO_MSSAI_MS_INDEX downto FIFO_MSSAI_LS_INDEX);
    
    sig_fifo_tstrb_out       <= (others => '1');
    
    

 
end generate GEN_S2MM_TKEEP_DISABLE4;

    
    
    -- FIFO Read Control
    sig_get_tstrb            <= sig_valid_dre_output_dbeat ;
    
    
    
    sig_tstrb_fifo_valid     <= ld_btt_cntr_reg2 or
                                (ld_btt_cntr_reg3 and 
                                 not(sig_btt_eq_0));
    
    
    sig_clr_fifo_ld_regs     <= (sig_tlast_ld_beat and
                                 sig_valid_fifo_ld) or
                                 sig_eop_sent;
    
     
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_FIFO_LD_1
    --
    -- Process Description:
    --   Implements the fifo loading control flop stage 1 
    --
    -------------------------------------------------------------
    IMP_FIFO_LD_1 : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset           = '1' or
                sig_clr_fifo_ld_regs = '1') then
              
              ld_btt_cntr_reg1  <= '0';
              
            
            Elsif (sig_ld_btt_cntr = '1') Then
            
              ld_btt_cntr_reg1  <= '1';
            
            else
              
              null; -- hold current state
              
            end if; 
         end if;       
       end process IMP_FIFO_LD_1; 
    
    
    
    
    
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_FIFO_LD_2
    --
    -- Process Description:
    --   Implements special fifo loading control flops 
    --
    -------------------------------------------------------------
    IMP_FIFO_LD_2 : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset           = '1' or
                sig_clr_fifo_ld_regs = '1') then
              
              ld_btt_cntr_reg2  <= '0';
              ld_btt_cntr_reg3  <= '0';
              
            Elsif (sig_tstrb_fifo_rdy = '1') Then
              
              ld_btt_cntr_reg2  <= ld_btt_cntr_reg1;
              ld_btt_cntr_reg3  <= ld_btt_cntr_reg2 or 
                                   ld_btt_cntr_reg3; -- once set, keep it set until cleared
              
            else

              null;  -- Hold current state
            
            end if; 
         end if;       
       end process IMP_FIFO_LD_2; 

--HIGHER_DATAWIDTH : if TSTRB_FIFO_DWIDTH > 40 generate
--begin    
    
    SLICE_INSERTION : entity axi_datamover_v5_1_17.axi_datamover_slice
         generic map (
             C_DATA_WIDTH => TSTRB_FIFO_DWIDTH
         )

         port map (
              ACLK => primary_aclk,
              ARESET => mmap_reset,

   -- Slave side
              S_PAYLOAD_DATA => sig_tstrb_fifo_data_in,
              S_VALID => sig_tstrb_fifo_valid,
              S_READY => sig_tstrb_fifo_rdy,

   -- Master side
              M_PAYLOAD_DATA => slice_insert_data,
              M_VALID => slice_insert_valid,
              M_READY => slice_insert_ready
         );
    

    ------------------------------------------------------------
    -- Instance: I_TSTRB_FIFO 
    --
    -- Description:
    -- Instance for the TSTRB FIFO
    --
    ------------------------------------------------------------
    I_TSTRB_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
    generic map (
  
      C_DWIDTH             =>  TSTRB_FIFO_DWIDTH      , 
      C_DEPTH              =>  TSTRB_FIFO_DEPTH       , 
      C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
      C_PRIM_TYPE          =>  FIFO_PRIM          , 
      C_FAMILY             =>  C_FAMILY                 
     
      )
    port map (
      
      -- Write Clock and reset
      fifo_wr_reset        =>   sig_clr_tstrb_fifo    , 
      fifo_wr_clk          =>   primary_aclk          , 
      
      -- Write Side
      fifo_wr_tvalid       =>   slice_insert_valid, --sig_tstrb_fifo_valid  , 
      fifo_wr_tready       =>   slice_insert_ready, --sig_tstrb_fifo_rdy    , 
      fifo_wr_tdata        =>   slice_insert_data, --sig_tstrb_fifo_data_in, 
      fifo_wr_full         =>   open                  , 
     
     
      -- Read Clock and reset
      fifo_async_rd_reset  =>   mmap_reset            ,   
      fifo_async_rd_clk    =>   primary_aclk          , 
      
      -- Read Side
      fifo_rd_tvalid       =>   sig_tstrb_valid         , 
      fifo_rd_tready       =>   sig_get_tstrb           , 
      fifo_rd_tdata        =>   sig_tstrb_fifo_data_out , 
      fifo_rd_empty        =>   sig_tstrb_fifo_empty   
     
      );
  
--end generate HIGHER_DATAWIDTH;
    
    
--LOWER_DATAWIDTH : if TSTRB_FIFO_DWIDTH <= 40 generate
--begin   

    ------------------------------------------------------------
    -- Instance: I_TSTRB_FIFO 
    --
    -- Description:
    -- Instance for the TSTRB FIFO
    --
    ------------------------------------------------------------
--    I_TSTRB_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
--    generic map (
--  
--      C_DWIDTH             =>  TSTRB_FIFO_DWIDTH      , 
--      C_DEPTH              =>  TSTRB_FIFO_DEPTH       , 
--      C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
--      C_PRIM_TYPE          =>  FIFO_PRIM          , 
--      C_FAMILY             =>  C_FAMILY                 
--     
--      )
--    port map (
--      
--      -- Write Clock and reset
--      fifo_wr_reset        =>   sig_clr_tstrb_fifo    , 
--      fifo_wr_clk          =>   primary_aclk          , 
--      
--     -- Write Side
--     fifo_wr_tvalid       =>   sig_tstrb_fifo_valid  , 
--     fifo_wr_tready       =>   sig_tstrb_fifo_rdy    , 
--     fifo_wr_tdata        =>   sig_tstrb_fifo_data_in, 
--     fifo_wr_full         =>   open                  , 
--    
--    
--     -- Read Clock and reset
--     fifo_async_rd_reset  =>   mmap_reset            ,   
--     fifo_async_rd_clk    =>   primary_aclk          , 
--     
--     -- Read Side
--     fifo_rd_tvalid       =>   sig_tstrb_valid         , 
--     fifo_rd_tready       =>   sig_get_tstrb           , 
--     fifo_rd_tdata        =>   sig_tstrb_fifo_data_out , 
--      fifo_rd_empty        =>   sig_tstrb_fifo_empty   
--     
--      );
--
--
--end generate LOWER_DATAWIDTH;
 
    ------------------------------------------------------------
    -- TSTRB FIFO Clear Logic
    ------------------------------------------------------------

    -- Special TSTRB FIFO Clear Logic to clean out any residue  
    -- once EOP has been sent out to DRE. This is primarily 
    -- needed in Indeterminate BTT mode but is also included in  
    -- the non-Indeterminate BTT mode for a more robust design. 
    sig_clr_tstrb_fifo   <=  mmap_reset or 
                             sig_set_packet_done;

  
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_EOP_SENT_REG
    --
    -- Process Description:
    --   Register the EOP being sent out to the DRE stage. This
    -- is used to clear the TSTRB FIFO of any residue.
    --
    -------------------------------------------------------------
    IMP_EOP_SENT_REG : process (primary_aclk)
      begin
        if (primary_aclk'event and primary_aclk = '1') then
           if (mmap_reset       = '1' or
               sig_eop_sent_reg = '1') then
    
             sig_eop_sent_reg <= '0';
    
           else
    
             sig_eop_sent_reg <= sig_eop_sent;
    
           end if; 
        end if;       
      end process IMP_EOP_SENT_REG; 

     
           
           


      
      
    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_EOF_REG
    --
    -- Process Description:
    --   Implement a sample and hold flop for the command EOF 
    --   The Commanded EOF is used when C_ENABLE_INDET_BTT = 0.
    -------------------------------------------------------------
    IMP_EOF_REG : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset          = '1' or
                sig_set_packet_done = '1') then
              
              sig_curr_eof_reg <= '0';
              
            elsif (sig_ld_cmd = '1') then
              
              sig_curr_eof_reg <= sig_drc2scatter_eof;
              
            else
              null; -- hold current state
            end if; 
         end if;       
       end process IMP_EOF_REG; 
    
    

    


   
   
   
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_INDET_BTT
    --
    -- If Generate Description:
    --  Implements the Scatter Freeze Register Controls plus 
    -- other logic needed when Indeterminate BTT Mode is not enabled.
    -- 
    --
    --
    ------------------------------------------------------------
    GEN_OMIT_INDET_BTT : if (C_ENABLE_INDET_BTT = 0) generate
    

       signal lsig_eop_matches_ms_strb     : std_logic := '0';

    
       begin

 
         sig_eop_sent    <=  sig_scatter2drc_eop and
                             sig_valid_dre_output_dbeat;
         
         
         sig_tlast_sent  <=  sig_scatter2drc_tlast and
                             sig_valid_dre_output_dbeat;
         
         
         sig_freeze_it   <= not(sig_stbgen_tstrb(STRM_NUM_BYTE_LANES-1)) and -- ms strobe not set
                            sig_valid_fifo_ld and                            -- tstrb fifo being loaded
                            not(sig_curr_eof_reg);                           -- Current input cmd does not have eof set
          
              
              
         -- Assign the TREADY out to the Stream In 
         sig_strm_tready  <= '0'
           when (sig_gated_fifo_freeze_out  = '1' or
                 sig_cmd_side_ready         = '0')
           Else sig_drc2scatter_tready;
         
         
         
 
         
         -- Without Indeterminate BTT, FIFO Freeze does not
         -- need to be gated.
         sig_gated_fifo_freeze_out <= sig_fifo_freeze_out;
         
         
         
         -- Strobe outputs are always generated from the input command
         -- with Indeterminate BTT omitted. Stream input Strobes are not
         -- sent to output.
         sig_scatter2drc_tstrb <= sig_fifo_tstrb_out;      
                               
                               
         -- The EOF marker is generated from the input command 
         -- with Indeterminate BTT omitted. Stream input TLAST is monitored
         -- but not sent to output to DRE.
         sig_scatter2drc_eop   <= sig_fifo_eof_out and 
                                  sig_scatter2drc_tvalid;
                                  
                                  
 
         -- TLast output marker always generated from the input command
         sig_scatter2drc_tlast     <= sig_fifo_tlast_out and 
                                      sig_scatter2drc_tvalid;
         
 

   
   
         
         --- TLAST Error Detection -------------------------------------------------
    
         sig_tlast_error_out  <=  sig_set_tlast_error or
                                  sig_tlast_error_reg;
                                   
          
         
        -- Compare the Most significant Asserted TSTRB from the TSTRB FIFO
        -- with that from the Input Skid Buffer
        lsig_eop_matches_ms_strb <= '1'
          when (sig_tstrb_fifo_mssai_out = sig_mssa_index)
          Else '0';
   
         
         
         
         -- Detect the case when the calculated end of packet
         -- marker preceeds the received end of packet marker
         -- and a freeze condition is not enabled
         sig_tlast_error_over <= '1'
          when (sig_valid_dre_output_dbeat  = '1' and           
                sig_fifo_freeze_out         = '0' and
                sig_fifo_eof_out            = '1' and
                sig_strm_tlast              = '0')
          Else '0';
         
         
         
         
         -- Detect the case when the received end of packet marker preceeds
         -- the calculated end of packet
         -- and a freeze condition is not enabled
         sig_tlast_error_under <= '1'
          when (sig_valid_dre_output_dbeat  = '1' and                    
                sig_fifo_freeze_out         = '0' and
                sig_fifo_eof_out            = '0' and
                sig_strm_tlast              = '1')
          Else '0';
         
         
         
         
         -- Detect the case when the received end of packet marker occurs
         -- in the same beat as the calculated end of packet but the most 
         -- significant received strobe that is asserted does not match
         -- the most significant calcualted strobe that is asserted.
         -- Also, a freeze condition is not enabled
         sig_tlast_error_exact <= '1'
           When (sig_valid_dre_output_dbeat  = '1' and                    
                 sig_fifo_freeze_out         = '0' and
                 sig_fifo_eof_out            = '1' and
                 sig_strm_tlast              = '1' and
                 lsig_eop_matches_ms_strb    = '0')
           
           Else '0';
         
         
         
         
         
         
         -- Combine all of the possible error conditions
         sig_set_tlast_error  <=  sig_tlast_error_over  or
                                  sig_tlast_error_under or
                                  sig_tlast_error_exact;
          
          
          
          
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_TLAST_ERROR_REG
         --
         -- Process Description:
         --
         --
         -------------------------------------------------------------
         IMP_TLAST_ERROR_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
                   
                   sig_tlast_error_reg <= '0';
                 
                 elsif (sig_set_tlast_error = '1') then
                   
                   sig_tlast_error_reg <= '1';
                 
                 else
                   Null;  -- Hold current State
                 end if; 
              end if;       
            end process IMP_TLAST_ERROR_REG; 
         
         
         
         
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_TLAST_ERROR_UNDER_REG
         --
         -- Process Description:
         --  Sample and Hold flop for the case when an underrun is 
         --  detected. This flag is used to force a a tvalid output.
         --
         -------------------------------------------------------------
         IMP_TLAST_ERROR_UNDER_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
                   
                   sig_err_underflow_reg <= '0';
                 
                 elsif (sig_tlast_error_under = '1') then
                   
                   sig_err_underflow_reg <= '1';
                 
                 else
                   Null;  -- Hold current State
                 end if; 
              end if;       
            end process IMP_TLAST_ERROR_UNDER_REG; 
         
         
         





    
       end generate GEN_OMIT_INDET_BTT;
    
    
 
 
 
 
 
 
 
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INDET_BTT
    --
    -- If Generate Description:
    --  Implements the Scatter Freeze Register and Controls plus
    -- other logic needed to support the Indeterminate BTT Mode
    -- of Operation.
    --
    --
    ------------------------------------------------------------
    GEN_INDET_BTT : if (C_ENABLE_INDET_BTT = 1) generate
    
       -- local signals
       
       -- signal lsig_valid_eop_dbeat   : std_logic := '0';
       signal lsig_strm_eop_asserted : std_logic := '0';
       signal lsig_absorb2tlast      : std_logic := '0';
       signal lsig_set_absorb2tlast  : std_logic := '0';
       signal lsig_clr_absorb2tlast  : std_logic := '0';
       
     
       begin

         -- Detect an end of packet condition. This is an EOP sent to the DRE or
         -- an overflow data absorption condition
         sig_eop_sent    <=  (sig_scatter2drc_eop and
                             sig_valid_dre_output_dbeat) or
                             (lsig_set_absorb2tlast and
                              not(lsig_absorb2tlast));
         
         sig_tlast_sent  <=  (sig_scatter2drc_tlast      and  --
                              sig_valid_dre_output_dbeat and  -- Normal Tlast Sent condition
                              not(lsig_set_absorb2tlast)) or  --
                              (lsig_absorb2tlast and
                              lsig_clr_absorb2tlast);         -- Overflow absorbion condition
         
         
         
         -- TStrb FIFO Input Stream Freeze control
         sig_freeze_it   <= not(sig_stbgen_tstrb(STRM_NUM_BYTE_LANES-1)) and -- ms strobe not set             
                           -- not(sig_curr_eof_reg) and                      -- tstrb fifo being loaded       
                            sig_valid_fifo_ld ;                              -- Current input cmd has eof set 
          

  
         -- Stream EOP assertion is caused when the stream input TLAST
         -- is asserted and the most significant strobe bit asserted in 
         -- the input stream data beat is less than or equal to the most
         -- significant calculated asserted strobe bit for the data beat.
         lsig_strm_eop_asserted <=  '1'
           when (sig_mssa_index <= sig_tstrb_fifo_mssai_out) and
                (sig_strm_tlast  = '1' and
                 sig_strm_tvalid = '1')
           else '0';
          
         
          
          
         -- Must not freeze the Stream input skid buffer if an EOF
         -- condition exists on the Stream input (skid buf output)
         sig_gated_fifo_freeze_out <= sig_fifo_freeze_out         and
                                      not(lsig_strm_eop_asserted) and
                                      sig_strm_tvalid;             -- CR617164
         
  
         -- Databeat DRE EOP output ---------------------------
         sig_scatter2drc_eop     <= (--sig_fifo_eof_out        or 
                                    lsig_strm_eop_asserted) and 
                                    sig_scatter2drc_tvalid;

         
         -- Databeat DRE Last output ---------------------------
         sig_scatter2drc_tlast  <= (sig_fifo_tlast_out      or
                                    lsig_strm_eop_asserted) and 
                                    sig_scatter2drc_tvalid;
         
         
         
         -- Formulate the output TSTRB vector. It is an AND of the command 
         -- generated TSTRB and the actual TSTRB received from the Stream input.
         sig_scatter2drc_tstrb  <= sig_fifo_tstrb_out and
                                   sig_strm_tstrb;


         
         sig_tlast_error_over     <= '0'; -- no tlast error in Indeterminate BTT
         sig_tlast_error_under    <= '0'; -- no tlast error in Indeterminate BTT
         sig_tlast_error_exact    <= '0'; -- no tlast error in Indeterminate BTT
         sig_set_tlast_error      <= '0'; -- no tlast error in Indeterminate BTT
         sig_tlast_error_reg      <= '0'; -- no tlast error in Indeterminate BTT
         
         sig_tlast_error_out      <= '0'; -- no tlast error in Indeterminate BTT 
         
         

         
         
         ------------------------------------------------
         -- Data absorption to TLAST logic
         -- This is used for the Stream Input overflow case. In this case, the
         -- input stream data is absorbed (thrown away) until the TLAST databeat 
         -- is received (also thrown away). However, data is only absorbed if
         -- the EOP bit from the TSTRB FIFO is encountered before the TLST from
         -- the Stream input.
         -- In addition, the scatter2drc_eop assertion is suppressed from the output
         -- to the DRE.
         
     
           
          
         -- Assign the TREADY out to the Stream In with Overflow data absorption
         -- case added.
         sig_strm_tready  <= '0'
           when  (lsig_absorb2tlast          = '0' and
                 (sig_gated_fifo_freeze_out  = '1' or -- Normal case
                  sig_cmd_side_ready         = '0'))
           Else '1'
           When (lsig_absorb2tlast = '1')  -- Absorb overflow case
           Else sig_drc2scatter_tready;
         
    
         
         -- Check for the condition for absorbing overflow data. The start of new input
         -- packet cannot reside in the same databeat as the end of the previous
         -- packet. Thus anytime an EOF is encountered from the TSTRB FIFO output, the
         -- entire databeat needs to be discarded after transfer to the DRE of the 
         -- appropriate data.
         lsig_set_absorb2tlast <=  '1'
           when (sig_fifo_eof_out     = '1'  and
                 sig_tstrb_fifo_empty = '0'  and  -- CR617164
                 (sig_strm_tlast      = '0'  and
                  sig_strm_tvalid     = '1'))
           Else '1'
           When  (sig_gated_fifo_freeze_out = '1' and
                  sig_fifo_eof_out          = '1' and
                  sig_tstrb_fifo_empty      = '0') -- CR617164
           else '0';
          
         
 
         lsig_clr_absorb2tlast <=  '1'
           when lsig_absorb2tlast = '1' and
                (sig_strm_tlast   = '1' and
                 sig_strm_tvalid  = '1')
           else '0';
          
         

        
        
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_ABSORB_FLOP
         --
         -- Process Description:
         --   Implements the flag for indicating a overflow absorption
         -- case is active.
         --
         -------------------------------------------------------------
         IMP_ABSORB_FLOP : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (mmap_reset            = '1' or
                    lsig_clr_absorb2tlast = '1') then
         
                  lsig_absorb2tlast <= '0';
         
                elsif (lsig_set_absorb2tlast = '1') then
         
                  lsig_absorb2tlast <= '1';
         
                else
         
                  null;  -- Hold Current State
         
                end if; 
             end if;       
           end process IMP_ABSORB_FLOP; 
        
        
         
         
         
         
        
    
       end generate GEN_INDET_BTT;
    
    
    
    
    
      
  
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_s2mm_realign.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_s2mm_realign.vhd
  --
  -- Description:
  --    This file implements the S2MM Data Realignment module. THe S2MM direction is
  --  more complex than the MM2S direction since the DRE needs to be upstream from
  --  the Write Data Controller. This requires the S2MM DRE to be running 2 to
  --  3 clocks ahead of the Write Data controller to minimize/eliminate xfer
  --  bubble insertion.
  --
  --
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_fifo;
  use axi_datamover_v5_1_17.axi_datamover_s2mm_dre;
  use axi_datamover_v5_1_17.axi_datamover_s2mm_scatter;

  -------------------------------------------------------------------------------

  entity axi_datamover_s2mm_realign is
    generic (

      C_ENABLE_INDET_BTT     : Integer range  0 to   1 :=  0;
        -- Specifies if the IBTT Indeterminate BTT Module is enabled
        -- for use (outside of this module)
      
      C_INCLUDE_DRE          : Integer range  0 to   1 :=  1;
        -- Includes/Omits the S2MM DRE
        -- 0 = Omit
        -- 1 = Include
      
      C_DRE_CNTL_FIFO_DEPTH  : Integer range  1 to  32 :=  1;
        -- Specifies the depth of the internal command queue fifo
      
      C_DRE_ALIGN_WIDTH      : Integer range  1 to   6 :=  2;
        -- Sets the width of the DRE alignment control ports
      
      C_SUPPORT_SCATTER      : Integer range  0 to   1 :=  1;
        -- Includes/Omits the Scatter functionality
        -- 0 = omit
        -- 1 = include
    C_ENABLE_S2MM_TKEEP             : integer range 0 to 1 := 1; 
      
      C_BTT_USED             : Integer range  8 to  26 := 16;
        -- Indicates the width of the input command BTT that is actually
        -- used
      
      C_STREAM_DWIDTH        : Integer range  8 to 1024 := 32;
        -- Sets the width of the Input and Output Stream Data ports
      
      C_TAG_WIDTH            : Integer range  1 to   8 :=  4;
        --  Sets the width of the input command Tag port
      
      C_STRT_SF_OFFSET_WIDTH : Integer range 1 to 7 := 1 ;
        -- Sets the width of the Store and Forward Start offset ports
      
      C_FAMILY               : String                  := "virtex7"
        -- specifies the target FPGA familiy
      

      );
    port (

      -- Clock and Reset Inputs -------------------------------------------
                                                                         --
      primary_aclk         : in  std_logic;                              --
         -- Primary synchronization clock for the Master side            --
         -- interface and internal logic. It is also used                --
         -- for the User interface synchronization when                  --
         -- C_STSCMD_IS_ASYNC = 0.                                       --
                                                                         --
      -- Reset input                                                     --
      mmap_reset           : in  std_logic;                              --
         -- Reset used for the internal master logic                     --
      ---------------------------------------------------------------------


       
     -- Write Data Controller or IBTT Indeterminate BTT I/O  -------------------------
                                                                                    --
      wdc2dre_wready      : In  std_logic;                                          --
        -- Write READY input from WDC or SF                                         --
                                                                                    --
      dre2wdc_wvalid      : Out  std_logic;                                         --
        -- Write VALID output to WDC or SF                                          --
                                                                                    --
      dre2wdc_wdata       : Out  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);      --
        -- Write DATA output to WDC or SF                                           --
                                                                                    --
      dre2wdc_wstrb       : Out  std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);  --
        -- Write DATA output to WDC or SF                                           --
                                                                                    --
      dre2wdc_wlast       : Out  std_logic;                                         --
        -- Write LAST output to WDC or SF                                           --
                                                                                    --
      dre2wdc_eop         : Out  std_logic;                                         --
        -- End of Packet indicator for the Stream input to WDC or SF                --
      --------------------------------------------------------------------------------



      -- Starting offset output for the Store and Forward Modules  -------------------
                                                                                    --
      dre2sf_strt_offset  : Out std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0);--
        -- Outputs the starting offset of a transfer. This is used with Store       --
        -- and Forward Packer/Unpacker logic                                        --
      --------------------------------------------------------------------------------

    

     -- AXI Slave Stream In ----------------------------------------------------------
                                                                                    --
      s2mm_strm_wready   : Out  Std_logic;                                          --
        -- AXI Stream READY input                                                   --
                                                                                    --
      s2mm_strm_wvalid   : In  std_logic;                                           --
        -- AXI Stream VALID Output                                                  --
                                                                                    --
      s2mm_strm_wdata    : In  std_logic_vector(C_STREAM_DWIDTH-1 downto 0);        --
        -- AXI Stream data output                                                   --
                                                                                    --
      s2mm_strm_wstrb    : In std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0);     --
        -- AXI Stream STRB output                                                   --
                                                                                    --
      s2mm_strm_wlast    : In std_logic;                                            --
        -- AXI Stream LAST output                                                   --
      --------------------------------------------------------------------------------



      -- Command Calculator Interface ---------------------------------------------------
                                                                                       --
      dre2mstr_cmd_ready      : Out std_logic ;                                        --
        -- Indication from the DRE that the command is being                           --
        -- accepted from the Command Calculator                                        --
                                                                                       --
      mstr2dre_cmd_valid      : In std_logic;                                          --
        -- The next command valid indication to the DRE                                --
        -- from the Command Calculator                                                 --
                                                                                       --
      mstr2dre_tag            : In std_logic_vector(C_TAG_WIDTH-1 downto 0);           --
        -- The next command tag                                                        --
                                                                                       --
      mstr2dre_dre_src_align  : In std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
        -- The source (input) alignment for the DRE                                    --
                                                                                       --
      mstr2dre_dre_dest_align : In std_logic_vector(C_DRE_ALIGN_WIDTH-1 downto 0);     --
        -- The destinstion (output) alignment for the DRE                              --
                                                                                       --
      mstr2dre_btt            : In std_logic_vector(C_BTT_USED-1 downto 0);            --
        -- The bytes to transfer value for the input command                           --
                                                                                       --
      mstr2dre_drr            : In std_logic;                                          --
        -- The starting tranfer of a sequence of transfers                             --
                                                                                       --
      mstr2dre_eof            : In std_logic;                                          --
        -- The endiing tranfer of a sequence of transfers                              --
                                                                                       --
      mstr2dre_cmd_cmplt      : In std_logic;                                          --
        -- The last tranfer command of a sequence of transfers                         --
        -- spawned from a single parent command                                        --
                                                                                       --
      mstr2dre_calc_error     : In std_logic;                                          --
        -- Indication if the next command in the calculation pipe                      --
        -- has a calculation error                                                     --
                                                                                       --
      mstr2dre_strt_offset    : In std_logic_vector(C_STRT_SF_OFFSET_WIDTH-1 downto 0);--
        -- Outputs the starting offset of a transfer. This is used with Store          --
        -- and Forward Packer/Unpacker logic                                           --
      -----------------------------------------------------------------------------------



      -- Premature TLAST assertion error flag -----------------------------
                                                                         --
      dre2all_tlast_error     : Out std_logic;                           --
        -- When asserted, this indicates the DRE detected                --
        -- a Early/Late TLAST assertion on the incoming data stream.     --
      ---------------------------------------------------------------------



      -- DRE Halted Status ------------------------------------------------
                                                                         --
      dre2all_halted          : Out std_logic                            --
        -- When asserted, this indicates the DRE has satisfied           --
        -- all pending transfers queued by the command calculator        --
        -- and is halted.                                                --
      ---------------------------------------------------------------------



      );

  end entity axi_datamover_s2mm_realign;


  architecture implementation of axi_datamover_s2mm_realign  is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



    -- Function Declarations  --------------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_size_realign_fifo
    --
    -- Function Description:
    --  Assures that the Realigner cmd fifo depth is at least 4 deep else it
    -- is equal to the pipe depth.
    --
    -------------------------------------------------------------------
    function funct_size_realign_fifo (pipe_depth : integer) return integer is
    
      Variable temp_fifo_depth : Integer := 4;
    
    begin
    
      If (pipe_depth < 4) Then
    
        temp_fifo_depth := 4;
      
      Else 

        temp_fifo_depth := pipe_depth;
          
      End if;
      
      
      Return (temp_fifo_depth);
      
      
    end function funct_size_realign_fifo;
    


    -- Constant Declarations  --------------------------------------------


    Constant BYTE_WIDTH            : integer := 8; -- bits
    Constant STRM_NUM_BYTE_LANES   : integer := C_STREAM_DWIDTH/BYTE_WIDTH;
    Constant STRM_STRB_WIDTH       : integer := STRM_NUM_BYTE_LANES;
    Constant SLICE_WIDTH           : integer := BYTE_WIDTH+2; -- 8 data bits plus Strobe plus TLAST bit
    Constant SLICE_STROBE_INDEX    : integer := (BYTE_WIDTH-1)+1;
    Constant SLICE_TLAST_INDEX     : integer := SLICE_STROBE_INDEX+1;
    Constant ZEROED_SLICE          : std_logic_vector(SLICE_WIDTH-1 downto 0) := (others => '0');
    Constant USE_SYNC_FIFO         : integer := 0;
    Constant REG_FIFO_PRIM         : integer := 0;
    Constant BRAM_FIFO_PRIM        : integer := 1;
    Constant SRL_FIFO_PRIM         : integer := 2;
    Constant FIFO_PRIM_TYPE        : integer := SRL_FIFO_PRIM;
    Constant TAG_WIDTH             : integer := C_TAG_WIDTH;
    Constant SRC_ALIGN_WIDTH       : integer := C_DRE_ALIGN_WIDTH;
    Constant DEST_ALIGN_WIDTH      : integer := C_DRE_ALIGN_WIDTH;
    Constant BTT_WIDTH             : integer := C_BTT_USED;
    Constant DRR_WIDTH             : integer := 1;
    Constant EOF_WIDTH             : integer := 1;
    Constant SEQUENTIAL_WIDTH      : integer := 1;
    Constant CALC_ERR_WIDTH        : integer := 1;
    Constant SF_OFFSET_WIDTH       : integer := C_STRT_SF_OFFSET_WIDTH;
    
    
    Constant BTT_OF_ZERO           : std_logic_vector(BTT_WIDTH-1 downto 0)
                                     := (others => '0');

    
    
    Constant DRECTL_FIFO_DEPTH     : integer := funct_size_realign_fifo(C_DRE_CNTL_FIFO_DEPTH);
    
    
    Constant DRECTL_FIFO_WIDTH     : Integer := TAG_WIDTH        +  -- Tag field
                                                SRC_ALIGN_WIDTH  +  -- Source align field width
                                                DEST_ALIGN_WIDTH +  -- Dest align field width
                                                BTT_WIDTH        +  -- BTT field width
                                                DRR_WIDTH        +  -- DRE Re-alignment Request Flag Field
                                                EOF_WIDTH        +  -- EOF flag field
                                                SEQUENTIAL_WIDTH +  -- Sequential command flag
                                                CALC_ERR_WIDTH   +  -- Calc error flag
                                                SF_OFFSET_WIDTH;    -- Store and Forward Offset

    Constant TAG_STRT_INDEX        : integer := 0;
    Constant SRC_ALIGN_STRT_INDEX  : integer := TAG_STRT_INDEX + TAG_WIDTH;
    Constant DEST_ALIGN_STRT_INDEX : integer := SRC_ALIGN_STRT_INDEX + SRC_ALIGN_WIDTH;
    Constant BTT_STRT_INDEX        : integer := DEST_ALIGN_STRT_INDEX + DEST_ALIGN_WIDTH;
    Constant DRR_STRT_INDEX        : integer := BTT_STRT_INDEX + BTT_WIDTH;
    Constant EOF_STRT_INDEX        : integer := DRR_STRT_INDEX + DRR_WIDTH;
    Constant SEQUENTIAL_STRT_INDEX : integer := EOF_STRT_INDEX + EOF_WIDTH;
    Constant CALC_ERR_STRT_INDEX   : integer := SEQUENTIAL_STRT_INDEX+SEQUENTIAL_WIDTH;
    Constant SF_OFFSET_STRT_INDEX  : integer := CALC_ERR_STRT_INDEX+CALC_ERR_WIDTH;
    
    
    
    Constant INCLUDE_DRE           : boolean := (C_INCLUDE_DRE    = 1  and
                                                 C_STREAM_DWIDTH <= 512 and
                                                 C_STREAM_DWIDTH >= 16);
                                                 
    Constant OMIT_DRE              : boolean := not(INCLUDE_DRE);



   
    -- Type Declarations  --------------------------------------------
    
    type TYPE_CMD_CNTL_SM is (
                INIT,
                LD_DRE_SCATTER_FIRST,
                CHK_POP_FIRST       ,
                LD_DRE_SCATTER_SECOND,
                CHK_POP_SECOND,
                ERROR_TRAP
                );





    -- Signal Declarations  --------------------------------------------
    
    Signal sig_cmdcntl_sm_state        : TYPE_CMD_CNTL_SM := INIT;
    Signal sig_cmdcntl_sm_state_ns     : TYPE_CMD_CNTL_SM := INIT;
    signal sig_sm_ld_dre_cmd_ns        : std_logic := '0';
    signal sig_sm_ld_dre_cmd           : std_logic := '0';
    signal sig_sm_ld_scatter_cmd_ns    : std_logic := '0';
    signal sig_sm_ld_scatter_cmd       : std_logic := '0';
    signal sig_sm_pop_cmd_fifo_ns      : std_logic := '0';
    signal sig_sm_pop_cmd_fifo         : std_logic := '0';

    signal sig_cmd_fifo_data_in        : std_logic_vector(DRECTL_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_cmd_fifo_data_out       : std_logic_vector(DRECTL_FIFO_WIDTH-1 downto 0) := (others => '0');
    signal sig_fifo_wr_cmd_valid       : std_logic := '0';
    signal sig_fifo_wr_cmd_ready       : std_logic := '0';
    signal sig_curr_tag_reg            : std_logic_vector(TAG_WIDTH-1 downto 0)        := (others => '0');
    signal sig_curr_src_align_reg      : std_logic_vector(SRC_ALIGN_WIDTH-1 downto 0)  := (others => '0');
    signal sig_curr_dest_align_reg     : std_logic_vector(DEST_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_curr_btt_reg            : std_logic_vector(BTT_WIDTH-1 downto 0)        := (others => '0');
    signal sig_curr_drr_reg            : std_logic := '0';
    signal sig_curr_eof_reg            : std_logic := '0';
    signal sig_curr_cmd_cmplt_reg      : std_logic := '0';
    signal sig_curr_calc_error_reg     : std_logic := '0';
    signal sig_dre_align_ready         : std_logic := '0';
    signal sig_dre_use_autodest        : std_logic := '0';
    signal sig_dre_src_align           : std_logic_vector(SRC_ALIGN_WIDTH-1 downto 0)  := (others => '0');
    signal sig_dre_dest_align          : std_logic_vector(DEST_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_dre_flush               : std_logic := '0';
    signal sig_dre2wdc_tstrb           : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_dre2wdc_tdata           : std_logic_vector(C_STREAM_DWIDTH-1 downto 0)     := (others => '0');
    signal sig_dre2wdc_tlast           : std_logic := '0';
    signal sig_dre2wdc_tvalid          : std_logic := '0';
    signal sig_wdc2dre_tready          : std_logic := '0';
    signal sig_tlast_err0r             : std_logic := '0';
    signal sig_dre_halted              : std_logic := '0';
    signal sig_strm2scatter_tstrb      : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_strm2scatter_tdata      : std_logic_vector(C_STREAM_DWIDTH-1 downto 0)     := (others => '0');
    signal sig_strm2scatter_tlast      : std_logic := '0';
    signal sig_strm2scatter_tvalid     : std_logic := '0';
    signal sig_scatter2strm_tready     : std_logic := '0';
    signal sig_scatter2dre_tstrb       : std_logic_vector((C_STREAM_DWIDTH/8)-1 downto 0) := (others => '0');
    signal sig_scatter2dre_tdata       : std_logic_vector(C_STREAM_DWIDTH-1 downto 0)     := (others => '0');
    signal sig_scatter2dre_tlast       : std_logic := '0';
    signal sig_scatter2dre_tvalid      : std_logic := '0';
    signal sig_dre2scatter_tready      : std_logic := '0';
    signal sig_scatter2dre_flush       : std_logic := '0';
    signal sig_scatter2drc_eop         : std_logic := '0';
    signal sig_scatter2dre_src_align   : std_logic_vector(SRC_ALIGN_WIDTH-1 downto 0) := (others => '0');
    signal sig_scatter2drc_cmd_ready   : std_logic := '0';
    signal sig_drc2scatter_push_cmd    : std_logic;
    signal sig_drc2scatter_btt         : std_logic_vector(BTT_WIDTH-1 downto 0);
    signal sig_drc2scatter_eof         : std_logic;
    signal sig_scatter2all_tlast_error : std_logic := '0';
    signal sig_need_cmd_flush          : std_logic := '0';
    signal sig_fifo_rd_cmd_valid       : std_logic := '0';
    signal sig_curr_strt_offset_reg    : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
    signal sig_ld_strt_offset          : std_logic := '0';
    signal sig_output_strt_offset_reg  : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
    signal sig_dre2sf_strt_offset      : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');




  begin --(architecture implementation)


    -------------------------------------------------------------
    -- Port connections


    -- Input Stream Attachment
    s2mm_strm_wready        <= sig_scatter2strm_tready ;
    sig_strm2scatter_tvalid <= s2mm_strm_wvalid        ;
    sig_strm2scatter_tdata  <= s2mm_strm_wdata         ;
    sig_strm2scatter_tstrb  <= s2mm_strm_wstrb         ;
    sig_strm2scatter_tlast  <= s2mm_strm_wlast         ;



    -- Write Data Controller Stream Attachment
    sig_wdc2dre_tready   <= wdc2dre_wready     ;
    dre2wdc_wvalid       <= sig_dre2wdc_tvalid ;
    dre2wdc_wdata        <= sig_dre2wdc_tdata  ;
    dre2wdc_wstrb        <= sig_dre2wdc_tstrb  ;
    dre2wdc_wlast        <= sig_dre2wdc_tlast  ;
    

    -- Status/Error flags
    dre2all_tlast_error  <= sig_tlast_err0r   ;
    dre2all_halted       <= sig_dre_halted    ;


    -- Store and Forward Starting Offset Output
    dre2sf_strt_offset   <= sig_dre2sf_strt_offset ;





    -------------------------------------------------------------
    -- Internal logic


    sig_dre_halted    <= sig_dre_align_ready;



  
  
    -------------------------------------------------------------
    -- DRE Handshake signals

    sig_dre_src_align        <= sig_curr_src_align_reg ;
    sig_dre_dest_align       <= sig_curr_dest_align_reg;

    sig_dre_use_autodest     <= '0';  -- not used
    sig_dre_flush            <= '0';  -- not used



 
  -------------------------------------------------------------------------
  -------- Realigner Command FIFO and controls 
  -------------------------------------------------------------------------
 
    -- Command Calculator Handshake
    sig_fifo_wr_cmd_valid    <= mstr2dre_cmd_valid   ;
    dre2mstr_cmd_ready       <= sig_fifo_wr_cmd_ready;




    -- Format the input fifo data word
    sig_cmd_fifo_data_in     <= mstr2dre_strt_offset    &
                                mstr2dre_calc_error     &
                                mstr2dre_cmd_cmplt      &
                                mstr2dre_eof            &
                                mstr2dre_drr            &
                                mstr2dre_btt            &
                                mstr2dre_dre_dest_align &
                                mstr2dre_dre_src_align  &
                                mstr2dre_tag ;


    -- Rip the output fifo data word
    sig_curr_tag_reg         <= sig_cmd_fifo_data_out((TAG_STRT_INDEX+TAG_WIDTH)-1 downto TAG_STRT_INDEX);
    sig_curr_src_align_reg   <= sig_cmd_fifo_data_out((SRC_ALIGN_STRT_INDEX+SRC_ALIGN_WIDTH)-1 downto SRC_ALIGN_STRT_INDEX);
    sig_curr_dest_align_reg  <= sig_cmd_fifo_data_out((DEST_ALIGN_STRT_INDEX+DEST_ALIGN_WIDTH)-1 downto DEST_ALIGN_STRT_INDEX);
    sig_curr_btt_reg         <= sig_cmd_fifo_data_out((BTT_STRT_INDEX+BTT_WIDTH)-1 downto BTT_STRT_INDEX);
    sig_curr_drr_reg         <= sig_cmd_fifo_data_out(DRR_STRT_INDEX);
    sig_curr_eof_reg         <= sig_cmd_fifo_data_out(EOF_STRT_INDEX);
    sig_curr_cmd_cmplt_reg   <= sig_cmd_fifo_data_out(SEQUENTIAL_STRT_INDEX);
    sig_curr_calc_error_reg  <= sig_cmd_fifo_data_out(CALC_ERR_STRT_INDEX);
    sig_curr_strt_offset_reg <= sig_cmd_fifo_data_out((SF_OFFSET_STRT_INDEX+SF_OFFSET_WIDTH)-1 downto SF_OFFSET_STRT_INDEX);



    ------------------------------------------------------------
    -- Instance: I_DRE_CNTL_FIFO
    --
    -- Description:
    -- Instance for the DRE Control FIFO
    --
    ------------------------------------------------------------
     I_DRE_CNTL_FIFO : entity axi_datamover_v5_1_17.axi_datamover_fifo
     generic map (

       C_DWIDTH             =>  DRECTL_FIFO_WIDTH      , 
       C_DEPTH              =>  DRECTL_FIFO_DEPTH  , 
       C_IS_ASYNC           =>  USE_SYNC_FIFO          , 
       C_PRIM_TYPE          =>  FIFO_PRIM_TYPE         , 
       C_FAMILY             =>  C_FAMILY                 

       )
     port map (

       -- Write Clock and reset
       fifo_wr_reset        =>   mmap_reset            , 
       fifo_wr_clk          =>   primary_aclk          , 

       -- Write Side
       fifo_wr_tvalid       =>   sig_fifo_wr_cmd_valid , 
       fifo_wr_tready       =>   sig_fifo_wr_cmd_ready , 
       fifo_wr_tdata        =>   sig_cmd_fifo_data_in  , 
       fifo_wr_full         =>   open                  , 


       -- Read Clock and reset
       fifo_async_rd_reset  =>   mmap_reset            , 
       fifo_async_rd_clk    =>   primary_aclk          , 

       -- Read Side
       fifo_rd_tvalid       =>   sig_fifo_rd_cmd_valid , 
       fifo_rd_tready       =>   sig_sm_pop_cmd_fifo   , 
       fifo_rd_tdata        =>   sig_cmd_fifo_data_out , 
       fifo_rd_empty        =>   open                    

       );





 
 
  -------------------------------------------------------------------------
  -------- DRE and Scatter Command Loader State Machine 
  -------------------------------------------------------------------------
 

   
    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CMDCNTL_SM_COMBINATIONAL
    --
    -- Process Description:
    -- Command Controller State Machine combinational implementation
    -- The design is based on the premise that for every parent 
    -- command loaded into the S2MM, the Realigner can be loaded with
    -- 1 or 2 commands spawned from it. The first command is used to 
    -- align ensuing transfers (in MMap space) to a max burst address 
    -- boundary. Then, if the parent command's BTT value is not satisfied
    -- after the first command completes, a second command is generated
    -- and loaded in the Realigner for the remaining BTT value. The 
    -- command complete bit in the Realigner command indicates if the
    -- first command the final command or the second command (if needed)
    -- is the final command,
    -------------------------------------------------------------
    CMDCNTL_SM_COMBINATIONAL : process (sig_cmdcntl_sm_state      ,
                                        sig_fifo_rd_cmd_valid     ,
                                        sig_dre_align_ready       ,
                                        sig_scatter2drc_cmd_ready ,
                                        sig_need_cmd_flush        ,
                                        sig_curr_cmd_cmplt_reg    ,
                                        sig_curr_calc_error_reg
                                       )
       
       begin

         -- SM Defaults
         sig_cmdcntl_sm_state_ns   <=  INIT;
         sig_sm_ld_dre_cmd_ns      <=  '0';
         sig_sm_ld_scatter_cmd_ns  <=  '0';
         sig_sm_pop_cmd_fifo_ns    <=  '0';
         


         case sig_cmdcntl_sm_state is

           --------------------------------------------
           when INIT =>

             sig_cmdcntl_sm_state_ns  <=  LD_DRE_SCATTER_FIRST;

           
           
           --------------------------------------------
           when LD_DRE_SCATTER_FIRST =>

             If  (sig_fifo_rd_cmd_valid   = '1' and
                  sig_curr_calc_error_reg = '1') Then   
            
               sig_cmdcntl_sm_state_ns  <=  ERROR_TRAP;
             
             
             elsif (sig_fifo_rd_cmd_valid     = '1' and
                    sig_dre_align_ready       = '1' and
                    sig_scatter2drc_cmd_ready = '1') Then

               sig_cmdcntl_sm_state_ns   <=  CHK_POP_FIRST ;
               sig_sm_ld_dre_cmd_ns      <=  '1';
               sig_sm_ld_scatter_cmd_ns  <=  '1';
               sig_sm_pop_cmd_fifo_ns    <=  '1';

             else

               sig_cmdcntl_sm_state_ns <=  LD_DRE_SCATTER_FIRST;

             End if;



           --------------------------------------------
           when CHK_POP_FIRST =>

             If (sig_curr_cmd_cmplt_reg = '1') Then
               
               sig_cmdcntl_sm_state_ns <=  LD_DRE_SCATTER_FIRST;
             
             Else 
             
               sig_cmdcntl_sm_state_ns <=  LD_DRE_SCATTER_SECOND;
             
             
             End if;
            
             

           --------------------------------------------
           when LD_DRE_SCATTER_SECOND =>

             If  (sig_fifo_rd_cmd_valid   = '1' and
                  sig_curr_calc_error_reg = '1') Then   
            
               sig_cmdcntl_sm_state_ns  <=  ERROR_TRAP;
             
             elsif (sig_fifo_rd_cmd_valid  = '1' and
                    sig_need_cmd_flush     = '1') Then
             
               sig_cmdcntl_sm_state_ns   <=  CHK_POP_SECOND ;
               sig_sm_pop_cmd_fifo_ns    <=  '1';
             
             
             elsif (sig_fifo_rd_cmd_valid     = '1' and
                    sig_dre_align_ready       = '1' and
                    sig_scatter2drc_cmd_ready = '1') Then

               sig_cmdcntl_sm_state_ns   <=  CHK_POP_FIRST ;
               sig_sm_ld_dre_cmd_ns      <=  '1';
               sig_sm_ld_scatter_cmd_ns  <=  '1';
               sig_sm_pop_cmd_fifo_ns    <=  '1';

             else

               sig_cmdcntl_sm_state_ns <=  LD_DRE_SCATTER_SECOND;

             End if;



           --------------------------------------------
           when CHK_POP_SECOND =>

             sig_cmdcntl_sm_state_ns   <=  LD_DRE_SCATTER_FIRST ;


           --------------------------------------------
           when ERROR_TRAP =>

             sig_cmdcntl_sm_state_ns   <=  ERROR_TRAP ;



           --------------------------------------------
           when others =>

             sig_cmdcntl_sm_state_ns <=  INIT;

         end case;



       end process CMDCNTL_SM_COMBINATIONAL;



     
     
     

    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: CMDCNTL_SM_REGISTERED
    --
    -- Process Description:
    -- Command Controller State Machine registered implementation
    --
    -------------------------------------------------------------
    CMDCNTL_SM_REGISTERED : process (primary_aclk)
       begin
         if (primary_aclk'event and primary_aclk = '1') then
            if (mmap_reset = '1') then

              sig_cmdcntl_sm_state  <= INIT;
              sig_sm_ld_dre_cmd     <= '0' ;
              sig_sm_ld_scatter_cmd <= '0' ;
              sig_sm_pop_cmd_fifo   <= '0' ;

            else

              sig_cmdcntl_sm_state  <= sig_cmdcntl_sm_state_ns   ;
              sig_sm_ld_dre_cmd     <= sig_sm_ld_dre_cmd_ns      ;
              sig_sm_ld_scatter_cmd <= sig_sm_ld_scatter_cmd_ns  ;
              sig_sm_pop_cmd_fifo   <= sig_sm_pop_cmd_fifo_ns    ;
              
            end if;
         end if;
       end process CMDCNTL_SM_REGISTERED;








   
  
  
  

  -------------------------------------------------------------------------
  -------- DRE Instance and controls 
  -------------------------------------------------------------------------
 



    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_DRE
    --
    -- If Generate Description:
    --  Includes the instance for the DRE
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_DRE : if (INCLUDE_DRE) generate

      signal lsig_eop_reg                : std_logic := '0';
      signal lsig_dre_load_beat          : std_logic := '0';
      signal lsig_dre_tlast_output_beat  : std_logic := '0';
      signal lsig_set_eop                : std_logic := '0';
      signal lsig_tlast_err_reg1         : std_logic := '0';
      signal lsig_tlast_err_reg2         : std_logic := '0';
      
      signal lsig_push_strt_offset_reg   : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
      signal lsig_pushreg_full           : std_logic := '0';
      signal lsig_pushreg_empty          : std_logic := '0';
      
      signal lsig_pull_strt_offset_reg   : std_logic_vector(SF_OFFSET_WIDTH-1 downto 0) := (others => '0');
      signal lsig_pullreg_full           : std_logic := '0';
      signal lsig_pullreg_empty          : std_logic := '0';
     
      signal lsig_pull_new_offset        : std_logic := '0';
      signal lsig_push_new_offset        : std_logic := '0';
     
     
     
     
      begin


        ------------------------------------------------------------
        -- Instance: I_S2MM_DRE_BLOCK
        --
        -- Description:
        --  Instance for the S2MM Data Realignment Engine (DRE)
        --
        ------------------------------------------------------------
        I_S2MM_DRE_BLOCK : entity axi_datamover_v5_1_17.axi_datamover_s2mm_dre
        generic map (

          C_DWIDTH          =>  C_STREAM_DWIDTH            , 
          C_ALIGN_WIDTH     =>  C_DRE_ALIGN_WIDTH            

          )
        port map (

         -- Clock and Reset
          dre_clk           =>  primary_aclk               , 
          dre_rst           =>  mmap_reset                 , 

         -- Alignment Control (Independent from Stream Input timing)
          dre_align_ready   =>  sig_dre_align_ready        , 
          dre_align_valid   =>  sig_sm_ld_dre_cmd          , 
          dre_use_autodest  =>  sig_dre_use_autodest       , 
          dre_src_align     =>  sig_scatter2dre_src_align  , 
          dre_dest_align    =>  sig_dre_dest_align         , 

         -- Flush Control (Aligned to input Stream timing)
          dre_flush         =>  sig_scatter2dre_flush      , 

         -- Stream Inputs
          dre_in_tstrb      =>  sig_scatter2dre_tstrb      , 
          dre_in_tdata      =>  sig_scatter2dre_tdata      , 
          dre_in_tlast      =>  sig_scatter2dre_tlast      , 
          dre_in_tvalid     =>  sig_scatter2dre_tvalid     , 
          dre_in_tready     =>  sig_dre2scatter_tready     , 


         -- Stream Outputs
          dre_out_tstrb     =>  sig_dre2wdc_tstrb          , 
          dre_out_tdata     =>  sig_dre2wdc_tdata          , 
          dre_out_tlast     =>  sig_dre2wdc_tlast          , 
          dre_out_tvalid    =>  sig_dre2wdc_tvalid         , 
          dre_out_tready    =>  sig_wdc2dre_tready           

          );






        lsig_dre_load_beat         <= sig_scatter2dre_tvalid and
                                      sig_dre2scatter_tready;
        
        
        lsig_set_eop               <=  sig_scatter2drc_eop and
                                       lsig_dre_load_beat ;
        
        
        lsig_dre_tlast_output_beat <=  sig_dre2wdc_tvalid and
                                       sig_wdc2dre_tready and
                                       sig_dre2wdc_tlast;
        
        
         dre2wdc_eop               <=  lsig_dre_tlast_output_beat and
                                       lsig_eop_reg;
        
        
        
         
        -------------------------------------------------------------
        -- Synchronous Process with Sync Reset
        --
        -- Label: IMP_EOP_REG
        --
        -- Process Description:
        --   Implements a flop for holding the EOP from the Scatter
        -- Engine until the corresponding packet clears out of the DRE.
        -- THis is used to transfer the EOP marker to the DRE output
        -- stream without the need for the DRE to pass it through.
        --
        -------------------------------------------------------------
        IMP_EOP_REG : process (primary_aclk)
          begin
            if (primary_aclk'event and primary_aclk = '1') then
               if (mmap_reset                 = '1' or
                  (lsig_dre_tlast_output_beat = '1' and
                   lsig_set_eop               = '0')) then
        
                 lsig_eop_reg  <= '0';
        
               elsif (lsig_set_eop = '1') then
        
                 lsig_eop_reg <= '1';
        
               else
                 
                 null;  -- Hold current state
        
               end if; 
            end if;       
          end process IMP_EOP_REG; 
         
         
         
        

       
       
          -- Delay TLAST Error by 2 clocks to compensate for DRE minimum
          -- delay of 2 clocks for the stream data.
          sig_tlast_err0r         <= lsig_tlast_err_reg2;
         
         
       
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_TLAST_ERR_DELAY
          --
          -- Process Description:
          --   Implements a 2 clock delay to better align the TLAST
          -- error detection with the Stream output data to the WDC
          -- which has a minimum 2 clock delay through the DRE.
          --
          -------------------------------------------------------------
          IMP_TLAST_ERR_DELAY : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
          
                   lsig_tlast_err_reg1 <= '0';
                   lsig_tlast_err_reg2 <= '0';
          
                 else
          
                   lsig_tlast_err_reg1 <= sig_scatter2all_tlast_error;
                   lsig_tlast_err_reg2 <= lsig_tlast_err_reg1;
          
                 end if; 
              end if;       
            end process IMP_TLAST_ERR_DELAY; 
       
     
     
     
     
       
          -------------------------------------------------------------------------
          -- Store and Forward Start Address Offset Registers Logic 
          --       Push-pull register is used to to time align the starting address 
          --       offset (ripped from the Realigner command via parsing) to DRE 
          --       TLAST output timing. The offset output of the pull register must
          --       be valid on the first output databeat of the DRE to the Store and
          --       Forward module.
          -------------------------------------------------------------------------
          
          sig_dre2sf_strt_offset <= lsig_pull_strt_offset_reg;
        
          --    lsig_push_new_offset   <= sig_dre_align_ready and
          --                              sig_gated_dre_align_valid ;
          
          lsig_push_new_offset   <= sig_sm_ld_dre_cmd ;
        
        
        
        
        
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_PUSH_STRT_OFFSET_REG
          --
          -- Process Description:
          --   Implements the input register for holding the starting address 
          -- offset sent to the external Store and Forward functions.
          --
          -------------------------------------------------------------
          IMP_PUSH_STRT_OFFSET_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
          
                   lsig_push_strt_offset_reg <= (others => '0');
                   lsig_pushreg_full         <= '0';
                   lsig_pushreg_empty        <= '1';
          
                 elsif (lsig_push_new_offset = '1') then
          
                   lsig_push_strt_offset_reg <= sig_curr_strt_offset_reg;
                   lsig_pushreg_full         <= '1';
                   lsig_pushreg_empty        <= '0';
          
                 elsif (lsig_pull_new_offset = '1') then
          
                   lsig_push_strt_offset_reg <= (others => '0');
                   lsig_pushreg_full         <= '0';
                   lsig_pushreg_empty        <= '1';
          
                 else
          
                   null;  -- Hold Current State
          
                 end if; 
              end if;       
            end process IMP_PUSH_STRT_OFFSET_REG; 
        
        
           
           
          
          -- Pull the next offset (if one exists) into the pull register  
          -- when the DRE outputs a TLAST. If the pull register is empty 
          -- and the push register has an offset, then push the new value 
          -- into the pull register.   
          lsig_pull_new_offset <= (sig_dre2wdc_tlast   and  
                                   sig_dre2wdc_tvalid  and 
                                   sig_wdc2dre_tready) or
                                  (lsig_pushreg_full   and 
                                   lsig_pullreg_empty);
        
                                                          
                                                          
                                                          
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_PULL_STRT_OFFSET_REG
          --
          -- Process Description:
          --   Implements the output register for holding the starting  
          -- address offset sent to the Store and Forward modul's upsizer
          -- logic.
          --
          -------------------------------------------------------------
          IMP_PULL_STRT_OFFSET_REG : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
          
                   lsig_pull_strt_offset_reg <= (others => '0');
                   lsig_pullreg_full         <= '0';
                   lsig_pullreg_empty        <= '1';
          
                 elsif (lsig_pull_new_offset = '1' and
                        lsig_pushreg_full    = '1') then
          
                   lsig_pull_strt_offset_reg <= lsig_push_strt_offset_reg;
                   lsig_pullreg_full         <= '1';
                   lsig_pullreg_empty        <= '0';
          
                 elsif (lsig_pull_new_offset = '1' and
                        lsig_pushreg_full    = '0') then
          
                   lsig_pull_strt_offset_reg <= (others => '0');
                   lsig_pullreg_full         <= '0';
                   lsig_pullreg_empty        <= '1';
          
                 else
          
                   null;  -- Hold Current State
          
                 end if; 
              end if;       
            end process IMP_PULL_STRT_OFFSET_REG; 
        
        
        
        
        
        


      end generate GEN_INCLUDE_DRE;






    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_DRE
    --
    -- If Generate Description:
    --   Omits the DRE from the Re-aligner.
    --
    --
    ------------------------------------------------------------
    GEN_OMIT_DRE : if (OMIT_DRE) generate

       begin

          
          -- DRE always ready
          sig_dre_align_ready     <= '1';
          
          
          --    -- Let the Scatter engine control the Realigner command
          --    -- flow.
          --    sig_dre_align_ready     <= sig_scatter2drc_cmd_ready;


          -- Pass through signal connections
          sig_dre2wdc_tstrb       <= sig_scatter2dre_tstrb  ;
          sig_dre2wdc_tdata       <= sig_scatter2dre_tdata  ;
          sig_dre2wdc_tlast       <= sig_scatter2dre_tlast  ;
          sig_dre2wdc_tvalid      <= sig_scatter2dre_tvalid ;
          sig_dre2scatter_tready  <= sig_wdc2dre_tready     ;

          dre2wdc_eop             <=  sig_scatter2drc_eop   ;


          
          -- Just pass TLAST Error through when no DRE is present
          sig_tlast_err0r         <= sig_scatter2all_tlast_error;
         
      
      
         
          -------------------------------------------------------------------------
          -------- Store and Forward Start Address Offset Register Logic 
          -------------------------------------------------------------------------
         
          sig_dre2sf_strt_offset <=  sig_output_strt_offset_reg;
          
          
          sig_ld_strt_offset <= sig_sm_ld_dre_cmd;
        
        
            
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_STRT_OFFSET_OUTPUT
          --
          -- Process Description:
          --   Implements the register for holding the starting address 
          -- offset sent to the S2MM Store and Forward module's upsizer
          -- logic.
          --
          -------------------------------------------------------------
          IMP_STRT_OFFSET_OUTPUT : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset = '1') then
          
                   sig_output_strt_offset_reg <= (others => '0');
          
                 elsif (sig_ld_strt_offset = '1') then
          
                   sig_output_strt_offset_reg <= sig_curr_strt_offset_reg;
          
                 else
          
                   null;  -- Hold Current State
          
                 end if; 
              end if;       
            end process IMP_STRT_OFFSET_OUTPUT; 
        
        
        
        
        
  
         
         
       end generate GEN_OMIT_DRE;








    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_SCATTER
    --
    -- If Generate Description:
    -- This IfGen implements the Scatter function which is a pre-
    -- processor for the S2MM DRE. The scatter function breaks up
    -- a continous input stream of data into constituant parts
    -- as described by a set of loaded commands that together
    -- describe an entire input packet.
    --
    ------------------------------------------------------------
    GEN_INCLUDE_SCATTER : if (C_SUPPORT_SCATTER = 1) generate


      begin


        -- Load the Scatter Engine command when the DRE command
        -- is loaded
        
        --    sig_drc2scatter_push_cmd <= sig_dre_align_ready and
        --                                sig_gated_dre_align_valid;

        
        sig_drc2scatter_push_cmd <= sig_sm_ld_scatter_cmd ;
        
        
        
        
        
        
        -- Assign the new Bytes to Transfer (BTT) qualifier for the
        -- Scatter Engine
        sig_drc2scatter_btt      <= sig_curr_btt_reg;

        -- Assign the new End of Frame (EOF) qualifier for the
        -- Scatter Engine
        sig_drc2scatter_eof      <= sig_curr_eof_reg;


       ------------------------------------------------------------
       -- Instance: I_S2MM_SCATTER
       --
       -- Description:
       --  Instance for the Scatter Engine. This block breaks up a
       --  input stream per commands loaded.
       --
       ------------------------------------------------------------
       I_S2MM_SCATTER : entity axi_datamover_v5_1_17.axi_datamover_s2mm_scatter
       generic map (

         C_ENABLE_INDET_BTT       =>  C_ENABLE_INDET_BTT        , 
         C_DRE_ALIGN_WIDTH        =>  C_DRE_ALIGN_WIDTH         ,
          C_ENABLE_S2MM_TKEEP       =>  C_ENABLE_S2MM_TKEEP        ,
         C_BTT_USED               =>  BTT_WIDTH                 ,
         C_STREAM_DWIDTH          =>  C_STREAM_DWIDTH           ,
         C_FAMILY                 =>  C_FAMILY

         )
       port map (

         -- Clock input & Reset input
         primary_aclk             => primary_aclk               ,  
         mmap_reset               => mmap_reset                 ,  

        -- DRE Realign Controller I/O  ----------------------------
         scatter2drc_cmd_ready    => sig_scatter2drc_cmd_ready  ,  
         drc2scatter_push_cmd     => sig_drc2scatter_push_cmd   ,  
         drc2scatter_btt          => sig_drc2scatter_btt        ,  
         drc2scatter_eof          => sig_drc2scatter_eof        ,  

        -- DRE Source Alignment -----------------------------------
         scatter2drc_src_align    => sig_scatter2dre_src_align ,  

        -- AXI Slave Stream In -----------------------------------
         s2mm_strm_tready         => sig_scatter2strm_tready   ,  
         s2mm_strm_tvalid         => sig_strm2scatter_tvalid   ,  
         s2mm_strm_tdata          => sig_strm2scatter_tdata    ,  
         s2mm_strm_tstrb          => sig_strm2scatter_tstrb    ,  
         s2mm_strm_tlast          => sig_strm2scatter_tlast    ,  

        -- Stream Out to S2MM DRE ---------------------------------
         drc2scatter_tready       => sig_dre2scatter_tready    ,  
         scatter2drc_tvalid       => sig_scatter2dre_tvalid    ,  
         scatter2drc_tdata        => sig_scatter2dre_tdata     ,  
         scatter2drc_tstrb        => sig_scatter2dre_tstrb     ,  
         scatter2drc_tlast        => sig_scatter2dre_tlast     ,  
         scatter2drc_flush        => sig_scatter2dre_flush     ,  
         scatter2drc_eop          => sig_scatter2drc_eop       ,  

         -- Premature TLAST assertion error flag
         scatter2drc_tlast_error  => sig_scatter2all_tlast_error  

         );




      end generate GEN_INCLUDE_SCATTER;









    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_SCATTER
    --
    -- If Generate Description:
    --   This IfGen omits the Scatter pre-processor.
    --
    --
    ------------------------------------------------------------
    GEN_OMIT_SCATTER : if (C_SUPPORT_SCATTER = 0) generate


       begin

        -- Just housekeep the signaling
        
        sig_scatter2drc_cmd_ready   <= '1'                     ;
        sig_scatter2drc_eop         <= sig_strm2scatter_tlast  ;    
        sig_scatter2dre_src_align   <= sig_dre_src_align       ;
        sig_scatter2all_tlast_error <= '0'                     ;
        sig_scatter2dre_flush       <= sig_dre_flush           ;
        sig_scatter2dre_tstrb       <= sig_strm2scatter_tstrb  ;
        sig_scatter2dre_tdata       <= sig_strm2scatter_tdata  ;
        sig_scatter2dre_tlast       <= sig_strm2scatter_tlast  ;
        sig_scatter2dre_tvalid      <= sig_strm2scatter_tvalid ;
        sig_scatter2strm_tready     <= sig_dre2scatter_tready  ;

        
        
       end generate GEN_OMIT_SCATTER;




    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_OMIT_INDET_BTT
    --
    -- If Generate Description:
    --    Omit and special logic for Indeterminate BTT support.
    --
    --
    ------------------------------------------------------------
    GEN_OMIT_INDET_BTT : if (C_ENABLE_INDET_BTT = 0) generate
    
    
       begin
  
         sig_need_cmd_flush        <= '0'                 ; -- not needed without Indeterminate BTT
  
    
       end generate GEN_OMIT_INDET_BTT;





    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ENABLE_INDET_BTT
    --
    -- If Generate Description:
    --   Include logic for the case when Indeterminate BTT is
    -- included as part of the S2MM. In this mode, the actual 
    -- length of input stream packets is not known when the S2MM
    -- is loaded with a transfer command. 
    --
    ------------------------------------------------------------
    GEN_ENABLE_INDET_BTT : if (C_ENABLE_INDET_BTT = 1) generate
    
  
       signal lsig_clr_cmd_flush        : std_logic := '0';
       signal lsig_set_cmd_flush        : std_logic := '0';
       signal lsig_cmd_set_fetch_pause  : std_logic := '0';
       signal lsig_cmd_clr_fetch_pause  : std_logic := '0';
       signal lsig_cmd_fetch_pause      : std_logic := '0';
       
       
       begin
  
  
         
          lsig_cmd_set_fetch_pause <= sig_drc2scatter_push_cmd    and
                                      not(sig_curr_cmd_cmplt_reg) and
                                      not(sig_need_cmd_flush);
         
          lsig_cmd_clr_fetch_pause <= sig_scatter2dre_tvalid and
                                      sig_dre2scatter_tready and
                                      sig_scatter2dre_tlast;
         
         
          -------------------------------------------------------------
          -- Synchronous Process with Sync Reset
          --
          -- Label: IMP_CMD_FETCH_PAUSE
          --
          -- Process Description:
          --   Implements the flop for the flag that causes the command
          -- queue manager to pause fetching the next command if the 
          -- current command does not have the command complete bit set.
          -- The pause remains set until the associated TLAST for the 
          -- command is output from the Scatter Engine. If the Tlast is
          -- also accompanied by a EOP and the pause is set, then the 
          -- ensuing command (which will have the cmd cmplt bit set) must
          -- be flushed from the queue and not loaded into the Scatter
          -- Engine or DRE, This is normally associated with indeterminate
          -- packets that are actually shorter than the intial align to 
          -- max burst child command sent to the Realigner, The next loaded
          -- child command is to finish the remainder of the indeterminate 
          -- packet up to the full BTT value in the original parent command.
          -- This child command becomes stranded in the Realigner command fifo
          -- and has to be flushed.
          --
          -------------------------------------------------------------
          IMP_CMD_FETCH_PAUSE : process (primary_aclk)
            begin
              if (primary_aclk'event and primary_aclk = '1') then
                 if (mmap_reset               = '1' or
                     lsig_cmd_clr_fetch_pause = '1') then
          
                   lsig_cmd_fetch_pause <= '0';
          
                 elsif (lsig_cmd_set_fetch_pause = '1') then
          
                   lsig_cmd_fetch_pause <= '1';
          
                 else
          
                   null; -- Hold current state
          
                 end if; 
              end if;       
            end process IMP_CMD_FETCH_PAUSE; 
         
         
         
         
         
         
         
         
         -- Clear the flush needed flag when the command with the command
         -- complete marker is popped off of the command queue.
         lsig_clr_cmd_flush  <= sig_need_cmd_flush and 
                                sig_sm_pop_cmd_fifo;
         
         
         -- The command queue has to be flushed if the stream EOP marker
         -- is transfered out of the Scatter Engine when the corresponding
         -- command being executed does not have the command complete
         -- marker set.
         lsig_set_cmd_flush  <= lsig_cmd_fetch_pause    and
                                sig_scatter2dre_tvalid  and
                                sig_dre2scatter_tready  and
                                sig_scatter2drc_eop;
         
  
         -------------------------------------------------------------
         -- Synchronous Process with Sync Reset
         --
         -- Label: IMP_CMD_FLUSH_FLOP
         --
         -- Process Description:
         --   Implements the flop for holding the command flush flag.
         -- This is only needed in Indeterminate BTT mode.
         --
         -------------------------------------------------------------
         IMP_CMD_FLUSH_FLOP : process (primary_aclk)
           begin
             if (primary_aclk'event and primary_aclk = '1') then
                if (mmap_reset         = '1' or
                    lsig_clr_cmd_flush = '1') then
         
                  sig_need_cmd_flush <= '0';
         
                elsif (lsig_set_cmd_flush = '1') then
         
                  sig_need_cmd_flush <= '1';
         
                else
         
                  null;  -- Hold current state
         
                end if; 
             end if;       
           end process IMP_CMD_FLUSH_FLOP; 
  
  
    
       end generate GEN_ENABLE_INDET_BTT;





  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_s2mm_basic_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_s2mm_basic_wrap.vhd
  --
  -- Description:     
  --    This file implements the DataMover S2MM Basic Wrapper.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -- axi_datamover Library Modules
  library axi_datamover_v5_1_17; 
  use axi_datamover_v5_1_17.axi_datamover_reset;  
  use axi_datamover_v5_1_17.axi_datamover_cmd_status;
  use axi_datamover_v5_1_17.axi_datamover_scc;
  use axi_datamover_v5_1_17.axi_datamover_addr_cntl;
  use axi_datamover_v5_1_17.axi_datamover_wrdata_cntl;
  use axi_datamover_v5_1_17.axi_datamover_wr_status_cntl;
  Use axi_datamover_v5_1_17.axi_datamover_skid2mm_buf;
  Use axi_datamover_v5_1_17.axi_datamover_skid_buf;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_s2mm_basic_wrap is
    generic (
      
      C_INCLUDE_S2MM    : Integer range 0 to  2 :=  2;
         -- Specifies the type of S2MM function to include
         -- 0 = Omit S2MM functionality
         -- 1 = Full S2MM Functionality
         -- 2 = Basic S2MM functionality
         
      C_S2MM_AWID  : Integer range 0 to 255 :=  9;
         -- Specifies the constant value to output on 
         -- the ARID output port
         
      C_S2MM_ID_WIDTH    : Integer range 1 to  8 :=  4;
         -- Specifies the width of the S2MM ID port 
         
      C_S2MM_ADDR_WIDTH  : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel 
         -- Address bus
         
      C_S2MM_MDATA_WIDTH : Integer range 32 to 64 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus
      
      C_S2MM_SDATA_WIDTH : Integer range 8 to 64 :=  32;
         -- Specifies the width of the S2MM Master Stream Data 
         -- Channel data bus
      
      C_INCLUDE_S2MM_STSFIFO    : Integer range 0 to  1 :=  1;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit S2MM Status FIFO
         -- 1 = Include S2MM Status FIFO
         
      C_S2MM_STSCMD_FIFO_DEPTH    : Integer range 1 to 16 :=  1;
         -- Specifies the depth of the S2MM Command FIFO and the 
         -- optional Status FIFO
         -- Valid values are 1,4,8,16
         
      C_S2MM_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces
         
      C_INCLUDE_S2MM_DRE    : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the S2MM function 
         -- 0 = Omit DRE
         -- 1 = Include DRE
      
      C_S2MM_BURST_SIZE    : Integer range 2 to  64 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the S2MM function 

      C_S2MM_ADDR_PIPE_DEPTH    : Integer range 1 to 30 := 1;
          -- This parameter specifies the depth of the S2MM internal 
          -- address pipeline queues in the Write Address Controller 
          -- and the Write Data Controller. Increasing this value will 
          -- allow more Write Addresses to be issued to the AXI4 Write 
          -- Address Channel before transmission of the associated  
          -- write data on the Write Data Channel.

      C_ENABLE_CACHE_USER           : Integer range 0 to 1 := 1; 

      C_ENABLE_SKID_BUF                : string := "11111";

      C_MICRO_DMA                   : integer range 0 to 1 := 0;

      C_TAG_WIDTH        : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field
         
      C_FAMILY : String := "virtex7"
         -- Specifies the target FPGA family type
      
      );
    port (
      
      
      -- S2MM Primary Clock and reset inputs -----------------------------
      s2mm_aclk         : in  std_logic;                                --
         -- Primary synchronization clock for the Master side           --
         -- interface and internal logic. It is also used               --
         -- for the User interface synchronization when                 --
         -- C_STSCMD_IS_ASYNC = 0.                                      --
                                                                        --
      -- S2MM Primary Reset input                                       --
      s2mm_aresetn      : in  std_logic;                                --
         -- Reset used for the internal master logic                    --
      --------------------------------------------------------------------
     
      -- S2MM Halt request input control ---------------------------------
      s2mm_halt               : in  std_logic;                          --
         -- Active high soft shutdown request                           --
                                                                        --
      -- S2MM Halt Complete status flag                                 --
      s2mm_halt_cmplt         : Out  std_logic;                         --
         -- Active high soft shutdown complete status                   --
      --------------------------------------------------------------------
      
      
      
      -- S2MM Error discrete output --------------------------------------
      s2mm_err          : Out std_logic;                                --
         -- Composite Error indication                                  --
      --------------------------------------------------------------------
      
     
     
     
      -- Optional Command/Status Interface Clock and Reset Inputs  -------
      -- Only used when C_S2MM_STSCMD_IS_ASYNC = 1                      --
                                                                        --
      s2mm_cmdsts_awclk       : in  std_logic;                          --
      -- Secondary Clock input for async CMD/Status interface           --
                                                                        --
      s2mm_cmdsts_aresetn     : in  std_logic;                          --
        -- Secondary Reset input for async CMD/Status interface         --
      --------------------------------------------------------------------
      
      
      -- User Command Interface Ports (AXI Stream) ------------------------------------------------------
      s2mm_cmd_wvalid         : in  std_logic;                                                         --
      s2mm_cmd_wready         : out std_logic;                                                         --
      s2mm_cmd_wdata          : in  std_logic_vector((C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_S2MM_ADDR_WIDTH+36)-1 downto 0);   --
      ---------------------------------------------------------------------------------------------------
      
      
      -- User Status Interface Ports (AXI Stream) ------------------------
      s2mm_sts_wvalid         : out std_logic;                          --
      s2mm_sts_wready         : in  std_logic;                          --
      s2mm_sts_wdata          : out std_logic_vector(7 downto 0);       --
      s2mm_sts_wstrb          : out std_logic_vector(0 downto 0);       --
      s2mm_sts_wlast          : out std_logic;                          --
      --------------------------------------------------------------------
      
      
      -- Address posting controls ----------------------------------------
      s2mm_allow_addr_req     : in  std_logic;                          --
      s2mm_addr_req_posted    : out std_logic;                          --
      s2mm_wr_xfer_cmplt      : out std_logic;                          --
      s2mm_ld_nxt_len         : out std_logic;                          --
      s2mm_wr_len             : out std_logic_vector(7 downto 0);       --
      --------------------------------------------------------------------
      
     
      
      -- S2MM AXI Address Channel I/O  --------------------------------------
      s2mm_awid     : out std_logic_vector(C_S2MM_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                  --
                                                                           --
      s2mm_awaddr   : out std_logic_vector(C_S2MM_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                             --
                                                                           --
      s2mm_awlen    : out std_logic_vector(7 downto 0);                    --
         -- AXI Address Channel LEN output                                 --
         -- Sized to support 256 data beat bursts                          --
                                                                           --
      s2mm_awsize   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel SIZE output                                --
                                                                           --
      s2mm_awburst  : out std_logic_vector(1 downto 0);                    --
         -- AXI Address Channel BURST output                               --
                                                                           --
      s2mm_awprot   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awcache  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --

      s2mm_awuser  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awvalid  : out std_logic;                                       --
         -- AXI Address Channel VALID output                               --
                                                                           --
      s2mm_awready  : in  std_logic;                                       --
         -- AXI Address Channel READY input                                --
      -----------------------------------------------------------------------
      
        
      -- Currently unsupported AXI Address Channel output signals -----------
        -- s2mm__awlock   : out std_logic_vector(2 downto 0);              --
        -- s2mm__awcache  : out std_logic_vector(4 downto 0);              --
        -- s2mm__awqos    : out std_logic_vector(3 downto 0);              --
        -- s2mm__awregion : out std_logic_vector(3 downto 0);              --
      -----------------------------------------------------------------------
  
  
  
  
      
      -- S2MM AXI MMap Write Data Channel I/O  ---------------------------------------------
      s2mm_wdata              : Out  std_logic_vector(C_S2MM_MDATA_WIDTH-1 downto 0);     --
      s2mm_wstrb              : Out  std_logic_vector((C_S2MM_MDATA_WIDTH/8)-1 downto 0); --
      s2mm_wlast              : Out  std_logic;                                           --
      s2mm_wvalid             : Out  std_logic;                                           --
      s2mm_wready             : In   std_logic;                                           --
      --------------------------------------------------------------------------------------
      
      
      -- S2MM AXI MMap Write response Channel I/O  -----------------------------------------
      s2mm_bresp              : In   std_logic_vector(1 downto 0);                        --
      s2mm_bvalid             : In   std_logic;                                           --
      s2mm_bready             : Out  std_logic;                                           --
      --------------------------------------------------------------------------------------
      
      
      
      -- S2MM AXI Master Stream Channel I/O  -----------------------------------------------
      s2mm_strm_wdata         : In  std_logic_vector(C_S2MM_SDATA_WIDTH-1 downto 0);      --
      s2mm_strm_wstrb         : In  std_logic_vector((C_S2MM_SDATA_WIDTH/8)-1 downto 0);  --
      s2mm_strm_wlast         : In  std_logic;                                            --
      s2mm_strm_wvalid        : In  std_logic;                                            --
      s2mm_strm_wready        : Out std_logic;                                            --
      --------------------------------------------------------------------------------------
      
      -- Testing Support I/O ------------------------------------------
      s2mm_dbg_sel            : in  std_logic_vector( 3 downto 0);   --
      s2mm_dbg_data           : out std_logic_vector(31 downto 0)    --
      -----------------------------------------------------------------
      
      
      );                            
  
  end entity axi_datamover_s2mm_basic_wrap;
  
  
  architecture implementation of axi_datamover_s2mm_basic_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Function Declarations   ----------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_calc_wdemux_sel_bits
    --
    -- Function Description:
    --  This function calculates the number of address bits needed for  
    -- the Write Strobe demux select control. 
    --
    -------------------------------------------------------------------
    function func_calc_wdemux_sel_bits (mmap_dwidth_value : integer) return integer is
    
      Variable num_addr_bits_needed : Integer range 1 to 5 := 1;
    
    begin
    
      case mmap_dwidth_value is
        when 32 =>
          num_addr_bits_needed := 2;
        when 64 =>
          num_addr_bits_needed := 3;
        when 128 =>
          num_addr_bits_needed := 4;
        when others => -- 256 bits
          num_addr_bits_needed := 5;
      end case;
      
      Return (num_addr_bits_needed);
       
    end function func_calc_wdemux_sel_bits;
    

   


    -- Constant Declarations   ----------------------------------------
    
     Constant LOGIC_LOW                 : std_logic := '0';
     Constant LOGIC_HIGH                : std_logic := '1';
     Constant S2MM_AWID_VALUE           : integer range  0 to 255 := C_S2MM_AWID;
     Constant S2MM_AWID_WIDTH           : integer range  1 to   8 := C_S2MM_ID_WIDTH;
     Constant S2MM_ADDR_WIDTH           : integer range 32 to  64 := C_S2MM_ADDR_WIDTH;
     Constant S2MM_MDATA_WIDTH          : integer range 32 to 256 := C_S2MM_MDATA_WIDTH;
     Constant S2MM_SDATA_WIDTH          : integer range  8 to 256 := C_S2MM_SDATA_WIDTH;
     Constant S2MM_CMD_WIDTH            : integer                 := (C_TAG_WIDTH+C_S2MM_ADDR_WIDTH+32);
     Constant S2MM_STS_WIDTH            : integer                 :=  8; -- always 8 for S2MM Basic Version
     Constant INCLUDE_S2MM_STSFIFO      : integer range  0 to   1 :=  1;
     Constant S2MM_STSCMD_FIFO_DEPTH    : integer range  1 to  16 :=  C_S2MM_STSCMD_FIFO_DEPTH;
     Constant S2MM_STSCMD_IS_ASYNC      : integer range  0 to   1 :=  C_S2MM_STSCMD_IS_ASYNC;
     Constant S2MM_BURST_SIZE           : integer range 16 to 256 := 16;
     Constant WR_ADDR_CNTL_FIFO_DEPTH   : integer range  1 to  30 := C_S2MM_ADDR_PIPE_DEPTH;
     Constant WR_DATA_CNTL_FIFO_DEPTH   : integer range  1 to  30 := C_S2MM_ADDR_PIPE_DEPTH;
     
     Constant WR_STATUS_CNTL_FIFO_DEPTH : integer range  1 to  32 := WR_DATA_CNTL_FIFO_DEPTH+2;-- 2 added for going 
                                                                                               -- full thresholding
                                                                                               -- in WSC           
     
     
     Constant SEL_ADDR_WIDTH            : integer := func_calc_wdemux_sel_bits(S2MM_MDATA_WIDTH);
     Constant INCLUDE_S2MM_DRE          : integer range  0 to   1 :=  1;
     Constant OMIT_S2MM_DRE             : integer range  0 to   1 :=  0;
     Constant OMIT_INDET_BTT            : integer := 0;
     Constant SF_BYTES_RCVD_WIDTH       : integer := 1;
     Constant ZEROS_8_BIT               : std_logic_vector(7 downto 0) := (others => '0');
     
     
        
    
    -- Signal Declarations  ------------------------------------------
    
     signal sig_cmd_stat_rst_user        : std_logic := '0';
     signal sig_cmd_stat_rst_int         : std_logic := '0';
     signal sig_mmap_rst                 : std_logic := '0';
     signal sig_stream_rst               : std_logic := '0';
     signal sig_s2mm_cmd_wdata           : std_logic_vector(S2MM_CMD_WIDTH-1 downto 0) := (others => '0');
     signal sig_s2mm_cache_data          : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_cmd2mstr_command         : std_logic_vector(S2MM_CMD_WIDTH-1 downto 0) := (others => '0');        
     signal sig_cmd2mstr_cmd_valid       : std_logic := '0';                                             
     signal sig_mst2cmd_cmd_ready        : std_logic := '0';                                             
     signal sig_mstr2addr_addr           : std_logic_vector(S2MM_ADDR_WIDTH-1 downto 0) := (others => '0');             
     signal sig_mstr2addr_len            : std_logic_vector(7 downto 0) := (others => '0');                          
     signal sig_mstr2addr_size           : std_logic_vector(2 downto 0) := (others => '0');                          
     signal sig_mstr2addr_burst          : std_logic_vector(1 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cache          : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_user           : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2addr_calc_error     : std_logic := '0';
     signal sig_mstr2addr_cmd_valid      : std_logic := '0';                                             
     signal sig_addr2mstr_cmd_ready      : std_logic := '0';                                              
     signal sig_mstr2data_saddr_lsb      : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_len            : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_mstr2data_strt_strb      : std_logic_vector((S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');      
     signal sig_mstr2data_last_strb      : std_logic_vector((S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_mstr2data_drr            : std_logic := '0';
     signal sig_mstr2data_eof            : std_logic := '0';
     signal sig_mstr2data_calc_error     : std_logic := '0';
     signal sig_mstr2data_cmd_last       : std_logic := '0';
     signal sig_mstr2data_cmd_valid      : std_logic := '0';                                             
     signal sig_data2mstr_cmd_ready      : std_logic := '0';                                               
     signal sig_addr2data_addr_posted    : std_logic := '0';
     signal sig_data2addr_data_rdy       : std_logic := '0';
     signal sig_data2all_tlast_error     : std_logic := '0';
     signal sig_data2all_dcntlr_halted   : std_logic := '0';
     signal sig_addr2wsc_calc_error      : std_logic := '0';
     signal sig_addr2wsc_cmd_fifo_empty  : std_logic := '0';
     signal sig_data2wsc_rresp           : std_logic_vector(1 downto 0) := (others => '0'); 
     signal sig_data2wsc_cmd_empty       : std_logic := '0';                   
     signal sig_data2wsc_calc_err        : std_logic := '0'; 
     signal sig_data2wsc_cmd_cmplt       : std_logic := '0';
     signal sig_data2wsc_last_err        : std_logic := '0';
     signal sig_calc2dm_calc_err         : std_logic := '0';
     signal sig_wsc2stat_status          : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_stat2wsc_status_ready    : std_logic := '0';   
     signal sig_wsc2stat_status_valid    : std_logic := '0';  
     signal sig_wsc2mstr_halt_pipe       : std_logic := '0';  
     signal sig_data2wsc_tag             : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_tag            : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2addr_tag            : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_addr_lsb       : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_wvalid         : std_logic := '0';
     signal sig_skid2data_wready         : std_logic := '0';
     signal sig_data2skid_wdata          : std_logic_vector(C_S2MM_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_wstrb          : std_logic_vector((C_S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_data2skid_wlast          : std_logic := '0';
     signal sig_skid2axi_wvalid          : std_logic := '0';
     signal sig_axi2skid_wready          : std_logic := '0';
     signal sig_skid2axi_wdata           : std_logic_vector(C_S2MM_MDATA_WIDTH-1 downto 0) := (others => '0');     
     signal sig_skid2axi_wstrb           : std_logic_vector((C_S2MM_MDATA_WIDTH/8)-1 downto 0) := (others => '0'); 
     signal sig_skid2axi_wlast           : std_logic := '0';
     signal sig_data2wsc_sof             : std_logic := '0';
     signal sig_data2wsc_eof             : std_logic := '0';
     signal sig_data2wsc_valid           : std_logic := '0';
     signal sig_wsc2data_ready           : std_logic := '0';
     signal sig_data2wsc_eop             : std_logic := '0';
     signal sig_data2wsc_bytes_rcvd      : std_logic_vector(SF_BYTES_RCVD_WIDTH-1 downto 0) := (others => '0');
     signal sig_dbg_data_mux_out         : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_0               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_1               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_rst2all_stop_request     : std_logic := '0';
     signal sig_data2rst_stop_cmplt      : std_logic := '0';
     signal sig_addr2rst_stop_cmplt      : std_logic := '0';
     signal sig_data2addr_stop_req       : std_logic := '0';
     signal sig_wsc2rst_stop_cmplt       : std_logic := '0';
     signal sig_data2skid_halt           : std_logic := '0';
     signal sig_realign2wdc_eop_error    : std_logic := '0';
     signal skid2wdc_wvalid              : std_logic := '0';
     signal wdc2skid_wready              : std_logic := '0';
     signal skid2wdc_wdata               : std_logic_vector(C_S2MM_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal skid2wdc_wstrb               : std_logic_vector((C_S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal skid2wdc_wlast               : std_logic := '0';
     signal s2mm_awcache_int             : std_logic_vector (3 downto 0);
     signal sig_cache2mstr_command       : std_logic_vector (7 downto 0);
    
    
  begin --(architecture implementation)
  
    
    
    -- Debug Port Assignments
    
    s2mm_dbg_data        <= sig_dbg_data_mux_out;
    
    -- Note that only the s2mm_dbg_sel(0) is used at this time
    sig_dbg_data_mux_out <= sig_dbg_data_1
      When (s2mm_dbg_sel(0) = '1')
      else sig_dbg_data_0 ;
    
    
    sig_dbg_data_0              <=  X"CAFE2222"             ;    -- 32 bit Constant indicating S2MM Basic type
    
    sig_dbg_data_1(0)           <= sig_cmd_stat_rst_user    ;
    sig_dbg_data_1(1)           <= sig_cmd_stat_rst_int     ;
    sig_dbg_data_1(2)           <= sig_mmap_rst             ;
    sig_dbg_data_1(3)           <= sig_stream_rst           ;
    sig_dbg_data_1(4)           <= sig_cmd2mstr_cmd_valid   ;
    sig_dbg_data_1(5)           <= sig_mst2cmd_cmd_ready    ;
    sig_dbg_data_1(6)           <= sig_stat2wsc_status_ready;
    sig_dbg_data_1(7)           <= sig_wsc2stat_status_valid;
    sig_dbg_data_1(11 downto 8) <= sig_data2wsc_tag         ; -- Current TAG of active data transfer
                         
                        
    sig_dbg_data_1(15 downto 12) <= sig_wsc2stat_status(3 downto 0); -- Internal status tag field
    sig_dbg_data_1(16)           <= sig_wsc2stat_status(4)         ; -- Internal error
    sig_dbg_data_1(17)           <= sig_wsc2stat_status(5)         ; -- Decode Error
    sig_dbg_data_1(18)           <= sig_wsc2stat_status(6)         ; -- Slave Error
    --sig_dbg_data_1(19)           <= sig_wsc2stat_status(7)         ; -- OKAY
    sig_dbg_data_1(19)           <= '0'                            ; -- OKAY not used by TB
    sig_dbg_data_1(20)           <= sig_stat2wsc_status_ready      ; -- Status Ready Handshake
    sig_dbg_data_1(21)           <= sig_wsc2stat_status_valid      ; -- Status Valid Handshake
                        
    
    sig_dbg_data_1(29 downto 22) <= sig_mstr2data_len              ; -- WDC Cmd FIFO LEN input
    sig_dbg_data_1(30)           <= sig_mstr2data_cmd_valid        ; -- WDC Cmd FIFO Valid Inpute
    sig_dbg_data_1(31)           <= sig_data2mstr_cmd_ready        ; -- WDC Cmd FIFO Ready Output
    
    
                        
    
    
    -- Write Data Channel I/O
     s2mm_wvalid         <= sig_skid2axi_wvalid; 
     sig_axi2skid_wready <= s2mm_wready        ;
     s2mm_wdata          <= sig_skid2axi_wdata ; 
     s2mm_wstrb          <= sig_skid2axi_wstrb ; 
     s2mm_wlast          <= sig_skid2axi_wlast ; 
     
     
    GEN_CACHE : if (C_ENABLE_CACHE_USER = 0) generate
      begin
     -- Cache signal tie-off
     s2mm_awcache <= "0011";  -- pre Interface-X guidelines for Masters
     s2mm_awuser <= "0000";  -- pre Interface-X guidelines for Masters
     sig_s2mm_cache_data <= (others => '0'); --s2mm_cmd_wdata(103 downto 96);
    end generate GEN_CACHE;
     
                        
    GEN_CACHE2 : if (C_ENABLE_CACHE_USER = 1) generate
      begin
     -- Cache signal tie-off
     s2mm_awcache <= "0011"; --sg_ctl (3 downto 0);  -- SG Cache from register
     s2mm_awuser <= "0000"; --sg_ctl (7 downto 4);  -- SG Cache from register
     sig_s2mm_cache_data <= s2mm_cmd_wdata(79+(C_S2MM_ADDR_WIDTH-32) downto 72+(C_S2MM_ADDR_WIDTH-32));
  --   sig_s2mm_cache_data <= s2mm_cmd_wdata(103 downto 96);
    end generate GEN_CACHE2;
                       
     -- Internal error output discrete
     s2mm_err            <=  sig_calc2dm_calc_err or sig_data2all_tlast_error;
     
     
     -- Rip the used portion of the Command Interface Command Data
     -- and throw away the padding
     sig_s2mm_cmd_wdata <= s2mm_cmd_wdata(S2MM_CMD_WIDTH-1 downto 0);
     
     
     
 
     -- No Realigner in S2MM Basic
     sig_realign2wdc_eop_error <= '0';

     
     
     
     
     
     
     
     
          
          
     ------------------------------------------------------------
     -- Instance: I_RESET 
     --
     -- Description:
     --   Reset Block  
     --
     ------------------------------------------------------------
      I_RESET : entity axi_datamover_v5_1_17.axi_datamover_reset
      generic map (
    
        C_STSCMD_IS_ASYNC    =>  S2MM_STSCMD_IS_ASYNC      
    
        )
      port map (
    
        primary_aclk         =>  s2mm_aclk               , 
        primary_aresetn      =>  s2mm_aresetn            , 
        secondary_awclk      =>  s2mm_cmdsts_awclk       , 
        secondary_aresetn    =>  s2mm_cmdsts_aresetn     , 
        halt_req             =>  s2mm_halt               , 
        halt_cmplt           =>  s2mm_halt_cmplt         , 
        flush_stop_request   =>  sig_rst2all_stop_request, 
        data_cntlr_stopped   =>  sig_data2rst_stop_cmplt , 
        addr_cntlr_stopped   =>  sig_addr2rst_stop_cmplt , 
        aux1_stopped         =>  sig_wsc2rst_stop_cmplt  , 
        aux2_stopped         =>  LOGIC_HIGH              , 
        cmd_stat_rst_user    =>  sig_cmd_stat_rst_user   , 
        cmd_stat_rst_int     =>  sig_cmd_stat_rst_int    , 
        mmap_rst             =>  sig_mmap_rst            , 
        stream_rst           =>  sig_stream_rst            
    
        );
    
    
    
  
  
          
     ------------------------------------------------------------
     -- Instance: I_CMD_STATUS 
     --
     -- Description:
     --   Command and Status Interface Block  
     --
     ------------------------------------------------------------
      I_CMD_STATUS : entity axi_datamover_v5_1_17.axi_datamover_cmd_status
      generic map (
    
        C_ADDR_WIDTH           =>  S2MM_ADDR_WIDTH           ,     
        C_INCLUDE_STSFIFO      =>  INCLUDE_S2MM_STSFIFO      ,     
        C_STSCMD_FIFO_DEPTH    =>  S2MM_STSCMD_FIFO_DEPTH    ,     
        C_STSCMD_IS_ASYNC      =>  S2MM_STSCMD_IS_ASYNC      ,     
        C_CMD_WIDTH            =>  S2MM_CMD_WIDTH            ,     
        C_STS_WIDTH            =>  S2MM_STS_WIDTH            ,     
        C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER       ,
        C_FAMILY               =>  C_FAMILY                        

        )
      port map (
    
        primary_aclk           =>  s2mm_aclk                 ,     
        secondary_awclk        =>  s2mm_cmdsts_awclk         ,     
        user_reset             =>  sig_cmd_stat_rst_user     ,     
        internal_reset         =>  sig_cmd_stat_rst_int      ,     
        cmd_wvalid             =>  s2mm_cmd_wvalid           ,     
        cmd_wready             =>  s2mm_cmd_wready           ,     
        cmd_wdata              =>  sig_s2mm_cmd_wdata        ,     
        cache_data             =>  sig_s2mm_cache_data        ,     
        sts_wvalid             =>  s2mm_sts_wvalid           ,     
        sts_wready             =>  s2mm_sts_wready           ,     
        sts_wdata              =>  s2mm_sts_wdata            ,     
        sts_wstrb              =>  s2mm_sts_wstrb            ,     
        sts_wlast              =>  s2mm_sts_wlast            ,     
        cmd2mstr_command       =>  sig_cmd2mstr_command      ,     
        cache2mstr_command     =>  sig_cache2mstr_command      ,
        mst2cmd_cmd_valid      =>  sig_cmd2mstr_cmd_valid    ,     
        cmd2mstr_cmd_ready     =>  sig_mst2cmd_cmd_ready     ,     
        mstr2stat_status       =>  sig_wsc2stat_status       ,     
        stat2mstr_status_ready =>  sig_stat2wsc_status_ready ,     
        mst2stst_status_valid  =>  sig_wsc2stat_status_valid       
    
        );
    
    
    
  
  
          
     ------------------------------------------------------------
     -- Instance: I_RD_STATUS_CNTLR 
     --
     -- Description:
     -- Write Status Controller Block    
     --
     ------------------------------------------------------------
      I_WR_STATUS_CNTLR : entity axi_datamover_v5_1_17.axi_datamover_wr_status_cntl
      generic map (
    
        C_ENABLE_INDET_BTT     =>  OMIT_INDET_BTT              ,  
        C_SF_BYTES_RCVD_WIDTH  =>  SF_BYTES_RCVD_WIDTH         ,  
        C_STS_FIFO_DEPTH       =>  WR_STATUS_CNTL_FIFO_DEPTH   ,
        C_STS_WIDTH            =>  S2MM_STS_WIDTH              ,  
        C_TAG_WIDTH            =>  C_TAG_WIDTH                 ,  
        C_FAMILY               =>  C_FAMILY                       

        )
      port map (
    
        primary_aclk           =>  s2mm_aclk                   ,  
        mmap_reset             =>  sig_mmap_rst                ,  
        rst2wsc_stop_request   =>  sig_rst2all_stop_request    ,  
        wsc2rst_stop_cmplt     =>  sig_wsc2rst_stop_cmplt      ,  
        addr2wsc_addr_posted   =>  sig_addr2data_addr_posted   ,  
        s2mm_bresp             =>  s2mm_bresp                  ,  
        s2mm_bvalid            =>  s2mm_bvalid                 ,  
        s2mm_bready            =>  s2mm_bready                 ,  
        calc2wsc_calc_error    =>  sig_calc2dm_calc_err        ,  
        addr2wsc_calc_error    =>  sig_addr2wsc_calc_error     ,  
        addr2wsc_fifo_empty    =>  sig_addr2wsc_cmd_fifo_empty ,  
        data2wsc_tag           =>  sig_data2wsc_tag            ,  
        data2wsc_calc_error    =>  sig_data2wsc_calc_err       ,  
        data2wsc_last_error    =>  sig_data2wsc_last_err       ,  
        data2wsc_cmd_cmplt     =>  sig_data2wsc_cmd_cmplt      ,  
        data2wsc_valid         =>  sig_data2wsc_valid          ,  
        wsc2data_ready         =>  sig_wsc2data_ready          ,  
        data2wsc_eop           =>  sig_data2wsc_eop            ,  
        data2wsc_bytes_rcvd    =>  sig_data2wsc_bytes_rcvd     ,  
        wsc2stat_status        =>  sig_wsc2stat_status         ,  
        stat2wsc_status_ready  =>  sig_stat2wsc_status_ready   ,  
        wsc2stat_status_valid  =>  sig_wsc2stat_status_valid   ,  
        wsc2mstr_halt_pipe     =>  sig_wsc2mstr_halt_pipe         
      
        );
    
    
    
  
  
          
    ------------------------------------------------------------
    -- Instance: I_MSTR_SCC 
    --
    -- Description:
    -- Simple Command Calculator Block   
    --
    ------------------------------------------------------------
     I_MSTR_SCC : entity axi_datamover_v5_1_17.axi_datamover_scc
     generic map (
   
       C_SEL_ADDR_WIDTH     =>  SEL_ADDR_WIDTH           ,   
       C_ADDR_WIDTH         =>  S2MM_ADDR_WIDTH          ,   
       C_STREAM_DWIDTH      =>  S2MM_SDATA_WIDTH         ,   
       C_MAX_BURST_LEN      =>  C_S2MM_BURST_SIZE        ,   
       C_CMD_WIDTH          =>  S2MM_CMD_WIDTH           ,   
       C_MICRO_DMA          =>  C_MICRO_DMA              ,
       C_TAG_WIDTH          =>  C_TAG_WIDTH                  
   
       )
     port map (
   
       -- Clock input
       primary_aclk         =>  s2mm_aclk                ,   
       mmap_reset           =>  sig_mmap_rst             ,   
       cmd2mstr_command     =>  sig_cmd2mstr_command     ,   
       cache2mstr_command   =>  sig_cache2mstr_command     ,   
       cmd2mstr_cmd_valid   =>  sig_cmd2mstr_cmd_valid   ,   
       mst2cmd_cmd_ready    =>  sig_mst2cmd_cmd_ready    ,   
       mstr2addr_tag        =>  sig_mstr2addr_tag        ,   
       mstr2addr_addr       =>  sig_mstr2addr_addr       ,   
       mstr2addr_len        =>  sig_mstr2addr_len        ,   
       mstr2addr_size       =>  sig_mstr2addr_size       ,   
       mstr2addr_burst      =>  sig_mstr2addr_burst      ,   
       mstr2addr_cache      =>  sig_mstr2addr_cache      ,   
       mstr2addr_user       =>  sig_mstr2addr_user       ,   
       mstr2addr_calc_error =>  sig_mstr2addr_calc_error ,   
       mstr2addr_cmd_cmplt  =>  sig_mstr2addr_cmd_cmplt  ,   
       mstr2addr_cmd_valid  =>  sig_mstr2addr_cmd_valid  ,   
       addr2mstr_cmd_ready  =>  sig_addr2mstr_cmd_ready  ,   
       mstr2data_tag        =>  sig_mstr2data_tag        ,   
       mstr2data_saddr_lsb  =>  sig_mstr2data_saddr_lsb  ,   
       mstr2data_len        =>  sig_mstr2data_len        ,   
       mstr2data_strt_strb  =>  sig_mstr2data_strt_strb  ,   
       mstr2data_last_strb  =>  sig_mstr2data_last_strb  ,   
       mstr2data_sof        =>  sig_mstr2data_drr        ,   
       mstr2data_eof        =>  sig_mstr2data_eof        ,   
       mstr2data_calc_error =>  sig_mstr2data_calc_error ,   
       mstr2data_cmd_cmplt  =>  sig_mstr2data_cmd_last   ,   
       mstr2data_cmd_valid  =>  sig_mstr2data_cmd_valid  ,   
       data2mstr_cmd_ready  =>  sig_data2mstr_cmd_ready  ,   
       calc_error           =>  sig_calc2dm_calc_err         
       
       );
    
    
    
  
  
          
     ------------------------------------------------------------
     -- Instance: I_ADDR_CNTL 
     --
     -- Description:
     --   Address Controller Block  
     --
     ------------------------------------------------------------
      I_ADDR_CNTL : entity axi_datamover_v5_1_17.axi_datamover_addr_cntl
      generic map (
    
        -- obsoleted   C_ENABlE_WAIT_FOR_DATA       =>  ENABLE_WAIT_FOR_DATA        ,     
        C_ADDR_FIFO_DEPTH            =>  WR_ADDR_CNTL_FIFO_DEPTH     ,
        --C_ADDR_FIFO_DEPTH            =>  S2MM_STSCMD_FIFO_DEPTH      ,     
        C_ADDR_WIDTH                 =>  S2MM_ADDR_WIDTH             ,     
        C_ADDR_ID                    =>  S2MM_AWID_VALUE             ,     
        C_ADDR_ID_WIDTH              =>  S2MM_AWID_WIDTH             ,     
        C_TAG_WIDTH                  =>  C_TAG_WIDTH                 ,
        C_FAMILY               =>  C_FAMILY     
    
        )
      port map (
    
        primary_aclk                 =>  s2mm_aclk                   ,    
        mmap_reset                   =>  sig_mmap_rst                ,    
        addr2axi_aid                 =>  s2mm_awid                   ,    
        addr2axi_aaddr               =>  s2mm_awaddr                 ,    
        addr2axi_alen                =>  s2mm_awlen                  ,    
        addr2axi_asize               =>  s2mm_awsize                 ,    
        addr2axi_aburst              =>  s2mm_awburst                ,    
        addr2axi_aprot               =>  s2mm_awprot                 ,    
        addr2axi_avalid              =>  s2mm_awvalid                ,    
        addr2axi_acache               =>  open            ,
        addr2axi_auser                =>  open                 ,

        axi2addr_aready              =>  s2mm_awready                ,    
        
        mstr2addr_tag                =>  sig_mstr2addr_tag           ,    
        mstr2addr_addr               =>  sig_mstr2addr_addr          ,    
        mstr2addr_len                =>  sig_mstr2addr_len           ,    
        mstr2addr_size               =>  sig_mstr2addr_size          ,    
        mstr2addr_burst              =>  sig_mstr2addr_burst         ,    
        mstr2addr_cache              =>  sig_mstr2addr_cache         ,    
        mstr2addr_user               =>  sig_mstr2addr_user         ,    
        mstr2addr_cmd_cmplt          =>  sig_mstr2addr_cmd_cmplt     ,    
        mstr2addr_calc_error         =>  sig_mstr2addr_calc_error    ,    
        mstr2addr_cmd_valid          =>  sig_mstr2addr_cmd_valid     ,    
        addr2mstr_cmd_ready          =>  sig_addr2mstr_cmd_ready     ,    
        
        addr2rst_stop_cmplt          =>  sig_addr2rst_stop_cmplt     ,    
 
        allow_addr_req               =>  s2mm_allow_addr_req         ,
        addr_req_posted              =>  s2mm_addr_req_posted        ,
        
        addr2data_addr_posted        =>  sig_addr2data_addr_posted   ,    
        data2addr_data_rdy           =>  sig_data2addr_data_rdy      ,    
        data2addr_stop_req           =>  sig_data2addr_stop_req      ,    
        
        addr2stat_calc_error         =>  sig_addr2wsc_calc_error     ,    
        addr2stat_cmd_fifo_empty     =>  sig_addr2wsc_cmd_fifo_empty      
        );
    
    
    




   
  
ENABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(4) = '1' generate
begin 


      ------------------------------------------------------------
      -- Instance: I_S2MM_STRM_SKID_BUF 
      --
      -- Description:
      --   Instance for the S2MM Skid Buffer which provides for
      -- registerd Slave Stream inputs and supports bi-dir
      -- throttling.  
      --
      ------------------------------------------------------------
      I_S2MM_STRM_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
      generic map (
         
        C_WDATA_WIDTH  =>  S2MM_SDATA_WIDTH        
    
        )
      port map (
    
        -- System Ports
        aclk           =>  s2mm_aclk             ,  
        arst           =>  sig_mmap_rst          ,  
     
        -- Shutdown control (assert for 1 clk pulse)
        skid_stop      =>  sig_data2skid_halt    ,  
     
        -- Slave Side (Stream Data Input) 
        s_valid        =>  s2mm_strm_wvalid      ,  
        s_ready        =>  s2mm_strm_wready      ,  
        s_data         =>  s2mm_strm_wdata       ,  
        s_strb         =>  s2mm_strm_wstrb       ,  
        s_last         =>  s2mm_strm_wlast       ,  

        -- Master Side (Stream Data Output 
        m_valid        =>  skid2wdc_wvalid       ,  
        m_ready        =>  wdc2skid_wready       ,  
        m_data         =>  skid2wdc_wdata        ,  
        m_strb         =>  skid2wdc_wstrb        ,  
        m_last         =>  skid2wdc_wlast           
    
        );
    
       
end generate ENABLE_AXIS_SKID;
  
    
DISABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(4) = '0' generate
begin 

   skid2wdc_wvalid <= s2mm_strm_wvalid;
   s2mm_strm_wready <= wdc2skid_wready;
   skid2wdc_wdata <= s2mm_strm_wdata;
   skid2wdc_wstrb <= s2mm_strm_wstrb;
   skid2wdc_wlast <= s2mm_strm_wlast;
   

end generate DISABLE_AXIS_SKID; 

       

      ------------------------------------------------------------
      -- Instance: I_WR_DATA_CNTL 
      --
      -- Description:
      --     Write Data Controller Block
      --
      ------------------------------------------------------------
      I_WR_DATA_CNTL : entity axi_datamover_v5_1_17.axi_datamover_wrdata_cntl
      generic map (
    
        -- obsoleted   C_ENABlE_WAIT_FOR_DATA =>  ENABLE_WAIT_FOR_DATA       , 
        C_REALIGNER_INCLUDED   =>  OMIT_S2MM_DRE              , 
        C_ENABLE_INDET_BTT     =>  OMIT_INDET_BTT             , 
        C_SF_BYTES_RCVD_WIDTH  =>  SF_BYTES_RCVD_WIDTH        , 
        C_SEL_ADDR_WIDTH       =>  SEL_ADDR_WIDTH             , 
        C_DATA_CNTL_FIFO_DEPTH =>  WR_DATA_CNTL_FIFO_DEPTH    , 
        C_MMAP_DWIDTH          =>  S2MM_MDATA_WIDTH           , 
        C_STREAM_DWIDTH        =>  S2MM_SDATA_WIDTH           , 
        C_TAG_WIDTH            =>  C_TAG_WIDTH                , 
        C_FAMILY               =>  C_FAMILY                     
    
        )
      port map (
    
        primary_aclk           =>  s2mm_aclk                  , 
        mmap_reset             =>  sig_mmap_rst               , 
        rst2data_stop_request  =>  sig_rst2all_stop_request   , 
        data2addr_stop_req     =>  sig_data2addr_stop_req     , 
        data2rst_stop_cmplt    =>  sig_data2rst_stop_cmplt    , 
        wr_xfer_cmplt          =>  s2mm_wr_xfer_cmplt         ,
        s2mm_ld_nxt_len        =>  s2mm_ld_nxt_len            ,
        s2mm_wr_len            =>  s2mm_wr_len                ,
        data2skid_saddr_lsb    =>  sig_data2skid_addr_lsb     , 
        data2skid_wdata        =>  sig_data2skid_wdata        , 
        data2skid_wstrb        =>  sig_data2skid_wstrb        , 
        data2skid_wlast        =>  sig_data2skid_wlast        , 
        data2skid_wvalid       =>  sig_data2skid_wvalid       , 
        skid2data_wready       =>  sig_skid2data_wready       , 
        s2mm_strm_wvalid       =>  skid2wdc_wvalid            , 
        s2mm_strm_wready       =>  wdc2skid_wready            , 
        s2mm_strm_wdata        =>  skid2wdc_wdata             ,     
        s2mm_strm_wstrb        =>  skid2wdc_wstrb             ,         
        s2mm_strm_wlast        =>  skid2wdc_wlast             , 
        s2mm_strm_eop          =>  skid2wdc_wlast             , 
        s2mm_stbs_asserted     =>  ZEROS_8_BIT                , 
        realign2wdc_eop_error  =>  sig_realign2wdc_eop_error  , 
        mstr2data_tag          =>  sig_mstr2data_tag          , 
        mstr2data_saddr_lsb    =>  sig_mstr2data_saddr_lsb    , 
        mstr2data_len          =>  sig_mstr2data_len          , 
        mstr2data_strt_strb    =>  sig_mstr2data_strt_strb    , 
        mstr2data_last_strb    =>  sig_mstr2data_last_strb    , 
        mstr2data_drr          =>  sig_mstr2data_drr          , 
        mstr2data_eof          =>  sig_mstr2data_eof          , 
        mstr2data_sequential   =>  LOGIC_LOW                  , 
        mstr2data_calc_error   =>  sig_mstr2data_calc_error   , 
        mstr2data_cmd_cmplt    =>  sig_mstr2data_cmd_last     , 
        mstr2data_cmd_valid    =>  sig_mstr2data_cmd_valid    , 
        data2mstr_cmd_ready    =>  sig_data2mstr_cmd_ready    , 
        addr2data_addr_posted  =>  sig_addr2data_addr_posted  , 
        data2addr_data_rdy     =>  sig_data2addr_data_rdy     , 
        data2all_tlast_error   =>  sig_data2all_tlast_error   , 
        data2all_dcntlr_halted =>  sig_data2all_dcntlr_halted , 
        data2skid_halt         =>  sig_data2skid_halt         , 
        data2wsc_tag           =>  sig_data2wsc_tag           , 
        data2wsc_calc_err      =>  sig_data2wsc_calc_err      , 
        data2wsc_last_err      =>  sig_data2wsc_last_err      , 
        data2wsc_cmd_cmplt     =>  sig_data2wsc_cmd_cmplt     , 
        wsc2data_ready         =>  sig_wsc2data_ready         , 
        data2wsc_valid         =>  sig_data2wsc_valid         , 
        data2wsc_eop           =>  sig_data2wsc_eop           , 
        data2wsc_bytes_rcvd    =>  sig_data2wsc_bytes_rcvd    , 
        wsc2mstr_halt_pipe     =>  sig_wsc2mstr_halt_pipe       
       
        );
   
   
    
  
  
          
      ------------------------------------------------------------
      -- Instance: I_S2MM_MMAP_SKID_BUF 
      --
      -- Description:
      --   Instance for the S2MM Skid Buffer which provides for
      -- registered outputs and supports bi-dir throttling. 
      -- 
      -- This Module also provides Write Data Bus Mirroring and WSTRB
      -- Demuxing to match a narrow Stream to a wider MMap Write 
      -- Channel. By doing this in the skid buffer, the resource 
      -- utilization of the skid buffer can be minimized by only
      -- having to buffer/mux the Stream data width, not the MMap
      -- Data width.   
      --
      ------------------------------------------------------------
       I_S2MM_MMAP_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid2mm_buf
       generic map (
          
         C_MDATA_WIDTH    =>  S2MM_MDATA_WIDTH       ,  
         C_SDATA_WIDTH    =>  S2MM_SDATA_WIDTH       ,  
         C_ADDR_LSB_WIDTH =>  SEL_ADDR_WIDTH            
         
         )
       port map (
     
         -- System Ports
         ACLK             =>   s2mm_aclk             ,  
         ARST             =>   sig_stream_rst        ,  
         
         -- Slave Side (Wr Data Controller Input Side ) 
         S_ADDR_LSB       =>   sig_data2skid_addr_lsb,   
         S_VALID          =>   sig_data2skid_wvalid  ,  
         S_READY          =>   sig_skid2data_wready  ,  
         S_Data           =>   sig_data2skid_wdata   ,  
         S_STRB           =>   sig_data2skid_wstrb   ,  
         S_Last           =>   sig_data2skid_wlast   ,  

         -- Master Side (MMap Write Data Output Side) 
         M_VALID          =>   sig_skid2axi_wvalid   ,  
         M_READY          =>   sig_axi2skid_wready   ,  
         M_Data           =>   sig_skid2axi_wdata    ,  
         M_STRB           =>   sig_skid2axi_wstrb    ,  
         M_Last           =>   sig_skid2axi_wlast       
     
         );
                              
                              
                              
                              
                           
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_s2mm_omit_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_s2mm_omit_wrap.vhd
  --
  -- Description:     
  --    This file implements the DataMover MM2S Omit Wrapper.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_s2mm_omit_wrap is
    generic (
      
      C_INCLUDE_S2MM    : Integer range 0 to  2 :=  0;
         -- Specifies the type of S2MM function to include
         -- 0 = Omit S2MM functionality
         -- 1 = Full S2MM Functionality
         -- 2 = Lite S2MM functionality
         
      C_S2MM_AWID  : Integer range 0 to  255 :=  9;
         -- Specifies the constant value to output on 
         -- the ARID output port
         
      C_S2MM_ID_WIDTH    : Integer range 1 to  8 :=  4;
         -- Specifies the width of the S2MM ID port 
         
      C_S2MM_ADDR_WIDTH  : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel 
         -- Address bus
         
      C_S2MM_MDATA_WIDTH : Integer range 32 to 1024 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus
      
      C_S2MM_SDATA_WIDTH : Integer range 8 to 1024 :=  32;
         -- Specifies the width of the S2MM Master Stream Data 
         -- Channel data bus
      
      C_INCLUDE_S2MM_STSFIFO    : Integer range 0 to  1 :=  0;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit S2MM Status FIFO
         -- 1 = Include S2MM Status FIFO
         
      C_S2MM_STSCMD_FIFO_DEPTH    : Integer range 1 to 16 :=  4;
         -- Specifies the depth of the S2MM Command FIFO and the 
         -- optional Status FIFO
         -- Valid values are 1,4,8,16
         
      C_S2MM_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces
         
      C_INCLUDE_S2MM_DRE        : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the S2MM function 
         -- 0 = Omit DRE
         -- 1 = Include DRE
      
      C_S2MM_BURST_SIZE         : Integer range 2 to  256 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the S2MM function 
      
      C_S2MM_SUPPORT_INDET_BTT  : Integer range 0 to  1 :=  0;
         -- Specifies if Store and Forward is enabled
 
      C_S2MM_ADDR_PIPE_DEPTH    : Integer range 1 to 30 := 1;
          -- This parameter specifies the depth of the S2MM internal 
          -- address pipeline queues in the Write Address Controller 
          -- and the Write Data Controller. Increasing this value will 
          -- allow more Write Addresses to be issued to the AXI4 Write 
          -- Address Channel before transmission of the associated  
          -- write data on the Write Data Channel.

      C_TAG_WIDTH        : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field

      C_ENABLE_CACHE_USER    : Integer range 0 to 1 := 0;
      C_MCDMA                : integer range 0 to 1 := 0;
         
      C_FAMILY : String := "virtex7"
         -- Specifies the target FPGA family type
      
      );
    port (
      
      
      -- S2MM Primary Clock and reset inputs -----------------------
      s2mm_aclk         : in  std_logic;                          --
         -- Primary synchronization clock for the Master side     --
         -- interface and internal logic. It is also used         --
         -- for the User interface synchronization when           --
         -- C_STSCMD_IS_ASYNC = 0.                                --
                                                                  --
      -- S2MM Primary Reset input                                 --
      s2mm_aresetn      : in  std_logic;                          --
         -- Reset used for the internal master logic              --
      --------------------------------------------------------------
      
 
     
      -- S2MM Halt request input control ---------------------------
      s2mm_halt               : in  std_logic;                    --
         -- Active high soft shutdown request                     --
                                                                  --
      -- S2MM Halt Complete status flag                           --
      s2mm_halt_cmplt         : out std_logic;                    --
         -- Active high soft shutdown complete status             --
      --------------------------------------------------------------
      
      
      
      -- S2MM Error discrete output --------------------------------
      s2mm_err          : Out std_logic;                          --
         -- Composite Error indication                            --
      --------------------------------------------------------------
     
     
     
      -- Optional S2MM Command/Status Clock and Reset Inputs -------
      -- Only used if C_S2MM_STSCMD_IS_ASYNC = 1                  --
      s2mm_cmdsts_awclk       : in  std_logic;                    --
      -- Secondary Clock input for async CMD/Status interface     --
                                                                  --
      s2mm_cmdsts_aresetn     : in  std_logic;                    --
        -- Secondary Reset input for async CMD/Status interface   --
      --------------------------------------------------------------
      
      
      -- User Command Interface Ports (AXI Stream) -----------------------------------------------------
      s2mm_cmd_wvalid         : in  std_logic;                                                        --
      s2mm_cmd_wready         : out std_logic;                                                        --
      s2mm_cmd_wdata          : in  std_logic_vector((C_MCDMA*3+C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_S2MM_ADDR_WIDTH+36)-1 downto 0);  --
      --------------------------------------------------------------------------------------------------
      
      
      -- User Status Interface Ports (AXI Stream) --------------------------------------------------------
      s2mm_sts_wvalid         : out std_logic;                                                          --
      s2mm_sts_wready         : in  std_logic;                                                          --
      s2mm_sts_wdata          : out std_logic_vector(((C_S2MM_SUPPORT_INDET_BTT*24+(C_MCDMA*3))+8)-1 downto 0);     --
      s2mm_sts_wstrb          : out std_logic_vector((((C_S2MM_SUPPORT_INDET_BTT*24)+8)/8)-1 downto 0); --
      s2mm_sts_wlast          : out std_logic;                                                          --
      ----------------------------------------------------------------------------------------------------
      
      
      -- Address posting controls -----------------------------------------
      s2mm_allow_addr_req     : in  std_logic;                           --
      s2mm_addr_req_posted    : out std_logic;                           --
      s2mm_wr_xfer_cmplt      : out std_logic;                           --
      s2mm_ld_nxt_len         : out std_logic;                           --
      s2mm_wr_len             : out std_logic_vector(7 downto 0);        --
      ---------------------------------------------------------------------
      
      
     
      
      -- S2MM AXI Address Channel I/O  --------------------------------------
      s2mm_awid     : out std_logic_vector(C_S2MM_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                  --
                                                                           --
      s2mm_awaddr   : out std_logic_vector(C_S2MM_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                             --
                                                                           --
      s2mm_awlen    : out std_logic_vector(7 downto 0);                    --
         -- AXI Address Channel LEN output                                 --
         -- Sized to support 256 data beat bursts                          --
                                                                           --
      s2mm_awsize   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel SIZE output                                --
                                                                           --
      s2mm_awburst  : out std_logic_vector(1 downto 0);                    --
         -- AXI Address Channel BURST output                               --
                                                                           --
      s2mm_awprot   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awcache  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --

      s2mm_awuser  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awvalid  : out std_logic;                                       --
         -- AXI Address Channel VALID output                               --
                                                                           --
      s2mm_awready  : in  std_logic;                                       --
         -- AXI Address Channel READY input                                --
      -----------------------------------------------------------------------
      
      
        
      -- Currently unsupported AXI Address Channel output signals -----------
        -- s2mm__awlock   : out std_logic_vector(2 downto 0);              --
        -- s2mm__awcache  : out std_logic_vector(4 downto 0);              --
        -- s2mm__awqos    : out std_logic_vector(3 downto 0);              --
        -- s2mm__awregion : out std_logic_vector(3 downto 0);              --
      -----------------------------------------------------------------------
  
  
  
  
      
      -- S2MM AXI MMap Write Data Channel I/O  ----------------------------------------------
      s2mm_wdata              : Out  std_logic_vector(C_S2MM_MDATA_WIDTH-1 downto 0);      --
      s2mm_wstrb              : Out  std_logic_vector((C_S2MM_MDATA_WIDTH/8)-1 downto 0);  --
      s2mm_wlast              : Out  std_logic;                                            --
      s2mm_wvalid             : Out  std_logic;                                            --
      s2mm_wready             : In   std_logic;                                            --
      ---------------------------------------------------------------------------------------
      
      
      -- S2MM AXI MMap Write response Channel I/O  ------------------------------------------
      s2mm_bresp              : In   std_logic_vector(1 downto 0);                         --
      s2mm_bvalid             : In   std_logic;                                            --
      s2mm_bready             : Out  std_logic;                                            --
      ---------------------------------------------------------------------------------------
      
      
      -- S2MM AXI Master Stream Channel I/O  ------------------------------------------------
      s2mm_strm_wdata         : In  std_logic_vector(C_S2MM_SDATA_WIDTH-1 downto 0);       --
      s2mm_strm_wstrb         : In  std_logic_vector((C_S2MM_SDATA_WIDTH/8)-1 downto 0);   --
      s2mm_strm_wlast         : In  std_logic;                                             --
      s2mm_strm_wvalid        : In  std_logic;                                             --
      s2mm_strm_wready        : Out std_logic;                                             --
      ---------------------------------------------------------------------------------------
      
      -- Testing Support I/O -----------------------------------------
      s2mm_dbg_sel            : in  std_logic_vector( 3 downto 0);  --
      s2mm_dbg_data           : out std_logic_vector(31 downto 0)   --
      ----------------------------------------------------------------
      
      
      );
  
  end entity axi_datamover_s2mm_omit_wrap;
  
  
  architecture implementation of axi_datamover_s2mm_omit_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    
    
    
    
    
  begin --(architecture implementation)
  
    
 
 
 
    -- Just tie off output ports
    
      s2mm_dbg_data        <=  X"CAFE0000"    ; -- 32 bit Constant indicating S2MM OMIT type
 
      s2mm_addr_req_posted <=  '0'            ;  
      s2mm_wr_xfer_cmplt   <=  '0'            ;  
      s2mm_ld_nxt_len      <=  '0'            ;
      s2mm_wr_len          <=  (others => '0');
      s2mm_halt_cmplt      <=  s2mm_halt      ;    
      s2mm_err             <=  '0'            ;    
      s2mm_cmd_wready      <=  '0'            ;    
      s2mm_sts_wvalid      <=  '0'            ;    
      s2mm_sts_wdata       <=  (others => '0');    
      s2mm_sts_wstrb       <=  (others => '0');    
      s2mm_sts_wlast       <=  '0'            ;    
      s2mm_awid            <=  (others => '0');    
      s2mm_awaddr          <=  (others => '0');    
      s2mm_awlen           <=  (others => '0');    
      s2mm_awsize          <=  (others => '0');    
      s2mm_awburst         <=  (others => '0');    
      s2mm_awprot          <=  (others => '0');    
      s2mm_awcache         <=  (others => '0');    
      s2mm_awuser          <=  (others => '0');    
      s2mm_awvalid         <=  '0'            ;    
      s2mm_wdata           <=  (others => '0');    
      s2mm_wstrb           <=  (others => '0');    
      s2mm_wlast           <=  '0'            ;    
      s2mm_wvalid          <=  '0'            ;    
      s2mm_bready          <=  '0'            ;    
      s2mm_strm_wready     <=  '0'            ;    
      
      
    -- Input ports are ignored 
     
    
    
    
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_s2mm_full_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_s2mm_full_wrap.vhd
  --
  -- Description:
  --    This file implements the DataMover S2MM FULL Wrapper.
  --
  --
  --
  --
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all   ;

  -- axi_datamover Library Modules
  library axi_datamover_v5_1_17;
  use axi_datamover_v5_1_17.axi_datamover_reset         ;
  use axi_datamover_v5_1_17.axi_datamover_cmd_status    ;
  use axi_datamover_v5_1_17.axi_datamover_pcc           ;
  use axi_datamover_v5_1_17.axi_datamover_ibttcc        ;
  use axi_datamover_v5_1_17.axi_datamover_indet_btt     ;
  use axi_datamover_v5_1_17.axi_datamover_s2mm_realign  ;
  use axi_datamover_v5_1_17.axi_datamover_addr_cntl     ;
  use axi_datamover_v5_1_17.axi_datamover_wrdata_cntl   ;
  use axi_datamover_v5_1_17.axi_datamover_wr_status_cntl;
  Use axi_datamover_v5_1_17.axi_datamover_skid2mm_buf   ;
  Use axi_datamover_v5_1_17.axi_datamover_skid_buf      ;
  Use axi_datamover_v5_1_17.axi_datamover_wr_sf         ;


  -------------------------------------------------------------------------------

  entity axi_datamover_s2mm_full_wrap is
    generic (

      C_INCLUDE_S2MM            : Integer range 0 to  2 :=  1;
         -- Specifies the type of S2MM function to include
         -- 0 = Omit S2MM functionality
         -- 1 = Full S2MM Functionality
         -- 2 = Lite S2MM functionality

      C_S2MM_AWID               : Integer range 0 to 255 :=  9;
         -- Specifies the constant value to output on
         -- the ARID output port

      C_S2MM_ID_WIDTH           : Integer range 1 to  8 :=  4;
         -- Specifies the width of the S2MM ID port

      C_S2MM_ADDR_WIDTH         : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel
         -- Address bus

      C_S2MM_MDATA_WIDTH        : Integer range 32 to 1024 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus

      C_S2MM_SDATA_WIDTH        : Integer range 8 to 1024 :=  32;
         -- Specifies the width of the S2MM Master Stream Data
         -- Channel data bus

      C_INCLUDE_S2MM_STSFIFO    : Integer range 0 to  1 :=  1;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit S2MM Status FIFO
         -- 1 = Include S2MM Status FIFO

      C_S2MM_STSCMD_FIFO_DEPTH  : Integer range 1 to 16 :=  4;
         -- Specifies the depth of the S2MM Command FIFO and the
         -- optional Status FIFO
         -- Valid values are 1,4,8,16

      C_S2MM_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces

      C_INCLUDE_S2MM_DRE        : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the S2MM function
         -- 0 = Omit DRE
         -- 1 = Include DRE

      C_S2MM_BURST_SIZE         : Integer range 2 to  256 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the S2MM function

      C_S2MM_BTT_USED           : Integer range 8 to  26 :=  16;
        -- Specifies the number of bits used from the BTT field
        -- of the input Command Word of the S2MM Command Interface

      C_S2MM_SUPPORT_INDET_BTT  : Integer range 0 to  1 :=  0;
         -- Specifies if support for indeterminate packet lengths
         -- are to be received on the input Stream interface
         -- 0 = Omit support (User MUST transfer the exact number of
         --     bytes on the Stream interface as specified in the BTT
         --     field of the Corresponding DataMover Command)
         -- 1 = Include support for indeterminate packet lengths
         --     This causes FIFOs to be added and "Store and Forward"
         --     behavior of the S2MM function

      C_S2MM_ADDR_PIPE_DEPTH    : Integer range 1 to 30 := 3;
          -- This parameter specifies the depth of the S2MM internal 
          -- address pipeline queues in the Write Address Controller 
          -- and the Write Data Controller. Increasing this value will 
          -- allow more Write Addresses to be issued to the AXI4 Write 
          -- Address Channel before transmission of the associated  
          -- write data on the Write Data Channel.

      C_TAG_WIDTH               : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field

      C_INCLUDE_S2MM_GP_SF      : Integer range 0 to 1 := 1 ;
        -- This parameter specifies the inclusion/omission of the
        -- S2MM (Write) General Purpose Store and Forward function
        -- 0 = Omit GP Store and Forward
        -- 1 = Include GP Store and Forward
      
      C_ENABLE_CACHE_USER           : Integer range 0 to 1 := 1; 

    C_ENABLE_S2MM_TKEEP             : integer range 0 to 1 := 1; 

      C_ENABLE_SKID_BUF         : string := "11111";

      C_FAMILY                  : String := "virtex7";
      C_MCDMA                   : integer range 0 to 1 := 0
         -- Specifies the target FPGA family type

      );
    port (


      -- S2MM Primary Clock and Reset inputs ----------------------------
      s2mm_aclk         : in  std_logic;                               --
         -- Primary synchronization clock for the Master side          --
         -- interface and internal logic. It is also used              --
         -- for the User interface synchronization when                --
         -- C_STSCMD_IS_ASYNC = 0.                                     --
      -------------------------------------------------------------------
      

      -- S2MM Primary Reset input ---------------------------------------
      s2mm_aresetn      : in  std_logic;                               --
         -- Reset used for the internal master logic                   --
      -------------------------------------------------------------------



      -- S2MM Halt request input control --------------------------------
      s2mm_halt               : in  std_logic;                         --
         -- Active high soft shutdown request                          --
                                                                       --
      -- S2MM Halt Complete status flag                                --
      s2mm_halt_cmplt         : Out  std_logic;                        --
         -- Active high soft shutdown complete status                  --
      -------------------------------------------------------------------



      -- S2MM Error discrete output -------------------------------------
      s2mm_err          : Out std_logic;                               --
         -- Composite Error indication                                 --
      -------------------------------------------------------------------



      -- Optional Command and Status Clock and Reset -------------------
      -- Only used when C_S2MM_STSCMD_IS_ASYNC = 1                    --
                                                                      --
      s2mm_cmdsts_awclk       : in  std_logic;                        --
      -- Secondary Clock input for async CMD/Status interface         --
                                                                      --
      s2mm_cmdsts_aresetn     : in  std_logic;                        --
        -- Secondary Reset input for async CMD/Status interface       --
      ------------------------------------------------------------------
      

      -- User Command Interface Ports (AXI Stream) -----------------------------------------------------
      s2mm_cmd_wvalid         : in  std_logic;                                                        --
      s2mm_cmd_wready         : out std_logic;                                                        --
      s2mm_cmd_wdata          : in  std_logic_vector((C_MCDMA*3+C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_S2MM_ADDR_WIDTH+36)-1 downto 0);  --
      --------------------------------------------------------------------------------------------------

      -- User Status Interface Ports (AXI Stream) --------------------------------------------------------
      s2mm_sts_wvalid         : out std_logic;                                                          --
      s2mm_sts_wready         : in  std_logic;                                                          --
      s2mm_sts_wdata          : out std_logic_vector(((C_S2MM_SUPPORT_INDET_BTT*(24+C_MCDMA*3))+8)-1 downto 0);     --
      s2mm_sts_wstrb          : out std_logic_vector((((C_S2MM_SUPPORT_INDET_BTT*24)+8)/8)-1 downto 0); --
      s2mm_sts_wlast          : out std_logic;                                                          --
      ----------------------------------------------------------------------------------------------------
      
      
      -- Address posting controls ---------------------------------------
      s2mm_allow_addr_req     : in  std_logic;                         --
      s2mm_addr_req_posted    : out std_logic;                         --
      s2mm_wr_xfer_cmplt      : out std_logic;                         --
      s2mm_ld_nxt_len         : out std_logic;                         --
      s2mm_wr_len             : out std_logic_vector(7 downto 0);      --
      -------------------------------------------------------------------
     
      
      -- S2MM AXI Address Channel I/O  --------------------------------------
      s2mm_awid     : out std_logic_vector(C_S2MM_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                  --
                                                                           --
      s2mm_awaddr   : out std_logic_vector(C_S2MM_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                             --
                                                                           --
      s2mm_awlen    : out std_logic_vector(7 downto 0);                    --
         -- AXI Address Channel LEN output                                 --
         -- Sized to support 256 data beat bursts                          --
                                                                           --
      s2mm_awsize   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel SIZE output                                --
                                                                           --
      s2mm_awburst  : out std_logic_vector(1 downto 0);                    --
         -- AXI Address Channel BURST output                               --
                                                                           --
      s2mm_awprot   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awcache  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --

      s2mm_awuser  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      s2mm_awvalid  : out std_logic;                                       --
         -- AXI Address Channel VALID output                               --
                                                                           --
      s2mm_awready  : in  std_logic;                                       --
         -- AXI Address Channel READY input                                --
      -----------------------------------------------------------------------
      

      -- Currently unsupported AXI Address Channel output signals -----------
        -- s2mm__awlock   : out std_logic_vector(2 downto 0);              --
        -- s2mm__awcache  : out std_logic_vector(4 downto 0);              --
        -- s2mm__awqos    : out std_logic_vector(3 downto 0);              --
        -- s2mm__awregion : out std_logic_vector(3 downto 0);              --
      -----------------------------------------------------------------------





      -- S2MM AXI MMap Write Data Channel I/O  ---------------------------------------------
      s2mm_wdata              : Out  std_logic_vector(C_S2MM_MDATA_WIDTH-1 downto 0);     --
      s2mm_wstrb              : Out  std_logic_vector((C_S2MM_MDATA_WIDTH/8)-1 downto 0); --
      s2mm_wlast              : Out  std_logic;                                           --
      s2mm_wvalid             : Out  std_logic;                                           --
      s2mm_wready             : In   std_logic;                                           --
      --------------------------------------------------------------------------------------
      

      -- S2MM AXI MMap Write response Channel I/O  ----------------------------------------- 
      s2mm_bresp              : In   std_logic_vector(1 downto 0);                        --
      s2mm_bvalid             : In   std_logic;                                           --
      s2mm_bready             : Out  std_logic;                                           --
      --------------------------------------------------------------------------------------


      -- S2MM AXI Master Stream Channel I/O  -----------------------------------------------
      s2mm_strm_wdata         : In  std_logic_vector(C_S2MM_SDATA_WIDTH-1 downto 0);      --
      s2mm_strm_wstrb         : In  std_logic_vector((C_S2MM_SDATA_WIDTH/8)-1 downto 0);  --
      s2mm_strm_wlast         : In  std_logic;                                            --
      s2mm_strm_wvalid        : In  std_logic;                                            --
      s2mm_strm_wready        : Out std_logic;                                            --
      --------------------------------------------------------------------------------------

      -- Testing Support I/O ------------------------------------------
      s2mm_dbg_sel            : in  std_logic_vector( 3 downto 0);   --
      s2mm_dbg_data           : out std_logic_vector(31 downto 0)    --
      -----------------------------------------------------------------


      );

  end entity axi_datamover_s2mm_full_wrap;


  architecture implementation of axi_datamover_s2mm_full_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";




    -- Function Declarations   ----------------------------------------

    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_calc_wdemux_sel_bits
    --
    -- Function Description:
    --  This function calculates the number of address bits needed for
    -- the Write Strobe demux select control.
    --
    -------------------------------------------------------------------
    function func_calc_wdemux_sel_bits (mmap_dwidth_value : integer) return integer is

      Variable num_addr_bits_needed : Integer range 1 to 7 := 1;

    begin

      case mmap_dwidth_value is
        when 32 =>
          num_addr_bits_needed := 2;
        when 64 =>
          num_addr_bits_needed := 3;
        when 128 =>
          num_addr_bits_needed := 4;
        when 256 =>
          num_addr_bits_needed := 5;
        when 512 =>
          num_addr_bits_needed := 6;
        when others => -- 1024 bits
          num_addr_bits_needed := 7;
      end case;

      Return (num_addr_bits_needed);

    end function func_calc_wdemux_sel_bits;






    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_include_dre
    --
    -- Function Description:
    -- This function desides if conditions are right for allowing DRE
    -- inclusion.
    --
    -------------------------------------------------------------------
    function func_include_dre (need_dre          : integer;
                               needed_data_width : integer) return integer is

      Variable include_dre : Integer := 0;

    begin

      if (need_dre = 1 and
          needed_data_width < 1024 and
          needed_data_width >   8) Then

         include_dre := 1;

      Else

        include_dre := 0;

      End if;

      Return (include_dre);

    end function func_include_dre;





    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_get_align_width
    --
    -- Function Description:
    -- This function calculates the needed DRE alignment port width\
    -- based upon the inclusion of DRE and the needed bit width of the
    -- DRE.
    --
    -------------------------------------------------------------------
    function func_get_align_width (dre_included   : integer;
                                   dre_data_width : integer) return integer is

       Variable align_port_width : Integer := 1;

    begin

      if (dre_included = 1) then


        If (dre_data_width = 512) Then

          align_port_width := 6;

        elsIf (dre_data_width = 256) Then

          align_port_width := 5;

        elsIf (dre_data_width = 128) Then

          align_port_width := 4;

        elsIf (dre_data_width = 64) Then

          align_port_width := 3;

        Elsif (dre_data_width = 32) Then

          align_port_width := 2;

        else  -- 16 bit data width

          align_port_width := 1;

        End if;

      else

        align_port_width := 1;

      end if;

      Return (align_port_width);

    end function func_get_align_width;





    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_set_status_width
    --
    -- Function Description:
    -- This function sets the width of the Status pipe depending on the
    -- Store and Forward inclusion or ommision.
    --
    -------------------------------------------------------------------
    function funct_set_status_width (mcdma : integer;
                                     store_forward_enabled : integer)
             return integer is


      Variable temp_status_bit_width : Integer := 8;


    begin


      If (store_forward_enabled = 1 and mcdma = 1) Then

        temp_status_bit_width := 35;
      elsIf (store_forward_enabled = 1 and mcdma = 0) Then

        temp_status_bit_width := 32;

      Else

        temp_status_bit_width := 8;

      End if;


      Return (temp_status_bit_width);


    end function funct_set_status_width;




    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: get_bits_needed
    --
    -- Function Description:
    --
    --
    -------------------------------------------------------------------
    function get_bits_needed (max_bytes : integer) return integer is
    
      Variable fvar_temp_bit_width : Integer := 1;
    
    begin
    
      
      if (max_bytes <= 1) then
      
         fvar_temp_bit_width := 1;
      
      elsif (max_bytes <= 3) then
      
         fvar_temp_bit_width := 2;
      
      elsif (max_bytes <= 7) then
      
         fvar_temp_bit_width := 3;
      
      elsif (max_bytes <= 15) then
      
         fvar_temp_bit_width := 4;
      
      elsif (max_bytes <= 31) then
      
         fvar_temp_bit_width := 5;
      
      elsif (max_bytes <= 63) then
      
         fvar_temp_bit_width := 6;
      
      elsif (max_bytes <= 127) then
      
         fvar_temp_bit_width := 7;
      
      elsif (max_bytes <= 255) then
      
         fvar_temp_bit_width := 8;
      
      elsif (max_bytes <= 511) then
      
         fvar_temp_bit_width := 9;
      
      elsif (max_bytes <= 1023) then
      
         fvar_temp_bit_width := 10;
      
      elsif (max_bytes <= 2047) then
      
         fvar_temp_bit_width := 11;
      
      elsif (max_bytes <= 4095) then
      
         fvar_temp_bit_width := 12;
      
      elsif (max_bytes <= 8191) then
      
         fvar_temp_bit_width := 13;
      
      else  -- 8k - 16K
      
         fvar_temp_bit_width := 14;
      
      end if;
       
       
      Return (fvar_temp_bit_width);
       
       
    end function get_bits_needed;
    

   

    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_rnd2pwr_of_2
    --
    -- Function Description:
    --  Rounds the input value up to the nearest power of 2 between
    --  128 and 8192.
    --
    -------------------------------------------------------------------
    function funct_rnd2pwr_of_2 (input_value : integer) return integer is

      Variable temp_pwr2 : Integer := 128;

    begin

      if (input_value <= 128) then

         temp_pwr2 := 128;

      elsif (input_value <= 256) then

         temp_pwr2 := 256;

      elsif (input_value <= 512) then

         temp_pwr2 := 512;

      elsif (input_value <= 1024) then

         temp_pwr2 := 1024;

      elsif (input_value <= 2048) then

         temp_pwr2 := 2048;

      elsif (input_value <= 4096) then

         temp_pwr2 := 4096;

      else

         temp_pwr2 := 8192;

      end if;


      Return (temp_pwr2);

    end function funct_rnd2pwr_of_2;
    -------------------------------------------------------------------
   
     
     
     
     

    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_need_realigner
    --
    -- Function Description:
    --  Determines if the Realigner module needs to be included.
    --
    -------------------------------------------------------------------
    function funct_need_realigner (indet_btt_enabled : integer;
                                   dre_included      : integer;
                                   gp_sf_included    : integer) return integer is
    
      Variable temp_val : Integer := 0;
    
    begin
    
      If ((indet_btt_enabled = 1) or
          (dre_included      = 1) or
          (gp_sf_included    = 1)) Then
    
         temp_val := 1;
      
      else

         temp_val := 0;
      
      End if;
      
    
      Return (temp_val);

    
    end function funct_need_realigner;
    -------------------------------------------------------------------
    
   
   
   
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_sf_offset_width
    --
    -- Function Description:
    --  This function calculates the address offset width needed by
    -- the GP Store and Forward module with data packing.
    --
    -------------------------------------------------------------------
    function funct_get_sf_offset_width (mmap_dwidth   : integer;
                                        stream_dwidth : integer) return integer is
    
      Constant FCONST_WIDTH_RATIO     : integer := mmap_dwidth/stream_dwidth;
      
      Variable fvar_temp_offset_width : Integer := 1;
    
    begin
    
      case FCONST_WIDTH_RATIO is
        when 1 =>
          fvar_temp_offset_width := 1;
        when 2 =>
          fvar_temp_offset_width := 1;
        when 4 =>
          fvar_temp_offset_width := 2;
        when 8 =>
          fvar_temp_offset_width := 3;
        when 16 =>
          fvar_temp_offset_width := 4;
        when 32 =>
          fvar_temp_offset_width := 5;
        when 64 =>
          fvar_temp_offset_width := 6;
        when others =>
          fvar_temp_offset_width := 7;
      end case;
      
      Return (fvar_temp_offset_width);
    
    
    end function funct_get_sf_offset_width;
    
   
     
     
     
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_stream_width2use
    --
    -- Function Description:
    --  This function calculates the Stream width to use for S2MM 
    -- modules downstream from the upsizing Store and Forward. If 
    -- Store and forward is present, then the effective Stream width 
    -- is the MMAP data width. If no Store and Forward then the Stream
    -- width is the input Stream width from the User. 
    --
    -------------------------------------------------------------------
    function funct_get_stream_width2use (mmap_data_width   : integer;
                                         stream_data_width : integer;
                                         sf_enabled        : integer) return integer is
    
      Variable fvar_temp_width : Integer := 32;
    
    begin
    
      If (sf_enabled > 0) Then
    
        fvar_temp_width := mmap_data_width;
      
      Else 

        fvar_temp_width := stream_data_width;
      
      End if;
     
      Return (fvar_temp_width);
     
    end function funct_get_stream_width2use;
    
   
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_bytes_per_dbeat
    --
    -- Function Description:
    --  This function calculates the number of bytes transfered per
    -- databeat on the MMap AXI4 Write Data Channel by the S2MM. The
    -- value is based on input parameterization of included functions
    -- in the S2MM block.
    --
    -------------------------------------------------------------------
    function funct_get_bytes_per_dbeat (ibtt_enabled  : integer ;
                                        gpsf_enabled  : integer ;
                                        stream_dwidth : integer ;
                                        mmap_dwidth   : integer ) return integer is
    
      Variable fvar_temp_bytes_per_xfer : Integer := 4;
    
    begin
    
      If (ibtt_enabled > 0 or
          gpsf_enabled > 0) Then -- transfers will be upsized to mmap data width
    
        fvar_temp_bytes_per_xfer := mmap_dwidth/8;      
      
      Else -- transfers will be in stream data widths (may be narrow transfers on mmap)
      
        fvar_temp_bytes_per_xfer := stream_dwidth/8;      
      
      End if;
    
    
      Return (fvar_temp_bytes_per_xfer);
    
    
    end function funct_get_bytes_per_dbeat;
    
    
    
    
    -- Constant Declarations   ----------------------------------------

     
     Constant SF_ENABLED                : integer := C_INCLUDE_S2MM_GP_SF + C_S2MM_SUPPORT_INDET_BTT;
     Constant SF_UPSIZED_SDATA_WIDTH    : integer := funct_get_stream_width2use(C_S2MM_MDATA_WIDTH,
                                                                                C_S2MM_SDATA_WIDTH,
                                                                                SF_ENABLED);
     
     Constant LOGIC_LOW                 : std_logic := '0';
     Constant LOGIC_HIGH                : std_logic := '1';
     Constant IS_NOT_MM2S               : integer range  0 to    1 := 0;
     Constant S2MM_AWID_VALUE           : integer range  0 to  255 := C_S2MM_AWID;
     Constant S2MM_AWID_WIDTH           : integer range  1 to    8 := C_S2MM_ID_WIDTH;
     Constant S2MM_ADDR_WIDTH           : integer range 32 to   64 := C_S2MM_ADDR_WIDTH;
     Constant S2MM_MDATA_WIDTH          : integer range 32 to 1024 := C_S2MM_MDATA_WIDTH;
     Constant S2MM_SDATA_WIDTH          : integer range  8 to 1024 := C_S2MM_SDATA_WIDTH;
     Constant S2MM_TAG_WIDTH            : integer range  1 to    8 := C_TAG_WIDTH;
     Constant S2MM_CMD_WIDTH            : integer                  := (S2MM_TAG_WIDTH+S2MM_ADDR_WIDTH+32+C_MCDMA*3);
     Constant INCLUDE_S2MM_STSFIFO      : integer range  0 to    1 := C_INCLUDE_S2MM_STSFIFO;
     Constant S2MM_STSCMD_FIFO_DEPTH    : integer range  1 to   16 := C_S2MM_STSCMD_FIFO_DEPTH;
     Constant S2MM_STSCMD_IS_ASYNC      : integer range  0 to    1 := C_S2MM_STSCMD_IS_ASYNC;
     Constant S2MM_BURST_SIZE           : integer range 2 to  256 := C_S2MM_BURST_SIZE;
     Constant ADDR_CNTL_FIFO_DEPTH      : integer range  1 to   30 := C_S2MM_ADDR_PIPE_DEPTH;
     Constant WR_DATA_CNTL_FIFO_DEPTH   : integer range  1 to   30 := C_S2MM_ADDR_PIPE_DEPTH;
     
     
     Constant SEL_ADDR_WIDTH            : integer range  2 to   7 := func_calc_wdemux_sel_bits(S2MM_MDATA_WIDTH);
     Constant S2MM_BTT_USED             : integer range  8 to  26 := C_S2MM_BTT_USED;
     Constant BITS_PER_BYTE             : integer := 8;
     
     Constant INCLUDE_S2MM_DRE          : integer range  0 to   1 := func_include_dre(C_INCLUDE_S2MM_DRE,
                                                                                      S2MM_SDATA_WIDTH);
     
     Constant DRE_CNTL_FIFO_DEPTH       : integer range  1 to  30 := C_S2MM_ADDR_PIPE_DEPTH;
     
     Constant S2MM_DRE_ALIGN_WIDTH      : integer range  1 to   6 := func_get_align_width(INCLUDE_S2MM_DRE,
                                                                                          S2MM_SDATA_WIDTH);
     Constant DRE_SUPPORT_SCATTER       : integer range  0 to   1 := 1;
     
     Constant ENABLE_INDET_BTT_SF       : integer range  0 to   1 := C_S2MM_SUPPORT_INDET_BTT;
     
     Constant ENABLE_GP_SF              : integer range  0 to   1 := C_INCLUDE_S2MM_GP_SF ;
    
     Constant BYTES_PER_MMAP_DBEAT      : integer := funct_get_bytes_per_dbeat(ENABLE_INDET_BTT_SF ,
                                                                               ENABLE_GP_SF        ,
                                                                               S2MM_SDATA_WIDTH    ,
                                                                               S2MM_MDATA_WIDTH);
     
     
     Constant MAX_BYTES_PER_BURST       : integer := BYTES_PER_MMAP_DBEAT*S2MM_BURST_SIZE;
     Constant IBTT_XFER_BYTES_WIDTH     : integer := get_bits_needed(MAX_BYTES_PER_BURST);
     
     
     
     Constant WR_STATUS_CNTL_FIFO_DEPTH : integer range  1 to  32 := WR_DATA_CNTL_FIFO_DEPTH+2; -- 2 added for going 
                                                                                                -- full thresholding
                                                                                                -- in WSC
     Constant WSC_STATUS_WIDTH          : integer range  8 to 35 := 
                                          funct_set_status_width(C_MCDMA, ENABLE_INDET_BTT_SF);
     Constant WSC_BYTES_RCVD_WIDTH      : integer range  8 to 32 :=  S2MM_BTT_USED;
     
     Constant ADD_REALIGNER             : integer := funct_need_realigner(ENABLE_INDET_BTT_SF ,
                                                                          INCLUDE_S2MM_DRE    ,
                                                                          ENABLE_GP_SF);
     
     
     
     
     -- Calculates the minimum needed depth of the GP Store and Forward FIFO
     -- based on the S2MM pipeline depth and the max allowed Burst length
     Constant PIPEDEPTH_BURST_LEN_PROD : integer :=
                    (ADDR_CNTL_FIFO_DEPTH+2) * S2MM_BURST_SIZE;
              
              
     -- Assigns the depth of the optional GP Store and Forward FIFO to the nearest
     -- power of 2
     Constant SF_FIFO_DEPTH        : integer range 128 to 8192 :=
                                     funct_rnd2pwr_of_2(PIPEDEPTH_BURST_LEN_PROD);


     -- Calculate the width of the Store and Forward Starting Address Offset bus
     Constant SF_STRT_OFFSET_WIDTH : integer := funct_get_sf_offset_width(S2MM_MDATA_WIDTH,
                                                                          S2MM_SDATA_WIDTH);
     
     
     
     
     
    
    
    -- Signal Declarations  ------------------------------------------

     signal sig_cmd_stat_rst_user        : std_logic := '0';
     signal sig_cmd_stat_rst_int         : std_logic := '0';
     signal sig_mmap_rst                 : std_logic := '0';
     signal sig_stream_rst               : std_logic := '0';
     signal sig_s2mm_cmd_wdata           : std_logic_vector(S2MM_CMD_WIDTH-1 downto 0) := (others => '0');
     signal sig_s2mm_cache_data           : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_cmd2mstr_command         : std_logic_vector(S2MM_CMD_WIDTH-1 downto 0) := (others => '0');
     signal sig_cmd2mstr_cmd_valid       : std_logic := '0';
     signal sig_mst2cmd_cmd_ready        : std_logic := '0';
     signal sig_mstr2addr_addr           : std_logic_vector(S2MM_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2addr_len            : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_mstr2addr_size           : std_logic_vector(2 downto 0) := (others => '0');
     signal sig_mstr2addr_burst          : std_logic_vector(1 downto 0) := (others => '0');
     signal sig_mstr2addr_cache          : std_logic_vector(3 downto 0) := (others => '0');
     signal sig_mstr2addr_user           : std_logic_vector(3 downto 0) := (others => '0');
     signal sig_mstr2addr_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2addr_calc_error     : std_logic := '0';
     signal sig_mstr2addr_cmd_valid      : std_logic := '0';
     signal sig_addr2mstr_cmd_ready      : std_logic := '0';
     signal sig_mstr2data_saddr_lsb      : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_len            : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_mstr2data_strt_strb      : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_mstr2data_last_strb      : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_mstr2data_drr            : std_logic := '0';
     signal sig_mstr2data_eof            : std_logic := '0';
     signal sig_mstr2data_sequential     : std_logic := '0';
     signal sig_mstr2data_calc_error     : std_logic := '0';
     signal sig_mstr2data_cmd_last       : std_logic := '0';
     signal sig_mstr2data_cmd_valid      : std_logic := '0';
     signal sig_data2mstr_cmd_ready      : std_logic := '0';
     signal sig_addr2data_addr_posted    : std_logic := '0';
     signal sig_data2addr_data_rdy       : std_logic := '0';
     signal sig_data2all_tlast_error     : std_logic := '0';
     signal sig_data2all_dcntlr_halted   : std_logic := '0';
     signal sig_addr2wsc_calc_error      : std_logic := '0';
     signal sig_addr2wsc_cmd_fifo_empty  : std_logic := '0';
     signal sig_data2wsc_rresp           : std_logic_vector(1 downto 0) := (others => '0');
     signal sig_data2wsc_cmd_empty       : std_logic := '0';
     signal sig_data2wsc_calc_err        : std_logic := '0';
     signal sig_data2wsc_cmd_cmplt       : std_logic := '0';
     signal sig_data2wsc_last_err        : std_logic := '0';
     signal sig_calc2dm_calc_err         : std_logic := '0';
     signal sig_wsc2stat_status          : std_logic_vector(WSC_STATUS_WIDTH-1 downto 0) := (others => '0');
     signal sig_stat2wsc_status_ready    : std_logic := '0';
     signal sig_wsc2stat_status_valid    : std_logic := '0';
     signal sig_wsc2mstr_halt_pipe       : std_logic := '0';
     signal sig_data2wsc_tag             : std_logic_vector(S2MM_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_tag            : std_logic_vector(S2MM_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2addr_tag            : std_logic_vector(S2MM_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_addr_lsb       : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_wvalid         : std_logic := '0';
     signal sig_skid2data_wready         : std_logic := '0';
     signal sig_data2skid_wdata          : std_logic_vector(SF_UPSIZED_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2skid_wstrb          : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_data2skid_wlast          : std_logic := '0';
     signal sig_skid2axi_wvalid          : std_logic := '0';
     signal sig_axi2skid_wready          : std_logic := '0';
     signal sig_skid2axi_wdata           : std_logic_vector(S2MM_MDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_skid2axi_wstrb           : std_logic_vector((S2MM_MDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_skid2axi_wlast           : std_logic := '0';
     signal sig_data2wsc_sof             : std_logic := '0';
     signal sig_data2wsc_eof             : std_logic := '0';
     signal sig_data2wsc_valid           : std_logic := '0';
     signal sig_wsc2data_ready           : std_logic := '0';
     signal sig_data2wsc_eop             : std_logic := '0';
     signal sig_data2wsc_bytes_rcvd      : std_logic_vector(WSC_BYTES_RCVD_WIDTH-1 downto 0) := (others => '0');
     signal sig_dbg_data_mux_out         : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_0               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_1               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_sf2pcc_xfer_valid        : std_logic := '0';
     signal sig_pcc2sf_xfer_ready        : std_logic := '0';
     signal sig_sf2pcc_cmd_cmplt         : std_logic := '0';
     signal sig_sf2pcc_packet_eop        : std_logic := '0';
     signal sig_sf2pcc_xfer_bytes        : std_logic_vector(IBTT_XFER_BYTES_WIDTH-1 downto 0) := (others => '0');
     signal sig_ibtt2wdc_tvalid          : std_logic := '0';
     signal sig_wdc2ibtt_tready          : std_logic := '0';
     signal sig_ibtt2wdc_tdata           : std_logic_vector(SF_UPSIZED_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_ibtt2wdc_tstrb           : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_ibtt2wdc_tlast           : std_logic := '0';
     signal sig_ibtt2wdc_eop             : std_logic := '0';
     signal sig_ibtt2wdc_stbs_asserted   : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_dre2ibtt_tvalid          : std_logic := '0';
     signal sig_ibtt2dre_tready          : std_logic := '0';
     signal sig_dre2ibtt_tdata           : std_logic_vector(S2MM_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_dre2ibtt_tstrb           : std_logic_vector((S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_dre2ibtt_tlast           : std_logic := '0';
     signal sig_dre2ibtt_eop             : std_logic := '0';
     signal sig_dre2mstr_cmd_ready       : std_logic := '0';
     signal sig_mstr2dre_cmd_valid       : std_logic := '0';
     signal sig_mstr2dre_tag             : std_logic_vector(S2MM_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2dre_dre_src_align   : std_logic_vector(S2MM_DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2dre_dre_dest_align  : std_logic_vector(S2MM_DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2dre_btt             : std_logic_vector(S2MM_BTT_USED-1 downto 0) := (others => '0');
     signal sig_mstr2dre_drr             : std_logic := '0';
     signal sig_mstr2dre_eof             : std_logic := '0';
     signal sig_mstr2dre_cmd_cmplt       : std_logic := '0';
     signal sig_mstr2dre_calc_error      : std_logic := '0';
     signal sig_realign2wdc_eop_error    : std_logic := '0';
     signal sig_dre2all_halted           : std_logic := '0';
     signal sig_rst2all_stop_request     : std_logic := '0';
     signal sig_data2rst_stop_cmplt      : std_logic := '0';
     signal sig_addr2rst_stop_cmplt      : std_logic := '0';
     signal sig_data2addr_stop_req       : std_logic := '0';
     signal sig_wsc2rst_stop_cmplt       : std_logic := '0';
     signal sig_data2skid_halt           : std_logic := '0';
     signal skid2dre_wvalid              : std_logic := '0';
     signal dre2skid_wready              : std_logic := '0';
     signal skid2dre_wdata               : std_logic_vector(S2MM_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal skid2dre_wstrb               : std_logic_vector((S2MM_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal skid2dre_wlast               : std_logic := '0';
     signal sig_s2mm_allow_addr_req      : std_logic := '0';
     signal sig_ok_to_post_wr_addr       : std_logic := '0';
     signal sig_s2mm_addr_req_posted     : std_logic := '0';
     signal sig_s2mm_wr_xfer_cmplt       : std_logic := '0';
     signal sig_s2mm_ld_nxt_len          : std_logic := '0';
     signal sig_s2mm_wr_len              : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_ibtt2wdc_error           : std_logic := '0';
     signal sig_sf_strt_addr_offset      : std_logic_vector(SF_STRT_OFFSET_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2dre_sf_strt_offset  : std_logic_vector(SF_STRT_OFFSET_WIDTH-1 downto 0) := (others => '0');
     signal sig_cache2mstr_command       : std_logic_vector (7 downto 0);
     signal s2mm_awcache_int             : std_logic_vector (3 downto 0);
     signal s2mm_awuser_int             : std_logic_vector (3 downto 0);
    
    
  begin --(architecture implementation)



    -- Debug/Test Port Assignments

    s2mm_dbg_data        <= sig_dbg_data_mux_out;

    -- Note that only the s2mm_dbg_sel(0) is used at this time
    sig_dbg_data_mux_out <= sig_dbg_data_1
      When (s2mm_dbg_sel(0) = '1')
      else sig_dbg_data_0 ;


    sig_dbg_data_0               <=  X"CAFE1111"             ;    -- 32 bit Constant indicating S2MM FULL type

    sig_dbg_data_1(0)            <= sig_cmd_stat_rst_user    ;
    sig_dbg_data_1(1)            <= sig_cmd_stat_rst_int     ;
    sig_dbg_data_1(2)            <= sig_mmap_rst             ;
    sig_dbg_data_1(3)            <= sig_stream_rst           ;
    sig_dbg_data_1(4)            <= sig_cmd2mstr_cmd_valid   ;
    sig_dbg_data_1(5)            <= sig_mst2cmd_cmd_ready    ;
    sig_dbg_data_1(6)            <= sig_stat2wsc_status_ready;
    sig_dbg_data_1(7)            <= sig_wsc2stat_status_valid;
    sig_dbg_data_1(11 downto 8)  <= sig_data2wsc_tag         ; -- Current TAG of active data transfer


    sig_dbg_data_1(15 downto 12) <= sig_wsc2stat_status(3 downto 0); -- Internal status tag field
    sig_dbg_data_1(16)           <= sig_wsc2stat_status(4)         ; -- Internal error
    sig_dbg_data_1(17)           <= sig_wsc2stat_status(5)         ; -- Decode Error
    sig_dbg_data_1(18)           <= sig_wsc2stat_status(6)         ; -- Slave Error
    --sig_dbg_data_1(19)           <= sig_wsc2stat_status(7)         ; -- OKAY
    sig_dbg_data_1(20)           <= sig_stat2wsc_status_ready      ; -- Status Ready Handshake
    sig_dbg_data_1(21)           <= sig_wsc2stat_status_valid      ; -- Status Valid Handshake
                        
    
    sig_dbg_data_1(29 downto 22) <= sig_mstr2data_len              ; -- WDC Cmd FIFO LEN input
    sig_dbg_data_1(30)           <= sig_mstr2data_cmd_valid        ; -- WDC Cmd FIFO Valid Inpute
    sig_dbg_data_1(31)           <= sig_data2mstr_cmd_ready        ; -- WDC Cmd FIFO Ready Output
    
    


    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ADD_DEBUG_EOP
    --
    -- If Generate Description:
    --
    --   This IfGen adds in the EOP status marker to the debug
    -- vector data when Indet BTT Store and Forward is enabled.
    --
    ------------------------------------------------------------
    GEN_ADD_DEBUG_EOP : if (ENABLE_INDET_BTT_SF = 1) generate
    
       begin
  
         sig_dbg_data_1(19)  <= sig_wsc2stat_status(31) ; -- EOP Marker
  
    
       end generate GEN_ADD_DEBUG_EOP;
   
   
   
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_DEBUG_EOP
    --
    -- If Generate Description:
    --
    --   This IfGen zeros the debug vector bit used for the  EOP 
    -- status marker when Indet BTT Store and Forward is not 
    -- enabled.
    --
    ------------------------------------------------------------
    GEN_NO_DEBUG_EOP : if (ENABLE_INDET_BTT_SF = 0) generate
    
       begin
  
         sig_dbg_data_1(19)   <= '0' ; -- EOP Marker
  
    
       end generate GEN_NO_DEBUG_EOP;
   
   
   
   
    ---- End of Debug/Test Support --------------------------------
   
   
   


     -- Assign the Address posting control outputs
     s2mm_addr_req_posted     <= sig_s2mm_addr_req_posted ;
     s2mm_wr_xfer_cmplt       <= sig_s2mm_wr_xfer_cmplt   ;
     s2mm_ld_nxt_len          <= sig_s2mm_ld_nxt_len      ;
     s2mm_wr_len              <= sig_s2mm_wr_len          ;
     
     
     
   
   
   
   
   


    -- Write Data Channel I/O
     s2mm_wvalid         <= sig_skid2axi_wvalid;
     sig_axi2skid_wready <= s2mm_wready        ;
     s2mm_wdata          <= sig_skid2axi_wdata ;
     s2mm_wlast          <= sig_skid2axi_wlast ;

GEN_S2MM_TKEEP_ENABLE2 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin

     s2mm_wstrb          <= sig_skid2axi_wstrb ;


end generate GEN_S2MM_TKEEP_ENABLE2;

GEN_S2MM_TKEEP_DISABLE2 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin

  s2mm_wstrb        <= (others => '1');

end generate GEN_S2MM_TKEEP_DISABLE2;




    GEN_CACHE : if (C_ENABLE_CACHE_USER = 0) generate
      begin
     -- Cache signal tie-off
     s2mm_awcache <= "0011";  -- pre Interface-X guidelines for Masters
     s2mm_awuser <= "0000";  -- pre Interface-X guidelines for Masters
     sig_s2mm_cache_data <= (others => '0'); --s2mm_cmd_wdata(103 downto 96);
    end generate GEN_CACHE;

    GEN_CACHE2 : if (C_ENABLE_CACHE_USER = 1) generate
      begin
     -- Cache signal tie-off
     s2mm_awcache <= s2mm_awcache_int;  -- pre Interface-X guidelines for Masters
     s2mm_awuser <= s2mm_awuser_int;  -- pre Interface-X guidelines for Masters
     sig_s2mm_cache_data <= s2mm_cmd_wdata(79+(C_S2MM_ADDR_WIDTH-32) downto 72+(C_S2MM_ADDR_WIDTH-32));
  --   sig_s2mm_cache_data <= s2mm_cmd_wdata(103 downto 96);
    end generate GEN_CACHE2;

     -- Internal error output discrete
     s2mm_err            <=  sig_calc2dm_calc_err or sig_data2all_tlast_error;


     -- Rip the used portion of the Command Interface Command Data
     -- and throw away the padding
     sig_s2mm_cmd_wdata <= s2mm_cmd_wdata(S2MM_CMD_WIDTH-1 downto 0);




     ------------------------------------------------------------
     -- Instance: I_RESET
     --
     -- Description:
     --   Reset Block
     --
     ------------------------------------------------------------
      I_RESET : entity axi_datamover_v5_1_17.axi_datamover_reset
      generic map (

        C_STSCMD_IS_ASYNC    =>  S2MM_STSCMD_IS_ASYNC       

        )
      port map (

        primary_aclk         =>  s2mm_aclk                , 
        primary_aresetn      =>  s2mm_aresetn             , 
        secondary_awclk      =>  s2mm_cmdsts_awclk        , 
        secondary_aresetn    =>  s2mm_cmdsts_aresetn      , 
        halt_req             =>  s2mm_halt                , 
        halt_cmplt           =>  s2mm_halt_cmplt          , 
        flush_stop_request   =>  sig_rst2all_stop_request , 
        data_cntlr_stopped   =>  sig_data2rst_stop_cmplt  , 
        addr_cntlr_stopped   =>  sig_addr2rst_stop_cmplt  , 
        aux1_stopped         =>  sig_wsc2rst_stop_cmplt   , 
        aux2_stopped         =>  LOGIC_HIGH               , 
        cmd_stat_rst_user    =>  sig_cmd_stat_rst_user    , 
        cmd_stat_rst_int     =>  sig_cmd_stat_rst_int     , 
        mmap_rst             =>  sig_mmap_rst             , 
        stream_rst           =>  sig_stream_rst             

        );






     ------------------------------------------------------------
     -- Instance: I_CMD_STATUS
     --
     -- Description:
     --   Command and Status Interface Block
     --
     ------------------------------------------------------------
      I_CMD_STATUS : entity axi_datamover_v5_1_17.axi_datamover_cmd_status
      generic map (

        C_ADDR_WIDTH           =>  S2MM_ADDR_WIDTH           , 
        C_INCLUDE_STSFIFO      =>  INCLUDE_S2MM_STSFIFO      , 
        C_STSCMD_FIFO_DEPTH    =>  S2MM_STSCMD_FIFO_DEPTH    , 
        C_STSCMD_IS_ASYNC      =>  S2MM_STSCMD_IS_ASYNC      , 
        C_CMD_WIDTH            =>  S2MM_CMD_WIDTH            , 
        C_STS_WIDTH            =>  WSC_STATUS_WIDTH          , 
        C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER       ,
        C_FAMILY               =>  C_FAMILY

        )
      port map (

        primary_aclk           =>  s2mm_aclk                 , 
        secondary_awclk        =>  s2mm_cmdsts_awclk         , 
        user_reset             =>  sig_cmd_stat_rst_user     , 
        internal_reset         =>  sig_cmd_stat_rst_int      , 
        cmd_wvalid             =>  s2mm_cmd_wvalid           , 
        cmd_wready             =>  s2mm_cmd_wready           , 
        cmd_wdata              =>  sig_s2mm_cmd_wdata        , 
        cache_data             =>  sig_s2mm_cache_data        , 
        sts_wvalid             =>  s2mm_sts_wvalid           , 
        sts_wready             =>  s2mm_sts_wready           , 
        sts_wdata              =>  s2mm_sts_wdata            , 
        sts_wstrb              =>  s2mm_sts_wstrb            , 
        sts_wlast              =>  s2mm_sts_wlast            , 
        cmd2mstr_command       =>  sig_cmd2mstr_command      , 
        cache2mstr_command     =>  sig_cache2mstr_command      , 
        mst2cmd_cmd_valid      =>  sig_cmd2mstr_cmd_valid    , 
        cmd2mstr_cmd_ready     =>  sig_mst2cmd_cmd_ready     , 
        mstr2stat_status       =>  sig_wsc2stat_status       , 
        stat2mstr_status_ready =>  sig_stat2wsc_status_ready , 
        mst2stst_status_valid  =>  sig_wsc2stat_status_valid   

        );






     ------------------------------------------------------------
     -- Instance: I_WR_STATUS_CNTLR
     --
     -- Description:
     -- Write Status Controller Block
     --
     ------------------------------------------------------------
      I_WR_STATUS_CNTLR : entity axi_datamover_v5_1_17.axi_datamover_wr_status_cntl
      generic map (

        C_ENABLE_INDET_BTT     =>  ENABLE_INDET_BTT_SF         ,  
        C_SF_BYTES_RCVD_WIDTH  =>  WSC_BYTES_RCVD_WIDTH        ,  
        C_STS_FIFO_DEPTH       =>  WR_STATUS_CNTL_FIFO_DEPTH   ,
        C_STS_WIDTH            =>  WSC_STATUS_WIDTH            ,  
        C_TAG_WIDTH            =>  S2MM_TAG_WIDTH              ,  
        C_MCDMA                =>  C_MCDMA                     ,
        C_FAMILY               =>  C_FAMILY                       

        )
      port map (

        primary_aclk           =>  s2mm_aclk                   ,  
        mmap_reset             =>  sig_mmap_rst                ,  
        rst2wsc_stop_request   =>  sig_rst2all_stop_request    ,  
        wsc2rst_stop_cmplt     =>  sig_wsc2rst_stop_cmplt      ,  
        addr2wsc_addr_posted   =>  sig_addr2data_addr_posted   ,  
        s2mm_bresp             =>  s2mm_bresp                  ,  
        s2mm_bvalid            =>  s2mm_bvalid                 ,  
        s2mm_bready            =>  s2mm_bready                 ,  
        calc2wsc_calc_error    =>  sig_calc2dm_calc_err        ,  
        addr2wsc_calc_error    =>  sig_addr2wsc_calc_error     ,  
        addr2wsc_fifo_empty    =>  sig_addr2wsc_cmd_fifo_empty ,  
        data2wsc_tag           =>  sig_data2wsc_tag            ,  
        data2wsc_calc_error    =>  sig_data2wsc_calc_err       ,  
        data2wsc_last_error    =>  sig_data2wsc_last_err       ,  
        data2wsc_cmd_cmplt     =>  sig_data2wsc_cmd_cmplt      ,  
        data2wsc_valid         =>  sig_data2wsc_valid          ,  
        wsc2data_ready         =>  sig_wsc2data_ready          ,  
        data2wsc_eop           =>  sig_data2wsc_eop            ,  
        data2wsc_bytes_rcvd    =>  sig_data2wsc_bytes_rcvd     ,  
        wsc2stat_status        =>  sig_wsc2stat_status         ,  
        stat2wsc_status_ready  =>  sig_stat2wsc_status_ready   ,  
        wsc2stat_status_valid  =>  sig_wsc2stat_status_valid   ,  
        wsc2mstr_halt_pipe     =>  sig_wsc2mstr_halt_pipe         

        );





    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_PCC
    --
    -- If Generate Description:
    --   Include the normal Predictive Command Calculator function, 
    -- Store and Forward is not an included feature.
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_PCC : if (ENABLE_INDET_BTT_SF = 0) generate


       begin


         ------------------------------------------------------------
         -- Instance: I_MSTR_PCC
         --
         -- Description:
         -- Predictive Command Calculator Block
         --
         ------------------------------------------------------------
         I_MSTR_PCC : entity axi_datamover_v5_1_17.axi_datamover_pcc
         generic map (

           C_IS_MM2S                 =>  IS_NOT_MM2S                  ,
           C_DRE_ALIGN_WIDTH         =>  S2MM_DRE_ALIGN_WIDTH         , 
           C_SEL_ADDR_WIDTH          =>  SEL_ADDR_WIDTH               , 
           C_ADDR_WIDTH              =>  S2MM_ADDR_WIDTH              , 
           C_STREAM_DWIDTH           =>  S2MM_SDATA_WIDTH             , 
           C_MAX_BURST_LEN           =>  S2MM_BURST_SIZE              , 
           C_CMD_WIDTH               =>  S2MM_CMD_WIDTH               , 
           C_TAG_WIDTH               =>  S2MM_TAG_WIDTH               , 
           C_BTT_USED                =>  S2MM_BTT_USED                , 
           C_SUPPORT_INDET_BTT       =>  ENABLE_INDET_BTT_SF          ,
           C_NATIVE_XFER_WIDTH       =>  SF_UPSIZED_SDATA_WIDTH       ,
           C_STRT_SF_OFFSET_WIDTH    =>  SF_STRT_OFFSET_WIDTH         ,
           C_MCDMA                   =>  C_MCDMA

           )
         port map (

           -- Clock input
           primary_aclk              =>  s2mm_aclk                    , 
           mmap_reset                =>  sig_mmap_rst                 , 
           
           cmd2mstr_command          =>  sig_cmd2mstr_command         , 
           cache2mstr_command        =>  sig_cache2mstr_command         , 
           cmd2mstr_cmd_valid        =>  sig_cmd2mstr_cmd_valid       , 
           mst2cmd_cmd_ready         =>  sig_mst2cmd_cmd_ready        , 

           mstr2addr_tag             =>  sig_mstr2addr_tag            , 
           mstr2addr_addr            =>  sig_mstr2addr_addr           , 
           mstr2addr_len             =>  sig_mstr2addr_len            , 
           mstr2addr_size            =>  sig_mstr2addr_size           , 
           mstr2addr_burst           =>  sig_mstr2addr_burst          , 
           mstr2addr_cache           =>  sig_mstr2addr_cache          , 
           mstr2addr_user            =>  sig_mstr2addr_user           , 
           mstr2addr_cmd_cmplt       =>  sig_mstr2addr_cmd_cmplt      , 
           mstr2addr_calc_error      =>  sig_mstr2addr_calc_error     , 
           mstr2addr_cmd_valid       =>  sig_mstr2addr_cmd_valid      , 
           addr2mstr_cmd_ready       =>  sig_addr2mstr_cmd_ready      , 
           
           mstr2data_tag             =>  sig_mstr2data_tag            , 
           mstr2data_saddr_lsb       =>  sig_mstr2data_saddr_lsb      , 
           mstr2data_len             =>  sig_mstr2data_len            , 
           mstr2data_strt_strb       =>  sig_mstr2data_strt_strb      , 
           mstr2data_last_strb       =>  sig_mstr2data_last_strb      , 
           mstr2data_drr             =>  sig_mstr2data_drr            , 
           mstr2data_eof             =>  sig_mstr2data_eof            , 
           mstr2data_sequential      =>  sig_mstr2data_sequential     , 
           mstr2data_calc_error      =>  sig_mstr2data_calc_error     , 
           mstr2data_cmd_cmplt       =>  sig_mstr2data_cmd_last       , 
           mstr2data_cmd_valid       =>  sig_mstr2data_cmd_valid      , 
           data2mstr_cmd_ready       =>  sig_data2mstr_cmd_ready      , 
           mstr2data_dre_src_align   =>  open                         ,
           mstr2data_dre_dest_align  =>  open                         ,
           

           calc_error                =>  sig_calc2dm_calc_err         , 

           dre2mstr_cmd_ready        =>  sig_dre2mstr_cmd_ready       , 
           mstr2dre_cmd_valid        =>  sig_mstr2dre_cmd_valid       , 
           mstr2dre_tag              =>  sig_mstr2dre_tag             , 
           mstr2dre_dre_src_align    =>  sig_mstr2dre_dre_src_align   , 
           mstr2dre_dre_dest_align   =>  sig_mstr2dre_dre_dest_align  , 
           mstr2dre_btt              =>  sig_mstr2dre_btt             , 
           mstr2dre_drr              =>  sig_mstr2dre_drr             , 
           mstr2dre_eof              =>  sig_mstr2dre_eof             , 
           mstr2dre_cmd_cmplt        =>  sig_mstr2dre_cmd_cmplt       , 
           mstr2dre_calc_error       =>  sig_mstr2dre_calc_error      ,
           
           mstr2dre_strt_offset      =>  sig_mstr2dre_sf_strt_offset

           );


       end generate GEN_INCLUDE_PCC;



    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_IBTTCC
    --
    -- If Generate Description:
    --   Include the Indeterminate BTT Command Calculator function, 
    -- Store and Forward is enabled in the S2MM.
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_IBTTCC : if (ENABLE_INDET_BTT_SF = 1) generate


       begin


         

         ------------------------------------------------------------
         -- Instance: I_S2MM_MSTR_SFCC
         --
         -- Description:
         --   Instantiates the Store and Forward Command Calculator 
         -- Block.
         --
         ------------------------------------------------------------
         I_S2MM_MSTR_IBTTCC : entity axi_datamover_v5_1_17.axi_datamover_ibttcc
         generic map (

           C_SF_XFER_BYTES_WIDTH     =>  IBTT_XFER_BYTES_WIDTH        , 
           C_DRE_ALIGN_WIDTH         =>  S2MM_DRE_ALIGN_WIDTH         , 
           C_SEL_ADDR_WIDTH          =>  SEL_ADDR_WIDTH               , 
           C_ADDR_WIDTH              =>  S2MM_ADDR_WIDTH              , 
           C_STREAM_DWIDTH           =>  S2MM_SDATA_WIDTH             , 
           C_MAX_BURST_LEN           =>  S2MM_BURST_SIZE              , 
           C_CMD_WIDTH               =>  S2MM_CMD_WIDTH               , 
           C_TAG_WIDTH               =>  S2MM_TAG_WIDTH               , 
           C_BTT_USED                =>  S2MM_BTT_USED                ,
           C_NATIVE_XFER_WIDTH       =>  SF_UPSIZED_SDATA_WIDTH       ,
           C_STRT_SF_OFFSET_WIDTH    =>  SF_STRT_OFFSET_WIDTH         ,
           C_MCDMA                   =>  C_MCDMA
           
           )
           
         port map (

           -- Clock input
           primary_aclk              =>  s2mm_aclk                    , 
           mmap_reset                =>  sig_mmap_rst                 , 
           
           cmd2mstr_command          =>  sig_cmd2mstr_command         , 
           cache2mstr_command        =>  sig_cache2mstr_command         , 
           cmd2mstr_cmd_valid        =>  sig_cmd2mstr_cmd_valid       , 
           mst2cmd_cmd_ready         =>  sig_mst2cmd_cmd_ready        , 

           sf2pcc_xfer_valid         =>  sig_sf2pcc_xfer_valid        , 
           pcc2sf_xfer_ready         =>  sig_pcc2sf_xfer_ready        , 
           sf2pcc_cmd_cmplt          =>  sig_sf2pcc_cmd_cmplt         , 
           sf2pcc_packet_eop         =>  sig_sf2pcc_packet_eop        , 
           sf2pcc_xfer_bytes         =>  sig_sf2pcc_xfer_bytes        , 
                
           mstr2addr_tag             =>  sig_mstr2addr_tag            , 
           mstr2addr_addr            =>  sig_mstr2addr_addr           , 
           mstr2addr_len             =>  sig_mstr2addr_len            , 
           mstr2addr_size            =>  sig_mstr2addr_size           , 
           mstr2addr_burst           =>  sig_mstr2addr_burst          , 
           mstr2addr_cache           =>  sig_mstr2addr_cache          , 
           mstr2addr_user            =>  sig_mstr2addr_user           , 
           mstr2addr_cmd_cmplt       =>  sig_mstr2addr_cmd_cmplt      , 
           mstr2addr_calc_error      =>  sig_mstr2addr_calc_error     , 
           mstr2addr_cmd_valid       =>  sig_mstr2addr_cmd_valid      , 
           addr2mstr_cmd_ready       =>  sig_addr2mstr_cmd_ready      , 
           
           mstr2data_tag             =>  sig_mstr2data_tag            , 
           mstr2data_saddr_lsb       =>  sig_mstr2data_saddr_lsb      , 
           mstr2data_len             =>  sig_mstr2data_len            , 
           mstr2data_strt_strb       =>  sig_mstr2data_strt_strb      , 
           mstr2data_last_strb       =>  sig_mstr2data_last_strb      , 
           mstr2data_drr             =>  sig_mstr2data_drr            , 
           mstr2data_eof             =>  sig_mstr2data_eof            , 
           mstr2data_sequential      =>  sig_mstr2data_sequential     , 
           mstr2data_calc_error      =>  sig_mstr2data_calc_error     , 
           mstr2data_cmd_cmplt       =>  sig_mstr2data_cmd_last       , 
           mstr2data_cmd_valid       =>  sig_mstr2data_cmd_valid      , 
           data2mstr_cmd_ready       =>  sig_data2mstr_cmd_ready      , 

           calc_error                =>  sig_calc2dm_calc_err         , 

           dre2mstr_cmd_ready        =>  sig_dre2mstr_cmd_ready       , 
           mstr2dre_cmd_valid        =>  sig_mstr2dre_cmd_valid       , 
           mstr2dre_tag              =>  sig_mstr2dre_tag             , 
           mstr2dre_dre_src_align    =>  sig_mstr2dre_dre_src_align   , 
           mstr2dre_dre_dest_align   =>  sig_mstr2dre_dre_dest_align  , 
           mstr2dre_btt              =>  sig_mstr2dre_btt             , 
           mstr2dre_drr              =>  sig_mstr2dre_drr             , 
           mstr2dre_eof              =>  sig_mstr2dre_eof             , 
           mstr2dre_cmd_cmplt        =>  sig_mstr2dre_cmd_cmplt       , 
           mstr2dre_calc_error       =>  sig_mstr2dre_calc_error      ,
           
           mstr2dre_strt_offset      =>  sig_mstr2dre_sf_strt_offset        

           );


       end generate GEN_INCLUDE_IBTTCC;



    
    
    
    
    
ENABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(4) = '1' generate
begin 
    
    
    ------------------------------------------------------------
    -- Instance: I_S2MM_STRM_SKID_BUF
    --
    -- Description:
    --   Instance for the S2MM Skid Buffer which provides for
    -- registerd Slave Stream inputs and supports bi-dir
    -- throttling.
    --
    ------------------------------------------------------------
    I_S2MM_STRM_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
    generic map (

      C_WDATA_WIDTH =>  S2MM_SDATA_WIDTH      

      )
    port map (

      -- System Ports
      aclk          =>  s2mm_aclk             ,  
      arst          =>  sig_mmap_rst          ,  

      -- Shutdown control (assert for 1 clk pulse)
      skid_stop     =>  sig_data2skid_halt    ,  

      -- Slave Side (Stream Data Input)
      s_valid       =>  s2mm_strm_wvalid      ,  
      s_ready       =>  s2mm_strm_wready      ,  
      s_data        =>  s2mm_strm_wdata       ,  
      s_strb        =>  s2mm_strm_wstrb       ,  
      s_last        =>  s2mm_strm_wlast       ,  

      -- Master Side (Stream Data Output
      m_valid       =>  skid2dre_wvalid       , 
      m_ready       =>  dre2skid_wready       , 
      m_data        =>  skid2dre_wdata        , 
      m_strb        =>  skid2dre_wstrb        , 
      m_last        =>  skid2dre_wlast          

      );


end generate ENABLE_AXIS_SKID;
  
    
DISABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(4) = '0' generate
begin 

   skid2dre_wvalid <= s2mm_strm_wvalid;
   s2mm_strm_wready <= dre2skid_wready;
   skid2dre_wdata <= s2mm_strm_wdata;
   skid2dre_wstrb <= s2mm_strm_wstrb;
   skid2dre_wlast <= s2mm_strm_wlast;
   

end generate DISABLE_AXIS_SKID; 

    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_REALIGNER
    --
    -- If Generate Description:
    --   Omit the S2MM Realignment Engine
    --
    --
    ------------------------------------------------------------
    GEN_NO_REALIGNER : if (ADD_REALIGNER = 0) generate

       begin


         -- Set to Always ready for DRE to PCC Command Interface
         sig_dre2mstr_cmd_ready <= LOGIC_HIGH;
         
         
         
         -- Without DRE and Scatter, the end of packet is the TLAST
         --sig_dre2ibtt_eop     <= skid2dre_wlast  ;
         sig_dre2ibtt_eop     <= sig_dre2ibtt_tlast  ; -- use skid buffered version
         
         -- Cant't detect undrrun/overrun here
         sig_realign2wdc_eop_error <= '0';

       
       
ENABLE_NOREALIGNER_SKID : if C_ENABLE_SKID_BUF(3) = '1' generate
begin 
        
        
         ------------------------------------------------------------
         -- Instance: I_NO_REALIGN_SKID_BUF
         --
         -- Description:
         --   Instance for a Skid Buffer which provides for
         -- Fmax timing improvement between the Null Absorber and
         -- the Write Data controller when the Realigner is not
         -- present (no DRE and no Store and Forward case).
         --
         ------------------------------------------------------------
         I_NO_REALIGN_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
         generic map (

           C_WDATA_WIDTH =>  S2MM_SDATA_WIDTH      

           )
         port map (

           -- System Ports
           aclk          =>  s2mm_aclk            ,  
           arst          =>  sig_mmap_rst         ,  

           -- Shutdown control (assert for 1 clk pulse)
           skid_stop     =>  LOGIC_LOW            ,  

           -- Slave Side (Null Absorber Input)
           s_valid       =>  skid2dre_wvalid      ,  
           s_ready       =>  dre2skid_wready      ,  
           s_data        =>  skid2dre_wdata       ,  
           s_strb        =>  skid2dre_wstrb       ,  
           s_last        =>  skid2dre_wlast       ,  

           -- Master Side (Stream Data Output to WData Cntlr)
           m_valid       =>  sig_dre2ibtt_tvalid  , 
           m_ready       =>  sig_ibtt2dre_tready  , 
           m_data        =>  sig_dre2ibtt_tdata   , 
           m_strb        =>  sig_dre2ibtt_tstrb   , 
           m_last        =>  sig_dre2ibtt_tlast     

           );

end generate ENABLE_NOREALIGNER_SKID;
  
    
DISABLE_NOREALIGNER_SKID : if C_ENABLE_SKID_BUF(3) = '0' generate
begin 

   sig_dre2ibtt_tvalid <= skid2dre_wvalid;
   dre2skid_wready <= sig_ibtt2dre_tready;
   sig_dre2ibtt_tdata <= skid2dre_wdata;
   sig_dre2ibtt_tstrb <= skid2dre_wstrb;
   sig_dre2ibtt_tlast <= skid2dre_wlast;
   

end generate DISABLE_NOREALIGNER_SKID; 


        
       end generate GEN_NO_REALIGNER;



    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_REALIGNER
    --
    -- If Generate Description:
    --   Include the S2MM realigner Module. It hosts the S2MM DRE
    -- and the Scatter Block.
    --
    -- Note that the General Purpose Store and Forward Module
    -- needs the Scatter function to detect input overrun and
    -- underrun events on the AXI Stream input. Thus the Realigner
    -- is included whenever the GP Store and Forward is enabled.
    --
    ------------------------------------------------------------
    GEN_INCLUDE_REALIGNER : if (ADD_REALIGNER = 1) generate

      begin



       ------------------------------------------------------------
       -- Instance: I_S2MM_REALIGNER
       --
       -- Description:
       --  Instance for the S2MM Data Realignment Module.
       --
       ------------------------------------------------------------
        I_S2MM_REALIGNER : entity axi_datamover_v5_1_17.axi_datamover_s2mm_realign
        generic map (

          C_ENABLE_INDET_BTT      =>  ENABLE_INDET_BTT_SF         ,  
          C_INCLUDE_DRE           =>  INCLUDE_S2MM_DRE            ,  
          C_DRE_CNTL_FIFO_DEPTH   =>  DRE_CNTL_FIFO_DEPTH         ,  
          C_DRE_ALIGN_WIDTH       =>  S2MM_DRE_ALIGN_WIDTH        ,  
          C_SUPPORT_SCATTER       =>  DRE_SUPPORT_SCATTER         ,  
          C_BTT_USED              =>  S2MM_BTT_USED               ,  
          C_STREAM_DWIDTH         =>  S2MM_SDATA_WIDTH            , 
          C_ENABLE_S2MM_TKEEP       =>  C_ENABLE_S2MM_TKEEP        ,
          C_TAG_WIDTH             =>  S2MM_TAG_WIDTH              ,  
          C_STRT_SF_OFFSET_WIDTH  =>  SF_STRT_OFFSET_WIDTH        ,
          C_FAMILY                =>  C_FAMILY                       

          )
        port map (

         -- Clock and Reset
          primary_aclk            =>  s2mm_aclk                   ,  
          mmap_reset              =>  sig_mmap_rst                ,  

         -- Write Data Controller or Store and Forward I/O  -------
          wdc2dre_wready          =>  sig_ibtt2dre_tready         ,  
          dre2wdc_wvalid          =>  sig_dre2ibtt_tvalid         ,  
          dre2wdc_wdata           =>  sig_dre2ibtt_tdata          ,  
          dre2wdc_wstrb           =>  sig_dre2ibtt_tstrb          ,  
          dre2wdc_wlast           =>  sig_dre2ibtt_tlast          ,  
          dre2wdc_eop             =>  sig_dre2ibtt_eop            ,  
          
         
         -- Starting offset output  -------------------------------
          dre2sf_strt_offset      => sig_sf_strt_addr_offset      ,                                                    
                                                                    
                                                                    
         -- AXI Slave Stream In -----------------------------------
          s2mm_strm_wready        =>  dre2skid_wready             ,  
          s2mm_strm_wvalid        =>  skid2dre_wvalid             ,  
          s2mm_strm_wdata         =>  skid2dre_wdata              ,  
          s2mm_strm_wstrb         =>  skid2dre_wstrb              ,  
          s2mm_strm_wlast         =>  skid2dre_wlast              ,  

          -- Command Calculator Interface --------------------------
          dre2mstr_cmd_ready      =>  sig_dre2mstr_cmd_ready      ,  
          mstr2dre_cmd_valid      =>  sig_mstr2dre_cmd_valid      ,  
          mstr2dre_tag            =>  sig_mstr2dre_tag            ,  
          mstr2dre_dre_src_align  =>  sig_mstr2dre_dre_src_align  ,  
          mstr2dre_dre_dest_align =>  sig_mstr2dre_dre_dest_align ,  
          mstr2dre_btt            =>  sig_mstr2dre_btt            ,  
          mstr2dre_drr            =>  sig_mstr2dre_drr            ,  
          mstr2dre_eof            =>  sig_mstr2dre_eof            ,  
          mstr2dre_cmd_cmplt      =>  sig_mstr2dre_cmd_cmplt      ,  
          mstr2dre_calc_error     =>  sig_mstr2dre_calc_error     ,
          mstr2dre_strt_offset    =>  sig_mstr2dre_sf_strt_offset ,
          
            

          -- Premature TLAST assertion error flag
          dre2all_tlast_error     =>  sig_realign2wdc_eop_error   ,  

          -- DRE Halted Status
          dre2all_halted          =>  sig_dre2all_halted             


          );


      end generate GEN_INCLUDE_REALIGNER;



    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_ENABLE_INDET_BTT_SF
    --
    -- If Generate Description:
    --   Include the Indeterminate BTT Logic with specialized 
    -- Store and Forward function, This also requires the 
    -- Scatter Engine in the Realigner module.
    --
    --
    ------------------------------------------------------------
    GEN_ENABLE_INDET_BTT_SF : if (ENABLE_INDET_BTT_SF = 1) generate


      begin


        -- Pass the Realigner EOP error through
        sig_ibtt2wdc_error   <=  sig_realign2wdc_eop_error;
        
        -- Use only external address posting enable      
        sig_s2mm_allow_addr_req <= s2mm_allow_addr_req ; 
        
        

        ------------------------------------------------------------
        -- Instance: I_INDET_BTT
        --
        -- Description:
        --  Instance for the Indeterminate BTT with Store and Forward
        -- module.
        --
        ------------------------------------------------------------
        I_INDET_BTT : entity axi_datamover_v5_1_17.axi_datamover_indet_btt
        generic map (

          C_SF_FIFO_DEPTH         =>  SF_FIFO_DEPTH             , 
          C_IBTT_XFER_BYTES_WIDTH =>  IBTT_XFER_BYTES_WIDTH     , 
          C_STRT_OFFSET_WIDTH     =>  SF_STRT_OFFSET_WIDTH      ,
          C_MAX_BURST_LEN         =>  S2MM_BURST_SIZE           , 
          C_MMAP_DWIDTH           =>  S2MM_MDATA_WIDTH          ,
          C_STREAM_DWIDTH         =>  S2MM_SDATA_WIDTH          , 
          C_ENABLE_SKID_BUF       =>  C_ENABLE_SKID_BUF         ,
          C_ENABLE_S2MM_TKEEP       =>  C_ENABLE_S2MM_TKEEP        ,
          C_ENABLE_DRE            =>  INCLUDE_S2MM_DRE          ,
          C_FAMILY                =>  C_FAMILY       
          )
        port map (

          primary_aclk              =>  s2mm_aclk                 , 
          mmap_reset                =>  sig_mmap_rst              , 

          ibtt2wdc_stbs_asserted    =>  sig_ibtt2wdc_stbs_asserted, 
          ibtt2wdc_eop              =>  sig_ibtt2wdc_eop          , 
          ibtt2wdc_tdata            =>  sig_ibtt2wdc_tdata        , 
          ibtt2wdc_tstrb            =>  sig_ibtt2wdc_tstrb        , 
          ibtt2wdc_tlast            =>  sig_ibtt2wdc_tlast        , 
          ibtt2wdc_tvalid           =>  sig_ibtt2wdc_tvalid       , 
          wdc2ibtt_tready           =>  sig_wdc2ibtt_tready       , 

          dre2ibtt_tvalid           =>  sig_dre2ibtt_tvalid       , 
          ibtt2dre_tready           =>  sig_ibtt2dre_tready       , 
          dre2ibtt_tdata            =>  sig_dre2ibtt_tdata        , 
          dre2ibtt_tstrb            =>  sig_dre2ibtt_tstrb        , 
          dre2ibtt_tlast            =>  sig_dre2ibtt_tlast        , 
          dre2ibtt_eop              =>  sig_dre2ibtt_eop          , 
        
          dre2ibtt_strt_addr_offset => sig_sf_strt_addr_offset    ,
          
          sf2pcc_xfer_valid         =>  sig_sf2pcc_xfer_valid     , 
          pcc2sf_xfer_ready         =>  sig_pcc2sf_xfer_ready     , 
          sf2pcc_cmd_cmplt          =>  sig_sf2pcc_cmd_cmplt      , 
          sf2pcc_packet_eop         =>  sig_sf2pcc_packet_eop     , 
          sf2pcc_xfer_bytes         =>  sig_sf2pcc_xfer_bytes       

          );


      end generate GEN_ENABLE_INDET_BTT_SF;



    
    
    
    
    
    
    
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_SF
    --
    -- If Generate Description:
    --   Bypasses any store and Forward functions.
    --
    --
    ------------------------------------------------------------
    GEN_NO_SF : if (ENABLE_INDET_BTT_SF = 0 and
                    ENABLE_GP_SF        = 0) generate

       begin

         -- Use only external address posting enable     
         sig_s2mm_allow_addr_req    <= s2mm_allow_addr_req ;
         
         -- Housekeep unused signal in this case
         sig_ok_to_post_wr_addr     <= '0'                 ; 

         -- SFCC Interface Signals that are not used
         sig_pcc2sf_xfer_ready      <= '0'                 ;
         sig_sf2pcc_xfer_valid      <= '0'                 ;
         sig_sf2pcc_cmd_cmplt       <= '0'                 ;
         sig_sf2pcc_packet_eop      <= '0'                 ;
         sig_sf2pcc_xfer_bytes      <= (others => '0')     ;

         -- Just pass DRE signals through
         sig_ibtt2dre_tready        <= sig_wdc2ibtt_tready ;
         sig_ibtt2wdc_tvalid        <= sig_dre2ibtt_tvalid ;
         sig_ibtt2wdc_tdata         <= sig_dre2ibtt_tdata  ;
         sig_ibtt2wdc_tstrb         <= sig_dre2ibtt_tstrb  ;
         sig_ibtt2wdc_tlast         <= sig_dre2ibtt_tlast  ;
         sig_ibtt2wdc_eop           <= sig_dre2ibtt_eop    ;
         sig_ibtt2wdc_stbs_asserted <= (others => '0')     ;
        
         -- Pass the Realigner EOP error through
         sig_ibtt2wdc_error         <=  sig_realign2wdc_eop_error;
        
                                                  
                                                  
       end generate GEN_NO_SF;



 
 
 
 
 
 
 
 
 
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_GP_SF
    --
    -- If Generate Description:
    --   Include the General Purpose Store and Forward module.
    -- This If Generate can only be enabled when
    -- Indeterminate BTT mode is not enabled. The General Purpose
    -- Store and Forward is instantiated in place of the Indet
    -- BTT Store and Forward.
    -- 
    ------------------------------------------------------------
    GEN_INCLUDE_GP_SF : if (ENABLE_INDET_BTT_SF = 0 and
                            ENABLE_GP_SF        = 1) generate

       begin

         
         -- Merge the external address posting control with the
         -- SF address posting control.
         sig_s2mm_allow_addr_req <= s2mm_allow_addr_req and
                                    sig_ok_to_post_wr_addr    ; 
         
         -- Zero these out since Indet BTT is not enabled, they
         -- are only used by the WDC in that mode
         sig_ibtt2wdc_stbs_asserted <= (others => '0')        ;
         sig_ibtt2wdc_eop           <= '0'                    ;
        
         -- SFCC Interface Signals that are not used
         sig_pcc2sf_xfer_ready      <=  '0'                   ;
         sig_sf2pcc_xfer_valid      <=  '0'                   ;
         sig_sf2pcc_cmd_cmplt       <=  '0'                   ;
         sig_sf2pcc_packet_eop      <=  '0'                   ;
         sig_sf2pcc_xfer_bytes      <=  (others => '0')       ;

         
             
         ------------------------------------------------------------
         -- Instance: I_S2MM_GP_SF 
         --
         -- Description:
         --   Instance for the S2MM (Write) General Purpose Store and
         -- Forward Module. This module can only be enabled when
         -- Indeterminate BTT mode is not enabled. It is connected
         -- in place of the IBTT Module when GP SF is enabled. 
         --
         ------------------------------------------------------------
         I_S2MM_GP_SF : entity axi_datamover_v5_1_17.axi_datamover_wr_sf
         generic map (
       
           C_WR_ADDR_PIPE_DEPTH    => ADDR_CNTL_FIFO_DEPTH ,
           C_SF_FIFO_DEPTH         => SF_FIFO_DEPTH        ,
           C_MMAP_DWIDTH           => S2MM_MDATA_WIDTH     ,
           C_STREAM_DWIDTH         => S2MM_SDATA_WIDTH     ,
           C_STRT_OFFSET_WIDTH     => SF_STRT_OFFSET_WIDTH ,
           C_FAMILY                => C_FAMILY              
            
            )
          port map (
        
            -- Clock and Reset inputs -----------------------------
            aclk                   => s2mm_aclk                 ,  
            reset                  => sig_mmap_rst              ,  
          
            -- Slave Stream Input  --------------------------------
            sf2sin_tready          => sig_ibtt2dre_tready       ,   
            sin2sf_tvalid          => sig_dre2ibtt_tvalid       ,   
            sin2sf_tdata           => sig_dre2ibtt_tdata        ,      
            sin2sf_tkeep           => sig_dre2ibtt_tstrb        ,         
            sin2sf_tlast           => sig_dre2ibtt_tlast        ,   
            sin2sf_error           => sig_realign2wdc_eop_error ,  
            
            
            -- Starting Address Offset Input  ---------------------
            sin2sf_strt_addr_offset => sig_sf_strt_addr_offset  ,  
                  
            
            
            -- DataMover Write Side Address Pipelining Control Interface -------- 
            ok_to_post_wr_addr     => sig_ok_to_post_wr_addr    ,    
            wr_addr_posted         => sig_s2mm_addr_req_posted  ,    
            wr_xfer_cmplt          => sig_s2mm_wr_xfer_cmplt    ,    
            wr_ld_nxt_len          => sig_s2mm_ld_nxt_len       ,    
            wr_len                 => sig_s2mm_wr_len           ,    
               
            
            -- Write Side Stream Out to DataMover S2MM -------------
            sout2sf_tready         => sig_wdc2ibtt_tready       ,    
            sf2sout_tvalid         => sig_ibtt2wdc_tvalid       ,    
            sf2sout_tdata          => sig_ibtt2wdc_tdata        ,    
            sf2sout_tkeep          => sig_ibtt2wdc_tstrb        ,    
            sf2sout_tlast          => sig_ibtt2wdc_tlast        ,    
            sf2sout_error          => sig_ibtt2wdc_error
              
            );
        
                                                  
       end generate GEN_INCLUDE_GP_SF;


 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
     ------------------------------------------------------------
     -- Instance: I_ADDR_CNTL
     --
     -- Description:
     --   Address Controller Block
     --
     ------------------------------------------------------------
      I_ADDR_CNTL : entity axi_datamover_v5_1_17.axi_datamover_addr_cntl
      generic map (

        C_ADDR_FIFO_DEPTH        =>  ADDR_CNTL_FIFO_DEPTH        , 
        C_ADDR_WIDTH             =>  S2MM_ADDR_WIDTH             , 
        C_ADDR_ID                =>  S2MM_AWID_VALUE             , 
        C_ADDR_ID_WIDTH          =>  S2MM_AWID_WIDTH             , 
        C_TAG_WIDTH              =>  S2MM_TAG_WIDTH              ,
        C_FAMILY               =>  C_FAMILY  

        )
      port map (

        primary_aclk             =>  s2mm_aclk                   , 
        mmap_reset               =>  sig_mmap_rst                , 
        
        addr2axi_aid             =>  s2mm_awid                   , 
        addr2axi_aaddr           =>  s2mm_awaddr                 , 
        addr2axi_alen            =>  s2mm_awlen                  , 
        addr2axi_asize           =>  s2mm_awsize                 , 
        addr2axi_aburst          =>  s2mm_awburst                , 
        addr2axi_aprot           =>  s2mm_awprot                 , 
        addr2axi_avalid          =>  s2mm_awvalid                , 
        addr2axi_acache           =>  s2mm_awcache_int            ,
        addr2axi_auser            =>  s2mm_awuser_int             ,

        axi2addr_aready          =>  s2mm_awready                , 
        
        mstr2addr_tag            =>  sig_mstr2addr_tag           , 
        mstr2addr_addr           =>  sig_mstr2addr_addr          , 
      --  mstr2addr_cache_info     =>  sig_cache2mstr_command      ,
        mstr2addr_len            =>  sig_mstr2addr_len           , 
        mstr2addr_size           =>  sig_mstr2addr_size          , 
        mstr2addr_burst          =>  sig_mstr2addr_burst         , 
        mstr2addr_cache          =>  sig_mstr2addr_cache         , 
        mstr2addr_user           =>  sig_mstr2addr_user          , 
        mstr2addr_cmd_cmplt      =>  sig_mstr2addr_cmd_cmplt     , 
        mstr2addr_calc_error     =>  sig_mstr2addr_calc_error    , 
        mstr2addr_cmd_valid      =>  sig_mstr2addr_cmd_valid     , 
        addr2mstr_cmd_ready      =>  sig_addr2mstr_cmd_ready     , 
        
        addr2rst_stop_cmplt      =>  sig_addr2rst_stop_cmplt     , 
 
        allow_addr_req           =>  sig_s2mm_allow_addr_req     ,
        addr_req_posted          =>  sig_s2mm_addr_req_posted    ,
        
        addr2data_addr_posted    =>  sig_addr2data_addr_posted   , 
        data2addr_data_rdy       =>  sig_data2addr_data_rdy      , 
        data2addr_stop_req       =>  sig_data2addr_stop_req      , 
        
        addr2stat_calc_error     =>  sig_addr2wsc_calc_error     , 
        addr2stat_cmd_fifo_empty =>  sig_addr2wsc_cmd_fifo_empty   
        );



    
    
    
    
    
    
    
      ------------------------------------------------------------
      -- Instance: I_WR_DATA_CNTL
      --
      -- Description:
      --     Write Data Controller Block
      --
      ------------------------------------------------------------
       I_WR_DATA_CNTL : entity axi_datamover_v5_1_17.axi_datamover_wrdata_cntl
       generic map (

         C_REALIGNER_INCLUDED   =>  ADD_REALIGNER             , 
         C_ENABLE_INDET_BTT     =>  ENABLE_INDET_BTT_SF       , 
         C_SF_BYTES_RCVD_WIDTH  =>  WSC_BYTES_RCVD_WIDTH      , 
         C_SEL_ADDR_WIDTH       =>  SEL_ADDR_WIDTH            , 
         C_DATA_CNTL_FIFO_DEPTH =>  WR_DATA_CNTL_FIFO_DEPTH   , 
         C_MMAP_DWIDTH          =>  S2MM_MDATA_WIDTH          , 
         C_STREAM_DWIDTH        =>  SF_UPSIZED_SDATA_WIDTH    , 
         C_TAG_WIDTH            =>  S2MM_TAG_WIDTH            , 
         C_FAMILY               =>  C_FAMILY                    

         )
       port map (

         primary_aclk           =>  s2mm_aclk                 , 
         mmap_reset             =>  sig_mmap_rst              , 
         rst2data_stop_request  =>  sig_rst2all_stop_request  , 
         data2addr_stop_req     =>  sig_data2addr_stop_req    , 
         data2rst_stop_cmplt    =>  sig_data2rst_stop_cmplt   , 
         wr_xfer_cmplt          =>  sig_s2mm_wr_xfer_cmplt    ,
         s2mm_ld_nxt_len        =>  sig_s2mm_ld_nxt_len       ,
         s2mm_wr_len            =>  sig_s2mm_wr_len           ,
         data2skid_saddr_lsb    =>  sig_data2skid_addr_lsb    , 
         data2skid_wdata        =>  sig_data2skid_wdata       , 
         data2skid_wstrb        =>  sig_data2skid_wstrb       , 
         data2skid_wlast        =>  sig_data2skid_wlast       , 
         data2skid_wvalid       =>  sig_data2skid_wvalid      , 
         skid2data_wready       =>  sig_skid2data_wready      , 
         s2mm_strm_wvalid       =>  sig_ibtt2wdc_tvalid       , 
         s2mm_strm_wready       =>  sig_wdc2ibtt_tready       , 
         s2mm_strm_wdata        =>  sig_ibtt2wdc_tdata        , 
         s2mm_strm_wstrb        =>  sig_ibtt2wdc_tstrb        , 
         s2mm_strm_wlast        =>  sig_ibtt2wdc_tlast        , 
         s2mm_strm_eop          =>  sig_ibtt2wdc_eop          , 
         s2mm_stbs_asserted     =>  sig_ibtt2wdc_stbs_asserted, 
         realign2wdc_eop_error  =>  sig_ibtt2wdc_error        , 
         mstr2data_tag          =>  sig_mstr2data_tag         , 
         mstr2data_saddr_lsb    =>  sig_mstr2data_saddr_lsb   , 
         mstr2data_len          =>  sig_mstr2data_len         , 
         mstr2data_strt_strb    =>  sig_mstr2data_strt_strb   , 
         mstr2data_last_strb    =>  sig_mstr2data_last_strb   , 
         mstr2data_drr          =>  sig_mstr2data_drr         , 
         mstr2data_eof          =>  sig_mstr2data_eof         , 
         mstr2data_sequential   =>  sig_mstr2data_sequential  , 
         mstr2data_calc_error   =>  sig_mstr2data_calc_error  , 
         mstr2data_cmd_cmplt    =>  sig_mstr2data_cmd_last    , 
         mstr2data_cmd_valid    =>  sig_mstr2data_cmd_valid   , 
         data2mstr_cmd_ready    =>  sig_data2mstr_cmd_ready   , 
         addr2data_addr_posted  =>  sig_addr2data_addr_posted , 
         data2addr_data_rdy     =>  sig_data2addr_data_rdy    , 
         data2all_tlast_error   =>  sig_data2all_tlast_error  , 
         data2all_dcntlr_halted =>  sig_data2all_dcntlr_halted, 
         data2skid_halt         =>  sig_data2skid_halt        , 
         data2wsc_tag           =>  sig_data2wsc_tag          , 
         data2wsc_calc_err      =>  sig_data2wsc_calc_err     , 
         data2wsc_last_err      =>  sig_data2wsc_last_err     , 
         data2wsc_cmd_cmplt     =>  sig_data2wsc_cmd_cmplt    , 
         wsc2data_ready         =>  sig_wsc2data_ready        , 
         data2wsc_valid         =>  sig_data2wsc_valid        , 
         data2wsc_eop           =>  sig_data2wsc_eop          , 
         data2wsc_bytes_rcvd    =>  sig_data2wsc_bytes_rcvd   , 
         wsc2mstr_halt_pipe     =>  sig_wsc2mstr_halt_pipe      

         );



    
    
    
    
--ENABLE_AXIMMAP_SKID : if C_ENABLE_SKID_BUF(4) = '1' generate
--begin 
    
    
    
      ------------------------------------------------------------
      -- Instance: I_S2MM_MMAP_SKID_BUF
      --
      -- Description:
      --   Instance for the S2MM Skid Buffer which provides for
      -- registered outputs and supports bi-dir throttling.
      --
      -- This Module also provides Write Data Bus Mirroring and WSTRB
      -- Demuxing to match a narrow Stream to a wider MMap Write
      -- Channel. By doing this in the skid buffer, the resource
      -- utilization of the skid buffer can be minimized by only
      -- having to buffer/mux the Stream data width, not the MMap
      -- Data width.
      --
      ------------------------------------------------------------
       I_S2MM_MMAP_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid2mm_buf
       generic map (

         C_MDATA_WIDTH    =>  S2MM_MDATA_WIDTH       , 
         C_SDATA_WIDTH    =>  SF_UPSIZED_SDATA_WIDTH , 
         C_ADDR_LSB_WIDTH =>  SEL_ADDR_WIDTH           

         )
       port map (

         -- System Ports
         ACLK             =>   s2mm_aclk             , 
         ARST             =>   sig_stream_rst        , 

         -- Slave Side (Wr Data Controller Input Side )
         S_ADDR_LSB       =>   sig_data2skid_addr_lsb, 
         S_VALID          =>   sig_data2skid_wvalid  , 
         S_READY          =>   sig_skid2data_wready  , 
         S_Data           =>   sig_data2skid_wdata   , 
         S_STRB           =>   sig_data2skid_wstrb   , 
         S_Last           =>   sig_data2skid_wlast   , 

         -- Master Side (MMap Write Data Output Side)
         M_VALID          =>   sig_skid2axi_wvalid   , 
         M_READY          =>   sig_axi2skid_wready   , 
         M_Data           =>   sig_skid2axi_wdata    , 
         M_STRB           =>   sig_skid2axi_wstrb    , 
         M_Last           =>   sig_skid2axi_wlast      

         );

--end generate ENABLE_AXIMMAP_SKID;



  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_mm2s_basic_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_mm2s_basic_wrap.vhd
  --
  -- Description:     
  --    This file implements the DataMover MM2S Basic Wrapper.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -- axi_datamover Library Modules
  library axi_datamover_v5_1_17; 
  use axi_datamover_v5_1_17.axi_datamover_reset;  
  use axi_datamover_v5_1_17.axi_datamover_cmd_status;
  use axi_datamover_v5_1_17.axi_datamover_scc;
  use axi_datamover_v5_1_17.axi_datamover_addr_cntl;
  use axi_datamover_v5_1_17.axi_datamover_rddata_cntl;
  use axi_datamover_v5_1_17.axi_datamover_rd_status_cntl;
  use axi_datamover_v5_1_17.axi_datamover_skid_buf;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_mm2s_basic_wrap is
    generic (
      
      C_INCLUDE_MM2S     : Integer range 0 to  2 :=  2;
         -- Specifies the type of MM2S function to include
         -- 0 = Omit MM2S functionality
         -- 1 = Full MM2S Functionality
         -- 2 = Basic MM2S functionality
         
      C_MM2S_ARID        : Integer range 0 to  255 :=  8;
         -- Specifies the constant value to output on 
         -- the ARID output port
         
      C_MM2S_ID_WIDTH    : Integer range 1 to   8 :=  4;
         -- Specifies the width of the MM2S ID port 
         
      C_MM2S_ADDR_WIDTH  : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel 
         -- Address bus
         
      C_MM2S_MDATA_WIDTH : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus
      
      C_MM2S_SDATA_WIDTH : Integer range 8 to 64 :=  32;
         -- Specifies the width of the MM2S Master Stream Data 
         -- Channel data bus
      
      C_INCLUDE_MM2S_STSFIFO    : Integer range 0 to  1 :=  1;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit MM2S Status FIFO
         -- 1 = Include MM2S Status FIFO
         
      C_MM2S_STSCMD_FIFO_DEPTH    : Integer range 1 to 16 :=  1;
         -- Specifies the depth of the MM2S Command FIFO and the 
         -- optional Status FIFO
         -- Valid values are 1,4,8,16
         
      C_MM2S_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces
         
      C_INCLUDE_MM2S_DRE : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the MM2S function 
         -- 0 = Omit DRE
         -- 1 = Include DRE
      
      C_MM2S_BURST_SIZE  : Integer range 2 to  64 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the MM2S function 
      
      C_MM2S_BTT_USED            : Integer range 8 to  23 :=  16;
        -- Specifies the number of bits used from the BTT field
        -- of the input Command Word of the MM2S Command Interface 
    
      C_MM2S_ADDR_PIPE_DEPTH     : Integer range 1 to 30 := 1;
        -- This parameter specifies the depth of the MM2S internal 
        -- child command queues in the Read Address Controller and 
        -- the Read Data Controller. Increasing this value will 
        -- allow more Read Addresses to be issued to the AXI4 Read 
        -- Address Channel before receipt of the associated read 
        -- data on the Read Data Channel.
      C_ENABLE_CACHE_USER    : Integer range 0 to 1 := 1;

      C_ENABLE_SKID_BUF         : string := "11111";

      C_MICRO_DMA         : integer range 0 to 1 := 0;

      C_TAG_WIDTH        : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field
         
      C_FAMILY           : String := "virtex7"
         -- Specifies the target FPGA family type
      
      );
    port (
      
      
      -- MM2S Primary Clock and Reset inputs -----------------------
      mm2s_aclk          : in  std_logic;                         --
         -- Primary synchronization clock for the Master side     --
         -- interface and internal logic. It is also used         --
         -- for the User interface synchronization when           --
         -- C_STSCMD_IS_ASYNC = 0.                                --
                                                                  --
      -- MM2S Primary Reset input                                 --
      mm2s_aresetn       : in  std_logic;                         --
         -- Reset used for the internal master logic              --
      --------------------------------------------------------------
     
      -- MM2S Halt request input control ---------------------------
      mm2s_halt          : in  std_logic;                         --
         -- Active high soft shutdown request                     --
                                                                  --
      -- MM2S Halt Complete status flag                           --
      mm2s_halt_cmplt    : Out  std_logic;                        --
         -- Active high soft shutdown complete status             --
      --------------------------------------------------------------
      
      
      
      -- Error discrete output -------------------------------------
      mm2s_err           : Out std_logic;                         --
         -- Composite Error indication                            --
      --------------------------------------------------------------
     
     
     
      -- Optional MM2S Command and Status Clock and Reset ----------
      -- These are used when C_MM2S_STSCMD_IS_ASYNC = 1           --
      mm2s_cmdsts_awclk   : in  std_logic;                        --
      -- Secondary Clock input for async CMD/Status interface     --
                                                                  --
      mm2s_cmdsts_aresetn : in  std_logic;                        --
        -- Secondary Reset input for async CMD/Status interface   --
      --------------------------------------------------------------
      
      
      
      -- User Command Interface Ports (AXI Stream) -------------------------------------------------
      mm2s_cmd_wvalid     : in  std_logic;                                                        --
      mm2s_cmd_wready     : out std_logic;                                                        --
      mm2s_cmd_wdata      : in  std_logic_vector((C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_MM2S_ADDR_WIDTH+36)-1 downto 0);  --
      ----------------------------------------------------------------------------------------------
     
      
      -- User Status Interface Ports (AXI Stream) -----------------
      mm2s_sts_wvalid     : out std_logic;                       --
      mm2s_sts_wready     : in  std_logic;                       --
      mm2s_sts_wdata      : out std_logic_vector(7 downto 0);    --
      mm2s_sts_wstrb      : out std_logic_vector(0 downto 0);    --
      mm2s_sts_wlast      : out std_logic;                       --
      -------------------------------------------------------------
      
      
      -- Address Posting contols ----------------------------------
      mm2s_allow_addr_req  : in  std_logic;                      --
      mm2s_addr_req_posted : out std_logic;                      --
      mm2s_rd_xfer_cmplt   : out std_logic;                      --
      -------------------------------------------------------------
      
                                                              
                                                              
      
      -- MM2S AXI Address Channel I/O  --------------------------------------
      mm2s_arid     : out std_logic_vector(C_MM2S_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                  --
                                                                           --
      mm2s_araddr   : out std_logic_vector(C_MM2S_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                             --
                                                                           --
      mm2s_arlen    : out std_logic_vector(7 downto 0);                    --
         -- AXI Address Channel LEN output                                 --
         -- Sized to support 256 data beat bursts                          --
                                                                           --
      mm2s_arsize   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel SIZE output                                --
                                                                           --
      mm2s_arburst  : out std_logic_vector(1 downto 0);                    --
         -- AXI Address Channel BURST output                               --
                                                                           --
      mm2s_arprot   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      mm2s_arcache  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel CACHE output                               --

      mm2s_aruser  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel USER output                               --
                                                                           --
      mm2s_arvalid  : out std_logic;                                       --
         -- AXI Address Channel VALID output                               --
                                                                           --
      mm2s_arready  : in  std_logic;                                       --
         -- AXI Address Channel READY input                                --
      -----------------------------------------------------------------------
      
      
        
      -- Currently unsupported AXI Address Channel output signals -------
        -- addr2axi_alock   : out std_logic_vector(2 downto 0);        --
        -- addr2axi_acache  : out std_logic_vector(4 downto 0);        --
        -- addr2axi_aqos    : out std_logic_vector(3 downto 0);        --
        -- addr2axi_aregion : out std_logic_vector(3 downto 0);        --
      -------------------------------------------------------------------
  
  
      
      -- MM2S AXI MMap Read Data Channel I/O  ------------------------------------------
      mm2s_rdata              : In  std_logic_vector(C_MM2S_MDATA_WIDTH-1 downto 0);  --
      mm2s_rresp              : In  std_logic_vector(1 downto 0);                     --
      mm2s_rlast              : In  std_logic;                                        --
      mm2s_rvalid             : In  std_logic;                                        --
      mm2s_rready             : Out std_logic;                                        --
      ----------------------------------------------------------------------------------
      
      
      
      -- MM2S AXI Master Stream Channel I/O  -----------------------------------------------
      mm2s_strm_wdata         : Out  std_logic_vector(C_MM2S_SDATA_WIDTH-1 downto 0);     --
      mm2s_strm_wstrb         : Out  std_logic_vector((C_MM2S_SDATA_WIDTH/8)-1 downto 0); --
      mm2s_strm_wlast         : Out  std_logic;                                           --
      mm2s_strm_wvalid        : Out  std_logic;                                           --
      mm2s_strm_wready        : In   std_logic;                                           --
      --------------------------------------------------------------------------------------
  
      
      -- Testing Support I/O --------------------------------------------
      mm2s_dbg_sel            : in  std_logic_vector( 3 downto 0);     --
      mm2s_dbg_data           : out std_logic_vector(31 downto 0)      --
      -------------------------------------------------------------------
      
      
      );
  
  end entity axi_datamover_mm2s_basic_wrap;
  
  
  architecture implementation of axi_datamover_mm2s_basic_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    -- Function Declarations   ----------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_calc_rdmux_sel_bits
    --
    -- Function Description:
    --  This function calculates the number of address bits needed for  
    -- the Read data mux select control. 
    --
    -------------------------------------------------------------------
    function func_calc_rdmux_sel_bits (mmap_dwidth_value : integer) return integer is
    
      Variable num_addr_bits_needed : Integer range 1 to 5 := 1;
    
    begin
    
      case mmap_dwidth_value is
        when 32 =>
          num_addr_bits_needed := 2;
        when 64 =>
          num_addr_bits_needed := 3;
        when 128 =>
          num_addr_bits_needed := 4;
        when others => -- 256 bits
          num_addr_bits_needed := 5;
      end case;
      
      Return (num_addr_bits_needed);
       
    end function func_calc_rdmux_sel_bits;
    
     
     
     
    -- Constant Declarations   ----------------------------------------
    
     Constant LOGIC_LOW               : std_logic := '0';
     Constant LOGIC_HIGH              : std_logic := '1';
     Constant INCLUDE_MM2S            : integer range  0 to   2 :=  2;
     Constant MM2S_ARID_VALUE         : integer range  0 to 255 := C_MM2S_ARID;
     Constant MM2S_ARID_WIDTH         : integer range  1 to  8  := C_MM2S_ID_WIDTH;
     Constant MM2S_ADDR_WIDTH         : integer range 32 to  64 := C_MM2S_ADDR_WIDTH;
     Constant MM2S_MDATA_WIDTH        : integer range 32 to 256 := C_MM2S_MDATA_WIDTH;
     Constant MM2S_SDATA_WIDTH        : integer range  8 to 256 := C_MM2S_SDATA_WIDTH;
     Constant MM2S_CMD_WIDTH          : integer                 := (C_TAG_WIDTH+C_MM2S_ADDR_WIDTH+32);
     Constant MM2S_STS_WIDTH          : integer                 := 8; -- always 8 for MM2S
     Constant INCLUDE_MM2S_STSFIFO    : integer range  0 to   1 :=  1;
     Constant MM2S_STSCMD_FIFO_DEPTH  : integer range  1 to  64 :=  C_MM2S_STSCMD_FIFO_DEPTH;
     Constant MM2S_STSCMD_IS_ASYNC    : integer range  0 to   1 :=  C_MM2S_STSCMD_IS_ASYNC;
     Constant INCLUDE_MM2S_DRE        : integer range  0 to   1 :=  0;
     Constant DRE_ALIGN_WIDTH         : integer range  1 to   3 :=  2;
     Constant MM2S_BURST_SIZE         : integer range 16 to 256 := 16;
     Constant RD_ADDR_CNTL_FIFO_DEPTH : integer range  1 to  30 := C_MM2S_ADDR_PIPE_DEPTH;  
     Constant RD_DATA_CNTL_FIFO_DEPTH : integer range  1 to  30 := C_MM2S_ADDR_PIPE_DEPTH; 
     Constant SEL_ADDR_WIDTH          : integer := func_calc_rdmux_sel_bits(MM2S_MDATA_WIDTH);
     Constant DRE_ALIGN_ZEROS         : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     -- obsoleted   Constant DISABLE_WAIT_FOR_DATA   : integer := 0;
     
        
    
    -- Signal Declarations  ------------------------------------------
    
     signal sig_cmd_stat_rst_user        : std_logic := '0';
     signal sig_cmd_stat_rst_int         : std_logic := '0';
     signal sig_mmap_rst                 : std_logic := '0';
     signal sig_stream_rst               : std_logic := '0';
     signal sig_mm2s_cmd_wdata           : std_logic_vector(MM2S_CMD_WIDTH-1 downto 0);        
     signal sig_mm2s_cache_data          : std_logic_vector(7 downto 0);        
     signal sig_cmd2mstr_command         : std_logic_vector(MM2S_CMD_WIDTH-1 downto 0) := (others => '0');        
     signal sig_cmd2mstr_cmd_valid       : std_logic := '0';                                             
     signal sig_mst2cmd_cmd_ready        : std_logic := '0';                                             
     signal sig_mstr2addr_addr           : std_logic_vector(MM2S_ADDR_WIDTH-1 downto 0) := (others => '0');             
     signal sig_mstr2addr_len            : std_logic_vector(7 downto 0) := (others => '0');                          
     signal sig_mstr2addr_size           : std_logic_vector(2 downto 0) := (others => '0');                          
     signal sig_mstr2addr_burst          : std_logic_vector(1 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cache          : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_user          : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2addr_calc_error     : std_logic := '0';
     signal sig_mstr2addr_cmd_valid      : std_logic := '0';                                             
     signal sig_addr2mstr_cmd_ready      : std_logic := '0';                                              
     signal sig_mstr2data_saddr_lsb      : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_len            : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_mstr2data_strt_strb      : std_logic_vector((MM2S_SDATA_WIDTH/8)-1 downto 0) := (others => '0');      
     signal sig_mstr2data_last_strb      : std_logic_vector((MM2S_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_mstr2data_drr            : std_logic := '0';
     signal sig_mstr2data_eof            : std_logic := '0';
     signal sig_mstr2data_sequential     : std_logic := '0';
     signal sig_mstr2data_calc_error     : std_logic := '0';
     signal sig_mstr2data_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2data_cmd_valid      : std_logic := '0';                                             
     signal sig_data2mstr_cmd_ready      : std_logic := '0';                                               
     signal sig_addr2data_addr_posted    : std_logic := '0';
     signal sig_data2all_dcntlr_halted   : std_logic := '0';
     signal sig_addr2rsc_calc_error      : std_logic := '0';
     signal sig_addr2rsc_cmd_fifo_empty  : std_logic := '0';
     signal sig_data2rsc_tag             : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2rsc_calc_err        : std_logic := '0';                     
     signal sig_data2rsc_okay            : std_logic := '0';
     signal sig_data2rsc_decerr          : std_logic := '0';
     signal sig_data2rsc_slverr          : std_logic := '0';
     signal sig_data2rsc_cmd_cmplt       : std_logic := '0';
     signal sig_rsc2data_ready           : std_logic := '0';
     signal sig_data2rsc_valid           : std_logic := '0';
     signal sig_calc2dm_calc_err         : std_logic := '0';
     signal sig_data2skid_wvalid         : std_logic := '0';                                     
     signal sig_data2skid_wready         : std_logic := '0';                                     
     signal sig_data2skid_wdata          : std_logic_vector(MM2S_SDATA_WIDTH-1 downto 0) := (others => '0');     
     signal sig_data2skid_wstrb          : std_logic_vector((MM2S_SDATA_WIDTH/8)-1 downto 0) := (others => '0'); 
     signal sig_data2skid_wlast          : std_logic := '0';                                     
     signal sig_rsc2stat_status          : std_logic_vector(MM2S_STS_WIDTH-1 downto 0) := (others => '0');
     signal sig_stat2rsc_status_ready    : std_logic := '0';   
     signal sig_rsc2stat_status_valid    : std_logic := '0';  
     signal sig_rsc2mstr_halt_pipe       : std_logic := '0';  
     signal sig_mstr2data_tag            : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2addr_tag            : std_logic_vector(C_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_dbg_data_mux_out         : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_0               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_1               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_rst2all_stop_request     : std_logic := '0';
     signal sig_data2rst_stop_cmplt      : std_logic := '0';
     signal sig_addr2rst_stop_cmplt      : std_logic := '0';
     signal sig_data2addr_stop_req       : std_logic := '0';
     signal sig_data2skid_halt           : std_logic := '0';

    signal sig_cache2mstr_command       : std_logic_vector (7 downto 0);
     signal mm2s_arcache_int             : std_logic_vector (3 downto 0);

    
    
    
  begin --(architecture implementation)
 
 
  
    -- Debug Support ------------------------------------------
    
    mm2s_dbg_data  <= sig_dbg_data_mux_out;
    
    
    -- Note that only the mm2s_dbg_sel(0) is used at this time
    sig_dbg_data_mux_out <= sig_dbg_data_1
      When (mm2s_dbg_sel(0) = '1')
      else sig_dbg_data_0 ;
    
    
    sig_dbg_data_0              <=  X"BEEF2222"             ;    -- 32 bit Constant indicating MM2S Basic type
    
    sig_dbg_data_1(0)           <= sig_cmd_stat_rst_user    ;
    sig_dbg_data_1(1)           <= sig_cmd_stat_rst_int     ;
    sig_dbg_data_1(2)           <= sig_mmap_rst             ;
    sig_dbg_data_1(3)           <= sig_stream_rst           ;
    sig_dbg_data_1(4)           <= sig_cmd2mstr_cmd_valid   ;
    sig_dbg_data_1(5)           <= sig_mst2cmd_cmd_ready    ;
    sig_dbg_data_1(6)           <= sig_stat2rsc_status_ready;
    sig_dbg_data_1(7)           <= sig_rsc2stat_status_valid;
    sig_dbg_data_1(11 downto 8) <= sig_data2rsc_tag         ; -- Current TAG of active data transfer
                        

    sig_dbg_data_1(15 downto 12) <= sig_rsc2stat_status(3 downto 0); -- Internal status tag field
    sig_dbg_data_1(16)           <= sig_rsc2stat_status(4)         ; -- Internal error
    sig_dbg_data_1(17)           <= sig_rsc2stat_status(5)         ; -- Decode Error
    sig_dbg_data_1(18)           <= sig_rsc2stat_status(6)         ; -- Slave Error
    sig_dbg_data_1(19)           <= sig_rsc2stat_status(7)         ; -- OKAY
    sig_dbg_data_1(20)           <= sig_stat2rsc_status_ready      ; -- Status Ready Handshake
    sig_dbg_data_1(21)           <= sig_rsc2stat_status_valid      ; -- Status Valid Handshake
                        
    
    -- Spare bits in debug1
    sig_dbg_data_1(31 downto 22) <= (others => '0')                ; -- spare bits
                        
                        
                        
                        
                        
    
    GEN_CACHE : if (C_ENABLE_CACHE_USER = 0) generate

       begin
 
    -- Cache signal tie-off
    mm2s_arcache       <= "0011";  -- Per Interface-X guidelines for Masters
    mm2s_aruser        <= "0000";  -- Per Interface-X guidelines for Masters
    sig_mm2s_cache_data <= (others => '0'); --mm2s_cmd_wdata(103 downto 96);
     
       end generate GEN_CACHE;                 


    GEN_CACHE2 : if (C_ENABLE_CACHE_USER = 1) generate

       begin
 
    -- Cache signal tie-off
    mm2s_arcache       <= "0011"; --sg_ctl (3 downto 0);  -- SG Cache from register
    mm2s_aruser        <= "0000";--sg_ctl (7 downto 4);  -- Per Interface-X guidelines for Masters
  --  sig_mm2s_cache_data <= mm2s_cmd_wdata(103 downto 96);
    sig_mm2s_cache_data <= mm2s_cmd_wdata(79+(C_MM2S_ADDR_WIDTH-32) downto 72+(C_MM2S_ADDR_WIDTH-32));
     
       end generate GEN_CACHE2;                 
    
    -- Cache signal tie-off
     
                        
                       
    -- Internal error output discrete ------------------------------
    mm2s_err                <=  sig_calc2dm_calc_err;
     
     
    -- Rip the used portion of the Command Interface Command Data
    -- and throw away the padding
    sig_mm2s_cmd_wdata <= mm2s_cmd_wdata(MM2S_CMD_WIDTH-1 downto 0);
     
     
          
   ------------------------------------------------------------
   -- Instance: I_RESET 
   --
   -- Description:
   --   Reset Block  
   --
   ------------------------------------------------------------
    I_RESET : entity axi_datamover_v5_1_17.axi_datamover_reset
    generic map (
  
      C_STSCMD_IS_ASYNC    =>  MM2S_STSCMD_IS_ASYNC       
  
      )
    port map (
  
      primary_aclk         =>  mm2s_aclk                , 
      primary_aresetn      =>  mm2s_aresetn             , 
      secondary_awclk      =>  mm2s_cmdsts_awclk        , 
      secondary_aresetn    =>  mm2s_cmdsts_aresetn      , 
      halt_req             =>  mm2s_halt                , 
      halt_cmplt           =>  mm2s_halt_cmplt          , 
      flush_stop_request   =>  sig_rst2all_stop_request , 
      data_cntlr_stopped   =>  sig_data2rst_stop_cmplt  , 
      addr_cntlr_stopped   =>  sig_addr2rst_stop_cmplt  , 
      aux1_stopped         =>  LOGIC_HIGH               , 
      aux2_stopped         =>  LOGIC_HIGH               , 
      cmd_stat_rst_user    =>  sig_cmd_stat_rst_user    , 
      cmd_stat_rst_int     =>  sig_cmd_stat_rst_int     , 
      mmap_rst             =>  sig_mmap_rst             , 
      stream_rst           =>  sig_stream_rst             
  
      );
  
  
  


        
   ------------------------------------------------------------
   -- Instance: I_CMD_STATUS 
   --
   -- Description:
   --   Command and Status Interface Block  
   --
   ------------------------------------------------------------
    I_CMD_STATUS : entity axi_datamover_v5_1_17.axi_datamover_cmd_status
    generic map (
  
      C_ADDR_WIDTH           =>  MM2S_ADDR_WIDTH           ,    
      C_INCLUDE_STSFIFO      =>  INCLUDE_MM2S_STSFIFO      ,    
      C_STSCMD_FIFO_DEPTH    =>  MM2S_STSCMD_FIFO_DEPTH    ,    
      C_STSCMD_IS_ASYNC      =>  MM2S_STSCMD_IS_ASYNC      ,    
      C_CMD_WIDTH            =>  MM2S_CMD_WIDTH            ,    
      C_STS_WIDTH            =>  MM2S_STS_WIDTH            ,    
      C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER       ,
      C_FAMILY               =>  C_FAMILY                      

      )
    port map (
  
      primary_aclk           =>  mm2s_aclk                 ,   
      secondary_awclk        =>  mm2s_cmdsts_awclk         ,   
      user_reset             =>  sig_cmd_stat_rst_user     ,   
      internal_reset         =>  sig_cmd_stat_rst_int      ,   
      cmd_wvalid             =>  mm2s_cmd_wvalid           ,   
      cmd_wready             =>  mm2s_cmd_wready           ,   
      cmd_wdata              =>  sig_mm2s_cmd_wdata        ,   
      cache_data             =>  sig_mm2s_cache_data       ,
      sts_wvalid             =>  mm2s_sts_wvalid           ,   
      sts_wready             =>  mm2s_sts_wready           ,   
      sts_wdata              =>  mm2s_sts_wdata            ,   
      sts_wstrb              =>  mm2s_sts_wstrb            ,   
      sts_wlast              =>  mm2s_sts_wlast            ,   
      cmd2mstr_command       =>  sig_cmd2mstr_command      ,   
      mst2cmd_cmd_valid      =>  sig_cmd2mstr_cmd_valid    ,   
      cmd2mstr_cmd_ready     =>  sig_mst2cmd_cmd_ready     ,   
      mstr2stat_status       =>  sig_rsc2stat_status       ,   
      stat2mstr_status_ready =>  sig_stat2rsc_status_ready ,   
      mst2stst_status_valid  =>  sig_rsc2stat_status_valid     
  
      );
  
  
  


        
   ------------------------------------------------------------
   -- Instance: I_RD_STATUS_CNTLR 
   --
   -- Description:
   -- Read Status Controller Block    
   --
   ------------------------------------------------------------
    I_RD_STATUS_CNTLR : entity axi_datamover_v5_1_17.axi_datamover_rd_status_cntl
    generic map (
  
      C_STS_WIDTH            =>  MM2S_STS_WIDTH              , 
      C_TAG_WIDTH            =>  C_TAG_WIDTH                   

      )
    port map (
  
      primary_aclk           =>  mm2s_aclk                   , 
      mmap_reset             =>  sig_mmap_rst                , 
      calc2rsc_calc_error    =>  sig_calc2dm_calc_err        , 
      addr2rsc_calc_error    =>  sig_addr2rsc_calc_error     , 
      addr2rsc_fifo_empty    =>  sig_addr2rsc_cmd_fifo_empty , 
      data2rsc_tag           =>  sig_data2rsc_tag            , 
      data2rsc_calc_error    =>  sig_data2rsc_calc_err       , 
      data2rsc_okay          =>  sig_data2rsc_okay           , 
      data2rsc_decerr        =>  sig_data2rsc_decerr         , 
      data2rsc_slverr        =>  sig_data2rsc_slverr         , 
      data2rsc_cmd_cmplt     =>  sig_data2rsc_cmd_cmplt      , 
      rsc2data_ready         =>  sig_rsc2data_ready          , 
      data2rsc_valid         =>  sig_data2rsc_valid          , 
      rsc2stat_status        =>  sig_rsc2stat_status         , 
      stat2rsc_status_ready  =>  sig_stat2rsc_status_ready   , 
      rsc2stat_status_valid  =>  sig_rsc2stat_status_valid   , 
      rsc2mstr_halt_pipe     =>  sig_rsc2mstr_halt_pipe        
    
      );
  
  
  


        
  ------------------------------------------------------------
  -- Instance: I_MSTR_SCC 
  --
  -- Description:
  -- Simple Command Calculator Block   
  --
  ------------------------------------------------------------
   I_MSTR_SCC : entity axi_datamover_v5_1_17.axi_datamover_scc
   generic map (
 
     C_SEL_ADDR_WIDTH     =>  SEL_ADDR_WIDTH           , 
     C_ADDR_WIDTH         =>  MM2S_ADDR_WIDTH          , 
     C_STREAM_DWIDTH      =>  MM2S_SDATA_WIDTH         , 
     C_MAX_BURST_LEN      =>  C_MM2S_BURST_SIZE        , 
     C_CMD_WIDTH          =>  MM2S_CMD_WIDTH           , 
     C_MICRO_DMA          =>  C_MICRO_DMA              ,
     C_TAG_WIDTH          =>  C_TAG_WIDTH                
 
     )
   port map (
 
     -- Clock input
     primary_aclk         =>  mm2s_aclk                , 
     mmap_reset           =>  sig_mmap_rst             , 
     cmd2mstr_command     =>  sig_cmd2mstr_command     , 
     cache2mstr_command     =>  sig_cache2mstr_command     , 
     cmd2mstr_cmd_valid   =>  sig_cmd2mstr_cmd_valid   , 
     mst2cmd_cmd_ready    =>  sig_mst2cmd_cmd_ready    , 
     mstr2addr_tag        =>  sig_mstr2addr_tag        , 
     mstr2addr_addr       =>  sig_mstr2addr_addr       , 
     mstr2addr_len        =>  sig_mstr2addr_len        , 
     mstr2addr_size       =>  sig_mstr2addr_size       , 
     mstr2addr_burst      =>  sig_mstr2addr_burst      , 
     mstr2addr_calc_error =>  sig_mstr2addr_calc_error , 
     mstr2addr_cmd_cmplt  =>  sig_mstr2addr_cmd_cmplt  , 
     mstr2addr_cmd_valid  =>  sig_mstr2addr_cmd_valid  , 
     addr2mstr_cmd_ready  =>  sig_addr2mstr_cmd_ready  , 
     mstr2data_tag        =>  sig_mstr2data_tag        , 
     mstr2data_saddr_lsb  =>  sig_mstr2data_saddr_lsb  , 
     mstr2data_len        =>  sig_mstr2data_len        , 
     mstr2data_strt_strb  =>  sig_mstr2data_strt_strb  , 
     mstr2data_last_strb  =>  sig_mstr2data_last_strb  , 
     mstr2data_sof        =>  sig_mstr2data_drr        , 
     mstr2data_eof        =>  sig_mstr2data_eof        , 
     mstr2data_calc_error =>  sig_mstr2data_calc_error , 
     mstr2data_cmd_cmplt  =>  sig_mstr2data_cmd_cmplt  , 
     mstr2data_cmd_valid  =>  sig_mstr2data_cmd_valid  , 
     data2mstr_cmd_ready  =>  sig_data2mstr_cmd_ready  , 
     calc_error           =>  sig_calc2dm_calc_err       
     
     );
  
  
  


        
   ------------------------------------------------------------
   -- Instance: I_ADDR_CNTL 
   --
   -- Description:
   --   Address Controller Block  
   --
   ------------------------------------------------------------
    I_ADDR_CNTL : entity axi_datamover_v5_1_17.axi_datamover_addr_cntl
    generic map (
  
      -- obsoleted   C_ENABlE_WAIT_FOR_DATA   =>  DISABLE_WAIT_FOR_DATA       ,  
      --C_ADDR_FIFO_DEPTH        =>  MM2S_STSCMD_FIFO_DEPTH      ,  
      C_ADDR_FIFO_DEPTH        =>  RD_ADDR_CNTL_FIFO_DEPTH     ,
      C_ADDR_WIDTH             =>  MM2S_ADDR_WIDTH             ,  
      C_ADDR_ID                =>  MM2S_ARID_VALUE             ,  
      C_ADDR_ID_WIDTH          =>  MM2S_ARID_WIDTH             ,  
      C_TAG_WIDTH              =>  C_TAG_WIDTH                 ,    
      C_FAMILY               =>  C_FAMILY
  
      )
    port map (
  
      primary_aclk             =>  mm2s_aclk                   ,  
      mmap_reset               =>  sig_mmap_rst                ,  
      addr2axi_aid             =>  mm2s_arid                   ,  
      addr2axi_aaddr           =>  mm2s_araddr                 ,  
      addr2axi_alen            =>  mm2s_arlen                  ,  
      addr2axi_asize           =>  mm2s_arsize                 ,  
      addr2axi_aburst          =>  mm2s_arburst                ,  
      addr2axi_aprot           =>  mm2s_arprot                 ,  
      addr2axi_avalid          =>  mm2s_arvalid                ,  
      addr2axi_acache           =>  open                        , 
      addr2axi_auser            =>  open                        , 
      axi2addr_aready          =>  mm2s_arready                ,  
      
      mstr2addr_tag            =>  sig_mstr2addr_tag           ,  
      mstr2addr_addr           =>  sig_mstr2addr_addr          ,  
      mstr2addr_len            =>  sig_mstr2addr_len           ,  
      mstr2addr_size           =>  sig_mstr2addr_size          ,  
      mstr2addr_burst          =>  sig_mstr2addr_burst         ,  
      mstr2addr_cache          =>  sig_mstr2addr_cache         ,  
      mstr2addr_user           =>  sig_mstr2addr_user          ,  
      mstr2addr_cmd_cmplt      =>  sig_mstr2addr_cmd_cmplt     ,  
      mstr2addr_calc_error     =>  sig_mstr2addr_calc_error    ,  
      mstr2addr_cmd_valid      =>  sig_mstr2addr_cmd_valid     ,  
      addr2mstr_cmd_ready      =>  sig_addr2mstr_cmd_ready     ,  
      
      addr2rst_stop_cmplt      =>  sig_addr2rst_stop_cmplt     ,  
       
      allow_addr_req           =>  mm2s_allow_addr_req         ,
      addr_req_posted          =>  mm2s_addr_req_posted        ,
       
      addr2data_addr_posted    =>  sig_addr2data_addr_posted   ,  
      data2addr_data_rdy       =>  LOGIC_LOW                   ,  
      data2addr_stop_req       =>  sig_data2addr_stop_req      ,  
      
      addr2stat_calc_error     =>  sig_addr2rsc_calc_error     ,  
      addr2stat_cmd_fifo_empty =>  sig_addr2rsc_cmd_fifo_empty    
      );
  
  
  


        
    ------------------------------------------------------------
    -- Instance: I_RD_DATA_CNTL 
    --
    -- Description:
    --     Read Data Controller Block
    --
    ------------------------------------------------------------
     I_RD_DATA_CNTL : entity axi_datamover_v5_1_17.axi_datamover_rddata_cntl
     generic map (
   
       C_INCLUDE_DRE           =>  INCLUDE_MM2S_DRE         ,  
       C_ALIGN_WIDTH           =>  DRE_ALIGN_WIDTH          ,  
       C_SEL_ADDR_WIDTH        =>  SEL_ADDR_WIDTH           ,  
       C_DATA_CNTL_FIFO_DEPTH  =>  RD_DATA_CNTL_FIFO_DEPTH  ,  
       C_MMAP_DWIDTH           =>  MM2S_MDATA_WIDTH         ,  
       C_STREAM_DWIDTH         =>  MM2S_SDATA_WIDTH         ,  
       C_TAG_WIDTH             =>  C_TAG_WIDTH              ,  
       C_FAMILY                =>  C_FAMILY                    
   
       )
     port map (
   
       -- Clock and Reset  -----------------------------------
       primary_aclk           =>  mm2s_aclk                 ,  
       mmap_reset             =>  sig_mmap_rst              ,  
     
       -- Soft Shutdown Interface -----------------------------
       rst2data_stop_request  =>  sig_rst2all_stop_request  ,  
       data2addr_stop_req     =>  sig_data2addr_stop_req    ,  
       data2rst_stop_cmplt    =>  sig_data2rst_stop_cmplt   ,  
        
       -- External Address Pipelining Contol support
       mm2s_rd_xfer_cmplt     =>  mm2s_rd_xfer_cmplt        ,
        
        
       -- AXI Read Data Channel I/O  -------------------------------
       mm2s_rdata             =>  mm2s_rdata                ,   
       mm2s_rresp             =>  mm2s_rresp                ,   
       mm2s_rlast             =>  mm2s_rlast                ,   
       mm2s_rvalid            =>  mm2s_rvalid               ,   
       mm2s_rready            =>  mm2s_rready               ,   
       
       -- MM2S DRE Control  -----------------------------------
       mm2s_dre_new_align     =>  open                      ,   
       mm2s_dre_use_autodest  =>  open                      ,   
       mm2s_dre_src_align     =>  open                      ,   
       mm2s_dre_dest_align    =>  open                      ,   
       mm2s_dre_flush         =>  open                      ,   
       
       -- AXI Master Stream  -----------------------------------
       mm2s_strm_wvalid       =>  sig_data2skid_wvalid      ,  
       mm2s_strm_wready       =>  sig_data2skid_wready      ,  
       mm2s_strm_wdata        =>  sig_data2skid_wdata       ,       
       mm2s_strm_wstrb        =>  sig_data2skid_wstrb       ,           
       mm2s_strm_wlast        =>  sig_data2skid_wlast       ,  
  
      -- MM2S Store and Forward Supplimental Control -----------
       mm2s_data2sf_cmd_cmplt  => open                      ,                               
                                                                                     
  
       
       -- Command Calculator Interface --------------------------
       mstr2data_tag          =>  sig_mstr2data_tag         ,  
       mstr2data_saddr_lsb    =>  sig_mstr2data_saddr_lsb   ,  
       mstr2data_len          =>  sig_mstr2data_len         ,  
       mstr2data_strt_strb    =>  sig_mstr2data_strt_strb   ,  
       mstr2data_last_strb    =>  sig_mstr2data_last_strb   ,  
       mstr2data_drr          =>  sig_mstr2data_drr         ,  
       mstr2data_eof          =>  sig_mstr2data_eof         ,  
       mstr2data_sequential   =>  LOGIC_LOW                 ,  
       mstr2data_calc_error   =>  sig_mstr2data_calc_error  ,  
       mstr2data_cmd_cmplt    =>  sig_mstr2data_cmd_cmplt   ,  
       mstr2data_cmd_valid    =>  sig_mstr2data_cmd_valid   ,  
       data2mstr_cmd_ready    =>  sig_data2mstr_cmd_ready   ,  
       mstr2data_dre_src_align  => DRE_ALIGN_ZEROS          ,  
       mstr2data_dre_dest_align => DRE_ALIGN_ZEROS          ,  
       
       -- Address Controller Interface --------------------------
       addr2data_addr_posted  =>  sig_addr2data_addr_posted , 
       
       -- Data Controller Halted Status
       data2all_dcntlr_halted =>  sig_data2all_dcntlr_halted, 
        
       -- Output Stream Skid Buffer Halt control
       data2skid_halt         =>  sig_data2skid_halt        , 
        
        
       -- Read Status Controller Interface --------------------------
       data2rsc_tag           =>  sig_data2rsc_tag          , 
       data2rsc_calc_err      =>  sig_data2rsc_calc_err     , 
       data2rsc_okay          =>  sig_data2rsc_okay         , 
       data2rsc_decerr        =>  sig_data2rsc_decerr       , 
       data2rsc_slverr        =>  sig_data2rsc_slverr       , 
       data2rsc_cmd_cmplt     =>  sig_data2rsc_cmd_cmplt    , 
       rsc2data_ready         =>  sig_rsc2data_ready        , 
       data2rsc_valid         =>  sig_data2rsc_valid        , 
       rsc2mstr_halt_pipe     =>  sig_rsc2mstr_halt_pipe      
        
       );
  
  
  

ENABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(5) = '1' generate
begin 
        
    ------------------------------------------------------------
    -- Instance: I_MM2S_SKID_BUF 
    --
    -- Description:
    --   Instance for the MM2S Skid Buffer which provides for
    -- registerd Master Stream outputs and supports bi-dir
    -- throttling.  
    --
    ------------------------------------------------------------
     I_MM2S_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
     generic map (
        
       C_WDATA_WIDTH  =>  MM2S_SDATA_WIDTH        
   
       )
     port map (
   
       -- System Ports
       aclk           =>  mm2s_aclk             ,  
       arst           =>  sig_stream_rst        ,  
     
        -- Shutdown control (assert for 1 clk pulse)
       skid_stop      =>  sig_data2skid_halt    ,  
     
       -- Slave Side (Stream Data Input) 
       s_valid        =>  sig_data2skid_wvalid  ,  
       s_ready        =>  sig_data2skid_wready  ,  
       s_data         =>  sig_data2skid_wdata   ,  
       s_strb         =>  sig_data2skid_wstrb   ,  
       s_last         =>  sig_data2skid_wlast   ,  

       -- Master Side (Stream Data Output 
       m_valid        =>  mm2s_strm_wvalid      ,  
       m_ready        =>  mm2s_strm_wready      ,  
       m_data         =>  mm2s_strm_wdata       ,  
       m_strb         =>  mm2s_strm_wstrb       ,  
       m_last         =>  mm2s_strm_wlast          
   
       );
   
end generate ENABLE_AXIS_SKID;
  
    
DISABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(5) = '0' generate
begin 

   mm2s_strm_wvalid <= sig_data2skid_wvalid;
   sig_data2skid_wready <= mm2s_strm_wready;
   mm2s_strm_wdata <= sig_data2skid_wdata;
   mm2s_strm_wstrb <= sig_data2skid_wstrb; 
   mm2s_strm_wlast <= sig_data2skid_wlast;
   

end generate DISABLE_AXIS_SKID; 
    
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_mm2s_omit_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_mm2s_omit_wrap.vhd
  --
  -- Description:     
  --    This file implements the DataMover MM2S Omit Wrapper.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_mm2s_omit_wrap is
    generic (
      
      C_INCLUDE_MM2S     : Integer range 0 to  2 :=  0;
         -- Specifies the type of MM2S function to include
         -- 0 = Omit MM2S functionality
         -- 1 = Full MM2S Functionality
         -- 2 = Lite MM2S functionality
         
      C_MM2S_ARID        : Integer range 0 to 255 :=  8;
         -- Specifies the constant value to output on 
         -- the ARID output port
         
      C_MM2S_ID_WIDTH    : Integer range 1 to  8 :=  4;
         -- Specifies the width of the MM2S ID port 
         
      C_MM2S_ADDR_WIDTH  : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel 
         -- Address bus
         
      C_MM2S_MDATA_WIDTH : Integer range 32 to 1024 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus
      
      C_MM2S_SDATA_WIDTH : Integer range 8 to 1024 :=  32;
         -- Specifies the width of the MM2S Master Stream Data 
         -- Channel data bus
                              
      C_INCLUDE_MM2S_STSFIFO    : Integer range 0 to  1 :=  0;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit MM2S Status FIFO
         -- 1 = Include MM2S Status FIFO
         
      C_MM2S_STSCMD_FIFO_DEPTH  : Integer range 1 to 16 :=  4;
         -- Specifies the depth of the MM2S Command FIFO and the 
         -- optional Status FIFO
         -- Valid values are 1,4,8,16
         
      C_MM2S_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces
         
      C_INCLUDE_MM2S_DRE : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the MM2S function 
         -- 0 = Omit DRE
         -- 1 = Include DRE
      
      C_MM2S_BURST_SIZE  : Integer range 2 to  256 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the MM2S function 
    
      C_MM2S_BTT_USED            : Integer range 8 to  26 :=  16;
        -- Specifies the number of bits used from the BTT field
        -- of the input Command Word of the MM2S Command Interface 
    
      C_MM2S_ADDR_PIPE_DEPTH     : Integer range 1 to 30 := 1;
        -- This parameter specifies the depth of the MM2S internal 
        -- child command queues in the Read Address Controller and 
        -- the Read Data Controller. Increasing this value will 
        -- allow more Read Addresses to be issued to the AXI4 Read 
        -- Address Channel before receipt of the associated read 
        -- data on the Read Data Channel.

      C_TAG_WIDTH        : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field

      C_ENABLE_CACHE_USER    : Integer range 0 to 1 := 0;
      C_MCDMA                : integer range 0 to 1 := 0;

         
      C_FAMILY : String := "virtex7"
         -- Specifies the target FPGA family type
      
      );
    port (
      
      
      -- MM2S Primary Clock input --------------------------------
      mm2s_aclk               : in  std_logic;                 --
         -- Primary synchronization clock for the Master side  --
         -- interface and internal logic. It is also used      --
         -- for the User interface synchronization when        --
         -- C_STSCMD_IS_ASYNC = 0.                             --
                                                               --
      -- MM2S Primary Reset input                              --
      mm2s_aresetn            : in  std_logic;                 --
         -- Reset used for the internal master logic           --
      -----------------------------------------------------------
      
 
     
      -- MM2S Halt request input control-------------------------
      mm2s_halt               : in  std_logic;                 --
         -- Active high soft shutdown request                  --
                                                               --
      -- MM2S Halt Complete status flag                        --
      mm2s_halt_cmplt         : Out  std_logic;                --
         -- Active high soft shutdown complete status          --
      -----------------------------------------------------------
      
      
      
      -- Error discrete output ----------------------------------
      mm2s_err                : Out std_logic;                 --
         -- Composite Error indication                         --
      -----------------------------------------------------------
     
     
     
      -- Optional MM2S Command and Status clock and Reset -----------
      -- Only used when C_MM2S_STSCMD_IS_ASYNC = 1                 --
      mm2s_cmdsts_awclk       : in  std_logic;                     --
      -- Secondary Clock input for async CMD/Status interface      --
                                                                   --
      mm2s_cmdsts_aresetn     : in  std_logic;                     --
        -- Secondary Reset input for async CMD/Status interface    --
      ---------------------------------------------------------------
      
      
      -- User Command Interface Ports (AXI Stream) ----------------------------------------------------
      mm2s_cmd_wvalid         : in  std_logic;                                                       --
      mm2s_cmd_wready         : out std_logic;                                                       --
      mm2s_cmd_wdata          : in  std_logic_vector((C_MCDMA*3+C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_MM2S_ADDR_WIDTH+36)-1 downto 0); --
      -------------------------------------------------------------------------------------------------
      
      -- User Status Interface Ports (AXI Stream) --------------------
      mm2s_sts_wvalid         : out std_logic;                      --
      mm2s_sts_wready         : in  std_logic;                      --
      mm2s_sts_wdata          : out std_logic_vector(7 downto 0);   --
      mm2s_sts_wstrb          : out std_logic_vector(0 downto 0);   --
      mm2s_sts_wlast          : out std_logic;                      --
      ----------------------------------------------------------------
      
      
      -- Address Posting contols -------------------------------------
      mm2s_allow_addr_req     : in  std_logic;                      --
      mm2s_addr_req_posted    : out std_logic;                      --
      mm2s_rd_xfer_cmplt      : out std_logic;                      --
      ----------------------------------------------------------------
      
      
      
      -- MM2S AXI Address Channel I/O  --------------------------------------
      mm2s_arid     : out std_logic_vector(C_MM2S_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                  --
                                                                           --
      mm2s_araddr   : out std_logic_vector(C_MM2S_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                             --
                                                                           --
      mm2s_arlen    : out std_logic_vector(7 downto 0);                    --
         -- AXI Address Channel LEN output                                 --
         -- Sized to support 256 data beat bursts                          --
                                                                           --
      mm2s_arsize   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel SIZE output                                --
                                                                           --
      mm2s_arburst  : out std_logic_vector(1 downto 0);                    --
         -- AXI Address Channel BURST output                               --
                                                                           --
      mm2s_arprot   : out std_logic_vector(2 downto 0);                    --
         -- AXI Address Channel PROT output                                --
                                                                           --
      mm2s_arcache  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel CACHE output                               --

      mm2s_aruser  : out std_logic_vector(3 downto 0);                    --
         -- AXI Address Channel USER output                               --
                                                                           --
      mm2s_arvalid  : out std_logic;                                       --
         -- AXI Address Channel VALID output                               --
                                                                           --
      mm2s_arready  : in  std_logic;                                       --
         -- AXI Address Channel READY input                                --
      -----------------------------------------------------------------------
      
        
      -- Currently unsupported AXI Address Channel output signals -----------
        -- addr2axi_alock   : out std_logic_vector(2 downto 0);            --
        -- addr2axi_acache  : out std_logic_vector(4 downto 0);            --
        -- addr2axi_aqos    : out std_logic_vector(3 downto 0);            --
        -- addr2axi_aregion : out std_logic_vector(3 downto 0);            --
      -----------------------------------------------------------------------
  
  
      
      -- MM2S AXI MMap Read Data Channel I/O  ------------------------------------------
      mm2s_rdata              : In  std_logic_vector(C_MM2S_MDATA_WIDTH-1 downto 0);  --
      mm2s_rresp              : In  std_logic_vector(1 downto 0);                     --
      mm2s_rlast              : In  std_logic;                                        --
      mm2s_rvalid             : In  std_logic;                                        --
      mm2s_rready             : Out std_logic;                                        --
      ----------------------------------------------------------------------------------
      
      
      
      -- MM2S AXI Master Stream Channel I/O  -----------------------------------------------
      mm2s_strm_wdata         : Out  std_logic_vector(C_MM2S_SDATA_WIDTH-1 downto 0);     --
      mm2s_strm_wstrb         : Out  std_logic_vector((C_MM2S_SDATA_WIDTH/8)-1 downto 0); --
      mm2s_strm_wlast         : Out  std_logic;                                           --
      mm2s_strm_wvalid        : Out  std_logic;                                           --
      mm2s_strm_wready        : In   std_logic;                                           --
      --------------------------------------------------------------------------------------
      
      -- Testing Support I/O -----------------------------------------------
      mm2s_dbg_sel            : in  std_logic_vector( 3 downto 0);        --
      mm2s_dbg_data           : out std_logic_vector(31 downto 0)         --
      ----------------------------------------------------------------------
      
      
      );
  
  end entity axi_datamover_mm2s_omit_wrap;
  
  
  architecture implementation of axi_datamover_mm2s_omit_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    
    
    
    
    
    
  begin --(architecture implementation)
  
    
      mm2s_dbg_data        <=  X"BEEF0000"    ;    -- 32 bit Constant indicating OMIT type
    
    -- Just tie off output ports
      mm2s_halt_cmplt      <=  mm2s_halt      ;    
      mm2s_err             <=  '0'            ;    
      mm2s_cmd_wready      <=  '0'            ;    
      mm2s_sts_wvalid      <=  '0'            ;    
      mm2s_sts_wdata       <=  (others => '0');    
      mm2s_sts_wstrb       <=  (others => '0');    
      mm2s_sts_wlast       <=  '0'            ;    
      mm2s_arid            <=  (others => '0');    
      mm2s_araddr          <=  (others => '0');    
      mm2s_arlen           <=  (others => '0');    
      mm2s_arsize          <=  (others => '0');    
      mm2s_arburst         <=  (others => '0');    
      mm2s_arprot          <=  (others => '0');    
      mm2s_arcache         <=  (others => '0');    
      mm2s_aruser          <=  (others => '0');    
      mm2s_arvalid         <=  '0'            ;    
      mm2s_rready          <=  '0'            ;    
      mm2s_strm_wdata      <=  (others => '0');    
      mm2s_strm_wstrb      <=  (others => '0');    
      mm2s_strm_wlast      <=  '0'            ;    
      mm2s_strm_wvalid     <=  '0'            ;    
      mm2s_addr_req_posted <=  '0'            ;
      mm2s_rd_xfer_cmplt   <=  '0'            ;
    
    
    -- Input ports are ignored 
     
    
    
    
  end implementation;


  -------------------------------------------------------------------------------
  -- axi_datamover_mm2s_full_wrap.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_datamover_mm2s_full_wrap.vhd
  --
  -- Description:     
  --    This file implements the DataMover MM2S Full Wrapper.                 
  --                  
  --                  
  --                  
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  
  
  
  -- axi_datamover Library Modules
  library axi_datamover_v5_1_17; 
  use axi_datamover_v5_1_17.axi_datamover_reset;  
  use axi_datamover_v5_1_17.axi_datamover_cmd_status;
  use axi_datamover_v5_1_17.axi_datamover_pcc;
  use axi_datamover_v5_1_17.axi_datamover_addr_cntl;
  use axi_datamover_v5_1_17.axi_datamover_rddata_cntl;
  use axi_datamover_v5_1_17.axi_datamover_rd_status_cntl;
  use axi_datamover_v5_1_17.axi_datamover_mm2s_dre;
  Use axi_datamover_v5_1_17.axi_datamover_rd_sf;
  use axi_datamover_v5_1_17.axi_datamover_skid_buf;
  
  
  -------------------------------------------------------------------------------
  
  entity axi_datamover_mm2s_full_wrap is
    generic (
      
      C_INCLUDE_MM2S            : Integer range 0 to  2 :=  1;
         -- Specifies the type of MM2S function to include
         -- 0 = Omit MM2S functionality
         -- 1 = Full MM2S Functionality
         -- 2 = Lite MM2S functionality
         
      C_MM2S_ARID               : Integer range 0 to  255 :=  8;
         -- Specifies the constant value to output on 
         -- the ARID output port
         
      C_MM2S_ID_WIDTH           : Integer range 1 to  8 :=  4;
         -- Specifies the width of the MM2S ID port 
         
      C_MM2S_ADDR_WIDTH         : Integer range 32 to  64 :=  32;
         -- Specifies the width of the MMap Read Address Channel 
         -- Address bus
         
      C_MM2S_MDATA_WIDTH        : Integer range 32 to 1024 :=  32;
         -- Specifies the width of the MMap Read Data Channel
         -- data bus
      
      C_MM2S_SDATA_WIDTH        : Integer range 8 to 1024 :=  32;
         -- Specifies the width of the MM2S Master Stream Data 
         -- Channel data bus
      
      C_INCLUDE_MM2S_STSFIFO    : Integer range 0 to  1 :=  1;
         -- Specifies if a Status FIFO is to be implemented
         -- 0 = Omit MM2S Status FIFO
         -- 1 = Include MM2S Status FIFO
         
      C_MM2S_STSCMD_FIFO_DEPTH  : Integer range 1 to 16 :=  4;
         -- Specifies the depth of the MM2S Command FIFO and the 
         -- optional Status FIFO
         -- Valid values are 1,4,8,16
         
      C_MM2S_STSCMD_IS_ASYNC    : Integer range 0 to  1 :=  0;
         -- Specifies if the Status and Command interfaces need to
         -- be asynchronous to the primary data path clocking
         -- 0 = Use same clocking as data path
         -- 1 = Use special Status/Command clock for the interfaces
         
      C_INCLUDE_MM2S_DRE        : Integer range 0 to  1 :=  0;
         -- Specifies if DRE is to be included in the MM2S function 
         -- 0 = Omit DRE
         -- 1 = Include DRE
      
      C_MM2S_BURST_SIZE         : Integer range 2 to  256 :=  16;
         -- Specifies the max number of databeats to use for MMap
         -- burst transfers by the MM2S function 
    
      C_MM2S_BTT_USED           : Integer range 8 to  26 :=  16;
        -- Specifies the number of bits used from the BTT field
        -- of the input Command Word of the MM2S Command Interface 
    
      C_MM2S_ADDR_PIPE_DEPTH     : Integer range 1 to 30 := 3;
        -- This parameter specifies the depth of the MM2S internal 
        -- child command queues in the Read Address Controller and 
        -- the Read Data Controller. Increasing this value will 
        -- allow more Read Addresses to be issued to the AXI4 Read 
        -- Address Channel before receipt of the associated read 
        -- data on the Read Data Channel.

      C_TAG_WIDTH               : Integer range 1 to 8 :=  4 ;
         -- Width of the TAG field
         
      C_INCLUDE_MM2S_GP_SF      : Integer range 0 to 1 := 1 ;
        -- This parameter specifies the incllusion/omission of the
        -- MM2S (Read) Store and Forward function
        -- 0 = Omit Store and Forward
        -- 1 = Include Store and Forward
      C_ENABLE_CACHE_USER           : Integer range 0 to 1 := 1; 

    C_ENABLE_MM2S_TKEEP             : integer range 0 to 1 := 1; 


      C_ENABLE_SKID_BUF         : string := "11111";
      C_MCDMA                   : integer range 0 to 1 := 0;

      C_FAMILY                  : String := "virtex7"
         -- Specifies the target FPGA family type
      
      );
    port (
      
      
      -- MM2S Primary Clock input ---------------------------------
      mm2s_aclk         : in  std_logic;                         --
         -- Primary synchronization clock for the Master side    --
         -- interface and internal logic. It is also used        --
         -- for the User interface synchronization when          --
         -- C_STSCMD_IS_ASYNC = 0.                               --
                                                                 --
      -- MM2S Primary Reset input                                --
      mm2s_aresetn      : in  std_logic;                         --
         -- Reset used for the internal master logic             --
      -------------------------------------------------------------
 
     
      -- MM2S Halt request input control --------------------------
      mm2s_halt               : in  std_logic;                   --
         -- Active high soft shutdown request                    --
                                                                 --
      -- MM2S Halt Complete status flag                          --
      mm2s_halt_cmplt         : Out  std_logic;                  --
         -- Active high soft shutdown complete status            --
      -------------------------------------------------------------
      
      
      -- Error discrete output ------------------------------------
      mm2s_err          : Out std_logic;                         --
         -- Composite Error indication                           --
      -------------------------------------------------------------
     
     
     
      -- Optional MM2S Command and Status Clock and Reset ---------
      -- Used when C_MM2S_STSCMD_IS_ASYNC = 1                    --
      mm2s_cmdsts_awclk       : in  std_logic;                   --
      -- Secondary Clock input for async CMD/Status interface    --
                                                                 --
      mm2s_cmdsts_aresetn     : in  std_logic;                   --
        -- Secondary Reset input for async CMD/Status interface  --
      -------------------------------------------------------------
      
      
      -- User Command Interface Ports (AXI Stream) ----------------------------------------------------
      mm2s_cmd_wvalid         : in  std_logic;                                                       --
      mm2s_cmd_wready         : out std_logic;                                                       --
      mm2s_cmd_wdata          : in  std_logic_vector((C_MCDMA*3+C_TAG_WIDTH+(8*C_ENABLE_CACHE_USER)+C_MM2S_ADDR_WIDTH+36)-1 downto 0); --
      -------------------------------------------------------------------------------------------------
      
      
      -- User Status Interface Ports (AXI Stream) -------------------
      mm2s_sts_wvalid         : out std_logic;                     --
      mm2s_sts_wready         : in  std_logic;                     --
      mm2s_sts_wdata          : out std_logic_vector(7 downto 0);  --
      mm2s_sts_wstrb          : out std_logic_vector(0 downto 0);  --
      mm2s_sts_wlast          : out std_logic;                     --
      ---------------------------------------------------------------
      
      
      -- Address Posting contols ------------------------------------
      mm2s_allow_addr_req     : in  std_logic;                     --
      mm2s_addr_req_posted    : out std_logic;                     --
      mm2s_rd_xfer_cmplt      : out std_logic;                     --
      ---------------------------------------------------------------
      
      
      -- MM2S AXI Address Channel I/O  ---------------------------------------
      mm2s_arid     : out std_logic_vector(C_MM2S_ID_WIDTH-1 downto 0);     --
         -- AXI Address Channel ID output                                   --
                                                                            --
      mm2s_araddr   : out std_logic_vector(C_MM2S_ADDR_WIDTH-1 downto 0);   --
         -- AXI Address Channel Address output                              --
                                                                            --
      mm2s_arlen    : out std_logic_vector(7 downto 0);                     --
         -- AXI Address Channel LEN output                                  --
         -- Sized to support 256 data beat bursts                           --
                                                                            --
      mm2s_arsize   : out std_logic_vector(2 downto 0);                     --
         -- AXI Address Channel SIZE output                                 --
                                                                            --
      mm2s_arburst  : out std_logic_vector(1 downto 0);                     --
         -- AXI Address Channel BURST output                                --
                                                                            --
      mm2s_arprot   : out std_logic_vector(2 downto 0);                     --
         -- AXI Address Channel PROT output                                 --
                                                                            --
      mm2s_arcache  : out std_logic_vector(3 downto 0);                     --
         -- AXI Address Channel CACHE output                                --

      mm2s_aruser  : out std_logic_vector(3 downto 0);                     --
         -- AXI Address Channel CACHE output                                --
                                                                            --
      mm2s_arvalid  : out std_logic;                                        --
         -- AXI Address Channel VALID output                                --
                                                                            --
      mm2s_arready  : in  std_logic;                                        --
         -- AXI Address Channel READY input                                 --
      ------------------------------------------------------------------------
         
        
      -- Currently unsupported AXI Address Channel output signals ------------
        -- addr2axi_alock   : out std_logic_vector(2 downto 0);             --
        -- addr2axi_acache  : out std_logic_vector(4 downto 0);             --
        -- addr2axi_aqos    : out std_logic_vector(3 downto 0);             --
        -- addr2axi_aregion : out std_logic_vector(3 downto 0);             --
      ------------------------------------------------------------------------
  
  
  
  
      
      -- MM2S AXI MMap Read Data Channel I/O  -----------------------------------------
      mm2s_rdata              : In  std_logic_vector(C_MM2S_MDATA_WIDTH-1 downto 0); --
      mm2s_rresp              : In  std_logic_vector(1 downto 0);                    --
      mm2s_rlast              : In  std_logic;                                       --
      mm2s_rvalid             : In  std_logic;                                       --
      mm2s_rready             : Out std_logic;                                       --
      ---------------------------------------------------------------------------------
      
      
      
      -- MM2S AXI Master Stream Channel I/O  -------------------------------------------------
      mm2s_strm_wdata         : Out  std_logic_vector(C_MM2S_SDATA_WIDTH-1 downto 0);       --
      mm2s_strm_wstrb         : Out  std_logic_vector((C_MM2S_SDATA_WIDTH/8)-1 downto 0);   --
      mm2s_strm_wlast         : Out  std_logic;                                             --
      mm2s_strm_wvalid        : Out  std_logic;                                             --
      mm2s_strm_wready        : In   std_logic;                                             --
      ----------------------------------------------------------------------------------------
      
      -- Testing Support I/O -------------------------------------------
      mm2s_dbg_sel            : in  std_logic_vector( 3 downto 0);    --
      mm2s_dbg_data           : out std_logic_vector(31 downto 0)     --
      ------------------------------------------------------------------
      
      
      );
  
  end entity axi_datamover_mm2s_full_wrap;
  
  
  architecture implementation of axi_datamover_mm2s_full_wrap is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    -- Function Declarations   ----------------------------------------
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_calc_rdmux_sel_bits
    --
    -- Function Description:
    --  This function calculates the number of address bits needed for  
    -- the Read data mux select control. 
    --
    -------------------------------------------------------------------
    function func_calc_rdmux_sel_bits (mmap_dwidth_value : integer) return integer is
    
      Variable num_addr_bits_needed : Integer range 1 to 7 := 1;
    
    begin
    
      case mmap_dwidth_value is
        when 32 =>
          num_addr_bits_needed := 2;
        when 64 =>
          num_addr_bits_needed := 3;
        when 128 =>
          num_addr_bits_needed := 4;
        when 256 => 
          num_addr_bits_needed := 5;
        when 512 => 
          num_addr_bits_needed := 6;
        
        when others => -- 1024 bits
          num_addr_bits_needed := 7;
      end case;
      
      Return (num_addr_bits_needed);
       
    end function func_calc_rdmux_sel_bits;
    
     
     
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_include_dre
    --
    -- Function Description:
    -- This function desides if conditions are right for allowing DRE 
    -- inclusion.
    --
    -------------------------------------------------------------------
    function func_include_dre (need_dre          : integer;
                               needed_data_width : integer) return integer is
    
      Variable include_dre : Integer := 0;
    
    begin
    
      If (need_dre = 1 and 
          needed_data_width < 1024 and
          needed_data_width >   8) Then
    
         include_dre := 1;
      
      Else 

        include_dre := 0;
      
      End if;
      
      Return (include_dre);
      
    end function func_include_dre;
    
 
 
    
    
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: func_get_align_width
    --
    -- Function Description:
    -- This function calculates the needed DRE alignment port width\
    -- based upon the inclusion of DRE and the needed bit width of the
    -- DRE.
    --
    -------------------------------------------------------------------
    function func_get_align_width (dre_included   : integer;
                                   dre_data_width : integer) return integer is
    
       Variable align_port_width : Integer := 1;
    
    begin
    
      if (dre_included = 1) then
      
        If (dre_data_width = 512) Then
    
          align_port_width := 6;
        
        elsIf (dre_data_width = 256) Then
    
          align_port_width := 5;
        
        elsIf (dre_data_width = 128) Then
    
          align_port_width := 4;
        
        elsIf (dre_data_width = 64) Then
    
          align_port_width := 3;
        
        Elsif (dre_data_width = 32) Then
    
          align_port_width := 2;
        
        else  -- 16 bit data width
    
          align_port_width := 1;
        
        End if;
      
      else -- no DRE
    
        align_port_width := 1;
        
      end if;
      
      Return (align_port_width);
       
    end function func_get_align_width;
    




    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_rnd2pwr_of_2
    --
    -- Function Description:
    --  Rounds the input value up to the nearest power of 2 between
    --  128 and 8192.
    --
    -------------------------------------------------------------------
    function funct_rnd2pwr_of_2 (input_value : integer) return integer is

      Variable temp_pwr2 : Integer := 128;

    begin

      if (input_value <= 128) then

         temp_pwr2 := 128;

      elsif (input_value <= 256) then

         temp_pwr2 := 256;

      elsif (input_value <= 512) then

         temp_pwr2 := 512;

      elsif (input_value <= 1024) then

         temp_pwr2 := 1024;

      elsif (input_value <= 2048) then

         temp_pwr2 := 2048;

      elsif (input_value <= 4096) then

         temp_pwr2 := 4096;

      else

         temp_pwr2 := 8192;

      end if;


      Return (temp_pwr2);

    end function funct_rnd2pwr_of_2;
    -------------------------------------------------------------------
    
   
   
   
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_sf_offset_width
    --
    -- Function Description:
    --  This function calculates the address offset width needed by
    -- the GP Store and Forward module with data packing.
    --
    -------------------------------------------------------------------
    function funct_get_sf_offset_width (mmap_dwidth   : integer;
                                        stream_dwidth : integer) return integer is
    
      Constant FCONST_WIDTH_RATIO     : integer := mmap_dwidth/stream_dwidth;
      
      Variable fvar_temp_offset_width : Integer := 1;
    
    begin
    
      case FCONST_WIDTH_RATIO is
        when 1 =>
          fvar_temp_offset_width := 1;
        when 2 =>
          fvar_temp_offset_width := 1;
        when 4 =>
          fvar_temp_offset_width := 2;
        when 8 =>
          fvar_temp_offset_width := 3;
        when 16 =>
          fvar_temp_offset_width := 4;
        when 32 =>
          fvar_temp_offset_width := 5;
        when 64 =>
          fvar_temp_offset_width := 6;
        when others => -- 128 ratio
          fvar_temp_offset_width := 7;
      end case;
      
      Return (fvar_temp_offset_width);
    
    
    end function funct_get_sf_offset_width;
    
   
     
     
     
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_get_stream_width2use
    --
    -- Function Description:
    --  This function calculates the Stream width to use for MM2S 
    -- modules upstream from the downsizing Store and Forward. If 
    -- Store and Forward is present, then the effective native width 
    -- is the MMAP data width. If no Store and Forward then the Stream
    -- width is the input Native Data width from the User. 
    --
    -------------------------------------------------------------------
    function funct_get_stream_width2use (mmap_data_width   : integer;
                                         stream_data_width : integer;
                                         sf_enabled        : integer) return integer is
    
      Variable fvar_temp_width : Integer := 32;
    
    begin
    
      If (sf_enabled = 1) Then
    
        fvar_temp_width := mmap_data_width;
      
      Else 

        fvar_temp_width := stream_data_width;
      
      End if;
     
      Return (fvar_temp_width);
     
    end function funct_get_stream_width2use;
    
   
    
    
    
    
    -- Constant Declarations   ----------------------------------------

     Constant SF_UPSIZED_SDATA_WIDTH  : integer := funct_get_stream_width2use(C_MM2S_MDATA_WIDTH,
                                                                              C_MM2S_SDATA_WIDTH,
                                                                              C_INCLUDE_MM2S_GP_SF);
     
     Constant LOGIC_LOW               : std_logic := '0';
     Constant LOGIC_HIGH              : std_logic := '1';     
     Constant INCLUDE_MM2S            : integer range  0 to    2 := C_INCLUDE_MM2S;
     Constant IS_MM2S                 : integer range  0 to    1 := 1;
     Constant MM2S_ARID_VALUE         : integer range  0 to  255 := C_MM2S_ARID;
     Constant MM2S_ARID_WIDTH         : integer range  1 to    8  := C_MM2S_ID_WIDTH;
     Constant MM2S_ADDR_WIDTH         : integer range 32 to   64 := C_MM2S_ADDR_WIDTH;
     Constant MM2S_MDATA_WIDTH        : integer range 32 to 1024 := C_MM2S_MDATA_WIDTH;
     Constant MM2S_SDATA_WIDTH        : integer range  8 to 1024 := C_MM2S_SDATA_WIDTH;
     Constant MM2S_TAG_WIDTH          : integer range  1 to    8 := C_TAG_WIDTH;
     Constant MM2S_CMD_WIDTH          : integer                  := (MM2S_TAG_WIDTH+C_MM2S_ADDR_WIDTH+32+C_MCDMA*3);
     Constant MM2S_STS_WIDTH          : integer                  := 8; -- always 8 for MM2S
     Constant INCLUDE_MM2S_STSFIFO    : integer range  0 to    1 := C_INCLUDE_MM2S_STSFIFO;
     Constant MM2S_STSCMD_FIFO_DEPTH  : integer range  1 to   16 := C_MM2S_STSCMD_FIFO_DEPTH;
     Constant MM2S_STSCMD_IS_ASYNC    : integer range  0 to    1 := C_MM2S_STSCMD_IS_ASYNC;
     Constant INCLUDE_MM2S_DRE        : integer range  0 to    1 := C_INCLUDE_MM2S_DRE;
     Constant MM2S_BURST_SIZE         : integer range 2 to  256 := C_MM2S_BURST_SIZE;
     Constant ADDR_CNTL_FIFO_DEPTH    : integer range  1 to   30 := C_MM2S_ADDR_PIPE_DEPTH;  
     Constant RD_DATA_CNTL_FIFO_DEPTH : integer range  1 to   30 := ADDR_CNTL_FIFO_DEPTH;
     Constant SEL_ADDR_WIDTH          : integer range  2 to    7 := func_calc_rdmux_sel_bits(MM2S_MDATA_WIDTH);
     Constant MM2S_BTT_USED           : integer range  8 to   26 := C_MM2S_BTT_USED;
     Constant NO_INDET_BTT            : integer range  0 to    1 := 0;
     Constant INCLUDE_DRE             : integer range  0 to    1 := func_include_dre(C_INCLUDE_MM2S_DRE,
                                                                                     C_MM2S_SDATA_WIDTH);
     Constant DRE_ALIGN_WIDTH         : integer range  1 to    6 := func_get_align_width(INCLUDE_DRE,
                                                                                        C_MM2S_SDATA_WIDTH);
     

     -- Calculates the minimum needed depth of the Store and Forward FIFO
     -- based on the MM2S pipeline depth and the max allowed Burst length
     Constant PIPEDEPTH_BURST_LEN_PROD : integer :=
                    (ADDR_CNTL_FIFO_DEPTH+2) * MM2S_BURST_SIZE;
              
              
     -- Assigns the depth of the optional Store and Forward FIFO to the nearest
     -- power of 2
     Constant SF_FIFO_DEPTH       : integer range 128 to 8192 :=
                                    funct_rnd2pwr_of_2(PIPEDEPTH_BURST_LEN_PROD);


     -- Calculate the width of the Store and Forward Starting Address Offset bus
     Constant SF_STRT_OFFSET_WIDTH : integer := funct_get_sf_offset_width(MM2S_MDATA_WIDTH,
                                                                          MM2S_SDATA_WIDTH);
     
     
     


     
    
    -- Signal Declarations  ------------------------------------------
    
     signal sig_cmd_stat_rst_user        : std_logic := '0';
     signal sig_cmd_stat_rst_int         : std_logic := '0';
     signal sig_mmap_rst                 : std_logic := '0';
     signal sig_stream_rst               : std_logic := '0';
     signal sig_mm2s_cmd_wdata           : std_logic_vector(MM2S_CMD_WIDTH-1 downto 0) := (others => '0');        
     signal sig_cache_data               : std_logic_vector(7 downto 0) := (others => '0');        
     signal sig_cmd2mstr_command         : std_logic_vector(MM2S_CMD_WIDTH-1 downto 0) := (others => '0');        
     signal sig_cmd2mstr_cmd_valid       : std_logic := '0';                                             
     signal sig_mst2cmd_cmd_ready        : std_logic := '0';                                             
     signal sig_mstr2addr_addr           : std_logic_vector(MM2S_ADDR_WIDTH-1 downto 0) := (others => '0');             
     signal first_addr           : std_logic_vector(MM2S_ADDR_WIDTH-1 downto 0) := (others => '0');             
     signal last_addr           : std_logic_vector(MM2S_ADDR_WIDTH-1 downto 0) := (others => '0');             
     signal sig_mstr2addr_len            : std_logic_vector(7 downto 0) := (others => '0');                          
     signal sig_mstr2addr_size           : std_logic_vector(2 downto 0) := (others => '0');                          
     signal sig_mstr2addr_burst          : std_logic_vector(1 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cache          : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_user           : std_logic_vector(3 downto 0) := (others => '0'); 
     signal sig_mstr2addr_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2addr_calc_error     : std_logic := '0';
     signal sig_mstr2addr_cmd_valid      : std_logic := '0';                                             
     signal sig_addr2mstr_cmd_ready      : std_logic := '0';                                              
     signal sig_mstr2data_saddr_lsb      : std_logic_vector(SEL_ADDR_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2data_len            : std_logic_vector(7 downto 0) := (others => '0');
     signal sig_mstr2data_strt_strb      : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');      
     signal sig_mstr2data_last_strb      : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_mstr2data_drr            : std_logic := '0';
     signal sig_mstr2data_eof            : std_logic := '0';
     signal sig_mstr2data_sequential     : std_logic := '0';
     signal sig_mstr2data_calc_error     : std_logic := '0';
     signal sig_mstr2data_cmd_cmplt      : std_logic := '0';
     signal sig_mstr2data_cmd_valid      : std_logic := '0';                                             
     signal sig_data2mstr_cmd_ready      : std_logic := '0';
     signal sig_mstr2data_dre_src_align  : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');      
     signal sig_mstr2data_dre_dest_align : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');      
     signal sig_addr2data_addr_posted    : std_logic := '0';
     signal sig_data2all_dcntlr_halted   : std_logic := '0';
     signal sig_addr2rsc_calc_error      : std_logic := '0';
     signal sig_addr2rsc_cmd_fifo_empty  : std_logic := '0';
     signal sig_data2rsc_tag             : std_logic_vector(MM2S_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2rsc_calc_err        : std_logic := '0';                     
     signal sig_data2rsc_okay            : std_logic := '0';
     signal sig_data2rsc_decerr          : std_logic := '0';
     signal sig_data2rsc_slverr          : std_logic := '0';
     signal sig_data2rsc_cmd_cmplt       : std_logic := '0';
     signal sig_rsc2data_ready           : std_logic := '0';
     signal sig_data2rsc_valid           : std_logic := '0';
     signal sig_calc2dm_calc_err         : std_logic := '0';
     signal sig_rsc2stat_status          : std_logic_vector(MM2S_STS_WIDTH-1 downto 0) := (others => '0');
     signal sig_stat2rsc_status_ready    : std_logic := '0';   
     signal sig_rsc2stat_status_valid    : std_logic := '0';  
     signal sig_rsc2mstr_halt_pipe       : std_logic := '0';  
     signal sig_mstr2data_tag            : std_logic_vector(MM2S_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2addr_tag            : std_logic_vector(MM2S_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_dbg_data_mux_out         : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_0               : std_logic_vector(31 downto 0) := (others => '0');
     signal sig_dbg_data_1               : std_logic_vector(31 downto 0) := (others => '0');
     
     signal sig_sf2rdc_wready            : std_logic := '0';
     signal sig_rdc2sf_wvalid            : std_logic := '0';
     signal sig_rdc2sf_wdata             : std_logic_vector(SF_UPSIZED_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_rdc2sf_wstrb             : std_logic_vector((SF_UPSIZED_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_rdc2sf_wlast             : std_logic := '0';
     
     signal sig_skid2dre_wready          : std_logic := '0';
     signal sig_dre2skid_wvalid          : std_logic := '0';
     signal sig_dre2skid_wdata           : std_logic_vector(MM2S_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_dre2skid_wstrb           : std_logic_vector((MM2S_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_dre2skid_wlast           : std_logic := '0';
     
     signal sig_dre2sf_wready            : std_logic := '0';
     signal sig_sf2dre_wvalid            : std_logic := '0';
     signal sig_sf2dre_wdata             : std_logic_vector(MM2S_SDATA_WIDTH-1 downto 0) := (others => '0');
     signal sig_sf2dre_wstrb             : std_logic_vector((MM2S_SDATA_WIDTH/8)-1 downto 0) := (others => '0');
     signal sig_sf2dre_wlast             : std_logic := '0';
   
     
     signal sig_rdc2dre_new_align        : std_logic := '0';
     signal sig_rdc2dre_use_autodest     : std_logic := '0';
     signal sig_rdc2dre_src_align        : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_rdc2dre_dest_align       : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_rdc2dre_flush            : std_logic := '0';
     
     signal sig_sf2dre_new_align         : std_logic := '0';
     signal sig_sf2dre_use_autodest      : std_logic := '0';
     signal sig_sf2dre_src_align         : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_sf2dre_dest_align        : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_sf2dre_flush             : std_logic := '0';
     
     signal sig_dre_new_align            : std_logic := '0';
     signal sig_dre_use_autodest         : std_logic := '0';
     signal sig_dre_src_align            : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_dre_dest_align           : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_dre_flush                : std_logic := '0';
     
     signal sig_rst2all_stop_request     : std_logic := '0';
     signal sig_data2rst_stop_cmplt      : std_logic := '0';
     signal sig_addr2rst_stop_cmplt      : std_logic := '0';
     signal sig_data2addr_stop_req       : std_logic := '0';
     signal sig_data2skid_halt           : std_logic := '0';
     
     signal sig_sf_allow_addr_req        : std_logic := '0';
     signal sig_mm2s_allow_addr_req      : std_logic := '0';
     signal sig_addr_req_posted          : std_logic := '0';
     signal sig_rd_xfer_cmplt            : std_logic := '0';
   
     signal sig_sf2mstr_cmd_ready        : std_logic := '0';
     signal sig_mstr2sf_cmd_valid        : std_logic := '0';
     signal sig_mstr2sf_tag              : std_logic_vector(MM2S_TAG_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2sf_dre_src_align    : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2sf_dre_dest_align   : std_logic_vector(DRE_ALIGN_WIDTH-1 downto 0) := (others => '0');
     signal sig_mstr2sf_btt              : std_logic_vector(MM2S_BTT_USED-1 downto 0) := (others => '0');
     signal sig_mstr2sf_drr              : std_logic := '0';
     signal sig_mstr2sf_eof              : std_logic := '0';
     signal sig_mstr2sf_calc_error       : std_logic := '0';
                                        
     signal sig_mstr2sf_strt_offset      : std_logic_vector(SF_STRT_OFFSET_WIDTH-1 downto 0) := (others => '0');
     signal sig_data2sf_cmd_cmplt        : std_logic := '0';
     signal sig_cache2mstr_command       : std_logic_vector (7 downto 0);
     signal mm2s_arcache_int             : std_logic_vector (3 downto 0);
     signal mm2s_aruser_int             : std_logic_vector (3 downto 0);
 
     
     
    
  begin --(architecture implementation)
  
  
    
    -- Debug vector output
    mm2s_dbg_data  <= sig_dbg_data_mux_out;
    
    
    -- Note that only the mm2s_dbg_sel(0) is used at this time
    sig_dbg_data_mux_out <= sig_dbg_data_1
      When (mm2s_dbg_sel(0) = '1')
      else sig_dbg_data_0 ;
    
    
    sig_dbg_data_0              <=  X"BEEF1111"             ; -- 32 bit Constant indicating MM2S Full type
    
    sig_dbg_data_1(0)           <= sig_cmd_stat_rst_user    ;
    sig_dbg_data_1(1)           <= sig_cmd_stat_rst_int     ;
    sig_dbg_data_1(2)           <= sig_mmap_rst             ;
    sig_dbg_data_1(3)           <= sig_stream_rst           ;
    sig_dbg_data_1(4)           <= sig_cmd2mstr_cmd_valid   ;
    sig_dbg_data_1(5)           <= sig_mst2cmd_cmd_ready    ;
    sig_dbg_data_1(6)           <= sig_stat2rsc_status_ready;
    sig_dbg_data_1(7)           <= sig_rsc2stat_status_valid;
    sig_dbg_data_1(11 downto 8) <= sig_data2rsc_tag         ; -- Current TAG of active data transfer


    sig_dbg_data_1(15 downto 12) <= sig_rsc2stat_status(3 downto 0); -- Internal status tag field
    sig_dbg_data_1(16)           <= sig_rsc2stat_status(4)         ; -- Internal error
    sig_dbg_data_1(17)           <= sig_rsc2stat_status(5)         ; -- Decode Error
    sig_dbg_data_1(18)           <= sig_rsc2stat_status(6)         ; -- Slave Error
    sig_dbg_data_1(19)           <= sig_rsc2stat_status(7)         ; -- OKAY
    sig_dbg_data_1(20)           <= sig_stat2rsc_status_ready      ; -- Status Ready Handshake
    sig_dbg_data_1(21)           <= sig_rsc2stat_status_valid      ; -- Status Valid Handshake
                        
    
    -- Spare bits in debug1
    sig_dbg_data_1(31 downto 22) <= (others => '0')                ; -- spare bits
                        
                        
                        
     
     
    GEN_CACHE : if (C_ENABLE_CACHE_USER = 0) generate

       begin
 
    -- Cache signal tie-off
    mm2s_arcache       <= "0011";  -- Per Interface-X guidelines for Masters
    mm2s_aruser       <= "0000";  -- Per Interface-X guidelines for Masters
    sig_cache_data <= (others => '0'); --mm2s_cmd_wdata(103 downto 96);   -- This is the xUser and xCache values
     
       end generate GEN_CACHE;                 


    GEN_CACHE2 : if (C_ENABLE_CACHE_USER = 1) generate

       begin
 
    -- Cache signal tie-off
    mm2s_arcache       <= mm2s_arcache_int;  -- Cache from Desc
    mm2s_aruser       <= mm2s_aruser_int;  -- Cache from Desc
  --  sig_cache_data <= mm2s_cmd_wdata(103 downto 96);   -- This is the xUser and xCache values
    sig_cache_data <= mm2s_cmd_wdata(79+(C_MM2S_ADDR_WIDTH-32) downto 72+(C_MM2S_ADDR_WIDTH-32));   -- This is the xUser and xCache values
     
       end generate GEN_CACHE2;                 
                       
    -- Internal error output discrete ------------------------------
    mm2s_err           <=  sig_calc2dm_calc_err;
    
    
    -- Rip the used portion of the Command Interface Command Data
    -- and throw away the padding
    sig_mm2s_cmd_wdata <= mm2s_cmd_wdata(MM2S_CMD_WIDTH-1 downto 0);
    
         
    ------------------------------------------------------------
    -- Instance: I_RESET 
    --
    -- Description:
    --   Reset Block  
    --
    ------------------------------------------------------------
    I_RESET : entity axi_datamover_v5_1_17.axi_datamover_reset
    generic map (
  
      C_STSCMD_IS_ASYNC    =>  MM2S_STSCMD_IS_ASYNC      
  
      )
    port map (
  
      primary_aclk         =>  mm2s_aclk                ,
      primary_aresetn      =>  mm2s_aresetn             ,
      secondary_awclk      =>  mm2s_cmdsts_awclk        ,
      secondary_aresetn    =>  mm2s_cmdsts_aresetn      ,
      
      halt_req             =>  mm2s_halt                ,
      halt_cmplt           =>  mm2s_halt_cmplt          ,
      flush_stop_request   =>  sig_rst2all_stop_request ,
      data_cntlr_stopped   =>  sig_data2rst_stop_cmplt  ,
      addr_cntlr_stopped   =>  sig_addr2rst_stop_cmplt  ,
      aux1_stopped         =>  LOGIC_HIGH               ,
      aux2_stopped         =>  LOGIC_HIGH               ,
      
      cmd_stat_rst_user    =>  sig_cmd_stat_rst_user    ,
      cmd_stat_rst_int     =>  sig_cmd_stat_rst_int     ,
      mmap_rst             =>  sig_mmap_rst             ,
      stream_rst           =>  sig_stream_rst            
  
      );
  
   
   
 
 
         
    ------------------------------------------------------------
    -- Instance: I_CMD_STATUS 
    --
    -- Description:
    --   Command and Status Interface Block  
    --
    ------------------------------------------------------------
     I_CMD_STATUS : entity axi_datamover_v5_1_17.axi_datamover_cmd_status
     generic map (
   
       C_ADDR_WIDTH           =>  MM2S_ADDR_WIDTH           , 
       C_INCLUDE_STSFIFO      =>  INCLUDE_MM2S_STSFIFO      , 
       C_STSCMD_FIFO_DEPTH    =>  MM2S_STSCMD_FIFO_DEPTH    , 
       C_STSCMD_IS_ASYNC      =>  MM2S_STSCMD_IS_ASYNC      , 
       C_CMD_WIDTH            =>  MM2S_CMD_WIDTH            , 
       C_STS_WIDTH            =>  MM2S_STS_WIDTH            , 
       C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER       ,
       C_FAMILY               =>  C_FAMILY                    

       )
     port map (
   
       primary_aclk           =>  mm2s_aclk                 , 
       secondary_awclk        =>  mm2s_cmdsts_awclk         , 
       user_reset             =>  sig_cmd_stat_rst_user     , 
       internal_reset         =>  sig_cmd_stat_rst_int      , 
       cmd_wvalid             =>  mm2s_cmd_wvalid           , 
       cmd_wready             =>  mm2s_cmd_wready           , 
       cmd_wdata              =>  sig_mm2s_cmd_wdata        , 
       cache_data             =>  sig_cache_data            ,
       sts_wvalid             =>  mm2s_sts_wvalid           , 
       sts_wready             =>  mm2s_sts_wready           , 
       sts_wdata              =>  mm2s_sts_wdata            , 
       sts_wstrb              =>  mm2s_sts_wstrb            , 
       sts_wlast              =>  mm2s_sts_wlast            , 
       cmd2mstr_command       =>  sig_cmd2mstr_command      , 
       cache2mstr_command     =>  sig_cache2mstr_command      , 
       mst2cmd_cmd_valid      =>  sig_cmd2mstr_cmd_valid    ,    
       cmd2mstr_cmd_ready     =>  sig_mst2cmd_cmd_ready     , 
       mstr2stat_status       =>  sig_rsc2stat_status       , 
       stat2mstr_status_ready =>  sig_stat2rsc_status_ready , 
       mst2stst_status_valid  =>  sig_rsc2stat_status_valid   
   
       );
   
   
   
 
 
         
    ------------------------------------------------------------
    -- Instance: I_RD_STATUS_CNTLR 
    --
    -- Description:
    -- Read Status Controller Block    
    --
    ------------------------------------------------------------
     I_RD_STATUS_CNTLR : entity axi_datamover_v5_1_17.axi_datamover_rd_status_cntl
     generic map (
   
       C_STS_WIDTH            =>  MM2S_STS_WIDTH ,      
       C_TAG_WIDTH            =>  MM2S_TAG_WIDTH        

       )
     port map (
   
       primary_aclk           =>  mm2s_aclk                   ,  
       mmap_reset             =>  sig_mmap_rst                ,  
       calc2rsc_calc_error    =>  sig_calc2dm_calc_err        ,  
       addr2rsc_calc_error    =>  sig_addr2rsc_calc_error     ,  
       addr2rsc_fifo_empty    =>  sig_addr2rsc_cmd_fifo_empty ,  
       data2rsc_tag           =>  sig_data2rsc_tag            ,  
       data2rsc_calc_error    =>  sig_data2rsc_calc_err       ,  
       data2rsc_okay          =>  sig_data2rsc_okay           ,  
       data2rsc_decerr        =>  sig_data2rsc_decerr         ,  
       data2rsc_slverr        =>  sig_data2rsc_slverr         ,  
       data2rsc_cmd_cmplt     =>  sig_data2rsc_cmd_cmplt      ,  
       rsc2data_ready         =>  sig_rsc2data_ready          ,  
       data2rsc_valid         =>  sig_data2rsc_valid          ,  
       rsc2stat_status        =>  sig_rsc2stat_status         ,  
       stat2rsc_status_ready  =>  sig_stat2rsc_status_ready   ,  
       rsc2stat_status_valid  =>  sig_rsc2stat_status_valid   ,  
       rsc2mstr_halt_pipe     =>  sig_rsc2mstr_halt_pipe         
     
       );
   
   
   
 
 
         
   ------------------------------------------------------------
   -- Instance: I_MSTR_PCC 
   --
   -- Description:
   -- Predictive Command Calculator Block   
   --
   ------------------------------------------------------------
    I_MSTR_PCC : entity axi_datamover_v5_1_17.axi_datamover_pcc
    generic map (
  
      C_IS_MM2S                 =>  IS_MM2S                      ,
      C_DRE_ALIGN_WIDTH         =>  DRE_ALIGN_WIDTH              , 
      C_SEL_ADDR_WIDTH          =>  SEL_ADDR_WIDTH               , 
      C_ADDR_WIDTH              =>  MM2S_ADDR_WIDTH              , 
      C_STREAM_DWIDTH           =>  MM2S_SDATA_WIDTH             , 
      C_MAX_BURST_LEN           =>  MM2S_BURST_SIZE              , 
      C_CMD_WIDTH               =>  MM2S_CMD_WIDTH               , 
      C_TAG_WIDTH               =>  MM2S_TAG_WIDTH               , 
      C_BTT_USED                =>  MM2S_BTT_USED                , 
      C_SUPPORT_INDET_BTT       =>  NO_INDET_BTT                 ,  
      C_NATIVE_XFER_WIDTH       =>  SF_UPSIZED_SDATA_WIDTH       ,
      C_STRT_SF_OFFSET_WIDTH    =>  SF_STRT_OFFSET_WIDTH         ,
      C_MCDMA                   =>  C_MCDMA                    
  
      )
    port map (
  
      -- Clock input
      primary_aclk              =>  mm2s_aclk                    , 
      mmap_reset                =>  sig_mmap_rst                 , 
      cmd2mstr_command          =>  sig_cmd2mstr_command         , 
      cache2mstr_command        =>  sig_cache2mstr_command       ,
      cmd2mstr_cmd_valid        =>  sig_cmd2mstr_cmd_valid       , 
      mst2cmd_cmd_ready         =>  sig_mst2cmd_cmd_ready        , 
      
      mstr2addr_tag             =>  sig_mstr2addr_tag            , 
      mstr2addr_addr            =>  sig_mstr2addr_addr           , 
      mstr2addr_len             =>  sig_mstr2addr_len            , 
      mstr2addr_size            =>  sig_mstr2addr_size           , 
      mstr2addr_burst           =>  sig_mstr2addr_burst          , 
      mstr2addr_cache           =>  sig_mstr2addr_cache          , 
      mstr2addr_user            =>  sig_mstr2addr_user           , 
      mstr2addr_cmd_cmplt       =>  sig_mstr2addr_cmd_cmplt      ,
      mstr2addr_calc_error      =>  sig_mstr2addr_calc_error     , 
      mstr2addr_cmd_valid       =>  sig_mstr2addr_cmd_valid      ,
      addr2mstr_cmd_ready       =>  sig_addr2mstr_cmd_ready      , 
      
      mstr2data_tag             =>  sig_mstr2data_tag            , 
      mstr2data_saddr_lsb       =>  sig_mstr2data_saddr_lsb      , 
      mstr2data_len             =>  sig_mstr2data_len            , 
      mstr2data_strt_strb       =>  sig_mstr2data_strt_strb      , 
      mstr2data_last_strb       =>  sig_mstr2data_last_strb      , 
      mstr2data_drr             =>  sig_mstr2data_drr            , 
      mstr2data_eof             =>  sig_mstr2data_eof            , 
      mstr2data_sequential      =>  sig_mstr2data_sequential     , 
      mstr2data_calc_error      =>  sig_mstr2data_calc_error     , 
      mstr2data_cmd_cmplt       =>  sig_mstr2data_cmd_cmplt      , 
      mstr2data_cmd_valid       =>  sig_mstr2data_cmd_valid      , 
      data2mstr_cmd_ready       =>  sig_data2mstr_cmd_ready      , 
      mstr2data_dre_src_align   =>  sig_mstr2data_dre_src_align  , 
      mstr2data_dre_dest_align  =>  sig_mstr2data_dre_dest_align , 
      
      calc_error                =>  sig_calc2dm_calc_err         , 
      
      dre2mstr_cmd_ready        =>  sig_sf2mstr_cmd_ready        , 
      mstr2dre_cmd_valid        =>  sig_mstr2sf_cmd_valid        , 
      mstr2dre_tag              =>  sig_mstr2sf_tag              , 
      mstr2dre_dre_src_align    =>  sig_mstr2sf_dre_src_align    , 
      mstr2dre_dre_dest_align   =>  sig_mstr2sf_dre_dest_align   , 
      mstr2dre_btt              =>  sig_mstr2sf_btt              , 
      mstr2dre_drr              =>  sig_mstr2sf_drr              , 
      mstr2dre_eof              =>  sig_mstr2sf_eof              , 
      mstr2dre_cmd_cmplt        =>  open                         ,
      mstr2dre_calc_error       =>  sig_mstr2sf_calc_error       ,  
    
      mstr2dre_strt_offset      =>  sig_mstr2sf_strt_offset 
      
      );
   
   
   
 
 
         
    ------------------------------------------------------------
    -- Instance: I_ADDR_CNTL 
    --
    -- Description:
    --   Address Controller Block  
    --
    ------------------------------------------------------------
     I_ADDR_CNTL : entity axi_datamover_v5_1_17.axi_datamover_addr_cntl
     generic map (
   
       C_ADDR_FIFO_DEPTH            =>  ADDR_CNTL_FIFO_DEPTH        , 
       C_ADDR_WIDTH                 =>  MM2S_ADDR_WIDTH             , 
       C_ADDR_ID                    =>  MM2S_ARID_VALUE             , 
       C_ADDR_ID_WIDTH              =>  MM2S_ARID_WIDTH             , 
       C_TAG_WIDTH                  =>  MM2S_TAG_WIDTH              ,
       C_FAMILY               =>  C_FAMILY  
   
       )
     port map (
   
       primary_aclk                 =>  mm2s_aclk                   ,
       mmap_reset                   =>  sig_mmap_rst                ,
       
       addr2axi_aid                 =>  mm2s_arid                   ,
       addr2axi_aaddr               =>  mm2s_araddr                 ,
       addr2axi_alen                =>  mm2s_arlen                  ,
       addr2axi_asize               =>  mm2s_arsize                 ,
       addr2axi_aburst              =>  mm2s_arburst                ,
       addr2axi_aprot               =>  mm2s_arprot                 ,
       addr2axi_avalid              =>  mm2s_arvalid                ,
       addr2axi_acache               =>  mm2s_arcache_int            ,
       addr2axi_auser                =>  mm2s_aruser_int             ,
       axi2addr_aready              =>  mm2s_arready                ,
       
       mstr2addr_tag                =>  sig_mstr2addr_tag           ,
       mstr2addr_addr               =>  sig_mstr2addr_addr          ,
       mstr2addr_len                =>  sig_mstr2addr_len           ,
       mstr2addr_size               =>  sig_mstr2addr_size          ,
       mstr2addr_burst              =>  sig_mstr2addr_burst         ,
       mstr2addr_cache              =>  sig_mstr2addr_cache         ,
       mstr2addr_user               =>  sig_mstr2addr_user          ,
       mstr2addr_cmd_cmplt          =>  sig_mstr2addr_cmd_cmplt     ,
       mstr2addr_calc_error         =>  sig_mstr2addr_calc_error    ,
       mstr2addr_cmd_valid          =>  sig_mstr2addr_cmd_valid     ,
       addr2mstr_cmd_ready          =>  sig_addr2mstr_cmd_ready     ,
       
       addr2rst_stop_cmplt          =>  sig_addr2rst_stop_cmplt     ,
       
       allow_addr_req               =>  sig_mm2s_allow_addr_req     ,
       addr_req_posted              =>  sig_addr_req_posted         ,
       
       addr2data_addr_posted        =>  sig_addr2data_addr_posted   ,
       data2addr_data_rdy           =>  LOGIC_LOW                   ,
       data2addr_stop_req           =>  sig_data2addr_stop_req      ,
       
       addr2stat_calc_error         =>  sig_addr2rsc_calc_error     ,
       addr2stat_cmd_fifo_empty     =>  sig_addr2rsc_cmd_fifo_empty  
       );
   
   
   
 
 
         
     ------------------------------------------------------------
     -- Instance: I_RD_DATA_CNTL 
     --
     -- Description:
     --     Read Data Controller Block
     --
     ------------------------------------------------------------
      I_RD_DATA_CNTL : entity axi_datamover_v5_1_17.axi_datamover_rddata_cntl
      generic map (
        
        C_INCLUDE_DRE             =>  INCLUDE_DRE                  , 
        C_ALIGN_WIDTH             =>  DRE_ALIGN_WIDTH              , 
        C_SEL_ADDR_WIDTH          =>  SEL_ADDR_WIDTH               , 
        C_DATA_CNTL_FIFO_DEPTH    =>  RD_DATA_CNTL_FIFO_DEPTH      , 
        C_MMAP_DWIDTH             =>  MM2S_MDATA_WIDTH             , 
        C_STREAM_DWIDTH           =>  SF_UPSIZED_SDATA_WIDTH       , 
          C_ENABLE_MM2S_TKEEP       =>  C_ENABLE_MM2S_TKEEP        ,
        C_TAG_WIDTH               =>  MM2S_TAG_WIDTH               , 
        C_FAMILY                  =>  C_FAMILY                       
    
        )
      port map (
    
        -- Clock and Reset  -----------------------------------
        primary_aclk              =>  mm2s_aclk                    , 
        mmap_reset                =>  sig_mmap_rst                 , 
     
        -- Soft Shutdown Interface -----------------------------
        rst2data_stop_request     =>  sig_rst2all_stop_request     , 
        data2addr_stop_req        =>  sig_data2addr_stop_req       , 
        data2rst_stop_cmplt       =>  sig_data2rst_stop_cmplt      , 
        
        -- External Address Pipelining Contol support
        mm2s_rd_xfer_cmplt        =>  sig_rd_xfer_cmplt            ,
        
        
        -- AXI Read Data Channel I/O  -------------------------------
        mm2s_rdata                =>  mm2s_rdata                   , 
        mm2s_rresp                =>  mm2s_rresp                   , 
        mm2s_rlast                =>  mm2s_rlast                   , 
        mm2s_rvalid               =>  mm2s_rvalid                  , 
        mm2s_rready               =>  mm2s_rready                  , 
        
        -- MM2S DRE Control  -----------------------------------
        mm2s_dre_new_align        =>  sig_rdc2dre_new_align        , 
        mm2s_dre_use_autodest     =>  sig_rdc2dre_use_autodest     , 
        mm2s_dre_src_align        =>  sig_rdc2dre_src_align        , 
        mm2s_dre_dest_align       =>  sig_rdc2dre_dest_align       , 
        mm2s_dre_flush            =>  sig_rdc2dre_flush            , 
        
        -- AXI Master Stream  -----------------------------------
        mm2s_strm_wvalid          =>  sig_rdc2sf_wvalid           , 
        mm2s_strm_wready          =>  sig_sf2rdc_wready           , 
        mm2s_strm_wdata           =>  sig_rdc2sf_wdata            ,     
        mm2s_strm_wstrb           =>  sig_rdc2sf_wstrb            ,         
        mm2s_strm_wlast           =>  sig_rdc2sf_wlast            , 
       
      -- MM2S Store and Forward Supplimental Control   ----------
        mm2s_data2sf_cmd_cmplt    =>  sig_data2sf_cmd_cmplt       ,
       
       
        
        -- Command Calculator Interface --------------------------
        mstr2data_tag             =>  sig_mstr2data_tag            , 
        mstr2data_saddr_lsb       =>  sig_mstr2data_saddr_lsb      , 
        mstr2data_len             =>  sig_mstr2data_len            , 
        mstr2data_strt_strb       =>  sig_mstr2data_strt_strb      , 
        mstr2data_last_strb       =>  sig_mstr2data_last_strb      , 
        mstr2data_drr             =>  sig_mstr2data_drr            , 
        mstr2data_eof             =>  sig_mstr2data_eof            , 
        mstr2data_sequential      =>  sig_mstr2data_sequential     , 
        mstr2data_calc_error      =>  sig_mstr2data_calc_error     , 
        mstr2data_cmd_cmplt       =>  sig_mstr2data_cmd_cmplt      , 
        mstr2data_cmd_valid       =>  sig_mstr2data_cmd_valid      , 
        data2mstr_cmd_ready       =>  sig_data2mstr_cmd_ready      , 
        mstr2data_dre_src_align   =>  sig_mstr2data_dre_src_align  , 
        mstr2data_dre_dest_align  =>  sig_mstr2data_dre_dest_align , 

        
        -- Address Controller Interface --------------------------
        addr2data_addr_posted     =>  sig_addr2data_addr_posted    , 
        
        -- Data Controller Halted Status
        data2all_dcntlr_halted    =>  sig_data2all_dcntlr_halted   , 
        
        -- Output Stream Skid Buffer Halt control
        data2skid_halt            =>  sig_data2skid_halt           , 
        
        
        -- Read Status Controller Interface --------------------------
        data2rsc_tag              =>  sig_data2rsc_tag             ,   
        data2rsc_calc_err         =>  sig_data2rsc_calc_err        ,   
        data2rsc_okay             =>  sig_data2rsc_okay            ,   
        data2rsc_decerr           =>  sig_data2rsc_decerr          ,   
        data2rsc_slverr           =>  sig_data2rsc_slverr          ,   
        data2rsc_cmd_cmplt        =>  sig_data2rsc_cmd_cmplt       ,   
        rsc2data_ready            =>  sig_rsc2data_ready           ,   
        data2rsc_valid            =>  sig_data2rsc_valid           ,   
        rsc2mstr_halt_pipe        =>  sig_rsc2mstr_halt_pipe           
         
        );
   
   
   
 
    
 
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_MM2S_SF
    --
    -- If Generate Description:
    --   Include the MM2S Store and Forward function
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_MM2S_SF : if (C_INCLUDE_MM2S_GP_SF = 1) generate
    
       begin

         -- Merge external address posting control with the
         -- Store and Forward address posting control
         sig_mm2s_allow_addr_req <= sig_sf_allow_addr_req and
                                    mm2s_allow_addr_req;
       
         -- Address Posting support outputs
         mm2s_addr_req_posted    <= sig_addr_req_posted   ;
         mm2s_rd_xfer_cmplt      <= sig_rd_xfer_cmplt     ;
         
                                  
         sig_dre_new_align       <=  sig_sf2dre_new_align    ;
         sig_dre_use_autodest    <=  sig_sf2dre_use_autodest ;
         sig_dre_src_align       <=  sig_sf2dre_src_align    ;
         sig_dre_dest_align      <=  sig_sf2dre_dest_align   ;
         sig_dre_flush           <=  sig_sf2dre_flush        ;
                                                             
         
         
         
         
       
        
             
         ------------------------------------------------------------
         -- Instance: I_RD_SF 
         --
         -- Description:
         --   Instance for the MM2S Store and Forward module with
         -- downsizer support.  
         --
         ------------------------------------------------------------
         I_RD_SF : entity axi_datamover_v5_1_17.axi_datamover_rd_sf
         generic map (
              
           C_SF_FIFO_DEPTH        => SF_FIFO_DEPTH           ,
           C_MAX_BURST_LEN        => MM2S_BURST_SIZE         ,   
           C_DRE_IS_USED          => INCLUDE_DRE             , 
           C_DRE_CNTL_FIFO_DEPTH  => RD_DATA_CNTL_FIFO_DEPTH ,
           C_DRE_ALIGN_WIDTH      => DRE_ALIGN_WIDTH         ,
           C_MMAP_DWIDTH          => MM2S_MDATA_WIDTH        ,
           C_STREAM_DWIDTH        => MM2S_SDATA_WIDTH        ,   
           C_STRT_SF_OFFSET_WIDTH => SF_STRT_OFFSET_WIDTH    ,
           C_TAG_WIDTH            => MM2S_TAG_WIDTH          ,
          C_ENABLE_MM2S_TKEEP       =>  C_ENABLE_MM2S_TKEEP        ,
           C_FAMILY               => C_FAMILY                    
           )
         port map (
       
           -- Clock and Reset inputs -------------------------------
           aclk                     => mm2s_aclk             ,                     
           reset                    => sig_mmap_rst          ,                     
           
           
           -- DataMover Read Side Address Pipelining Control Interface 
           ok_to_post_rd_addr       => sig_sf_allow_addr_req ,                    
           rd_addr_posted           => sig_addr_req_posted   ,                              
           rd_xfer_cmplt            => sig_rd_xfer_cmplt     ,                              
           
            
             
           -- Read Side Stream In from DataMover MM2S Read Data Controller -----
           sf2sin_tready            => sig_sf2rdc_wready     ,         
           sin2sf_tvalid            => sig_rdc2sf_wvalid     ,         
           sin2sf_tdata             => sig_rdc2sf_wdata      ,         
           sin2sf_tkeep             => sig_rdc2sf_wstrb      ,            
           sin2sf_tlast             => sig_rdc2sf_wlast      ,         

           -- RDC Store and Forward Supplimental Controls ----------
           data2sf_cmd_cmplt        => sig_data2sf_cmd_cmplt ,
           data2sf_dre_flush        => sig_rdc2dre_flush     ,
          
                    
           -- DRE Control Interface from the Command Calculator -----------------------------
           dre2mstr_cmd_ready       => sig_sf2mstr_cmd_ready       ,
           mstr2dre_cmd_valid       => sig_mstr2sf_cmd_valid       ,
           mstr2dre_tag             => sig_mstr2sf_tag             ,
           mstr2dre_dre_src_align   => sig_mstr2sf_dre_src_align   , 
           mstr2dre_dre_dest_align  => sig_mstr2sf_dre_dest_align  , 
           mstr2dre_drr             => sig_mstr2sf_drr             ,
           mstr2dre_eof             => sig_mstr2sf_eof             ,
           mstr2dre_calc_error      => sig_mstr2sf_calc_error      ,
           mstr2dre_strt_offset     => sig_mstr2sf_strt_offset     ,
                                         
           
                     
     
           -- MM2S DRE Control  -------------------------------------------------------------
           sf2dre_new_align         => sig_sf2dre_new_align    ,
           sf2dre_use_autodest      => sig_sf2dre_use_autodest ,
           sf2dre_src_align         => sig_sf2dre_src_align    ,
           sf2dre_dest_align        => sig_sf2dre_dest_align   ,
           sf2dre_flush             => sig_sf2dre_flush        ,
           
            
           
           -- Stream Out  ----------------------------------
           sout2sf_tready           => sig_dre2sf_wready    ,   
           sf2sout_tvalid           => sig_sf2dre_wvalid    ,   
           sf2sout_tdata            => sig_sf2dre_wdata     ,   
           sf2sout_tkeep            => sig_sf2dre_wstrb     ,   
           sf2sout_tlast            => sig_sf2dre_wlast         
              
           );
        
        
        --  ------------------------------------------------------------
        --  -- Instance: I_RD_SF 
        --  --
        --  -- Description:
        --  --   Instance for the MM2S Store and Forward module.  
        --  --
        --  ------------------------------------------------------------
        --  I_RD_SF : entity axi_datamover_v5_1_17.axi_datamover_rd_sf
        --  generic map (
        --       
        --    C_SF_FIFO_DEPTH        => SF_FIFO_DEPTH    ,
        --    C_MAX_BURST_LEN        => MM2S_BURST_SIZE  ,   
        --    C_DRE_IS_USED          => INCLUDE_DRE      ,   
        --    C_STREAM_DWIDTH        => MM2S_SDATA_WIDTH ,   
        --    C_FAMILY               => C_FAMILY             
        --    )
        --  port map (
        -- 
        --    -- Clock and Reset inputs -------------------------------
        --    aclk                   => mm2s_aclk             ,                     
        --    reset                  => sig_mmap_rst          ,                     
        --    
        --    
        --    -- DataMover Read Side Address Pipelining Control Interface 
        --    ok_to_post_rd_addr     => sig_sf_allow_addr_req ,                    
        --    rd_addr_posted         => sig_addr_req_posted   ,                              
        --    rd_xfer_cmplt          => sig_rd_xfer_cmplt     ,                              
        --    
        --     
        --      
        --    -- Read Side Stream In from DataMover MM2S -----
        --    sf2sin_tready          => sig_sf2dre_wready     ,         
        --    sin2sf_tvalid          => sig_dre2sf_wvalid     ,         
        --    sin2sf_tdata           => sig_dre2sf_wdata      ,         
        --    sin2sf_tkeep           => sig_dre2sf_wstrb      ,            
        --    sin2sf_tlast           => sig_dre2sf_wlast      ,         
        -- 
        --             
        --              
        --    -- Stream Out  ----------------------------------
        --    sout2sf_tready         => sig_skid2sf_wready    ,   
        --    sf2sout_tvalid         => sig_sf2skid_wvalid    ,   
        --    sf2sout_tdata          => sig_sf2skid_wdata     ,   
        --    sf2sout_tkeep          => sig_sf2skid_wstrb     ,   
        --    sf2sout_tlast          => sig_sf2skid_wlast         
        --       
        --    );
        
        
        
        
         
       end generate GEN_INCLUDE_MM2S_SF;
       
       






    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_MM2S_SF
    --
    -- If Generate Description:
    --   Omit the MM2S Store and Forward function
    --
    --
    ------------------------------------------------------------
    GEN_NO_MM2S_SF : if (C_INCLUDE_MM2S_GP_SF = 0) generate
    
       begin

         -- Allow external address posting control
         -- Ignore Store and Forward Control
         sig_mm2s_allow_addr_req <= mm2s_allow_addr_req ;
         sig_sf_allow_addr_req   <= '0'                 ;
  
         -- Address Posting support outputs
         mm2s_addr_req_posted <= sig_addr_req_posted    ;
         mm2s_rd_xfer_cmplt   <= sig_rd_xfer_cmplt      ;
         
  
  
         -- DRE Control Bus (Connect to the Read data Controller)                         
         sig_dre_new_align       <= sig_rdc2dre_new_align     ;
         sig_dre_use_autodest    <= sig_rdc2dre_use_autodest  ;
         sig_dre_src_align       <= sig_rdc2dre_src_align     ;
         sig_dre_dest_align      <= sig_rdc2dre_dest_align    ;
         sig_dre_flush           <= sig_rdc2dre_flush         ;
                                                             
  
         -- Just pass stream signals through
         sig_sf2rdc_wready       <= sig_dre2sf_wready   ; 
         
         sig_sf2dre_wvalid       <= sig_rdc2sf_wvalid   ;   
         sig_sf2dre_wdata        <= sig_rdc2sf_wdata    ;   
         sig_sf2dre_wstrb        <= sig_rdc2sf_wstrb    ;   
         sig_sf2dre_wlast        <= sig_rdc2sf_wlast    ;   
          
                                                           
         -- Always enable the DRE Cmd bus for loading to keep from
         -- stalling the PCC module
         sig_sf2mstr_cmd_ready  <= LOGIC_HIGH;
         
                                                           
       end generate GEN_NO_MM2S_SF;
       
       





    
         
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_INCLUDE_MM2S_DRE
    --
    -- If Generate Description:
    --   Include the MM2S DRE
    --
    --
    ------------------------------------------------------------
    GEN_INCLUDE_MM2S_DRE : if (INCLUDE_DRE = 1) generate
    
       begin

       
       
         ------------------------------------------------------------
         -- Instance: I_DRE64 
         --
         -- Description:
         -- Instance for the MM2S DRE whach can support widths of 
         -- 16 bits to 64 bits.     
         --
         ------------------------------------------------------------
          I_DRE_16_to_64 : entity axi_datamover_v5_1_17.axi_datamover_mm2s_dre
          generic map (
        
            C_DWIDTH         =>  MM2S_SDATA_WIDTH      , 
            C_ALIGN_WIDTH    =>  DRE_ALIGN_WIDTH           
        
            )
          port map (
        
           -- Control inputs
            dre_clk          =>  mm2s_aclk              , 
            dre_rst          =>  sig_stream_rst         , 
          
            dre_new_align    => sig_dre_new_align       , 
            dre_use_autodest => sig_dre_use_autodest    , 
            dre_src_align    => sig_dre_src_align       , 
            dre_dest_align   => sig_dre_dest_align      , 
            dre_flush        => sig_dre_flush           , 

           -- Stream Inputs
            dre_in_tstrb     => sig_sf2dre_wstrb        , 
            dre_in_tdata     => sig_sf2dre_wdata        , 
            dre_in_tlast     => sig_sf2dre_wlast        , 
            dre_in_tvalid    => sig_sf2dre_wvalid       , 
            dre_in_tready    => sig_dre2sf_wready       , 

         
           -- Stream Outputs
            dre_out_tstrb    => sig_dre2skid_wstrb      , 
            dre_out_tdata    => sig_dre2skid_wdata      , 
            dre_out_tlast    => sig_dre2skid_wlast      , 
            dre_out_tvalid   => sig_dre2skid_wvalid     , 
            dre_out_tready   => sig_skid2dre_wready       
        
            );
        
       
 
 
          
       end generate GEN_INCLUDE_MM2S_DRE;
     
     
     
     
     
       
       
    
         
    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: GEN_NO_MM2S_DRE
    --
    -- If Generate Description:
    --   Omit the MM2S DRE and housekeep the signals that it 
    -- needs to output.
    --
    ------------------------------------------------------------
    GEN_NO_MM2S_DRE : if (INCLUDE_DRE = 0) generate
    
       begin

         -- Just pass stream signals through from the Store 
         -- and Forward module
     
         sig_dre2sf_wready   <= sig_skid2dre_wready ;
         
         sig_dre2skid_wvalid <= sig_sf2dre_wvalid   ;
         sig_dre2skid_wdata  <= sig_sf2dre_wdata    ;
         sig_dre2skid_wstrb  <= sig_sf2dre_wstrb    ;
         sig_dre2skid_wlast  <= sig_sf2dre_wlast    ;
     
          
       end generate GEN_NO_MM2S_DRE;
       
       




ENABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(5) = '1' generate
begin 

     ------------------------------------------------------------
     -- Instance: I_MM2S_SKID_BUF 
     --
     -- Description:
     --   Instance for the MM2S Skid Buffer which provides for
     -- registerd Master Stream outputs and supports bi-dir
     -- throttling.  
     --
     ------------------------------------------------------------
      I_MM2S_SKID_BUF : entity axi_datamover_v5_1_17.axi_datamover_skid_buf
      generic map (
         
        C_WDATA_WIDTH  =>  MM2S_SDATA_WIDTH        
    
        )
      port map (
    
        -- System Ports
        aclk           =>  mm2s_aclk           ,  
        arst           =>  sig_stream_rst      ,  
     
        -- Shutdown control (assert for 1 clk pulse)
        skid_stop      =>  sig_data2skid_halt  ,  
     
        -- Slave Side (Stream Data Input) 
        s_valid        =>  sig_dre2skid_wvalid ,  
        s_ready        =>  sig_skid2dre_wready ,  
        s_data         =>  sig_dre2skid_wdata  ,  
        s_strb         =>  sig_dre2skid_wstrb  ,  
        s_last         =>  sig_dre2skid_wlast  ,  

        -- Master Side (Stream Data Output 
        m_valid        =>  mm2s_strm_wvalid    ,  
        m_ready        =>  mm2s_strm_wready    ,  
        m_data         =>  mm2s_strm_wdata     ,  
        m_strb         =>  mm2s_strm_wstrb     ,  
        m_last         =>  mm2s_strm_wlast        
    
        );
    
end generate ENABLE_AXIS_SKID;
  
    
DISABLE_AXIS_SKID : if C_ENABLE_SKID_BUF(5) = '0' generate
begin 

   mm2s_strm_wvalid <= sig_dre2skid_wvalid;
   sig_skid2dre_wready <= mm2s_strm_wready;
   mm2s_strm_wdata <= sig_dre2skid_wdata;
   mm2s_strm_wstrb <= sig_dre2skid_wstrb; 
   mm2s_strm_wlast <= sig_dre2skid_wlast;
   

end generate DISABLE_AXIS_SKID; 

    
    
    
  end implementation;


-------------------------------------------------------------------------------
-- axi_datamover.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_datamover.vhd
--
-- Description:     
--  Top level VHDL wrapper for the AXI DataMover                
--                  
--                  
--                  
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;



library axi_datamover_v5_1_17;
use axi_datamover_v5_1_17.axi_datamover_mm2s_omit_wrap ;
use axi_datamover_v5_1_17.axi_datamover_mm2s_full_wrap ;
use axi_datamover_v5_1_17.axi_datamover_mm2s_basic_wrap;
use axi_datamover_v5_1_17.axi_datamover_s2mm_omit_wrap ;
use axi_datamover_v5_1_17.axi_datamover_s2mm_full_wrap ;
use axi_datamover_v5_1_17.axi_datamover_s2mm_basic_wrap;


-------------------------------------------------------------------------------

entity axi_datamover is
  generic (
    C_INCLUDE_MM2S              : Integer range 0 to  2 :=  2;
       -- Specifies the type of MM2S function to include
       -- 0 = Omit MM2S functionality
       -- 1 = Full MM2S Functionality
       -- 2 = Basic MM2S functionality
       
    C_M_AXI_MM2S_ARID           : Integer range 0 to  255 :=  0;
       -- Specifies the constant value to output on 
       -- the ARID output port
       
    C_M_AXI_MM2S_ID_WIDTH       : Integer range 1 to  8 :=  4;
       -- Specifies the width of the MM2S ID port 
       
    C_M_AXI_MM2S_ADDR_WIDTH     : Integer range 32 to  64 :=  32;
       -- Specifies the width of the MMap Read Address Channel 
       -- Address bus
       
    C_M_AXI_MM2S_DATA_WIDTH     : Integer range 32 to 1024 :=  32;
       -- Specifies the width of the MMap Read Data Channel
       -- data bus
    
    C_M_AXIS_MM2S_TDATA_WIDTH   : Integer range 8 to 1024 :=  32;
       -- Specifies the width of the MM2S Master Stream Data 
       -- Channel data bus
    
    C_INCLUDE_MM2S_STSFIFO      : Integer range 0 to  1 :=  1;
       -- Specifies if a Status FIFO is to be implemented
       -- 0 = Omit MM2S Status FIFO
       -- 1 = Include MM2S Status FIFO
       
    C_MM2S_STSCMD_FIFO_DEPTH    : Integer range 1 to 16 :=  4;
       -- Specifies the depth of the MM2S Command FIFO and the 
       -- optional Status FIFO
       -- Valid values are 1,4,8,16
       
    C_MM2S_STSCMD_IS_ASYNC      : Integer range 0 to  1 :=  0;
       -- Specifies if the Status and Command interfaces need to
       -- be asynchronous to the primary data path clocking
       -- 0 = Use same clocking as data path
       -- 1 = Use special Status/Command clock for the interfaces
       
    C_INCLUDE_MM2S_DRE          : Integer range 0 to  1 :=  1;
       -- Specifies if DRE is to be included in the MM2S function 
       -- 0 = Omit DRE
       -- 1 = Include DRE
    
    C_MM2S_BURST_SIZE           : Integer range 2 to  256 :=  16;
       -- Specifies the max number of databeats to use for MMap
       -- burst transfers by the MM2S function 
    
    C_MM2S_BTT_USED             : Integer range 8 to  26 :=  16;
      -- Specifies the number of bits used from the BTT field
      -- of the input Command Word of the MM2S Command Interface 
   
    C_MM2S_ADDR_PIPE_DEPTH      : Integer range 1 to 30 := 3;
      -- This parameter specifies the depth of the MM2S internal 
      -- child command queues in the Read Address Controller and 
      -- the Read Data Controller. Increasing this value will 
      -- allow more Read Addresses to be issued to the AXI4 Read 
      -- Address Channel before receipt of the associated read 
      -- data on the Read Data Channel.

    C_MM2S_INCLUDE_SF           : Integer range 0 to 1 := 1 ;
      -- This parameter specifies the inclusion/omission of the
      -- MM2S (Read) Store and Forward function
      -- 0 = Omit MM2S Store and Forward
      -- 1 = Include MM2S Store and Forward
    
  
   
     
    
    C_INCLUDE_S2MM              : Integer range 0 to  4 :=  2;
       -- Specifies the type of S2MM function to include
       -- 0 = Omit S2MM functionality
       -- 1 = Full S2MM Functionality
       -- 2 = Basic S2MM functionality
       
    C_M_AXI_S2MM_AWID           : Integer range 0 to  255 :=  1;
       -- Specifies the constant value to output on 
       -- the ARID output port
       
    C_M_AXI_S2MM_ID_WIDTH       : Integer range 1 to  8 :=  4;
       -- Specifies the width of the S2MM ID port 
       
    C_M_AXI_S2MM_ADDR_WIDTH     : Integer range 32 to  64 :=  32;
       -- Specifies the width of the MMap Read Address Channel 
       -- Address bus
       
    C_M_AXI_S2MM_DATA_WIDTH     : Integer range 32 to 1024 :=  32;
       -- Specifies the width of the MMap Read Data Channel
       -- data bus
    
    C_S_AXIS_S2MM_TDATA_WIDTH   : Integer range 8 to 1024 :=  32;
       -- Specifies the width of the S2MM Master Stream Data 
       -- Channel data bus
    
    C_INCLUDE_S2MM_STSFIFO      : Integer range 0 to  1 :=  1;
       -- Specifies if a Status FIFO is to be implemented
       -- 0 = Omit S2MM Status FIFO
       -- 1 = Include S2MM Status FIFO
       
    C_S2MM_STSCMD_FIFO_DEPTH    : Integer range 1 to 16 :=  4;
       -- Specifies the depth of the S2MM Command FIFO and the 
       -- optional Status FIFO
       -- Valid values are 1,4,8,16
       
    C_S2MM_STSCMD_IS_ASYNC      : Integer range 0 to  1 :=  0;
       -- Specifies if the Status and Command interfaces need to
       -- be asynchronous to the primary data path clocking
       -- 0 = Use same clocking as data path
       -- 1 = Use special Status/Command clock for the interfaces
       
    C_INCLUDE_S2MM_DRE          : Integer range 0 to  1 :=  1;
       -- Specifies if DRE is to be included in the S2MM function 
       -- 0 = Omit DRE
       -- 1 = Include DRE
    
    C_S2MM_BURST_SIZE           : Integer range 2 to  256 :=  16;
       -- Specifies the max number of databeats to use for MMap
       -- burst transfers by the S2MM function 
    
    C_S2MM_BTT_USED             : Integer range 8 to  26 :=  16;
      -- Specifies the number of bits used from the BTT field
      -- of the input Command Word of the S2MM Command Interface 
   
    C_S2MM_SUPPORT_INDET_BTT    : Integer range 0 to  1 :=  0;
       -- Specifies if support for indeterminate packet lengths
       -- are to be received on the input Stream interface 
       -- 0 = Omit support (User MUST transfer the exact number of  
       --     bytes on the Stream interface as specified in the BTT 
       --     field of the Corresponding DataMover Command)
       -- 1 = Include support for indeterminate packet lengths
       --     This causes FIFOs to be added and "Store and Forward" 
       --     behavior of the S2MM function

    C_S2MM_ADDR_PIPE_DEPTH      : Integer range 1 to 30 := 3;
        -- This parameter specifies the depth of the S2MM internal 
        -- address pipeline queues in the Write Address Controller 
        -- and the Write Data Controller. Increasing this value will 
        -- allow more Write Addresses to be issued to the AXI4 Write 
        -- Address Channel before transmission of the associated  
        -- write data on the Write Data Channel.

    C_S2MM_INCLUDE_SF           : Integer range 0 to 1 := 1 ;
      -- This parameter specifies the inclusion/omission of the
      -- S2MM (Write) Store and Forward function
      -- 0 = Omit S2MM Store and Forward
      -- 1 = Include S2MM Store and Forward
 
    C_ENABLE_CACHE_USER             : integer range 0 to 1 := 0; 

    C_ENABLE_SKID_BUF                  : string := "11111";
    C_ENABLE_MM2S_TKEEP             : integer range 0 to 1 := 1; 
    C_ENABLE_S2MM_TKEEP             : integer range 0 to 1 := 1;
    C_ENABLE_S2MM_ADV_SIG           : integer range 0 to 1 := 0; 
    C_ENABLE_MM2S_ADV_SIG           : integer range 0 to 1 := 0; 
    C_MICRO_DMA                     : integer range 0 to 1 := 0;
    C_CMD_WIDTH                     : integer range 72 to 112 := 72;
    C_MCDMA                         : integer range 0 to 1 := 0;
     
    C_FAMILY                    : String := "virtex7"
       -- Specifies the target FPGA family type
    
    
    );
  port (

      -- MM2S Primary Clock input ----------------------------------
      m_axi_mm2s_aclk           : in  std_logic;                  --
         -- Primary synchronization clock for the Master side     --
         -- interface and internal logic. It is also used         --
         -- for the User interface synchronization when           --
         -- C_STSCMD_IS_ASYNC = 0.                                --
                                                                  --
      -- MM2S Primary Reset input                                 --
      m_axi_mm2s_aresetn        : in  std_logic;                  --
         -- Reset used for the internal master logic              --
      --------------------------------------------------------------

      -- MM2S Halt request input control --------------------
      mm2s_halt                 : in  std_logic;           --
         -- Active high soft shutdown request              --
                                                           --
      -- MM2S Halt Complete status flag                    --
      mm2s_halt_cmplt           : Out std_logic;           --
         -- Active high soft shutdown complete status      --
      -------------------------------------------------------
      
      
      -- Error discrete output -------------------------
      mm2s_err                  : Out std_logic;      --
         -- Composite Error indication                --
      --------------------------------------------------
     
     
      -- Memory Map to Stream Command FIFO and Status FIFO I/O ---------
      m_axis_mm2s_cmdsts_aclk    : in  std_logic;                     --
      -- Secondary Clock input for async CMD/Status interface         --
                                                                      --
      m_axis_mm2s_cmdsts_aresetn : in  std_logic;                     --
        -- Secondary Reset input for async CMD/Status interface       --
      ------------------------------------------------------------------
      
      
      
      -- User Command Interface Ports (AXI Stream) -------------------------------------------------
      s_axis_mm2s_cmd_tvalid     : in  std_logic;                                                 -- 
      s_axis_mm2s_cmd_tready     : out std_logic;                                                 -- 
      s_axis_mm2s_cmd_tdata      : in  std_logic_vector(C_CMD_WIDTH+(C_MCDMA*3)-1 downto 0); --
      ---------------------------------------------------------------------------------------------- 
      
      -- User Status Interface Ports (AXI Stream) ------------------------
      m_axis_mm2s_sts_tvalid     : out std_logic;                       --
      m_axis_mm2s_sts_tready     : in  std_logic;                       --
      m_axis_mm2s_sts_tdata      : out std_logic_vector(7 downto 0);    --
      m_axis_mm2s_sts_tkeep      : out std_logic_vector(0 downto 0);    --
      m_axis_mm2s_sts_tlast      : out std_logic;                       --
      --------------------------------------------------------------------
      
      
      -- Address Posting contols -----------------------
      mm2s_allow_addr_req       : in  std_logic;      --                 
      mm2s_addr_req_posted      : out std_logic;      --                 
      mm2s_rd_xfer_cmplt        : out std_logic;      --
      --------------------------------------------------                 
      
      
      -- MM2S AXI Address Channel I/O  --------------------------------------------------
      m_axi_mm2s_arid     : out std_logic_vector(C_M_AXI_MM2S_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                              --
                                                                                       --
      m_axi_mm2s_araddr   : out std_logic_vector(C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                                         --
                                                                                       --
      m_axi_mm2s_arlen    : out std_logic_vector(7 downto 0);                          --
         -- AXI Address Channel LEN output                                             --
         -- Sized to support 256 data beat bursts                                      --
                                                                                       --
      m_axi_mm2s_arsize   : out std_logic_vector(2 downto 0);                          --
         -- AXI Address Channel SIZE output                                            --
                                                                                       --
      m_axi_mm2s_arburst  : out std_logic_vector(1 downto 0);                          --
         -- AXI Address Channel BURST output                                           --
                                                                                       --
      m_axi_mm2s_arprot   : out std_logic_vector(2 downto 0);                          --
         -- AXI Address Channel PROT output                                            --
                                                                                       --
      m_axi_mm2s_arcache  : out std_logic_vector(3 downto 0);                          --
         -- AXI Address Channel CACHE output                                           --

      m_axi_mm2s_aruser   : out std_logic_vector(3 downto 0);                          --
         -- AXI Address Channel USER output                                           --
                                                                                       --
      m_axi_mm2s_arvalid  : out std_logic;                                             --
         -- AXI Address Channel VALID output                                           --
                                                                                       --
      m_axi_mm2s_arready  : in  std_logic;                                             --
         -- AXI Address Channel READY input                                            --
      -----------------------------------------------------------------------------------  
                                              
                                              
                                              
                                              
      -- Currently unsupported AXI Address Channel output signals -------
        -- m_axi_mm2s_alock   : out std_logic_vector(2 downto 0);      --
        -- m_axi_mm2s_acache  : out std_logic_vector(4 downto 0);      --
        -- m_axi_mm2s_aqos    : out std_logic_vector(3 downto 0);      --
        -- m_axi_mm2s_aregion : out std_logic_vector(3 downto 0);      --
      -------------------------------------------------------------------
  
  
  
  
      
      -- MM2S AXI MMap Read Data Channel I/O  ------------------------------------------------
      m_axi_mm2s_rdata        : In  std_logic_vector(C_M_AXI_MM2S_DATA_WIDTH-1 downto 0);   -- 
      m_axi_mm2s_rresp        : In  std_logic_vector(1 downto 0);                           -- 
      m_axi_mm2s_rlast        : In  std_logic;                                              -- 
      m_axi_mm2s_rvalid       : In  std_logic;                                              -- 
      m_axi_mm2s_rready       : Out std_logic;                                              -- 
      ----------------------------------------------------------------------------------------
      
      
      -- MM2S AXI Master Stream Channel I/O  -------------------------------------------------------
      m_axis_mm2s_tdata       : Out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0);      -- 
      m_axis_mm2s_tkeep       : Out  std_logic_vector((C_M_AXIS_MM2S_TDATA_WIDTH/8)-1 downto 0);  -- 
      m_axis_mm2s_tlast       : Out  std_logic;                                                   -- 
      m_axis_mm2s_tvalid      : Out  std_logic;                                                   -- 
      m_axis_mm2s_tready      : In   std_logic;                                                   -- 
      ----------------------------------------------------------------------------------------------
      
      -- Testing Support I/O --------------------------------------------------------
      mm2s_dbg_sel            : in  std_logic_vector( 3 downto 0);                 -- 
      mm2s_dbg_data           : out std_logic_vector(31 downto 0) ;                -- 
      -------------------------------------------------------------------------------
      

 
      
      
      -- S2MM Primary Clock input ---------------------------------
      m_axi_s2mm_aclk         : in  std_logic;                   --
         -- Primary synchronization clock for the Master side    --
         -- interface and internal logic. It is also used        --
         -- for the User interface synchronization when          --
         -- C_STSCMD_IS_ASYNC = 0.                               --
                                                                 --
      -- S2MM Primary Reset input                                --
      m_axi_s2mm_aresetn      : in  std_logic;                   --
         -- Reset used for the internal master logic             --
      -------------------------------------------------------------                                                           
 
     
      -- S2MM Halt request input control ------------------
      s2mm_halt               : in  std_logic;           --
         -- Active high soft shutdown request            --
                                                         --
      -- S2MM Halt Complete status flag                  --
      s2mm_halt_cmplt         : out std_logic;           --
         -- Active high soft shutdown complete status    --
      -----------------------------------------------------
      
      
      -- S2MM Error discrete output ------------------
      s2mm_err                : Out std_logic;      --
         -- Composite Error indication              --
      ------------------------------------------------
      
      
     
      -- Memory Map to Stream Command FIFO and Status FIFO I/O -----------------
      m_axis_s2mm_cmdsts_awclk   : in  std_logic;                             --
      -- Secondary Clock input for async CMD/Status interface                 --
                                                                              --
      m_axis_s2mm_cmdsts_aresetn : in  std_logic;                             --
        -- Secondary Reset input for async CMD/Status interface               --
      --------------------------------------------------------------------------  
      
      -- User Command Interface Ports (AXI Stream) --------------------------------------------------
      s_axis_s2mm_cmd_tvalid     : in  std_logic;                                                  --
      s_axis_s2mm_cmd_tready     : out std_logic;                                                  --
      s_axis_s2mm_cmd_tdata      : in  std_logic_vector(C_CMD_WIDTH+(C_MCDMA*3)-1 downto 0);  --
      -----------------------------------------------------------------------------------------------
                                                                                                     
                                                                                                     
      -- User Status Interface Ports (AXI Stream) -----------------------------------------------------------
      m_axis_s2mm_sts_tvalid     : out std_logic;                                                          --
      m_axis_s2mm_sts_tready     : in  std_logic;                                                          --
      m_axis_s2mm_sts_tdata      : out std_logic_vector(((C_S2MM_SUPPORT_INDET_BTT*(24+3*C_MCDMA))+8)-1 downto 0);     --
      m_axis_s2mm_sts_tkeep      : out std_logic_vector((((C_S2MM_SUPPORT_INDET_BTT*24)+8)/8)-1 downto 0); --
      m_axis_s2mm_sts_tlast      : out std_logic;                                                          --
      -------------------------------------------------------------------------------------------------------
      
      -- Address posting controls -----------------------------------------
      s2mm_allow_addr_req    : in  std_logic;                            --
      s2mm_addr_req_posted   : out std_logic;                            --
      s2mm_wr_xfer_cmplt     : out std_logic;                            --
      s2mm_ld_nxt_len        : out std_logic;                            --
      s2mm_wr_len            : out std_logic_vector(7 downto 0);         --
      ---------------------------------------------------------------------
      
     
      -- S2MM AXI Address Channel I/O  ----------------------------------------------------
      m_axi_s2mm_awid       : out std_logic_vector(C_M_AXI_S2MM_ID_WIDTH-1 downto 0);    --
         -- AXI Address Channel ID output                                                --
                                                                                         --
      m_axi_s2mm_awaddr     : out std_logic_vector(C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);  --
         -- AXI Address Channel Address output                                           --
                                                                                         --
      m_axi_s2mm_awlen      : out std_logic_vector(7 downto 0);                          --
         -- AXI Address Channel LEN output                                               --
         -- Sized to support 256 data beat bursts                                        --
                                                                                         --
      m_axi_s2mm_awsize     : out std_logic_vector(2 downto 0);                          --
         -- AXI Address Channel SIZE output                                              --
                                                                                         --
      m_axi_s2mm_awburst    : out std_logic_vector(1 downto 0);                          --
         -- AXI Address Channel BURST output                                             --
                                                                                         --
      m_axi_s2mm_awprot     : out std_logic_vector(2 downto 0);                          --
         -- AXI Address Channel PROT output                                              --
                                                                                         --
      m_axi_s2mm_awcache    : out std_logic_vector(3 downto 0);                          --
         -- AXI Address Channel CACHE output                                             --

      m_axi_s2mm_awuser    : out std_logic_vector(3 downto 0);                          --
         -- AXI Address Channel USER output                                             --
                                                                                         --
      m_axi_s2mm_awvalid    : out std_logic;                                             --
         -- AXI Address Channel VALID output                                             --
                                                                                         --
      m_axi_s2mm_awready    : in  std_logic;                                             --
         -- AXI Address Channel READY input                                              --
      -------------------------------------------------------------------------------------   
      
        
      -- Currently unsupported AXI Address Channel output signals -------
        -- m_axi_s2mm__awlock   : out std_logic_vector(2 downto 0);    --
        -- m_axi_s2mm__awcache  : out std_logic_vector(4 downto 0);    --
        -- m_axi_s2mm__awqos    : out std_logic_vector(3 downto 0);    --
        -- m_axi_s2mm__awregion : out std_logic_vector(3 downto 0);    --
      -------------------------------------------------------------------
  
  
  
  
      
      -- S2MM AXI MMap Write Data Channel I/O  --------------------------------------------------
      m_axi_s2mm_wdata        : Out  std_logic_vector(C_M_AXI_S2MM_DATA_WIDTH-1 downto 0);     --
      m_axi_s2mm_wstrb        : Out  std_logic_vector((C_M_AXI_S2MM_DATA_WIDTH/8)-1 downto 0); --
      m_axi_s2mm_wlast        : Out  std_logic;                                                --
      m_axi_s2mm_wvalid       : Out  std_logic;                                                --
      m_axi_s2mm_wready       : In   std_logic;                                                --
      -------------------------------------------------------------------------------------------
      
      
      -- S2MM AXI MMap Write response Channel I/O  -------------------------
      m_axi_s2mm_bresp        : In   std_logic_vector(1 downto 0);        --
      m_axi_s2mm_bvalid       : In   std_logic;                           --
      m_axi_s2mm_bready       : Out  std_logic;                           --
      ----------------------------------------------------------------------
                                                                          
                                                                          
      -- S2MM AXI Slave Stream Channel I/O  -------------------------------------------------------
      s_axis_s2mm_tdata       : In  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0);      --
      s_axis_s2mm_tkeep       : In  std_logic_vector((C_S_AXIS_S2MM_TDATA_WIDTH/8)-1 downto 0);  --
      s_axis_s2mm_tlast       : In  std_logic;                                                   --
      s_axis_s2mm_tvalid      : In  std_logic;                                                   --
      s_axis_s2mm_tready      : Out std_logic;                                                   --
      ---------------------------------------------------------------------------------------------
      
      -- Testing Support I/O  ------------------------------------------------
      s2mm_dbg_sel            : in  std_logic_vector( 3 downto 0);          --
      s2mm_dbg_data           : out std_logic_vector(31 downto 0)           --
      ------------------------------------------------------------------------
      
 
    );

end entity axi_datamover;


architecture implementation of axi_datamover is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


 
   
   -- Function Declarations 
   
   -------------------------------------------------------------------
   -- Function
   --
   -- Function Name: funct_clip_brst_len
   --
   -- Function Description:
   -- This function is used to limit the parameterized max burst 
   -- databeats when the tranfer data width is 256 bits or greater.
   -- This is required to keep from crossing the 4K byte xfer
   -- boundary required by AXI. This process is further complicated
   -- by the inclusion/omission of upsizers or downsizers in the 
   -- data path.
   --
   -------------------------------------------------------------------
   function funct_clip_brst_len (param_burst_beats         : integer;
                                 mmap_transfer_bit_width   : integer;
                                 stream_transfer_bit_width : integer;
                                 down_up_sizers_enabled    : integer) return integer is
   
     constant FCONST_SIZERS_ENABLED : boolean := (down_up_sizers_enabled > 0);
     Variable fvar_max_burst_dbeats : Integer;
     
     
     
   begin
      
      
      if (FCONST_SIZERS_ENABLED) then -- use MMap dwidth for calc
      
        If (mmap_transfer_bit_width <= 128) Then -- allowed
      
          fvar_max_burst_dbeats := param_burst_beats;
        
        Elsif (mmap_transfer_bit_width <= 256) Then
        
           If (param_burst_beats <= 128) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 128;
           
           End if;
        
        Elsif (mmap_transfer_bit_width <= 512) Then
        
           If (param_burst_beats <= 64) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 64;
           
           End if;
        
        Else -- 1024 bit mmap width case
        
           If (param_burst_beats <= 32) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 32;
           
           End if;
        
        
        End if;
      
      else                            -- use stream dwidth for calc
      
        If (stream_transfer_bit_width <= 128) Then -- allowed
      
          fvar_max_burst_dbeats := param_burst_beats;
        
        Elsif (stream_transfer_bit_width <= 256) Then
        
           If (param_burst_beats <= 128) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 128;
           
           End if;
        
        Elsif (stream_transfer_bit_width <= 512) Then
        
           If (param_burst_beats <= 64) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 64;
           
           End if;
        
        Else -- 1024 bit stream width case
        
           If (param_burst_beats <= 32) Then
    
             fvar_max_burst_dbeats := param_burst_beats;
           
           Else 
           
             fvar_max_burst_dbeats := 32;
           
           End if;
        
        
        End if;
      
      end if;
      
      
      
      Return (fvar_max_burst_dbeats);
        
        
   end function funct_clip_brst_len;
   
   
   
    
   -------------------------------------------------------------------
   -- Function
   --
   -- Function Name: funct_fix_depth_16
   --
   -- Function Description:
   -- This function is used to fix the Command and Status FIFO depths to
   -- 16 entries when Async clocking mode is enabled. This is required
   -- due to the way the async_fifo_fg.vhd design in proc_common is 
   -- implemented.
   -------------------------------------------------------------------
   function funct_fix_depth_16 (async_clocking_mode : integer;
                                requested_depth     : integer) return integer is
   
     Variable fvar_depth_2_use : Integer;
   
   begin
        
      If (async_clocking_mode = 1) Then -- async mode so fix at 16
      
        fvar_depth_2_use := 16;
      
      Elsif (requested_depth > 16) Then -- limit at 16
      
        fvar_depth_2_use := 16;
      
      Else -- use requested depth
        
        fvar_depth_2_use := requested_depth;
      
      End if;
      
      Return (fvar_depth_2_use);
        
        
   end function funct_fix_depth_16;
   
   
   
    
   -------------------------------------------------------------------
   -- Function
   --
   -- Function Name: funct_get_min_btt_width
   --
   -- Function Description:
   --   This function calculates the minimum required value  
   -- for the used width of the command BTT field. 
   --
   -------------------------------------------------------------------
   function funct_get_min_btt_width (max_burst_beats : integer;
                                     bytes_per_beat  : integer ) return integer is
   
     Variable var_min_btt_needed      : Integer;
     Variable var_max_bytes_per_burst : Integer;
   
   
   begin
   
     var_max_bytes_per_burst := max_burst_beats*bytes_per_beat;
     
     
     if (var_max_bytes_per_burst <= 16) then
     
        var_min_btt_needed := 5;
     
     elsif (var_max_bytes_per_burst <= 32) then
     
        var_min_btt_needed := 6;
     
     elsif (var_max_bytes_per_burst <= 64) then
     
        var_min_btt_needed := 7;
     
     elsif (var_max_bytes_per_burst <= 128) then
     
        var_min_btt_needed := 8;
     
     elsif (var_max_bytes_per_burst <= 256) then
     
        var_min_btt_needed := 9;
     
     elsif (var_max_bytes_per_burst <= 512) then
     
        var_min_btt_needed := 10;
     
     elsif (var_max_bytes_per_burst <= 1024) then
     
        var_min_btt_needed := 11;
     
     elsif (var_max_bytes_per_burst <= 2048) then
     
        var_min_btt_needed := 12;
     
     elsif (var_max_bytes_per_burst <= 4096) then
     
        var_min_btt_needed := 13;
     
     else   -- 8K byte range
     
        var_min_btt_needed := 14;
          
     end if;
     
     
     
     Return (var_min_btt_needed);
   
     
   end function funct_get_min_btt_width;
   
   
   -------------------------------------------------------------------
   -- Function
   --
   -- Function Name: funct_get_xfer_bytes_per_dbeat
   --
   -- Function Description:
   --  Calculates the nuber of bytes that will transfered per databeat
   -- on the AXI4 MMap Bus.
   --
   -------------------------------------------------------------------
   function funct_get_xfer_bytes_per_dbeat (mmap_transfer_bit_width   : integer;
                                            stream_transfer_bit_width : integer;
                                            down_up_sizers_enabled    : integer) return integer is
     
     Variable temp_bytes_per_dbeat : Integer := 4;
   
   begin
   
     if (down_up_sizers_enabled > 0) then  -- down/up sizers are in use, use full mmap dwidth
     
        temp_bytes_per_dbeat := mmap_transfer_bit_width/8;
     
     else                                  -- No down/up sizers so use Stream data width
     
        temp_bytes_per_dbeat := stream_transfer_bit_width/8;
     
     end if;
     
   
     Return (temp_bytes_per_dbeat);
   
   
   
   end function funct_get_xfer_bytes_per_dbeat;
   
   
   -------------------------------------------------------------------
   -- Function
   --
   -- Function Name: funct_fix_btt_used
   --
   -- Function Description:
   --  THis function makes sure the BTT width used is at least the
   -- minimum needed.
   --
   -------------------------------------------------------------------
   function funct_fix_btt_used (requested_btt_width : integer;
                                min_btt_width       : integer) return integer is
   
     Variable var_corrected_btt_width : Integer;
   
   begin
   
     
     If (requested_btt_width < min_btt_width) Then
         
       var_corrected_btt_width :=  min_btt_width;
     
     else
         
       var_corrected_btt_width :=  requested_btt_width;
     
     End if;
     
     
     Return (var_corrected_btt_width);
   
     
   end function funct_fix_btt_used;



   function funct_fix_addr     (in_addr_width : integer) return integer is
   
     Variable new_addr_width : Integer;
   
   begin
   
     If (in_addr_width <= 32) Then
       new_addr_width :=  32;
     elsif (in_addr_width > 32 and in_addr_width <= 40) Then
       new_addr_width :=  40;
     elsif (in_addr_width > 40 and in_addr_width <= 48) Then
       new_addr_width :=  48;
     elsif (in_addr_width > 48 and in_addr_width <= 56) Then
       new_addr_width :=  56;
     else
       new_addr_width :=  64;
    
     End if;
     
     Return (new_addr_width);
   
     
   end function funct_fix_addr;
   
   -------------------------------------------------------------------
   -- Constant Declarations 
   -------------------------------------------------------------------
    
   Constant MM2S_TAG_WIDTH         : integer := 4;
   Constant S2MM_TAG_WIDTH         : integer := 4;
   
   Constant MM2S_DOWNSIZER_ENABLED : integer := C_MM2S_INCLUDE_SF;
   Constant S2MM_UPSIZER_ENABLED   : integer := C_S2MM_INCLUDE_SF + C_S2MM_SUPPORT_INDET_BTT;
   
   
   
   Constant MM2S_MAX_BURST_BEATS    : integer   := funct_clip_brst_len(C_MM2S_BURST_SIZE,
                                                                       C_M_AXI_MM2S_DATA_WIDTH,
                                                                       C_M_AXIS_MM2S_TDATA_WIDTH,
                                                                       MM2S_DOWNSIZER_ENABLED);
   
   Constant S2MM_MAX_BURST_BEATS    : integer   := funct_clip_brst_len(C_S2MM_BURST_SIZE,
                                                                       C_M_AXI_S2MM_DATA_WIDTH,
                                                                       C_S_AXIS_S2MM_TDATA_WIDTH,
                                                                       S2MM_UPSIZER_ENABLED);
   
   
   Constant MM2S_CMDSTS_FIFO_DEPTH  : integer := funct_fix_depth_16(C_MM2S_STSCMD_IS_ASYNC,
                                                                    C_MM2S_STSCMD_FIFO_DEPTH);
   
   Constant S2MM_CMDSTS_FIFO_DEPTH  : integer := funct_fix_depth_16(C_S2MM_STSCMD_IS_ASYNC,
                                                                    C_S2MM_STSCMD_FIFO_DEPTH);
   
 
   
   
   Constant MM2S_BYTES_PER_BEAT     : integer := funct_get_xfer_bytes_per_dbeat(C_M_AXI_MM2S_DATA_WIDTH,
                                                                                C_M_AXIS_MM2S_TDATA_WIDTH,
                                                                                MM2S_DOWNSIZER_ENABLED);
   
   Constant MM2S_MIN_BTT_NEEDED     : integer := funct_get_min_btt_width(MM2S_MAX_BURST_BEATS,
                                                                         MM2S_BYTES_PER_BEAT);
   
   Constant MM2S_CORRECTED_BTT_USED : integer := funct_fix_btt_used(C_MM2S_BTT_USED,
                                                                    MM2S_MIN_BTT_NEEDED);
   
   
   Constant S2MM_BYTES_PER_BEAT     : integer := funct_get_xfer_bytes_per_dbeat(C_M_AXI_S2MM_DATA_WIDTH,
                                                                                C_S_AXIS_S2MM_TDATA_WIDTH,
                                                                                S2MM_UPSIZER_ENABLED);
   
   Constant S2MM_MIN_BTT_NEEDED     : integer := funct_get_min_btt_width(S2MM_MAX_BURST_BEATS,
                                                                         S2MM_BYTES_PER_BEAT);
   
   Constant S2MM_CORRECTED_BTT_USED : integer := funct_fix_btt_used(C_S2MM_BTT_USED,
                                                                    S2MM_MIN_BTT_NEEDED);
   
   constant C_M_AXI_MM2S_ADDR_WIDTH_int : integer := funct_fix_addr(C_M_AXI_MM2S_ADDR_WIDTH); 
   constant C_M_AXI_S2MM_ADDR_WIDTH_int : integer := funct_fix_addr(C_M_AXI_S2MM_ADDR_WIDTH); 
 
  -- Signals
   signal sig_mm2s_tstrb     : std_logic_vector((C_M_AXIS_MM2S_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
   signal sig_mm2s_sts_tstrb : std_logic_vector(0 downto 0) := (others => '0');
   signal sig_s2mm_tstrb     : std_logic_vector((C_S_AXIS_S2MM_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
   signal sig_s2mm_sts_tstrb : std_logic_vector((((C_S2MM_SUPPORT_INDET_BTT*24)+8)/8)-1 downto 0) := (others => '0');
   signal m_axi_mm2s_araddr_int : std_logic_vector (C_M_AXI_MM2S_ADDR_WIDTH_int-1 downto 0)  ;
   signal m_axi_s2mm_awaddr_int : std_logic_vector (C_M_AXI_S2MM_ADDR_WIDTH_int-1 downto 0)  ;
 
 
 

begin --(architecture implementation)


  
  
  -------------------------------------------------------------
  -- Conversion to tkeep for external stream connnections
  -------------------------------------------------------------
  
  -- MM2S Status Stream Output    
  m_axis_mm2s_sts_tkeep <= sig_mm2s_sts_tstrb ;
  
  
GEN_MM2S_TKEEP_ENABLE1 : if C_ENABLE_MM2S_TKEEP = 1 generate
begin

  
  -- MM2S Stream Output
  m_axis_mm2s_tkeep     <= sig_mm2s_tstrb     ;
 

end generate GEN_MM2S_TKEEP_ENABLE1;

GEN_MM2S_TKEEP_DISABLE1 : if C_ENABLE_MM2S_TKEEP = 0 generate
begin

  m_axis_mm2s_tkeep        <= (others => '1');

end generate GEN_MM2S_TKEEP_DISABLE1;


 
GEN_S2MM_TKEEP_ENABLE1 : if C_ENABLE_S2MM_TKEEP = 1 generate
begin

  -- S2MM Stream Input
  sig_s2mm_tstrb        <= s_axis_s2mm_tkeep  ;


end generate GEN_S2MM_TKEEP_ENABLE1;

GEN_S2MM_TKEEP_DISABLE1 : if C_ENABLE_S2MM_TKEEP = 0 generate
begin

  sig_s2mm_tstrb        <= (others => '1');

end generate GEN_S2MM_TKEEP_DISABLE1;

  
  -- S2MM Status Stream Output    
  m_axis_s2mm_sts_tkeep <= sig_s2mm_sts_tstrb ;
  
  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_MM2S_OMIT
  --
  -- If Generate Description:
  --  Instantiate the MM2S OMIT Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_MM2S_OMIT : if (C_INCLUDE_MM2S = 0) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_MM2S_OMIT_WRAPPER 
       --
       -- Description:
       -- Read omit Wrapper Instance    
       --
       ------------------------------------------------------------
        I_MM2S_OMIT_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_mm2s_omit_wrap
        generic map (
      
          C_INCLUDE_MM2S           =>  C_INCLUDE_MM2S             ,
          C_MM2S_ARID              =>  C_M_AXI_MM2S_ARID          ,   
          C_MM2S_ID_WIDTH          =>  C_M_AXI_MM2S_ID_WIDTH      ,
          C_MM2S_ADDR_WIDTH        =>  C_M_AXI_MM2S_ADDR_WIDTH_int    ,  
          C_MM2S_MDATA_WIDTH       =>  C_M_AXI_MM2S_DATA_WIDTH    ,  
          C_MM2S_SDATA_WIDTH       =>  C_M_AXIS_MM2S_TDATA_WIDTH  ,  
          C_INCLUDE_MM2S_STSFIFO   =>  C_INCLUDE_MM2S_STSFIFO     ,
          C_MM2S_STSCMD_FIFO_DEPTH =>  MM2S_CMDSTS_FIFO_DEPTH     ,
          C_MM2S_STSCMD_IS_ASYNC   =>  C_MM2S_STSCMD_IS_ASYNC     ,
          C_INCLUDE_MM2S_DRE       =>  C_INCLUDE_MM2S_DRE         ,
          C_MM2S_BURST_SIZE        =>  MM2S_MAX_BURST_BEATS       ,
          C_MM2S_BTT_USED          =>  MM2S_CORRECTED_BTT_USED    ,
          C_MM2S_ADDR_PIPE_DEPTH   =>  C_MM2S_ADDR_PIPE_DEPTH     ,
          C_TAG_WIDTH              =>  MM2S_TAG_WIDTH             ,
          C_ENABLE_CACHE_USER          =>  C_ENABLE_CACHE_USER            ,
          C_FAMILY                 =>  C_FAMILY,
          C_MCDMA                   => C_MCDMA
          )
        port map (
      
          mm2s_aclk                =>  m_axi_mm2s_aclk            ,  
          mm2s_aresetn             =>  m_axi_mm2s_aresetn         ,  
          mm2s_halt                =>  mm2s_halt                  ,
          mm2s_halt_cmplt          =>  mm2s_halt_cmplt            ,
          mm2s_err                 =>  mm2s_err                   ,  
          mm2s_cmdsts_awclk        =>  m_axis_mm2s_cmdsts_aclk    ,  
          mm2s_cmdsts_aresetn      =>  m_axis_mm2s_cmdsts_aresetn ,  
                                   
          mm2s_cmd_wvalid          =>  s_axis_mm2s_cmd_tvalid     ,  
          mm2s_cmd_wready          =>  s_axis_mm2s_cmd_tready     ,  
          mm2s_cmd_wdata           =>  s_axis_mm2s_cmd_tdata      ,  
                                                  
          mm2s_sts_wvalid          =>  m_axis_mm2s_sts_tvalid     ,  
          mm2s_sts_wready          =>  m_axis_mm2s_sts_tready     ,  
          mm2s_sts_wdata           =>  m_axis_mm2s_sts_tdata      ,  
          mm2s_sts_wstrb           =>  sig_mm2s_sts_tstrb         ,  
          mm2s_sts_wlast           =>  m_axis_mm2s_sts_tlast      ,  
                                                  
          mm2s_allow_addr_req      =>  mm2s_allow_addr_req        ,   
          mm2s_addr_req_posted     =>  mm2s_addr_req_posted       ,
          mm2s_rd_xfer_cmplt       =>  mm2s_rd_xfer_cmplt         ,
          
          mm2s_arid                =>  m_axi_mm2s_arid            ,  
          mm2s_araddr              =>  m_axi_mm2s_araddr_int          ,  
          mm2s_arlen               =>  m_axi_mm2s_arlen           ,  
          mm2s_arsize              =>  m_axi_mm2s_arsize          ,  
          mm2s_arburst             =>  m_axi_mm2s_arburst         ,  
          mm2s_arprot              =>  m_axi_mm2s_arprot          ,
          mm2s_arcache             =>  m_axi_mm2s_arcache         ,
          mm2s_aruser              =>  m_axi_mm2s_aruser          ,
          mm2s_arvalid             =>  m_axi_mm2s_arvalid         ,  
          mm2s_arready             =>  m_axi_mm2s_arready         ,  
                                                  
          mm2s_rdata               =>  m_axi_mm2s_rdata           ,  
          mm2s_rresp               =>  m_axi_mm2s_rresp           ,  
          mm2s_rlast               =>  m_axi_mm2s_rlast           ,  
          mm2s_rvalid              =>  m_axi_mm2s_rvalid          ,  
          mm2s_rready              =>  m_axi_mm2s_rready          ,  
                                                  
          mm2s_strm_wdata          =>  m_axis_mm2s_tdata          ,  
          mm2s_strm_wstrb          =>  sig_mm2s_tstrb             ,  
          mm2s_strm_wlast          =>  m_axis_mm2s_tlast          ,  
          mm2s_strm_wvalid         =>  m_axis_mm2s_tvalid         ,  
          mm2s_strm_wready         =>  m_axis_mm2s_tready         ,   
     
          mm2s_dbg_sel             =>  mm2s_dbg_sel               ,
          mm2s_dbg_data            =>  mm2s_dbg_data 
          );
      
 
  
  
     end generate GEN_MM2S_OMIT;



  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_MM2S_FULL
  --
  -- If Generate Description:
  --  Instantiate the MM2S Full Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_MM2S_FULL : if (C_INCLUDE_MM2S = 1) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_MM2S_FULL_WRAPPER 
       --
       -- Description:
       -- Read Full Wrapper Instance    
       --
       ------------------------------------------------------------
        I_MM2S_FULL_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_mm2s_full_wrap
        generic map (
      
          C_INCLUDE_MM2S           =>  C_INCLUDE_MM2S             ,
          C_MM2S_ARID              =>  C_M_AXI_MM2S_ARID          ,   
          C_MM2S_ID_WIDTH          =>  C_M_AXI_MM2S_ID_WIDTH      ,
          C_MM2S_ADDR_WIDTH        =>  C_M_AXI_MM2S_ADDR_WIDTH_int    ,  
          C_MM2S_MDATA_WIDTH       =>  C_M_AXI_MM2S_DATA_WIDTH    ,  
          C_MM2S_SDATA_WIDTH       =>  C_M_AXIS_MM2S_TDATA_WIDTH  ,  
          C_INCLUDE_MM2S_STSFIFO   =>  C_INCLUDE_MM2S_STSFIFO     ,
          C_MM2S_STSCMD_FIFO_DEPTH =>  MM2S_CMDSTS_FIFO_DEPTH     ,
          C_MM2S_STSCMD_IS_ASYNC   =>  C_MM2S_STSCMD_IS_ASYNC     ,
          C_INCLUDE_MM2S_DRE       =>  C_INCLUDE_MM2S_DRE         ,
          C_MM2S_BURST_SIZE        =>  MM2S_MAX_BURST_BEATS       ,
          C_MM2S_BTT_USED          =>  MM2S_CORRECTED_BTT_USED    ,
          C_MM2S_ADDR_PIPE_DEPTH   =>  C_MM2S_ADDR_PIPE_DEPTH     ,
          C_TAG_WIDTH              =>  MM2S_TAG_WIDTH             ,
          C_INCLUDE_MM2S_GP_SF     =>  C_MM2S_INCLUDE_SF          ,
          C_ENABLE_CACHE_USER   =>  C_ENABLE_CACHE_USER     ,
          C_ENABLE_MM2S_TKEEP       =>  C_ENABLE_MM2S_TKEEP        ,
          C_ENABLE_SKID_BUF        =>  C_ENABLE_SKID_BUF           ,
          C_FAMILY                 =>  C_FAMILY                   ,
          C_MCDMA                  => C_MCDMA
          )
        port map (
      
          mm2s_aclk                =>  m_axi_mm2s_aclk            ,  
          mm2s_aresetn             =>  m_axi_mm2s_aresetn         ,  
          mm2s_halt                =>  mm2s_halt                  ,
          mm2s_halt_cmplt          =>  mm2s_halt_cmplt            ,
          mm2s_err                 =>  mm2s_err                   ,  
          mm2s_cmdsts_awclk        =>  m_axis_mm2s_cmdsts_aclk    ,  
          mm2s_cmdsts_aresetn      =>  m_axis_mm2s_cmdsts_aresetn ,  
                                   
          mm2s_cmd_wvalid          =>  s_axis_mm2s_cmd_tvalid     ,  
          mm2s_cmd_wready          =>  s_axis_mm2s_cmd_tready     ,  
          mm2s_cmd_wdata           =>  s_axis_mm2s_cmd_tdata      ,  
                                                  
          mm2s_sts_wvalid          =>  m_axis_mm2s_sts_tvalid     ,  
          mm2s_sts_wready          =>  m_axis_mm2s_sts_tready     ,  
          mm2s_sts_wdata           =>  m_axis_mm2s_sts_tdata      ,  
          mm2s_sts_wstrb           =>  sig_mm2s_sts_tstrb         ,  
          mm2s_sts_wlast           =>  m_axis_mm2s_sts_tlast      ,  
                                                  
          mm2s_allow_addr_req      =>  mm2s_allow_addr_req        ,   
          mm2s_addr_req_posted     =>  mm2s_addr_req_posted       ,
          mm2s_rd_xfer_cmplt       =>  mm2s_rd_xfer_cmplt         ,
          
          mm2s_arid                =>  m_axi_mm2s_arid            ,  
          mm2s_araddr              =>  m_axi_mm2s_araddr_int          ,  
          mm2s_arlen               =>  m_axi_mm2s_arlen           ,  
          mm2s_arsize              =>  m_axi_mm2s_arsize          ,  
          mm2s_arburst             =>  m_axi_mm2s_arburst         ,  
          mm2s_arprot              =>  m_axi_mm2s_arprot          ,  
          mm2s_arcache             =>  m_axi_mm2s_arcache         ,
          mm2s_aruser              =>  m_axi_mm2s_aruser          ,
          mm2s_arvalid             =>  m_axi_mm2s_arvalid         ,  
          mm2s_arready             =>  m_axi_mm2s_arready         ,  
                                                  
          mm2s_rdata               =>  m_axi_mm2s_rdata           ,  
          mm2s_rresp               =>  m_axi_mm2s_rresp           ,  
          mm2s_rlast               =>  m_axi_mm2s_rlast           ,  
          mm2s_rvalid              =>  m_axi_mm2s_rvalid          ,  
          mm2s_rready              =>  m_axi_mm2s_rready          ,  
                                                  
          mm2s_strm_wdata          =>  m_axis_mm2s_tdata          ,  
          mm2s_strm_wstrb          =>  sig_mm2s_tstrb             ,  
          mm2s_strm_wlast          =>  m_axis_mm2s_tlast          ,  
          mm2s_strm_wvalid         =>  m_axis_mm2s_tvalid         ,  
          mm2s_strm_wready         =>  m_axis_mm2s_tready         ,   
     
          mm2s_dbg_sel             =>  mm2s_dbg_sel               ,
          mm2s_dbg_data            =>  mm2s_dbg_data 
          );
      
 
  
  
     end generate GEN_MM2S_FULL;



  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_MM2S_BASIC
  --
  -- If Generate Description:
  --  Instantiate the MM2S Basic Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_MM2S_BASIC : if (C_INCLUDE_MM2S = 2) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_MM2S_BASIC_WRAPPER 
       --
       -- Description:
       -- Read Basic Wrapper Instance    
       --
       ------------------------------------------------------------
        I_MM2S_BASIC_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_mm2s_basic_wrap
        generic map (
      
          C_INCLUDE_MM2S           =>  C_INCLUDE_MM2S             ,
          C_MM2S_ARID              =>  C_M_AXI_MM2S_ARID          ,   
          C_MM2S_ID_WIDTH          =>  C_M_AXI_MM2S_ID_WIDTH      ,
          C_MM2S_ADDR_WIDTH        =>  C_M_AXI_MM2S_ADDR_WIDTH_int    ,  
          C_MM2S_MDATA_WIDTH       =>  C_M_AXI_MM2S_DATA_WIDTH    ,  
          C_MM2S_SDATA_WIDTH       =>  C_M_AXIS_MM2S_TDATA_WIDTH  ,  
          C_INCLUDE_MM2S_STSFIFO   =>  C_INCLUDE_MM2S_STSFIFO     ,
          C_MM2S_STSCMD_FIFO_DEPTH =>  MM2S_CMDSTS_FIFO_DEPTH     ,
          C_MM2S_STSCMD_IS_ASYNC   =>  C_MM2S_STSCMD_IS_ASYNC     ,
          C_INCLUDE_MM2S_DRE       =>  C_INCLUDE_MM2S_DRE         ,
          C_MM2S_BURST_SIZE        =>  MM2S_MAX_BURST_BEATS       ,
          C_MM2S_BTT_USED          =>  MM2S_CORRECTED_BTT_USED    ,
          C_MM2S_ADDR_PIPE_DEPTH   =>  C_MM2S_ADDR_PIPE_DEPTH     ,
          C_TAG_WIDTH              =>  MM2S_TAG_WIDTH             ,
          C_ENABLE_CACHE_USER      =>  C_ENABLE_CACHE_USER        ,
          C_ENABLE_SKID_BUF        =>  C_ENABLE_SKID_BUF          ,
          C_MICRO_DMA              =>  C_MICRO_DMA                ,
          C_FAMILY                 =>  C_FAMILY
          )
        port map (
      
          mm2s_aclk                =>  m_axi_mm2s_aclk            ,  
          mm2s_aresetn             =>  m_axi_mm2s_aresetn         ,  
 
          mm2s_halt                =>  mm2s_halt                  ,
          mm2s_halt_cmplt          =>  mm2s_halt_cmplt            ,          
          mm2s_err                 =>  mm2s_err                   ,  
          mm2s_cmdsts_awclk        =>  m_axis_mm2s_cmdsts_aclk    ,  
          mm2s_cmdsts_aresetn      =>  m_axis_mm2s_cmdsts_aresetn ,  
                                   
          mm2s_cmd_wvalid          =>  s_axis_mm2s_cmd_tvalid     ,  
          mm2s_cmd_wready          =>  s_axis_mm2s_cmd_tready     ,  
          mm2s_cmd_wdata           =>  s_axis_mm2s_cmd_tdata      ,  
                                                  
          mm2s_sts_wvalid          =>  m_axis_mm2s_sts_tvalid     ,  
          mm2s_sts_wready          =>  m_axis_mm2s_sts_tready     ,  
          mm2s_sts_wdata           =>  m_axis_mm2s_sts_tdata      ,  
          mm2s_sts_wstrb           =>  sig_mm2s_sts_tstrb         ,  
          mm2s_sts_wlast           =>  m_axis_mm2s_sts_tlast      ,  
                                                  
          mm2s_allow_addr_req      =>  mm2s_allow_addr_req        ,   
          mm2s_addr_req_posted     =>  mm2s_addr_req_posted       ,
          mm2s_rd_xfer_cmplt       =>  mm2s_rd_xfer_cmplt         ,
          
          mm2s_arid                =>  m_axi_mm2s_arid            ,  
          mm2s_araddr              =>  m_axi_mm2s_araddr_int          ,  
          mm2s_arlen               =>  m_axi_mm2s_arlen           ,  
          mm2s_arsize              =>  m_axi_mm2s_arsize          ,  
          mm2s_arburst             =>  m_axi_mm2s_arburst         ,  
          mm2s_arprot              =>  m_axi_mm2s_arprot          ,  
          mm2s_arcache             =>  m_axi_mm2s_arcache         ,
          mm2s_aruser              =>  m_axi_mm2s_aruser          ,
          mm2s_arvalid             =>  m_axi_mm2s_arvalid         ,  
          mm2s_arready             =>  m_axi_mm2s_arready         ,  
                                                  
          mm2s_rdata               =>  m_axi_mm2s_rdata           ,  
          mm2s_rresp               =>  m_axi_mm2s_rresp           ,  
          mm2s_rlast               =>  m_axi_mm2s_rlast           ,  
          mm2s_rvalid              =>  m_axi_mm2s_rvalid          ,  
          mm2s_rready              =>  m_axi_mm2s_rready          ,  
                                                  
          mm2s_strm_wdata          =>  m_axis_mm2s_tdata          ,  
          mm2s_strm_wstrb          =>  sig_mm2s_tstrb             ,  
          mm2s_strm_wlast          =>  m_axis_mm2s_tlast          ,  
          mm2s_strm_wvalid         =>  m_axis_mm2s_tvalid         ,  
          mm2s_strm_wready         =>  m_axis_mm2s_tready         ,   
     
          mm2s_dbg_sel             =>  mm2s_dbg_sel               ,
          mm2s_dbg_data            =>  mm2s_dbg_data 
          );
      
 
  
  
     end generate GEN_MM2S_BASIC;


  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_S2MM_OMIT
  --
  -- If Generate Description:
  --  Instantiate the S2MM OMIT Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_S2MM_OMIT : if (C_INCLUDE_S2MM = 0) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_S2MM_OMIT_WRAPPER 
       --
       -- Description:
       -- Write Omit Wrapper Instance    
       --
       ------------------------------------------------------------
        I_S2MM_OMIT_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_s2mm_omit_wrap
        generic map (
      
          C_INCLUDE_S2MM            =>  C_INCLUDE_S2MM           ,
          C_S2MM_AWID               =>  C_M_AXI_S2MM_AWID        ,
          C_S2MM_ID_WIDTH           =>  C_M_AXI_S2MM_ID_WIDTH    ,
          C_S2MM_ADDR_WIDTH         =>  C_M_AXI_S2MM_ADDR_WIDTH_int  ,  
          C_S2MM_MDATA_WIDTH        =>  C_M_AXI_S2MM_DATA_WIDTH  ,  
          C_S2MM_SDATA_WIDTH        =>  C_S_AXIS_S2MM_TDATA_WIDTH , 
          C_INCLUDE_S2MM_STSFIFO    =>  C_INCLUDE_S2MM_STSFIFO   ,
          C_S2MM_STSCMD_FIFO_DEPTH  =>  S2MM_CMDSTS_FIFO_DEPTH   ,
          C_S2MM_STSCMD_IS_ASYNC    =>  C_S2MM_STSCMD_IS_ASYNC   ,
          C_INCLUDE_S2MM_DRE        =>  C_INCLUDE_S2MM_DRE       ,
          C_S2MM_BURST_SIZE         =>  S2MM_MAX_BURST_BEATS     ,
          C_S2MM_SUPPORT_INDET_BTT  =>  C_S2MM_SUPPORT_INDET_BTT ,        
          C_S2MM_ADDR_PIPE_DEPTH    =>  C_S2MM_ADDR_PIPE_DEPTH   ,
          C_TAG_WIDTH               =>  S2MM_TAG_WIDTH           ,
          C_ENABLE_CACHE_USER          =>  C_ENABLE_CACHE_USER            ,
          C_FAMILY                  =>  C_FAMILY,
          C_MCDMA                   => C_MCDMA
                  
          )
        port map (
      
          s2mm_aclk            =>  m_axi_s2mm_aclk               , 
          s2mm_aresetn         =>  m_axi_s2mm_aresetn            , 
          s2mm_halt            =>  s2mm_halt                     ,
          s2mm_halt_cmplt      =>  s2mm_halt_cmplt               ,
          s2mm_err             =>  s2mm_err                      , 
          s2mm_cmdsts_awclk    =>  m_axis_s2mm_cmdsts_awclk      , 
          s2mm_cmdsts_aresetn  =>  m_axis_s2mm_cmdsts_aresetn    , 
                                                             
          s2mm_cmd_wvalid      =>  s_axis_s2mm_cmd_tvalid        , 
          s2mm_cmd_wready      =>  s_axis_s2mm_cmd_tready        , 
          s2mm_cmd_wdata       =>  s_axis_s2mm_cmd_tdata         , 
                                              
          s2mm_sts_wvalid      =>  m_axis_s2mm_sts_tvalid        , 
          s2mm_sts_wready      =>  m_axis_s2mm_sts_tready        , 
          s2mm_sts_wdata       =>  m_axis_s2mm_sts_tdata         , 
          s2mm_sts_wstrb       =>  sig_s2mm_sts_tstrb            , 
          s2mm_sts_wlast       =>  m_axis_s2mm_sts_tlast         , 
       
          s2mm_allow_addr_req  =>  s2mm_allow_addr_req           ,
          s2mm_addr_req_posted =>  s2mm_addr_req_posted          ,
          s2mm_wr_xfer_cmplt   =>  s2mm_wr_xfer_cmplt            ,
          s2mm_ld_nxt_len      =>  s2mm_ld_nxt_len               ,
          s2mm_wr_len          =>  s2mm_wr_len                   ,
          
                                              
          s2mm_awid            =>  m_axi_s2mm_awid               , 
          s2mm_awaddr          =>  m_axi_s2mm_awaddr_int             , 
          s2mm_awlen           =>  m_axi_s2mm_awlen              , 
          s2mm_awsize          =>  m_axi_s2mm_awsize             , 
          s2mm_awburst         =>  m_axi_s2mm_awburst            , 
          s2mm_awprot          =>  m_axi_s2mm_awprot             , 
          s2mm_awcache         =>  m_axi_s2mm_awcache            ,
          s2mm_awuser          =>  m_axi_s2mm_awuser             ,
          s2mm_awvalid         =>  m_axi_s2mm_awvalid            , 
          s2mm_awready         =>  m_axi_s2mm_awready            , 
                                              
          s2mm_wdata           =>  m_axi_s2mm_wdata              , 
          s2mm_wstrb           =>  m_axi_s2mm_wstrb              , 
          s2mm_wlast           =>  m_axi_s2mm_wlast              , 
          s2mm_wvalid          =>  m_axi_s2mm_wvalid             , 
          s2mm_wready          =>  m_axi_s2mm_wready             , 
    
          s2mm_bresp           =>  m_axi_s2mm_bresp              , 
          s2mm_bvalid          =>  m_axi_s2mm_bvalid             , 
          s2mm_bready          =>  m_axi_s2mm_bready             , 
                                              
          s2mm_strm_wdata      =>  s_axis_s2mm_tdata             , 
          s2mm_strm_wstrb      =>  sig_s2mm_tstrb                , 
          s2mm_strm_wlast      =>  s_axis_s2mm_tlast             , 
          s2mm_strm_wvalid     =>  s_axis_s2mm_tvalid            , 
          s2mm_strm_wready     =>  s_axis_s2mm_tready            ,  
     
          s2mm_dbg_sel         =>  s2mm_dbg_sel                  ,
          s2mm_dbg_data        =>  s2mm_dbg_data 
          );
  
  
  
     end generate GEN_S2MM_OMIT;


  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_S2MM_FULL
  --
  -- If Generate Description:
  --  Instantiate the S2MM FULL Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_S2MM_FULL : if (C_INCLUDE_S2MM = 1) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_S2MM_FULL_WRAPPER 
       --
       -- Description:
       -- Write Full Wrapper Instance    
       --
       ------------------------------------------------------------
        I_S2MM_FULL_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_s2mm_full_wrap
        generic map (
      
          C_INCLUDE_S2MM            =>  C_INCLUDE_S2MM           ,
          C_S2MM_AWID               =>  C_M_AXI_S2MM_AWID        ,
          C_S2MM_ID_WIDTH           =>  C_M_AXI_S2MM_ID_WIDTH    ,
          C_S2MM_ADDR_WIDTH         =>  C_M_AXI_S2MM_ADDR_WIDTH_int  ,  
          C_S2MM_MDATA_WIDTH        =>  C_M_AXI_S2MM_DATA_WIDTH  ,  
          C_S2MM_SDATA_WIDTH        =>  C_S_AXIS_S2MM_TDATA_WIDTH , 
          C_INCLUDE_S2MM_STSFIFO    =>  C_INCLUDE_S2MM_STSFIFO   ,
          C_S2MM_STSCMD_FIFO_DEPTH  =>  S2MM_CMDSTS_FIFO_DEPTH   ,
          C_S2MM_STSCMD_IS_ASYNC    =>  C_S2MM_STSCMD_IS_ASYNC   ,
          C_INCLUDE_S2MM_DRE        =>  C_INCLUDE_S2MM_DRE       ,
          C_S2MM_BURST_SIZE         =>  S2MM_MAX_BURST_BEATS     ,
          C_S2MM_BTT_USED           =>  S2MM_CORRECTED_BTT_USED  ,
          C_S2MM_SUPPORT_INDET_BTT  =>  C_S2MM_SUPPORT_INDET_BTT ,
          C_S2MM_ADDR_PIPE_DEPTH    =>  C_S2MM_ADDR_PIPE_DEPTH   ,
          C_TAG_WIDTH               =>  S2MM_TAG_WIDTH           ,
          C_INCLUDE_S2MM_GP_SF      =>  C_S2MM_INCLUDE_SF        ,
          C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER   , 
          C_ENABLE_S2MM_TKEEP       =>  C_ENABLE_S2MM_TKEEP        ,
          C_ENABLE_SKID_BUF         =>  C_ENABLE_SKID_BUF        ,
          C_FAMILY                  =>  C_FAMILY,
          C_MCDMA                   =>  C_MCDMA
                  
          )
        port map (
      
          s2mm_aclk            =>  m_axi_s2mm_aclk               , 
          s2mm_aresetn         =>  m_axi_s2mm_aresetn            , 
          s2mm_halt            =>  s2mm_halt                     ,
          s2mm_halt_cmplt      =>  s2mm_halt_cmplt               ,
          s2mm_err             =>  s2mm_err                      , 
          s2mm_cmdsts_awclk    =>  m_axis_s2mm_cmdsts_awclk      , 
          s2mm_cmdsts_aresetn  =>  m_axis_s2mm_cmdsts_aresetn    , 
          
          s2mm_cmd_wvalid      =>  s_axis_s2mm_cmd_tvalid        , 
          s2mm_cmd_wready      =>  s_axis_s2mm_cmd_tready        , 
          s2mm_cmd_wdata       =>  s_axis_s2mm_cmd_tdata         , 
                                              
          s2mm_sts_wvalid      =>  m_axis_s2mm_sts_tvalid        , 
          s2mm_sts_wready      =>  m_axis_s2mm_sts_tready        , 
          s2mm_sts_wdata       =>  m_axis_s2mm_sts_tdata         , 
          s2mm_sts_wstrb       =>  sig_s2mm_sts_tstrb            , 
          s2mm_sts_wlast       =>  m_axis_s2mm_sts_tlast         , 
       
          s2mm_allow_addr_req  =>  s2mm_allow_addr_req           ,
          s2mm_addr_req_posted =>  s2mm_addr_req_posted          ,
          s2mm_wr_xfer_cmplt   =>  s2mm_wr_xfer_cmplt            ,
          s2mm_ld_nxt_len      =>  s2mm_ld_nxt_len               ,
          s2mm_wr_len          =>  s2mm_wr_len                   ,
          
          s2mm_awid            =>  m_axi_s2mm_awid               , 
          s2mm_awaddr          =>  m_axi_s2mm_awaddr_int             , 
          s2mm_awlen           =>  m_axi_s2mm_awlen              , 
          s2mm_awsize          =>  m_axi_s2mm_awsize             , 
          s2mm_awburst         =>  m_axi_s2mm_awburst            , 
          s2mm_awprot          =>  m_axi_s2mm_awprot             , 
          s2mm_awcache         =>  m_axi_s2mm_awcache            ,
          s2mm_awuser          =>  m_axi_s2mm_awuser             ,
          s2mm_awvalid         =>  m_axi_s2mm_awvalid            , 
          s2mm_awready         =>  m_axi_s2mm_awready            , 
                                              
          s2mm_wdata           =>  m_axi_s2mm_wdata              , 
          s2mm_wstrb           =>  m_axi_s2mm_wstrb              , 
          s2mm_wlast           =>  m_axi_s2mm_wlast              , 
          s2mm_wvalid          =>  m_axi_s2mm_wvalid             , 
          s2mm_wready          =>  m_axi_s2mm_wready             , 
    
          s2mm_bresp           =>  m_axi_s2mm_bresp              , 
          s2mm_bvalid          =>  m_axi_s2mm_bvalid             , 
          s2mm_bready          =>  m_axi_s2mm_bready             , 
    
                                              
          s2mm_strm_wdata      =>  s_axis_s2mm_tdata             , 
          s2mm_strm_wstrb      =>  sig_s2mm_tstrb                , 
          s2mm_strm_wlast      =>  s_axis_s2mm_tlast             , 
          s2mm_strm_wvalid     =>  s_axis_s2mm_tvalid            , 
          s2mm_strm_wready     =>  s_axis_s2mm_tready            ,  
     
          s2mm_dbg_sel         =>  s2mm_dbg_sel                  ,
          s2mm_dbg_data        =>  s2mm_dbg_data      
     
          );
  
  
  
     end generate GEN_S2MM_FULL;

  
  ------------------------------------------------------------
  -- If Generate
  --
  -- Label: GEN_S2MM_BASIC
  --
  -- If Generate Description:
  --  Instantiate the S2MM Basic Wrapper 
  --
  --
  ------------------------------------------------------------
  GEN_S2MM_BASIC : if (C_INCLUDE_S2MM = 2) generate
  
  
     begin
  
       ------------------------------------------------------------
       -- Instance: I_S2MM_BASIC_WRAPPER 
       --
       -- Description:
       -- Write Basic Wrapper Instance    
       --
       ------------------------------------------------------------
        I_S2MM_BASIC_WRAPPER : entity axi_datamover_v5_1_17.axi_datamover_s2mm_basic_wrap
        generic map (
      
          C_INCLUDE_S2MM            =>  C_INCLUDE_S2MM           ,
          C_S2MM_AWID               =>  C_M_AXI_S2MM_AWID        ,
          C_S2MM_ID_WIDTH           =>  C_M_AXI_S2MM_ID_WIDTH    ,
          C_S2MM_ADDR_WIDTH         =>  C_M_AXI_S2MM_ADDR_WIDTH_int  ,  
          C_S2MM_MDATA_WIDTH        =>  C_M_AXI_S2MM_DATA_WIDTH  ,  
          C_S2MM_SDATA_WIDTH        =>  C_S_AXIS_S2MM_TDATA_WIDTH , 
          C_INCLUDE_S2MM_STSFIFO    =>  C_INCLUDE_S2MM_STSFIFO   ,
          C_S2MM_STSCMD_FIFO_DEPTH  =>  S2MM_CMDSTS_FIFO_DEPTH   ,
          C_S2MM_STSCMD_IS_ASYNC    =>  C_S2MM_STSCMD_IS_ASYNC   ,
          C_INCLUDE_S2MM_DRE        =>  C_INCLUDE_S2MM_DRE       ,
          C_S2MM_BURST_SIZE         =>  S2MM_MAX_BURST_BEATS     ,
          C_S2MM_ADDR_PIPE_DEPTH    =>  C_S2MM_ADDR_PIPE_DEPTH   ,
          C_TAG_WIDTH               =>  S2MM_TAG_WIDTH           ,
          C_ENABLE_CACHE_USER    =>  C_ENABLE_CACHE_USER   ,
          C_ENABLE_SKID_BUF         =>  C_ENABLE_SKID_BUF        ,
          C_MICRO_DMA              =>  C_MICRO_DMA                ,
          C_FAMILY                  =>  C_FAMILY
                  
          )
        port map (
      
          s2mm_aclk            =>  m_axi_s2mm_aclk               , 
          s2mm_aresetn         =>  m_axi_s2mm_aresetn            , 

          s2mm_halt            =>  s2mm_halt                     ,
          s2mm_halt_cmplt      =>  s2mm_halt_cmplt               ,
          s2mm_err             =>  s2mm_err                      , 
          s2mm_cmdsts_awclk    =>  m_axis_s2mm_cmdsts_awclk      , 
          s2mm_cmdsts_aresetn  =>  m_axis_s2mm_cmdsts_aresetn    , 
          
          s2mm_cmd_wvalid      =>  s_axis_s2mm_cmd_tvalid        , 
          s2mm_cmd_wready      =>  s_axis_s2mm_cmd_tready        , 
          s2mm_cmd_wdata       =>  s_axis_s2mm_cmd_tdata         , 
                                              
          s2mm_sts_wvalid      =>  m_axis_s2mm_sts_tvalid        , 
          s2mm_sts_wready      =>  m_axis_s2mm_sts_tready        , 
          s2mm_sts_wdata       =>  m_axis_s2mm_sts_tdata         , 
          s2mm_sts_wstrb       =>  sig_s2mm_sts_tstrb            , 
          s2mm_sts_wlast       =>  m_axis_s2mm_sts_tlast         , 
       
          s2mm_allow_addr_req  =>  s2mm_allow_addr_req           ,
          s2mm_addr_req_posted =>  s2mm_addr_req_posted          ,
          s2mm_wr_xfer_cmplt   =>  s2mm_wr_xfer_cmplt            ,
          s2mm_ld_nxt_len      =>  s2mm_ld_nxt_len               ,
          s2mm_wr_len          =>  s2mm_wr_len                   ,
                                                        
          s2mm_awid            =>  m_axi_s2mm_awid               , 
          s2mm_awaddr          =>  m_axi_s2mm_awaddr_int             , 
          s2mm_awlen           =>  m_axi_s2mm_awlen              , 
          s2mm_awsize          =>  m_axi_s2mm_awsize             , 
          s2mm_awburst         =>  m_axi_s2mm_awburst            , 
          s2mm_awprot          =>  m_axi_s2mm_awprot             , 
          s2mm_awcache         =>  m_axi_s2mm_awcache            ,
          s2mm_awuser          =>  m_axi_s2mm_awuser             ,
          s2mm_awvalid         =>  m_axi_s2mm_awvalid            , 
          s2mm_awready         =>  m_axi_s2mm_awready            , 
                                              
          s2mm_wdata           =>  m_axi_s2mm_wdata              , 
          s2mm_wstrb           =>  m_axi_s2mm_wstrb              , 
          s2mm_wlast           =>  m_axi_s2mm_wlast              , 
          s2mm_wvalid          =>  m_axi_s2mm_wvalid             , 
          s2mm_wready          =>  m_axi_s2mm_wready             , 
    
          s2mm_bresp           =>  m_axi_s2mm_bresp              , 
          s2mm_bvalid          =>  m_axi_s2mm_bvalid             , 
          s2mm_bready          =>  m_axi_s2mm_bready             , 
    
                                              
          s2mm_strm_wdata      =>  s_axis_s2mm_tdata             , 
          s2mm_strm_wstrb      =>  sig_s2mm_tstrb                , 
          s2mm_strm_wlast      =>  s_axis_s2mm_tlast             , 
          s2mm_strm_wvalid     =>  s_axis_s2mm_tvalid            , 
          s2mm_strm_wready     =>  s_axis_s2mm_tready            ,  
     
          s2mm_dbg_sel         =>  s2mm_dbg_sel                  ,
          s2mm_dbg_data        =>  s2mm_dbg_data      
     
          );
  
  
  
     end generate GEN_S2MM_BASIC;


m_axi_mm2s_araddr <= m_axi_mm2s_araddr_int (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);
m_axi_s2mm_awaddr <= m_axi_s2mm_awaddr_int (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);



end implementation;


