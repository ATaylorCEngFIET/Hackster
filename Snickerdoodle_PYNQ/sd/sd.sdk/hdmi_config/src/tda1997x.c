/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file    tda1997x.c
 * @author  R. Bush
 * @email   bush@krtkl.com
 * @version v1.0
 * @date    2017 September 14
 * @brief   TDA1997x HDMI Receiver
 * @license FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#include "tda1997x.h"


#define DEBUG_PRINT(__format__, ...)		printf("[DEBUG] %s() %s %d: " __format__ "\r\n", __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__)

/**
 * @defgroup	TDA1997X TDA1997x HDMI Receiver
 * @{
 */
#define TDA1997X_HDCP_DDC_ADDR				(0x74U)

#define PAGE_ADDR(__PAGE__, __ADDR__)			(((__PAGE__) << 8) | ((__ADDR__) & 0xFFU))
#define PAGE_OF(__REG__)				((uint8_t)(((__REG__) >> 8) & 0xFFU))

#define EDID_BLOCK_LENGTH				(127)

#define COLOR_CONV_MATRIX_LENGTH			(15)

/* MAN_SUS_HDMI_SEL - PAGE_TMDSB (0x13): 0xE8 */
#define MAN_SUS_HDMI_DIS_OUT_BUF			(1 << 7)
#define MAN_SUS_HDMI_ANA_PATH				(1 << 6)
#define MAN_SUS_HDMI_DIS_HDCP				(1 << 5)
#define MAN_SUS_HDMI_DIS_TMDS_ENC			(1 << 4)
#define MAN_SUS_HDMI_DIS_TMDS_FLOW			(1 << 3)
#define MAN_SUS_HDMI_RST_HDCP				(1 << 2)
#define MAN_SUS_HDMI_TMDS_ENC				(1 << 1)
#define MAN_SUS_HDMI_TMDS_FLOW				(1 << 0)

/* HDMI_SOFT_RST - PAGE_CTRL (0x00): 0x0B */
#define HDMI_SOFT_RESET_DC				(1 << 7)		/**< Soft reset bit */

/* HDMI_INFO_RST - PAGE_CTRL (0x00): 0x0C */
#define INFO_RST_NACK_HDCP				(1 << 7)		/**< Nack HDCP */
#define INFO_RST_AUDIO_FIFO_CTRL			(1 << 5)		/**< Reset audio FIFO control */
#define INFO_RST_AUDIO_FIFO				(1 << 4)		/**< Reset audio FIFO */

#define INFO_RST_AUDIO_FIFO_MASK			(0x30U)

#define INFO_RST_GAMUT					(1 << 3)		/**< Reset gamut */
#define INFO_RST_AI					(1 << 2)		/**< Reset advanced infoframe */
#define INFO_RST_INFOFRAME				(1 << 1)		/**< Reset infoframe */
#define INFO_RST_AUDIO					(1 << 0)		/**< Reset audio */

/* RATE_CTRL - PAGE_CTRL (0x00): 0x40 */
#define RATE_CTRL_REFTIM_ENABLE				(1 << 0)
#define SUS_ENABLE					RATE_CTRL_REFTIM_ENABLE

/* HDCP_CTRL - PAGE_CTRL (0x00): 0x60 */
#define HDCP_CTRL_DECRYPTKEY_ON				(1 << 1)
#define HDCP_CTRL_ENABLE				(1 << 0)

/* HDCP_BCAPS - PAGE_CTRL (0x00): 0x63 */
#define HDCP_BCAPS_DEFAULT				(1 << 7)
#define HDCP_BCAPS_FAST_REAUTH				(1 << 0)

/* FILTERS_CTRL - PAGE_CTRL (0x00): 0xE0 */
#define FILTERS_CTRL_PREFIL_MASK			(0x03U)

/* OF_CTRL - PAGE_CTRL (0x00): 0xEA */
#define OF_CTRL_OUTPUT_ACTIVE				(1 << 7)		/**< Output active */
#define OF_CTRL_VIDEO_HIZ				(1 << 6)		/**< Set video port to high impedance */
#define OF_CTRL_BIT_5					(1 << 5)
#define OF_CTRL_BLANKING_INSERT				(1 << 4)
#define OF_CTRL_TIMINGREF_INSERT			(1 << 3)
#define OF_CTRL_FORMAT_MASK				(0x03U)

#define CLKOUT_CLK_DELAY_MASK				(0x70U)			/**< Clock delay on V_CLK */
#define CLKOUT_CTRL_TOGGLE_ON				(1 << 2)		/**< V_CLK invert polarity */
#define CLKOUT_CLK_SEL_MASK				(0x03U)

enum clkout_clk_sel {
	CLKOUT_CLK_SEL_PCLK = 0x00,
	CLKOUT_CLK_SEL_PCLK_X2 = 0x01,
	CLKOUT_CLK_SEL_PCLK_DIV2 = 0x02,
	CLKOUT_CLK_SEL_PCLK_DIV4 = 0x03
};

#define VDP_CTRL_COMPDEL_BYPASS				(1 << 5)
#define VDP_CTRL_FORMATTER_BYPASS			(1 << 4)

#define VDP_CTRL_PREFILTER_BYPASS			(1 << 1)
#define VDP_CTRL_MATRIX_BYPASS				(1 << 0)

#define DE_FREF_SEL_DELAY_MASK				(0xF0U)			/**< Delay from HDMI to DE */
#define DE_FREF_SEL_PIX_QUAL				(1 << 3)		/**< Pixel qualification */
#define DE_FREF_SEL_POL_INV				(1 << 2)		/**< Invert DE signal polarity */
#define DE_FREF_SEL_OUT_MASK				(0x03U)			/**< Signal output selection */

enum de_fref_sel {
	DE_FREF_SEL_OUT_DE_VHREF = 0x00,
	DE_FREF_SEL_OUT_FREF_VHREF = 0x01,
	DE_FREF_SEL_OUT_FREF_HDMI = 0x02
};

#define HS_HREF_SEL_DELAY_MASK				(0xF0U)			/**< Delay from HDMI to HS */
#define HS_HREF_SEL_PIX_QUAL				(1 << 3)		/**< Pixel qualification */
#define HS_HREF_SEL_POL_INV				(1 << 2)		/**< Invert HS signal polarity */
#define HS_HREF_SEL_OUT_MASK				(0x03U)			/**< Signal output selection */

enum hs_href_sel {
	HS_HREF_SEL_OUT_HS_VHREF = 0x00,
	HS_HREF_SEL_OUT_HREF_VHREF = 0x01,
	HS_HREF_SEL_OUT_HREF_HDMI = 0x02,
	HS_HREF_SEL_OUT_NOT_GENERATED = 0x03
};

#define VS_VREF_SEL_DELAY_MASK				(0xF0U)			/**< Delay from HDMI to VS */
#define VS_VREF_SEL_PIX_QUAL				(1 << 3)		/**< Pixel qualification */
#define VS_VREF_SEL_POL_INV				(1 << 2)		/**< Invert VS signal polarity */
#define VS_VREF_SEL_OUT_MASK				(0x03U)			/**< Signal output selection */

enum vs_vref_sel {
	VS_VREF_SEL_OUT_VS_VHREF = 0x00,
	VS_VREF_SEL_OUT_VREF_VHREF = 0x01,
	VS_VREF_SEL_OUT_VREF_HDMI = 0x02,
	VS_VREF_SEL_OUT_NOT_GENERATED = 0x03
};

#define INPUT_SEL_FORMAT_RESET				(1 << 7)

#define INPUT_SEL_HDMIOUT				(1 << 1)
#define INPUT_SEL_DIG_INPUT				(1 << 0)

#define INPUT_SEL_VDPR_FMT_MASK				(0x85U)


/**
 * @addtogroup	TDA1997X
 * @{
 */
#define AUDIO_PATH_SP_FLAG_USED_BY_FIFO			(1 << 2)
#define AUDIO_PATH_LAYOUT_FORCED			(1 << 1)
#define AUDIO_PATH_LAYOUT_FORCED_1			(1 << 0)

#define AUDIO_SEL_ACLKINV				(1 << 7)		/**< Invert A_CLK pin polarity */
#define AUDIO_SEL_TESTTONE				(1 << 6)		/**< Test tone generator */
#define AUDIO_SEL_SPDIF					(1 << 5)		/**< SPDIF format */
#define AUDIO_SEL_I2S32					(1 << 4)		/**< 32-bit I2S mode */
#define AUDIO_SEL_AUTOMUTE				(1 << 3)		/**< Auto mute audio */
#define AUDIO_SEL_HBR_DEMUX				(1 << 2)		/**< High bit rate demux */
#define AUDIO_SEL_MODE_MASK				(0x03U)			/**< Audio type */

#define AUDIO_LAYOUT_SP_FLAG				(1 << 2)		/**< SP flag used by FIFO control */
#define AUDIO_LAYOUT_MANUAL				(1 << 1)		/**< Manual control of layout */
#define AUDIO_LAYOUT_LAYOUT_1				(1 << 0)

#define AUDIO_OUT_ENABLE_ACLK				(1 << 5)		/**< Audio clock port */
#define AUDIO_OUT_ENABLE_WS				(1 << 4)		/**< Word select port */
#define AUDIO_OUT_ENABLE_AP3				(1 << 3)		/**< AP3 */
#define AUDIO_OUT_ENABLE_AP2				(1 << 2)		/**< AP2 */
#define AUDIO_OUT_ENABLE_AP1				(1 << 1)		/**< AP1 */
#define AUDIO_OUT_ENABLE_AP0				(1 << 0)		/**< AP0 */

#define AUDIO_CLOCK_POWER_OFF				(1 << 7)		/**< Power down audio clocks */
#define AUDIO_CLOCK_REF_TMDS				(1 << 6)		/**< Use TMDS as reference rather than xtal */
#define AUDIO_CLOCK_REF_FREQ_MASK			(0x03U << 4)

enum audio_clock_ref_freq {
	AUDIO_CLOCK_REF_FREQ_13_5MHz = 0x00,
	AUDIO_CLOCK_REF_FREQ_27MHz = 0x10,
	AUDIO_CLOCK_REF_FREQ_54MHz = 0x20
};

#define AUDIO_CLOCK_MODE_MASK				(0x07U)

enum audio_clock_mode {
	AUDIO_CLOCK_MODE_16FS = 0x00,
	AUDIO_CLOCK_MODE_32FS = 0x01,
	AUDIO_CLOCK_MODE_64FS = 0x02,
	AUDIO_CLOCK_MODE_128FS = 0x03,
	AUDIO_CLOCK_MODE_256FS = 0x04,
	AUDIO_CLOCK_MODE_512FS = 0x05
};

/* AUDIO_FLAGS - PAGE_HDMI (0x01): 0x08 */
#define AUDIO_FLAGS_HWMUTE				(1 << 7)
#define AUDIO_FLAGS_PACKET_MASK				(0x0FU)

enum audio_flags_packet {
	AUDIO_FLAGS_PACKET_NONE = 0x00,
	AUDIO_FLAGS_PACKET_SAMPLE = 0x01,
	AUDIO_FLAGS_PACKET_HBR = 0x02,
	AUDIO_FLAGS_PACKET_OBA = 0x04,
	AUDIO_FLAGS_PACKET_DST = 0x08
};
/**
 * @}
 */

/* Interrupt status bits */
#define IRQ_TOP_SUS					(1 << 0)
#define IRQ_TOP_DDC					(1 << 1)
#define IRQ_TOP_RATE					(1 << 2)
#define IRQ_TOP_MODE					(1 << 3)
#define IRQ_TOP_INFO					(1 << 4)
#define IRQ_TOP_AUDIO					(1 << 5)
#define IRQ_TOP_HDCP					(1 << 6)
#define IRQ_TOP_AFE					(1 << 7)

#define NIRQ_TOP_FLAGS					(8)
#define NIRQ_SOURCE_FLAGS				(8)

#define IRQ_SUS_MTP					(1 << 7)
#define IRQ_SUS_FORMAT					(1 << 5)
#define IRQ_SUS_RT_PULSE				(1 << 4)
#define IRQ_SUS_END					(1 << 3)
#define IRQ_SUS_ACTIVITY				(1 << 2)
#define IRQ_SUS_INPUT					(1 << 1)
#define IRQ_SUS_STATE					(1 << 0)

#define IRQ_DDC_EDID_MTP				(1 << 7)
#define IRQ_DDC_ERROR					(1 << 6)
#define IRQ_DDC_CMD_DONE				(1 << 5)
#define IRQ_DDC_READ_DONE				(1 << 4)
#define IRQ_DDC_RX_SW					(1 << 3)
#define IRQ_DDC_HDCP_SW					(1 << 2)
#define IRQ_DDC_PULSE_END				(1 << 1)
#define IRQ_DDC_DET_5V					(1 << 0)

#define IRQ_RATE_RXDB					(1 << 6)
#define IRQ_RATE_RXDA					(1 << 2)

#define IRQ_MODE_FLAGS					(1 << 7)
#define IRQ_MODE_GAMUT					(1 << 6)
#define IRQ_MODE_ISRC2					(1 << 5)
#define IRQ_MODE_ISRC1					(1 << 4)
#define IRQ_MODE_ACP					(1 << 3)
#define IRQ_MODE_DC_CHANGE				(1 << 0)

#define IRQ_INFO_MPS					(1 << 6)
#define IRQ_INFO_AUD					(1 << 5)
#define IRQ_INFO_SPD					(1 << 4)
#define IRQ_INFO_AVI					(1 << 3)
#define IRQ_INFO_VS_OTHER_BK2				(1 << 2)
#define IRQ_INFO_VS_OTHER_BK1				(1 << 1)
#define IRQ_INFO_VS					(1 << 0)

#define IRQ_AUDIO_FREQ_CHANGE				(1 << 5)
#define IRQ_AUDIO_FLAGS					(1 << 4)
#define IRQ_AUDIO_MUTE					(1 << 3)
#define IRQ_AUDIO_CHAN_STATUS				(1 << 2)
#define IRQ_AUDIO_FIFO_UNMUTE				(1 << 1)
#define IRQ_AUDIO_FIFO_ERROR				(1 << 0)

#define IRQ_HDCP_MTP					(1 << 7)
#define IRQ_HDCP_DLMTP					(1 << 4)
#define IRQ_HDCP_STATE_C5				(1 << 1)

#define IRQ_AFE_WDL_UNLOCKED				(1 << 7)		/**< Wordlocker was unlocked */
#define IRQ_AFE_GAIN_DONE				(1 << 6)		/**< Gain calibration done */
#define IRQ_AFE_OFFSET_DONE				(1 << 5)		/**< Offset calibration done */
#define IRQ_AFE_ACTIVITY_DET				(1 << 4)		/**< Activity detected on data */
#define IRQ_AFE_PLL_LOCK				(1 << 3)		/**< TMDS PLL is locked */
#define IRQ_AFE_TRMCAL_DONE				(1 << 2)		/**< Termination calibration done */
#define IRQ_AFE_ASU_STATE				(1 << 1)		/**< ASU state is reached */
#define IRQ_AFE_ASU_READY				(1 << 0)		/**< AFE calibration done: TMDS ready */

/* SUS_STATUS - PAGE_CTRL (0x00): 0x21 */
#define SUS_STATUS_STATE_MASK				(0x1FU)

#define SUS_STATUS_STATE				(1 << 4)

#define SUS_STATUS_CLK_STABLE				(1 << 2)
#define SUS_STATUS_CLK_ACTIVE				(1 << 1)

#define SUS_STATUS_LAST_STATE				(SUS_STATUS_STATE | (1 << 3) | SUS_STATUS_CLK_ACTIVE | (1 << 0))

/* Video port configuration */
#define VP_CTRL_LOZ					(0x00U)
#define VP_CTRL_HIZ					(0x40U)

#define VP_CTRL_A_LSB					(0xC0U)
#define VP_CTRL_A_ISB					(0xC1U)
#define VP_CTRL_A_MSB					(0xC2U)

#define VP_CTRL_B_LSB					(0xC3U)
#define VP_CTRL_B_ISB					(0xC4U)
#define VP_CTRL_B_MSB					(0xC5U)

#define VP_CTRL_C_LSB					(0xC6U)
#define VP_CTRL_C_ISB					(0xC7U)
#define VP_CTRL_C_MSB					(0xC8U)

#define VP_CTRL_RED_LSB 				VP_CTRL_A_LSB
#define VP_CTRL_RED_ISB					VP_CTRL_A_ISB
#define VP_CTRL_RED_MSB					VP_CTRL_A_MSB
#define VP_CTRL_BLUE_LSB				VP_CTRL_B_LSB
#define VP_CTRL_BLUE_ISB				VP_CTRL_B_ISB
#define VP_CTRL_BLUE_MSB				VP_CTRL_B_MSB
#define VP_CTRL_GREEN_LSB				VP_CTRL_C_LSB
#define VP_CTRL_GREEN_ISB				VP_CTRL_C_ISB
#define VP_CTRL_GREEN_MSB				VP_CTRL_C_MSB

#define VP_CTRL_CBCR_LSB				VP_CTRL_A_LSB
#define VP_CTRL_CBCR_ISB				VP_CTRL_A_ISB
#define VP_CTRL_CBCR_MSB				VP_CTRL_A_MSB
#define VP_CTRL_CB_LSB					VP_CTRL_B_LSB
#define VP_CTRL_CB_ISB					VP_CTRL_B_ISB
#define VP_CTRL_CB_MSB					VP_CTRL_B_MSB
#define VP_CTRL_Y_LSB					VP_CTRL_C_LSB
#define VP_CTRL_Y_ISB					VP_CTRL_C_ISB
#define VP_CTRL_Y_MSB					VP_CTRL_C_MSB

#define PIX_REPEAT_UP_SEL_MASK				(0x30U)

enum pix_repeat_up_sel {
	PIX_REPEAT_UP_SEL_BYPASS = 0x00,
	PIX_REPEAT_UP_SEL_REPEATCHROMA = 0x10,
	PIX_REPEAT_UP_SEL_INTERPOLATE  = 0x20
};

#define PIX_REPEAT_PIX_REP_MASK				(0x0FU)

#define HPD_POWER_BYPASS_MASK				(0x0CU)
#define HPD_POWER_EDID_ONLY				(1 << 1)

#define HPD_AUTO_READ_EDID				(1 << 7)
#define HPD_AUTO_F3TECH					(1 << 5)
#define HPD_AUTO_OTHER					(1 << 4)
#define HPD_AUTO_UNSEL					(1 << 3)
#define HPD_AUTO_ALL_CHAN				(1 << 2)
#define HPD_AUTO_PREV_CHAN				(1 << 1)
#define HPD_AUTO_NEW_CHAN				(1 << 0)

#define HPD_MAN_GAIN_MASK				(0x03U)

/* HDMI_FLAGS - PAGE_HDMI (0x01): 0x00 */
#define HDMI_FLAGS_AUDIO				(1 << 7)		/**< Audio packet in last videoframe */
#define HDMI_FLAGS_HDMI					(1 << 6)		/**< HDMI detected */
#define HDMI_FLAGS_EESS					(1 << 5)		/**< EESS detected */
#define HDMI_FLAGS_HDCP					(1 << 4)		/**< HDCP detected */
#define HDMI_FLAGS_AVMUTE				(1 << 3)		/**< AVMUTE */
#define HDMI_FLAGS_AUD_LAYOUT				(1 << 2)		/**< Layout status Audio sample packet */
#define HDMI_FLAGS_AUD_FIFO_OVR				(1 << 1)		/**< FIFO overflow */
#define HDMI_FLAGS_AUD_FIFO_LOW				(1 << 0)		/**< FIFO read ptr within 2 of write */

/* HDMI_CTRL - PAGE_TMDSB (0x13): 0x77 */
#define HDMI_CTRL_MUTE_MASK				(0x0CU)

/* HMTP_CTRL - PAGE_TMDSB (0x13): 0x7A */
#define HMTP_CNTRL_DL_ALL				(1 << 0)

enum hdmi_ctrl_mute {
	HDMI_CTRL_MUTE_AUTO = 0x00,
	HDMI_CTRL_MUTE_OFF = 0x04,
	HDMI_CTRL_MUTE_ON = 0x08
};

#define HDMI_CTRL_HDCP_MASK				(0x03U)
enum hdmi_ctrl_hdcp {
	HDMI_CTRL_HDCP_AUTO = 0x00,
	HDMI_CTRL_HDCP_OESS = 0x01,
	HDMI_CTRL_HDCP_EESS = 0x02
};

enum page {
	PAGE_CTRL = 0x00,
	PAGE_HDMI = 0x01,
	PAGE_AVI = 0x02,
	PAGE_TMDSA = 0x12,
	PAGE_TMDSB = 0x13,
	PAGE_14 = 0x14,
	PAGE_EDIDA = 0x20,
	PAGE_EDIDB = 0x21,
	PAGE_CMTP = 0x30,
	PAGE_MTPA = 0x40,
	PAGE_MTPB = 0x41,
	PAGE_MTPC = 0x42,
	PAGE_INVALID = 0xFF
};

enum hdmi_reg {
	VERSION				= PAGE_ADDR(PAGE_CTRL, 0x00),
	INPUT_SEL			= PAGE_ADDR(PAGE_CTRL, 0x01),
	SERVICE_MODE			= PAGE_ADDR(PAGE_CTRL, 0x02),
	HPD_MAN_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x03),
	RT_MAN_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x04),
	MANUAL_PD_DDC			= PAGE_ADDR(PAGE_CTRL, 0x05),
	MANUAL_PD_TMDS			= PAGE_ADDR(PAGE_CTRL, 0x06),
	MANUAL_PD_VDP			= PAGE_ADDR(PAGE_CTRL, 0x07),
	MANUAL_PD_ADP			= PAGE_ADDR(PAGE_CTRL, 0x08),
	DDC_SOFT_RST			= PAGE_ADDR(PAGE_CTRL, 0x09),
	STANDBY_SOFT_RST		= PAGE_ADDR(PAGE_CTRL, 0x0A),
	HDMI_SOFT_RST			= PAGE_ADDR(PAGE_CTRL, 0x0B),
	HDMI_INFO_RST			= PAGE_ADDR(PAGE_CTRL, 0x0C),
	IRQ_FLG_CLR_TOP			= PAGE_ADDR(PAGE_CTRL, 0x0E),
	IRQ_FLG_CLR_SUS			= PAGE_ADDR(PAGE_CTRL, 0x0F),
	IRQ_FLG_CLR_DDC			= PAGE_ADDR(PAGE_CTRL, 0x10),
	IRQ_FLG_CLR_RATE		= PAGE_ADDR(PAGE_CTRL, 0x11),
	IRQ_FLG_CLR_MODE		= PAGE_ADDR(PAGE_CTRL, 0x12),
	IRQ_FLG_CLR_INFO		= PAGE_ADDR(PAGE_CTRL, 0x13),
	IRQ_FLG_CLR_AUDIO		= PAGE_ADDR(PAGE_CTRL, 0x14),
	IRQ_FLG_CLR_HDCP		= PAGE_ADDR(PAGE_CTRL, 0x15),
	IRQ_FLG_CLR_AFE			= PAGE_ADDR(PAGE_CTRL, 0x16),
	IRQ_MASK_TOP			= PAGE_ADDR(PAGE_CTRL, 0x17),
	IRQ_MASK_SUS			= PAGE_ADDR(PAGE_CTRL, 0x18),
	IRQ_MASK_DDC			= PAGE_ADDR(PAGE_CTRL, 0x19),
	IRQ_MASK_RATE			= PAGE_ADDR(PAGE_CTRL, 0x1A),
	IRQ_MASK_MODE			= PAGE_ADDR(PAGE_CTRL, 0x1B),
	IRQ_MASK_INFO			= PAGE_ADDR(PAGE_CTRL, 0x1C),
	IRQ_MASK_AUDIO			= PAGE_ADDR(PAGE_CTRL, 0x1D),
	IRQ_MASK_HDCP			= PAGE_ADDR(PAGE_CTRL, 0x1E),
	IRQ_MASK_AFE			= PAGE_ADDR(PAGE_CTRL, 0x1F),
	DETECT_5V_HPD			= PAGE_ADDR(PAGE_CTRL, 0x20),
	SUS_STATUS			= PAGE_ADDR(PAGE_CTRL, 0x21),
	V_PER_MSB			= PAGE_ADDR(PAGE_CTRL, 0x22),
	V_PER_ISB			= PAGE_ADDR(PAGE_CTRL, 0x23),
	V_PER_LSB			= PAGE_ADDR(PAGE_CTRL, 0x24),
	H_PER_MSB			= PAGE_ADDR(PAGE_CTRL, 0x25),
	H_PER_LSB			= PAGE_ADDR(PAGE_CTRL, 0x26),
	HS_WIDTH_MSB			= PAGE_ADDR(PAGE_CTRL, 0x27),
	HS_WIDTH_LSB			= PAGE_ADDR(PAGE_CTRL, 0x28),
	FMT_H_TOT_MSB			= PAGE_ADDR(PAGE_CTRL, 0x29),
	FMT_H_TOT_LSB			= PAGE_ADDR(PAGE_CTRL, 0x2A),
	FMT_H_ACT_MSB			= PAGE_ADDR(PAGE_CTRL, 0x2B),
	FMT_H_ACT_LSB			= PAGE_ADDR(PAGE_CTRL, 0x2C),
	FMT_H_FRONT_MSB			= PAGE_ADDR(PAGE_CTRL, 0x2D),
	FMT_H_FRONT_LSB			= PAGE_ADDR(PAGE_CTRL, 0x2E),
	FMT_H_SYNC_MSB			= PAGE_ADDR(PAGE_CTRL, 0x2F),
	FMT_H_SYNC_LSB			= PAGE_ADDR(PAGE_CTRL, 0x30),
	FMT_H_BACK_MSB			= PAGE_ADDR(PAGE_CTRL, 0x31),
	FMT_H_BACK_LSB			= PAGE_ADDR(PAGE_CTRL, 0x32),
	FMT_V_TOT_MSB			= PAGE_ADDR(PAGE_CTRL, 0x33),
	FMT_V_TOT_LSB			= PAGE_ADDR(PAGE_CTRL, 0x34),
	FMT_V_ACT_MSB			= PAGE_ADDR(PAGE_CTRL, 0x35),
	FMT_V_ACT_LSB			= PAGE_ADDR(PAGE_CTRL, 0x36),
	FMT_V_FRONT_F1			= PAGE_ADDR(PAGE_CTRL, 0x37),
	FMT_V_FRONT_F2			= PAGE_ADDR(PAGE_CTRL, 0x38),
	FMT_V_SYNC			= PAGE_ADDR(PAGE_CTRL, 0x39),
	FMT_V_BACK_F1			= PAGE_ADDR(PAGE_CTRL, 0x3A),
	FMT_V_BACK_F2			= PAGE_ADDR(PAGE_CTRL, 0x3B),
	FMT_DE_ACT			= PAGE_ADDR(PAGE_CTRL, 0x3C),
	EQ_STATUS0			= PAGE_ADDR(PAGE_CTRL, 0x3E),
	EQ_STATUS1			= PAGE_ADDR(PAGE_CTRL, 0x3F),
	RATE_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x40),
	RATE_DELTA			= PAGE_ADDR(PAGE_CTRL, 0x41),
	RATE_STABLE_CNT			= PAGE_ADDR(PAGE_CTRL, 0x42),
	CLK_MIN_RATE_MSB		= PAGE_ADDR(PAGE_CTRL, 0x43),
	CLK_MIN_RATE_ISB		= PAGE_ADDR(PAGE_CTRL, 0x44),
	CLK_MIN_RATE_LSB		= PAGE_ADDR(PAGE_CTRL, 0x45),
	CLK_MAX_RATE_MSB		= PAGE_ADDR(PAGE_CTRL, 0x46),
	CLK_MAX_RATE_ISB		= PAGE_ADDR(PAGE_CTRL, 0x47),
	CLK_MAX_RATE_LSB		= PAGE_ADDR(PAGE_CTRL, 0x48),
	CLK_A_STATUS			= PAGE_ADDR(PAGE_CTRL, 0x49),
	CLK_A_RATE_MSB			= PAGE_ADDR(PAGE_CTRL, 0x4A),
	CLK_A_RATE_ISB			= PAGE_ADDR(PAGE_CTRL, 0x4B),
	CLK_A_RATE_LSB			= PAGE_ADDR(PAGE_CTRL, 0x4C),
	DRIFT_CLK_A_REG			= PAGE_ADDR(PAGE_CTRL, 0x4D),
	CLK_B_STATUS			= PAGE_ADDR(PAGE_CTRL, 0x4E),
	CLK_B_RATE_MSB			= PAGE_ADDR(PAGE_CTRL, 0x4F),
	CLK_B_RATE_ISB			= PAGE_ADDR(PAGE_CTRL, 0x50),
	CLK_B_RATE_LSB			= PAGE_ADDR(PAGE_CTRL, 0x51),
	DRIFT_CLK_B_REG			= PAGE_ADDR(PAGE_CTRL, 0x52),
	HDCP_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x60),
	HDCP_KDS_MSB			= PAGE_ADDR(PAGE_CTRL, 0x61),
	HDCP_KDS_LSB			= PAGE_ADDR(PAGE_CTRL, 0x62),
	HDCP_BCAPS			= PAGE_ADDR(PAGE_CTRL, 0x63),
	HDCP_KEY_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x64),
	HDCP_BSTATUS_MSB		= PAGE_ADDR(PAGE_CTRL, 0x65),
	HDCP_BSTATUS_LSB		= PAGE_ADDR(PAGE_CTRL, 0x66),
	FIFO_KSV_IDX			= PAGE_ADDR(PAGE_CTRL, 0x67),
	FIFO_KSV4			= PAGE_ADDR(PAGE_CTRL, 0x68),
	FIFO_KSV3			= PAGE_ADDR(PAGE_CTRL, 0x69),
	FIFO_KSV2			= PAGE_ADDR(PAGE_CTRL, 0x6A),
	FIFO_KSV1			= PAGE_ADDR(PAGE_CTRL, 0x6B),
	FIFO_KSV0			= PAGE_ADDR(PAGE_CTRL, 0x6C),
	HDCP_RPT_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x6D),
	INFO_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x76),
	INFO_EXCEED			= PAGE_ADDR(PAGE_CTRL, 0x77),
	ACP_TIMEOUT			= PAGE_ADDR(PAGE_CTRL, 0x78),
	PACKET_TYPE_SCAN		= PAGE_ADDR(PAGE_CTRL, 0x79),
	PIX_REPEAT			= PAGE_ADDR(PAGE_CTRL, 0x7B),
	AUDIO_PATH			= PAGE_ADDR(PAGE_CTRL, 0x7C),
	AUDIO_SEL			= PAGE_ADDR(PAGE_CTRL, 0x7D),
	AUDIO_OUT_ENABLE		= PAGE_ADDR(PAGE_CTRL, 0x7E),
	AUDIO_OUT_LOW_HIZ		= PAGE_ADDR(PAGE_CTRL, 0x7F),
	VDP_CTRL			= PAGE_ADDR(PAGE_CTRL, 0x80),
	MAT_OI1_MSB			= PAGE_ADDR(PAGE_CTRL, 0x81),
	MAT_OI1_LSB			= PAGE_ADDR(PAGE_CTRL, 0x82),
	MAT_OI2_MSB			= PAGE_ADDR(PAGE_CTRL, 0x83),
	MAT_OI2_LSB			= PAGE_ADDR(PAGE_CTRL, 0x84),
	MAT_OI3_MSB			= PAGE_ADDR(PAGE_CTRL, 0x85),
	MAT_OI3_LSB			= PAGE_ADDR(PAGE_CTRL, 0x86),
	MAT_P11_MSB			= PAGE_ADDR(PAGE_CTRL, 0x87),
	MAT_P11_LSB			= PAGE_ADDR(PAGE_CTRL, 0x88),
	MAT_P12_MSB			= PAGE_ADDR(PAGE_CTRL, 0x89),
	MAT_P12_LSB			= PAGE_ADDR(PAGE_CTRL, 0x8A),
	MAT_P13_MSB			= PAGE_ADDR(PAGE_CTRL, 0x8B),
	MAT_P13_LSB			= PAGE_ADDR(PAGE_CTRL, 0x8C),
	MAT_P21_MSB			= PAGE_ADDR(PAGE_CTRL, 0x8D),
	MAT_P21_LSB			= PAGE_ADDR(PAGE_CTRL, 0x8E),
	MAT_P22_MSB			= PAGE_ADDR(PAGE_CTRL, 0x8F),
	MAT_P22_LSB			= PAGE_ADDR(PAGE_CTRL, 0x90),
	MAT_P23_MSB			= PAGE_ADDR(PAGE_CTRL, 0x91),
	MAT_P23_LSB			= PAGE_ADDR(PAGE_CTRL, 0x92),
	MAT_P31_MSB			= PAGE_ADDR(PAGE_CTRL, 0x93),
	MAT_P31_LSB			= PAGE_ADDR(PAGE_CTRL, 0x94),
	MAT_P32_MSB			= PAGE_ADDR(PAGE_CTRL, 0x95),
	MAT_P32_LSB			= PAGE_ADDR(PAGE_CTRL, 0x96),
	MAT_P33_MSB			= PAGE_ADDR(PAGE_CTRL, 0x97),
	MAT_P33_LSB			= PAGE_ADDR(PAGE_CTRL, 0x98),
	MAT_OO1_MSB			= PAGE_ADDR(PAGE_CTRL, 0x99),
	MAT_OO1_LSB			= PAGE_ADDR(PAGE_CTRL, 0x9A),
	MAT_OO2_MSB			= PAGE_ADDR(PAGE_CTRL, 0x9B),
	MAT_OO2_LSB			= PAGE_ADDR(PAGE_CTRL, 0x9C),
	MAT_OO3_MSB			= PAGE_ADDR(PAGE_CTRL, 0x9D),
	MAT_OO3_LSB			= PAGE_ADDR(PAGE_CTRL, 0x9E),
	VHREF_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xA0),
	PXCNT_PR_MSB			= PAGE_ADDR(PAGE_CTRL, 0xA2),
	PXCNT_PR_LSB			= PAGE_ADDR(PAGE_CTRL, 0xA3),
	PXCNT_NPIX_MSB			= PAGE_ADDR(PAGE_CTRL, 0xA4),
	PXCNT_NPIX_LSB			= PAGE_ADDR(PAGE_CTRL, 0xA5),
	LCNT_PR_MSB			= PAGE_ADDR(PAGE_CTRL, 0xA6),
	LCNT_PR_LSB			= PAGE_ADDR(PAGE_CTRL, 0xA7),
	LCNT_NLIN_MSB			= PAGE_ADDR(PAGE_CTRL, 0xA8),
	LCNT_NLIN_LSB			= PAGE_ADDR(PAGE_CTRL, 0xA9),
	HREF_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xAA),
	HREF_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xAB),
	HREF_E_MSB			= PAGE_ADDR(PAGE_CTRL, 0xAC),
	HREF_E_LSB			= PAGE_ADDR(PAGE_CTRL, 0xAD),
	HS_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xAE),
	HS_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xAF),
	HS_E_MSB			= PAGE_ADDR(PAGE_CTRL, 0xB0),
	HS_E_LSB			= PAGE_ADDR(PAGE_CTRL, 0xB1),
	VREF_F1_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xB2),
	VREF_F1_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xB3),
	VREF_F1_WIDTH			= PAGE_ADDR(PAGE_CTRL, 0xB4),
	VREF_F2_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xB5),
	VREF_F2_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xB6),
	VREF_F2_WIDTH			= PAGE_ADDR(PAGE_CTRL, 0xB7),
	VS_F1_LINE_S_MSB		= PAGE_ADDR(PAGE_CTRL, 0xB8),
	VS_F1_LINE_S_LSB		= PAGE_ADDR(PAGE_CTRL, 0xB9),
	VS_F1_LINE_WIDTH		= PAGE_ADDR(PAGE_CTRL, 0xBA),
	VS_F2_LINE_S_MSB		= PAGE_ADDR(PAGE_CTRL, 0xBB),
	VS_F2_LINE_S_LSB		= PAGE_ADDR(PAGE_CTRL, 0xBC),
	VS_F2_LINE_WIDTH		= PAGE_ADDR(PAGE_CTRL, 0xBD),
	VS_F1_PIX_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xBE),
	VS_F1_PIX_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xBF),
	VS_F1_PIX_E_MSB			= PAGE_ADDR(PAGE_CTRL, 0xC0),
	VS_F1_PIX_E_LSB			= PAGE_ADDR(PAGE_CTRL, 0xC1),
	VS_F2_PIX_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xC2),
	VS_F2_PIX_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xC3),
	VS_F2_PIX_E_MSB			= PAGE_ADDR(PAGE_CTRL, 0xC4),
	VS_F2_PIX_E_LSB			= PAGE_ADDR(PAGE_CTRL, 0xC5),
	FREF_F1_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xC6),
	FREF_F1_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xC7),
	FREF_F2_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xC8),
	FREF_F2_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xC9),
	FDW_S_MSB			= PAGE_ADDR(PAGE_CTRL, 0xCA),
	FDW_S_LSB			= PAGE_ADDR(PAGE_CTRL, 0xCB),
	FDW_E_MSB			= PAGE_ADDR(PAGE_CTRL, 0xCC),
	FDW_E_LSB			= PAGE_ADDR(PAGE_CTRL, 0xCD),
	MEASLIN_MSB			= PAGE_ADDR(PAGE_CTRL, 0xCE),
	MEASLIN_LSB			= PAGE_ADDR(PAGE_CTRL, 0xCF),
	MEASPIX_MSB			= PAGE_ADDR(PAGE_CTRL, 0xD0),
	MEASPIX_LSB			= PAGE_ADDR(PAGE_CTRL, 0xD1),
	ASD_MEASLIN_MSB			= PAGE_ADDR(PAGE_CTRL, 0xD2),
	BLK_GY_MSB			= PAGE_ADDR(PAGE_CTRL, 0xDA),
	BLK_GY_LSB			= PAGE_ADDR(PAGE_CTRL, 0xDB),
	BLK_BU_MSB			= PAGE_ADDR(PAGE_CTRL, 0xDC),
	BLK_BU_LSB			= PAGE_ADDR(PAGE_CTRL, 0xDD),
	BLK_RV_MSB			= PAGE_ADDR(PAGE_CTRL, 0xDE),
	BLK_RV_LSB			= PAGE_ADDR(PAGE_CTRL, 0xDF),
	FILTERS_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xE0),
	C_CEIL_MSB			= PAGE_ADDR(PAGE_CTRL, 0xE1),
	C_CEIL_LSB			= PAGE_ADDR(PAGE_CTRL, 0xE2),
	C_FLOOR_MSB			= PAGE_ADDR(PAGE_CTRL, 0xE3),
	C_FLOOR_LSB			= PAGE_ADDR(PAGE_CTRL, 0xE4),
	Y_CEIL_MSB			= PAGE_ADDR(PAGE_CTRL, 0xE5),
	Y_CEIL_LSB			= PAGE_ADDR(PAGE_CTRL, 0xE6),
	Y_FLOOR_MSB			= PAGE_ADDR(PAGE_CTRL, 0xE7),
	Y_FLOOR_LSB			= PAGE_ADDR(PAGE_CTRL, 0xE8),
	DITHERING_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xE9),
	OF_CTRL				= PAGE_ADDR(PAGE_CTRL, 0xEA),
	CLKOUT_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xEB),
	HS_HREF_SEL			= PAGE_ADDR(PAGE_CTRL, 0xEC),
	VS_VREF_SEL			= PAGE_ADDR(PAGE_CTRL, 0xED),
	DE_FREF_SEL			= PAGE_ADDR(PAGE_CTRL, 0xEE),
	VP35_32_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xEF),
	VP31_28_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF0),
	VP27_24_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF1),
	VP23_20_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF2),
	VP19_16_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF3),
	VP15_12_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF4),
	VP11_8_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF5),
	VP7_4_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF6),
	VP3_0_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xF7),
	EMTP_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xFA),
	EMTP_ADDRESS			= PAGE_ADDR(PAGE_CTRL, 0xFB),
	CMTP_CTRL			= PAGE_ADDR(PAGE_CTRL, 0xFC),
	CMTP_ADDRESS			= PAGE_ADDR(PAGE_CTRL, 0xFD),
	ECC_CHECK			= PAGE_ADDR(PAGE_CTRL, 0xFE),

	HDMI_FLAGS			= PAGE_ADDR(PAGE_HDMI, 0x00),
	DEEP_COLOR_MODE			= PAGE_ADDR(PAGE_HDMI, 0x01),
	ERR_FR_MSB			= PAGE_ADDR(PAGE_HDMI, 0x02),
	ERR_FR_LSB			= PAGE_ADDR(PAGE_HDMI, 0x03),
	FR_ERR_MSB			= PAGE_ADDR(PAGE_HDMI, 0x04),
	FR_ERR_LSB			= PAGE_ADDR(PAGE_HDMI, 0x05),
	AUDIO_FLAGS			= PAGE_ADDR(PAGE_HDMI, 0x08),
	AUDIO_FREQ			= PAGE_ADDR(PAGE_HDMI, 0x09),
	ACRP_CTS_MSB			= PAGE_ADDR(PAGE_HDMI, 0x0A),
	ACRP_CTS_ISB			= PAGE_ADDR(PAGE_HDMI, 0x0B),
	ACRP_CTS_LSB			= PAGE_ADDR(PAGE_HDMI, 0x0C),
	ACRP_N_MSB			= PAGE_ADDR(PAGE_HDMI, 0x0D),
	ACRP_N_ISB			= PAGE_ADDR(PAGE_HDMI, 0x0E),
	ACRP_N_LSB			= PAGE_ADDR(PAGE_HDMI, 0x0F),
	CH_STAT_BYTE0			= PAGE_ADDR(PAGE_HDMI, 0x10),
	CH_STAT_BYTE1			= PAGE_ADDR(PAGE_HDMI, 0x11),
	CH_STAT_BYTE3			= PAGE_ADDR(PAGE_HDMI, 0x12),
	CH_STAT_BYTE4			= PAGE_ADDR(PAGE_HDMI, 0x13),
	CH_STAT_BYTE2_AP0_L 		= PAGE_ADDR(PAGE_HDMI, 0x14),
	CH_STAT_BYTE2_AP0_R 		= PAGE_ADDR(PAGE_HDMI, 0x15),
	CH_STAT_BYTE2_AP1_L 		= PAGE_ADDR(PAGE_HDMI, 0x16),
	CH_STAT_BYTE2_AP1_R 		= PAGE_ADDR(PAGE_HDMI, 0x17),
	CH_STAT_BYTE2_AP2_L		= PAGE_ADDR(PAGE_HDMI, 0x18),
	CH_STAT_BYTE2_AP2_R		= PAGE_ADDR(PAGE_HDMI, 0x19),
	CH_STAT_BYTE2_AP3_L		= PAGE_ADDR(PAGE_HDMI, 0x1A),
	CH_STAT_BYTE2_AP3_R		= PAGE_ADDR(PAGE_HDMI, 0x1B),
	GCP_PACKET_TYPE			= PAGE_ADDR(PAGE_HDMI, 0x21),
	GCP_HEADER1			= PAGE_ADDR(PAGE_HDMI, 0x22),
	GCP_HEADER2			= PAGE_ADDR(PAGE_HDMI, 0x23),
	GCP_BYTE0			= PAGE_ADDR(PAGE_HDMI, 0x24),
	GCP_BYTE1			= PAGE_ADDR(PAGE_HDMI, 0x25),
	GCP_BYTE2			= PAGE_ADDR(PAGE_HDMI, 0x26),
	GCP_BYTE3			= PAGE_ADDR(PAGE_HDMI, 0x27),
	GCP_BYTE4			= PAGE_ADDR(PAGE_HDMI, 0x28),
	GCP_BYTE5			= PAGE_ADDR(PAGE_HDMI, 0x29),
	GCP_BYTE6			= PAGE_ADDR(PAGE_HDMI, 0x2A),
	ACP_UPDATE			= PAGE_ADDR(PAGE_HDMI, 0x40),
	ACP_PACKET_TYPE			= PAGE_ADDR(PAGE_HDMI, 0x41),
	ACP_TYPE			= PAGE_ADDR(PAGE_HDMI, 0x42),
	ACP_RSVD			= PAGE_ADDR(PAGE_HDMI, 0x43),
	ACP_BYTE0			= PAGE_ADDR(PAGE_HDMI, 0x44),
	ACP_BYTE1			= PAGE_ADDR(PAGE_HDMI, 0x45),
	ACP_BYTE2			= PAGE_ADDR(PAGE_HDMI, 0x46),
	ACP_BYTE3			= PAGE_ADDR(PAGE_HDMI, 0x47),
	ACP_BYTE4			= PAGE_ADDR(PAGE_HDMI, 0x48),
	ACP_BYTE5			= PAGE_ADDR(PAGE_HDMI, 0x49),
	ACP_BYTE6			= PAGE_ADDR(PAGE_HDMI, 0x4A),
	ACP_BYTE7			= PAGE_ADDR(PAGE_HDMI, 0x4B),
	ACP_BYTE8			= PAGE_ADDR(PAGE_HDMI, 0x4C),
	ACP_BYTE9			= PAGE_ADDR(PAGE_HDMI, 0x4D),
	ACP_BYTE10			= PAGE_ADDR(PAGE_HDMI, 0x4E),
	ACP_BYTE11			= PAGE_ADDR(PAGE_HDMI, 0x4F),
	ACP_BYTE12			= PAGE_ADDR(PAGE_HDMI, 0x50),
	ACP_BYTE13			= PAGE_ADDR(PAGE_HDMI, 0x51),
	ACP_BYTE14			= PAGE_ADDR(PAGE_HDMI, 0x52),
	ACP_BYTE15			= PAGE_ADDR(PAGE_HDMI, 0x53),
	ISRC1_PACKET_TYPE		= PAGE_ADDR(PAGE_HDMI, 0x61),
	ISRC1_CTRL			= PAGE_ADDR(PAGE_HDMI, 0x62),
	ISRC1_RSVD			= PAGE_ADDR(PAGE_HDMI, 0x63),
	UPC_EAN_ISRC0			= PAGE_ADDR(PAGE_HDMI, 0x64),
	UPC_EAN_ISRC1			= PAGE_ADDR(PAGE_HDMI, 0x65),
	UPC_EAN_ISRC2			= PAGE_ADDR(PAGE_HDMI, 0x66),
	UPC_EAN_ISRC3			= PAGE_ADDR(PAGE_HDMI, 0x67),
	UPC_EAN_ISRC4			= PAGE_ADDR(PAGE_HDMI, 0x68),
	UPC_EAN_ISRC5			= PAGE_ADDR(PAGE_HDMI, 0x69),
	UPC_EAN_ISRC6			= PAGE_ADDR(PAGE_HDMI, 0x6A),
	UPC_EAN_ISRC7			= PAGE_ADDR(PAGE_HDMI, 0x6B),
	UPC_EAN_ISRC8			= PAGE_ADDR(PAGE_HDMI, 0x6C),
	UPC_EAN_ISRC9			= PAGE_ADDR(PAGE_HDMI, 0x6D),
	UPC_EAN_ISRC10			= PAGE_ADDR(PAGE_HDMI, 0x6E),
	UPC_EAN_ISRC11			= PAGE_ADDR(PAGE_HDMI, 0x6F),
	UPC_EAN_ISRC12			= PAGE_ADDR(PAGE_HDMI, 0x70),
	UPC_EAN_ISRC13			= PAGE_ADDR(PAGE_HDMI, 0x71),
	UPC_EAN_ISRC14			= PAGE_ADDR(PAGE_HDMI, 0x72),
	UPC_EAN_ISRC15			= PAGE_ADDR(PAGE_HDMI, 0x73),
	ISRC2_PACKET_TYPE		= PAGE_ADDR(PAGE_HDMI, 0x81),
	ISRC2_RSVD1			= PAGE_ADDR(PAGE_HDMI, 0x82),
	ISRC2_RSVD2			= PAGE_ADDR(PAGE_HDMI, 0x83),
	UPC_EAN_ISRC16			= PAGE_ADDR(PAGE_HDMI, 0x84),
	UPC_EAN_ISRC17			= PAGE_ADDR(PAGE_HDMI, 0x85),
	UPC_EAN_ISRC18			= PAGE_ADDR(PAGE_HDMI, 0x86),
	UPC_EAN_ISRC19			= PAGE_ADDR(PAGE_HDMI, 0x87),
	UPC_EAN_ISRC20			= PAGE_ADDR(PAGE_HDMI, 0x88),
	UPC_EAN_ISRC21			= PAGE_ADDR(PAGE_HDMI, 0x89),
	UPC_EAN_ISRC22			= PAGE_ADDR(PAGE_HDMI, 0x8A),
	UPC_EAN_ISRC23			= PAGE_ADDR(PAGE_HDMI, 0x8B),
	UPC_EAN_ISRC24			= PAGE_ADDR(PAGE_HDMI, 0x8C),
	UPC_EAN_ISRC25			= PAGE_ADDR(PAGE_HDMI, 0x8D),
	UPC_EAN_ISRC26			= PAGE_ADDR(PAGE_HDMI, 0x8E),
	UPC_EAN_ISRC27			= PAGE_ADDR(PAGE_HDMI, 0x8F),
	UPC_EAN_ISRC28			= PAGE_ADDR(PAGE_HDMI, 0x90),
	UPC_EAN_ISRC29			= PAGE_ADDR(PAGE_HDMI, 0x91),
	UPC_EAN_ISRC30			= PAGE_ADDR(PAGE_HDMI, 0x92),
	UPC_EAN_ISRC31			= PAGE_ADDR(PAGE_HDMI, 0x93),
	GBD_UPDATE			= PAGE_ADDR(PAGE_HDMI, 0xA0),
	GBD_PACKET_TYPE			= PAGE_ADDR(PAGE_HDMI, 0xA1),
	GBD_HEADER1			= PAGE_ADDR(PAGE_HDMI, 0xA2),
	GBD_HEADER2			= PAGE_ADDR(PAGE_HDMI, 0xA3),
	GBD_BYTE0			= PAGE_ADDR(PAGE_HDMI, 0xA4),
	GBD_BYTE1			= PAGE_ADDR(PAGE_HDMI, 0xA5),
	GBD_BYTE2			= PAGE_ADDR(PAGE_HDMI, 0xA6),
	GBD_BYTE3			= PAGE_ADDR(PAGE_HDMI, 0xA7),
	GBD_BYTE4			= PAGE_ADDR(PAGE_HDMI, 0xA8),
	GBD_BYTE5			= PAGE_ADDR(PAGE_HDMI, 0xA9),
	GBD_BYTE6			= PAGE_ADDR(PAGE_HDMI, 0xAA),
	GBD_BYTE7			= PAGE_ADDR(PAGE_HDMI, 0xAB),
	GBD_BYTE8			= PAGE_ADDR(PAGE_HDMI, 0xAC),
	GBD_BYTE9			= PAGE_ADDR(PAGE_HDMI, 0xAD),
	GBD_BYTE10			= PAGE_ADDR(PAGE_HDMI, 0xAE),
	GBD_BYTE11			= PAGE_ADDR(PAGE_HDMI, 0xAF),
	GBD_BYTE12			= PAGE_ADDR(PAGE_HDMI, 0xB0),
	GBD_BYTE13			= PAGE_ADDR(PAGE_HDMI, 0xB1),
	GBD_BYTE14			= PAGE_ADDR(PAGE_HDMI, 0xB2),
	GBD_BYTE15			= PAGE_ADDR(PAGE_HDMI, 0xB3),
	GBD_BYTE16			= PAGE_ADDR(PAGE_HDMI, 0xB4),
	GBD_BYTE17			= PAGE_ADDR(PAGE_HDMI, 0xB5),
	GBD_BYTE18			= PAGE_ADDR(PAGE_HDMI, 0xB6),
	GBD_BYTE19			= PAGE_ADDR(PAGE_HDMI, 0xB7),
	GBD_BYTE20			= PAGE_ADDR(PAGE_HDMI, 0xB8),
	GBD_BYTE21			= PAGE_ADDR(PAGE_HDMI, 0xB9),
	GBD_BYTE22			= PAGE_ADDR(PAGE_HDMI, 0xBA),
	GBD_BYTE23			= PAGE_ADDR(PAGE_HDMI, 0xBB),
	GBD_BYTE24			= PAGE_ADDR(PAGE_HDMI, 0xBC),
	GBD_BYTE25			= PAGE_ADDR(PAGE_HDMI, 0xBD),
	GBD_BYTE26			= PAGE_ADDR(PAGE_HDMI, 0xBE),
	GBD_BYTE27			= PAGE_ADDR(PAGE_HDMI, 0xBF),
	HDCP_RI_MSB			= PAGE_ADDR(PAGE_HDMI, 0xE0),
	HDCP_RI_LSB			= PAGE_ADDR(PAGE_HDMI, 0xE1),
	HDCP_PJ				= PAGE_ADDR(PAGE_HDMI, 0xE2),
	HDCP_AKSV4			= PAGE_ADDR(PAGE_HDMI, 0xE3),
	HDCP_AKSV3			= PAGE_ADDR(PAGE_HDMI, 0xE4),
	HDCP_AKSV2			= PAGE_ADDR(PAGE_HDMI, 0xE5),
	HDCP_AKSV1			= PAGE_ADDR(PAGE_HDMI, 0xE6),
	HDCP_AKSV0			= PAGE_ADDR(PAGE_HDMI, 0xE7),
	HDCP_AN7			= PAGE_ADDR(PAGE_HDMI, 0xE8),
	HDCP_AN6			= PAGE_ADDR(PAGE_HDMI, 0xE9),
	HDCP_AN5			= PAGE_ADDR(PAGE_HDMI, 0xEA),
	HDCP_AN4			= PAGE_ADDR(PAGE_HDMI, 0xEB),
	HDCP_AN3			= PAGE_ADDR(PAGE_HDMI, 0xEC),
	HDCP_AN2			= PAGE_ADDR(PAGE_HDMI, 0xED),
	HDCP_AN1			= PAGE_ADDR(PAGE_HDMI, 0xEE),
	HDCP_AN0			= PAGE_ADDR(PAGE_HDMI, 0xEF),
	HDCP_AINFO			= PAGE_ADDR(PAGE_HDMI, 0xF0),
	HDCP_FSM_STATE			= PAGE_ADDR(PAGE_HDMI, 0xF1),

	VS_IF_HDMI_UPDATE		= PAGE_ADDR(PAGE_AVI, 0x00),
	VS_IF_HDMI_TYPE			= PAGE_ADDR(PAGE_AVI, 0x01),
	VS_IF_HDMI_VERSION		= PAGE_ADDR(PAGE_AVI, 0x02),
	VS_IF_HDMI_LENGTH		= PAGE_ADDR(PAGE_AVI, 0x03),
	VS_IF_HDMI_CHECKSUM		= PAGE_ADDR(PAGE_AVI, 0x04),
	VS_IF_HDMI_BYTE1		= PAGE_ADDR(PAGE_AVI, 0x05),
	VS_IF_HDMI_BYTE27		= PAGE_ADDR(PAGE_AVI, 0x1F),
	VS_IF_OTHER_BK1_UPDATE		= PAGE_ADDR(PAGE_AVI, 0x20),
	VS_IF_OTHER_BK1_TYPE		= PAGE_ADDR(PAGE_AVI, 0x21),
	VS_IF_OTHER_BK1_VERSION 	= PAGE_ADDR(PAGE_AVI, 0x22),
	VS_IF_OTHER_BK1_LENGTH		= PAGE_ADDR(PAGE_AVI, 0x23),
	VS_IF_OTHER_BK1_CHECKSUM	= PAGE_ADDR(PAGE_AVI, 0x24),
	VS_IF_OTHER_BK1_BYTE1		= PAGE_ADDR(PAGE_AVI, 0x25),
	VS_IF_OTHER_BK1_BYTE27		= PAGE_ADDR(PAGE_AVI, 0x3F),
	VS_IF_OTHER_BK2_UPDATE		= PAGE_ADDR(PAGE_AVI, 0x40),
	VS_IF_OTHER_BK2_TYPE		= PAGE_ADDR(PAGE_AVI, 0x41),
	VS_IF_OTHER_BK2_VERSION		= PAGE_ADDR(PAGE_AVI, 0x42),
	VS_IF_OTHER_BK2_LENGTH		= PAGE_ADDR(PAGE_AVI, 0x43),
	VS_IF_OTHER_BK2_CHECKSUM	= PAGE_ADDR(PAGE_AVI, 0x44),
	VS_IF_OTHER_BK2_BYTE1		= PAGE_ADDR(PAGE_AVI, 0x45),
	VS_IF_OTHER_BK2_BYTE27		= PAGE_ADDR(PAGE_AVI, 0x5F),
	AVI_IF_UPDATE			= PAGE_ADDR(PAGE_AVI, 0x60),
	AVI_IF_TYPE			= PAGE_ADDR(PAGE_AVI, 0x61),
	AVI_IF_VERSION			= PAGE_ADDR(PAGE_AVI, 0x62),
	AVI_IF_LENGTH			= PAGE_ADDR(PAGE_AVI, 0x63),
	AVI_IF_CHECKSUM			= PAGE_ADDR(PAGE_AVI, 0x64),
	AVI_IF_BYTE1			= PAGE_ADDR(PAGE_AVI, 0x65),
	AVI_IF_BYTE13			= PAGE_ADDR(PAGE_AVI, 0x71),
	SPD_IF_UPDATE			= PAGE_ADDR(PAGE_AVI, 0x80),
	SPD_IF_TYPE			= PAGE_ADDR(PAGE_AVI, 0x81),
	SPD_IF_VERSION			= PAGE_ADDR(PAGE_AVI, 0x82),
	SPD_IF_LENGTH			= PAGE_ADDR(PAGE_AVI, 0x83),
	SPD_IF_CHECKSUM			= PAGE_ADDR(PAGE_AVI, 0x84),
	SPD_IF_BYTE1			= PAGE_ADDR(PAGE_AVI, 0x85),
	SPD_IF_BYTE27			= PAGE_ADDR(PAGE_AVI, 0x9F),
	AUD_IF_UPDATE			= PAGE_ADDR(PAGE_AVI, 0xA0),
	AUD_IF_TYPE			= PAGE_ADDR(PAGE_AVI, 0xA1),
	AUD_IF_VERSION			= PAGE_ADDR(PAGE_AVI, 0xA2),
	AUD_IF_LENGTH			= PAGE_ADDR(PAGE_AVI, 0xA3),
	AUD_IF_CHECKSUM			= PAGE_ADDR(PAGE_AVI, 0xA4),
	AUD_IF_BYTE1			= PAGE_ADDR(PAGE_AVI, 0xA5),
	AUD_IF_BYTE10			= PAGE_ADDR(PAGE_AVI, 0xAE),
	MPS_IF_UPDATE			= PAGE_ADDR(PAGE_AVI, 0xC0),
	MPS_IF_TYPE			= PAGE_ADDR(PAGE_AVI, 0xC1),
	MPS_IF_VERSION			= PAGE_ADDR(PAGE_AVI, 0xC2),
	MPS_IF_LENGTH			= PAGE_ADDR(PAGE_AVI, 0xC3),
	MPS_IF_CHECKSUM			= PAGE_ADDR(PAGE_AVI, 0xC4),
	MPS_IF_BYTE1			= PAGE_ADDR(PAGE_AVI, 0xC5),
	MPS_IF_BYTE10			= PAGE_ADDR(PAGE_AVI, 0xCE),
	CHECKSUM_VS_IF_HDMI		= PAGE_ADDR(PAGE_AVI, 0xE0),
	CHECKSUM_VS_IF_OTHER_BK1	= PAGE_ADDR(PAGE_AVI, 0xE1),
	CHECKSUM_VS_IF_OTHER_BK2	= PAGE_ADDR(PAGE_AVI, 0xE2),
	CHECKSUM_AVI_IF			= PAGE_ADDR(PAGE_AVI, 0xE3),
	CHECKSUM_SPD_IF			= PAGE_ADDR(PAGE_AVI, 0xE4),
	CHECKSUM_AUD_IF			= PAGE_ADDR(PAGE_AVI, 0xE5),
	CHECKSUM_MPS_IF			= PAGE_ADDR(PAGE_AVI, 0xE6),

	CLK_CFG				= PAGE_ADDR(PAGE_TMDSA, 0x00),
	CLK_OUT_CFG			= PAGE_ADDR(PAGE_TMDSA, 0x01),
	CFG1				= PAGE_ADDR(PAGE_TMDSA, 0x02),
	CFG2				= PAGE_ADDR(PAGE_TMDSA, 0x03),
	PHS_CONF			= PAGE_ADDR(PAGE_TMDSA, 0x05),
	PHS_AVERAGINGK			= PAGE_ADDR(PAGE_TMDSA, 0x06),
	PHS_CH0_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x07),
	PHS_CH1_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x08),
	PHS_CH2_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x09),
	PHS_CH0_USED			= PAGE_ADDR(PAGE_TMDSA, 0x0A),
	PHS_CH1_USED			= PAGE_ADDR(PAGE_TMDSA, 0x0B),
	PHS_CH2_USED			= PAGE_ADDR(PAGE_TMDSA, 0x0C),
	WDL_CFG				= PAGE_ADDR(PAGE_TMDSA, 0x10),
	WDL_FROZEN			= PAGE_ADDR(PAGE_TMDSA, 0x11),
	DELOCK_DELAY			= PAGE_ADDR(PAGE_TMDSA, 0x12),
	SWAP_PN				= PAGE_ADDR(PAGE_TMDSA, 0x13),
	OFFSET_CH0_SELPHS		= PAGE_ADDR(PAGE_TMDSA, 0x18),
	OFFSET_CH1_SELPHS		= PAGE_ADDR(PAGE_TMDSA, 0x19),
	OFFSET_CH2_SELPHS		= PAGE_ADDR(PAGE_TMDSA, 0x1A),
	OFFSET_OSM_OVR			= PAGE_ADDR(PAGE_TMDSA, 0x1B),
	OFFSET_CH0_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x1C),
	OFFSET_CH1_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x1D),
	OFFSET_CH2_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x1E),
	OFFSET_CH0			= PAGE_ADDR(PAGE_TMDSA, 0x1F),
	OFFSET_CH1			= PAGE_ADDR(PAGE_TMDSA, 0x20),
	OFFSET_CH2			= PAGE_ADDR(PAGE_TMDSA, 0x21),
	SW_OFFSETCAL_EN			= PAGE_ADDR(PAGE_TMDSA, 0x22),
	OFFSETCAL_RES			= PAGE_ADDR(PAGE_TMDSA, 0x23),
	GAIN_CFG1			= PAGE_ADDR(PAGE_TMDSA, 0x28),
	GAIN_CFG2			= PAGE_ADDR(PAGE_TMDSA, 0x29),
	GAIN_CFG3			= PAGE_ADDR(PAGE_TMDSA, 0x2A),
	GAIN_CH0			= PAGE_ADDR(PAGE_TMDSA, 0x2B),
	GAIN_CH1			= PAGE_ADDR(PAGE_TMDSA, 0x2C),
	GAIN_CH2			= PAGE_ADDR(PAGE_TMDSA, 0x2D),
	ACTIVITY			= PAGE_ADDR(PAGE_TMDSA, 0x2E),
	GAIN_TEMPKICK			= PAGE_ADDR(PAGE_TMDSA, 0x2F),
	GAIN_OVR_EN			= PAGE_ADDR(PAGE_TMDSA, 0x30),
	GAIN_CH0_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x31),
	GAIN_CH1_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x32),
	GAIN_CH2_OVRD			= PAGE_ADDR(PAGE_TMDSA, 0x33),
	SW_GAINCAL_EN			= PAGE_ADDR(PAGE_TMDSA, 0x34),
	GAINCAL_RES			= PAGE_ADDR(PAGE_TMDSA, 0x35),
	PLL_RSV				= PAGE_ADDR(PAGE_TMDSA, 0x38),
	PLL_PFD_OVR			= PAGE_ADDR(PAGE_TMDSA, 0x39),
	PLL_LOCKFILTER			= PAGE_ADDR(PAGE_TMDSA, 0x3A),
	PLL_IPCP			= PAGE_ADDR(PAGE_TMDSA, 0x3B),
	PLL_TMDS_CTRL			= PAGE_ADDR(PAGE_TMDSA, 0x3C),
	PLL_SEL_PHS			= PAGE_ADDR(PAGE_TMDSA, 0x3D),
	PLL_STATUS			= PAGE_ADDR(PAGE_TMDSA, 0x3E),
	ASU_STATE_CTRL			= PAGE_ADDR(PAGE_TMDSA, 0x40),
	ASU_STATE_READ			= PAGE_ADDR(PAGE_TMDSA, 0x41),
	ASU_EQ_CALTIME			= PAGE_ADDR(PAGE_TMDSA, 0x42),
	ASU_NO_WAIT_ACT			= PAGE_ADDR(PAGE_TMDSA, 0x43),
	ASU_USE_PLL			= PAGE_ADDR(PAGE_TMDSA, 0x44),
	EQ_REFTIM_SLOWx4		= PAGE_ADDR(PAGE_TMDSA, 0x45),
	EQ_REFTIM_MSB			= PAGE_ADDR(PAGE_TMDSA, 0x46),
	EQ_REFTIM_LSB			= PAGE_ADDR(PAGE_TMDSA, 0x47),
	MODE_TX_EN			= PAGE_ADDR(PAGE_TMDSA, 0x5A),
	FREEZE_EN			= PAGE_ADDR(PAGE_TMDSA, 0x5B),
	MODE_DIG_EN			= PAGE_ADDR(PAGE_TMDSA, 0x5C),
	TRM_INV_CMP			= PAGE_ADDR(PAGE_TMDSA, 0x60),
	TRM_OVR				= PAGE_ADDR(PAGE_TMDSA, 0x61),
	TRM_SW_CAL_EN			= PAGE_ADDR(PAGE_TMDSA, 0x62),
	TRM_STATUS			= PAGE_ADDR(PAGE_TMDSA, 0x63),
	CAL_RES_SEL_CH			= PAGE_ADDR(PAGE_TMDSA, 0x68),
	RESULT_OFFSETCNT_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x69),
	RESULT_OFFSETCNT_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x6A),
	RESULT_STDDEV_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x6B),
	RESULT_STDDEV_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x6C),
	RESULT_EDGECOUNT_PH0_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x6D),
	RESULT_EDGECOUNT_PH0_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x6E),
	RESULT_EDGECOUNT_PH1_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x6F),
	RESULT_EDGECOUNT_PH1_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x70),
	RESULT_EDGECOUNT_PH2_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x71),
	RESULT_EDGECOUNT_PH2_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x72),
	RESULT_EDGECOUNT_PH3_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x73),
	RESULT_EDGECOUNT_PH3_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x74),
	RESULT_EDGECOUNT_PH4_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x75),
	RESULT_EDGECOUNT_PH4_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x76),
	RESULT_EDGECOUNT_PH5_MSB	= PAGE_ADDR(PAGE_TMDSA, 0x77),
	RESULT_EDGECOUNT_PH5_LSB	= PAGE_ADDR(PAGE_TMDSA, 0x78),
	RESULT_HISTOGRAM0_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x79),
	RESULT_HISTOGRAM0_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x7A),
	RESULT_HISTOGRAM1_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x7B),
	RESULT_HISTOGRAM1_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x7C),
	RESULT_HISTOGRAM2_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x7D),
	RESULT_HISTOGRAM2_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x7E),
	RESULT_HISTOGRAM3_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x7F),
	RESULT_HISTOGRAM3_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x80),
	RESULT_HISTOGRAM4_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x81),
	RESULT_HISTOGRAM4_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x82),
	RESULT_HISTOGRAM5_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x83),
	RESULT_HISTOGRAM5_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x84),
	RESULT_HISTOGRAM6_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x85),
	RESULT_HISTOGRAM6_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x86),
	RESULT_HISTOGRAM7_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x87),
	RESULT_HISTOGRAM7_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x88),
	DEBUG_TYPE			= PAGE_ADDR(PAGE_TMDSA, 0x90),
	DEBUG_CTRL			= PAGE_ADDR(PAGE_TMDSA, 0x91),
	DEBUG_NB_WORD			= PAGE_ADDR(PAGE_TMDSA, 0x92),
	DEBUG_TMDS_CLK_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x93),
	DEBUG_TMDS_CLK_LSB		= PAGE_ADDR(PAGE_TMDSA, 0x94),
	DEBUG_TMDS_WORD_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x95),
	DEBUG_TMDS_LSB_MSB		= PAGE_ADDR(PAGE_TMDSA, 0x96),
	DEBUG_MUX_SW_ENA		= PAGE_ADDR(PAGE_TMDSA, 0x97),
	PON_OVR_EN			= PAGE_ADDR(PAGE_TMDSA, 0xA0),
	PON_CBIAS			= PAGE_ADDR(PAGE_TMDSA, 0xA1),
	PON_RESCAL			= PAGE_ADDR(PAGE_TMDSA, 0xA2),
	PON_RES				= PAGE_ADDR(PAGE_TMDSA, 0xA3),
	PON_CLK				= PAGE_ADDR(PAGE_TMDSA, 0xA4),
	PON_PLL				= PAGE_ADDR(PAGE_TMDSA, 0xA5),
	PON_EQ				= PAGE_ADDR(PAGE_TMDSA, 0xA6),
	PON_DES				= PAGE_ADDR(PAGE_TMDSA, 0xA7),
	PON_OUT				= PAGE_ADDR(PAGE_TMDSA, 0xA8),
	PON_MUX				= PAGE_ADDR(PAGE_TMDSA, 0xA9),
	EQ_CALIBRATION			= PAGE_ADDR(PAGE_TMDSA, 0xAA),
	BIST_CTRL1			= PAGE_ADDR(PAGE_TMDSA, 0xB0),
	BIST_CTRL2			= PAGE_ADDR(PAGE_TMDSA, 0xB1),
	BIST_CTRL3			= PAGE_ADDR(PAGE_TMDSA, 0xB2),
	BIST_TCB_REG_TIMOUT		= PAGE_ADDR(PAGE_TMDSA, 0xB3),
	BIST_CORREL_RESULT_MSB		= PAGE_ADDR(PAGE_TMDSA, 0xB4),
	BIST_CORREL_RESULT_LSB		= PAGE_ADDR(PAGE_TMDSA, 0xB5),
	BIST_CORREL_LENGTH3		= PAGE_ADDR(PAGE_TMDSA, 0xB6),
	BIST_CORREL_LENGTH2		= PAGE_ADDR(PAGE_TMDSA, 0xB7),
	BIST_CORREL_LENGTH1		= PAGE_ADDR(PAGE_TMDSA, 0xB8),
	BIST_CORREL_LENGTH0		= PAGE_ADDR(PAGE_TMDSA, 0xB9),
	BIST_GAIN_CH0			= PAGE_ADDR(PAGE_TMDSA, 0xBA),
	BIST_GAIN_CH1			= PAGE_ADDR(PAGE_TMDSA, 0xBB),
	BIST_GAIN_CH2			= PAGE_ADDR(PAGE_TMDSA, 0xBC),
	BIST_STATUS			= PAGE_ADDR(PAGE_TMDSA, 0xBD),
	IRQ_SET_TOP			= PAGE_ADDR(PAGE_TMDSA, 0xC0),
	IRQ_SET_SUS			= PAGE_ADDR(PAGE_TMDSA, 0xC1),
	IRQ_SET_DDC			= PAGE_ADDR(PAGE_TMDSA, 0xC2),
	IRQ_SET_RATE			= PAGE_ADDR(PAGE_TMDSA, 0xC3),
	IRQ_SET_MODE			= PAGE_ADDR(PAGE_TMDSA, 0xC4),
	IRQ_SET_INFO			= PAGE_ADDR(PAGE_TMDSA, 0xC5),
	IRQ_SET_AUDIO			= PAGE_ADDR(PAGE_TMDSA, 0xC6),
	IRQ_SET_HDCP			= PAGE_ADDR(PAGE_TMDSA, 0xC7),
	IRQ_SET_AFE			= PAGE_ADDR(PAGE_TMDSA, 0xC8),
	AUDIO_LAYOUT			= PAGE_ADDR(PAGE_TMDSA, 0xD0),
	SEL_RD_VAL			= PAGE_ADDR(PAGE_TMDSA, 0xD1),
	FRAME_START_WIDTH		= PAGE_ADDR(PAGE_TMDSA, 0xD2),
	DELTA_WR_RD_PNTR		= PAGE_ADDR(PAGE_TMDSA, 0xD3),
	BCH_DECODER			= PAGE_ADDR(PAGE_TMDSA, 0xD4),
	TX_BUFFER_CFG			= PAGE_ADDR(PAGE_TMDSA, 0xF6),
	MODE_RECOVER_CFG1		= PAGE_ADDR(PAGE_TMDSA, 0xF8),
	MODE_RECOVER_CFG2		= PAGE_ADDR(PAGE_TMDSA, 0xF9),
	MODE_RECOVER_STATUS		= PAGE_ADDR(PAGE_TMDSA, 0xFA),
	DEEP_COLOR_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0x00),
	DEEP_COLOR_MAN			= PAGE_ADDR(PAGE_TMDSB, 0x01),
	DEEP_COLOR_GCP			= PAGE_ADDR(PAGE_TMDSB, 0x02),
	IVS_SEL				= PAGE_ADDR(PAGE_TMDSB, 0x03),
	CGU_DEBUG_INV			= PAGE_ADDR(PAGE_TMDSB, 0x04),
	CGU_DEBUG_SEL			= PAGE_ADDR(PAGE_TMDSB, 0x05),
	X_OUTPUTS			= PAGE_ADDR(PAGE_TMDSB, 0x06),
	VP_DEBUG			= PAGE_ADDR(PAGE_TMDSB, 0x07),
	DEEP_COLOR_CLK_CTRL		= PAGE_ADDR(PAGE_TMDSB, 0x08),
	DC_PAT0_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x09),
	DC_PAT1_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x0A),
	DC_PAT2_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x0B),
	DC_PAT3_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x0C),
	DC_PAT4_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x0D),
	DC_PAT3210_LSB			= PAGE_ADDR(PAGE_TMDSB, 0x0E),
	DEEP_COLOR_PAT_MAN		= PAGE_ADDR(PAGE_TMDSB, 0x0F),
	HDCP_DDC_ADDR			= PAGE_ADDR(PAGE_TMDSB, 0x10),
	HDCP_BKSV4			= PAGE_ADDR(PAGE_TMDSB, 0x11),
	HDCP_BKSV3			= PAGE_ADDR(PAGE_TMDSB, 0x12),
	HDCP_BKSV2			= PAGE_ADDR(PAGE_TMDSB, 0x13),
	HDCP_BKSV1			= PAGE_ADDR(PAGE_TMDSB, 0x14),
	HDCP_BKSV0			= PAGE_ADDR(PAGE_TMDSB, 0x15),
	HDCP_KIDX			= PAGE_ADDR(PAGE_TMDSB, 0x16),
	HDCP_KEY6			= PAGE_ADDR(PAGE_TMDSB, 0x17),
	HDCP_KEY5			= PAGE_ADDR(PAGE_TMDSB, 0x18),
	HDCP_KEY4			= PAGE_ADDR(PAGE_TMDSB, 0x19),
	HDCP_KEY3			= PAGE_ADDR(PAGE_TMDSB, 0x1A),
	HDCP_KEY2			= PAGE_ADDR(PAGE_TMDSB, 0x1B),
	HDCP_KEY1			= PAGE_ADDR(PAGE_TMDSB, 0x1C),
	HDCP_KEY0			= PAGE_ADDR(PAGE_TMDSB, 0x1D),

//	DEEP_PLL0			= PAGE_ADDR(PAGE_TMDSB, 0x40),
//	DEEP_PLL1			= PAGE_ADDR(PAGE_TMDSB, 0x41),
//	DEEP_PLL2			= PAGE_ADDR(PAGE_TMDSB, 0x42),
//	DEEP_PLL3			= PAGE_ADDR(PAGE_TMDSB, 0x43),
//	DEEP_PLL4			= PAGE_ADDR(PAGE_TMDSB, 0x44),
//	DEEP_PLL5			= PAGE_ADDR(PAGE_TMDSB, 0x45),
//	DEEP_PLL6			= PAGE_ADDR(PAGE_TMDSB, 0x46),
//	DEEP_PLL7			= PAGE_ADDR(PAGE_TMDSB, 0x47),
//	SOFTAFC_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x50),
//	SOFTAFC_LSB			= PAGE_ADDR(PAGE_TMDSB, 0x51),
//	FIFO_LATENCY_CTRL		= PAGE_ADDR(PAGE_TMDSB, 0x52),
//	FIFO_LATENCY			= PAGE_ADDR(PAGE_TMDSB, 0x53),
//	FIFO_CTL_COEFF_W		= PAGE_ADDR(PAGE_TMDSB, 0x54),
//	FIFO_CTL_COEFF_WR		= PAGE_ADDR(PAGE_TMDSB, 0x55),
//	AFC_ODPRX_MSB			= PAGE_ADDR(PAGE_TMDSB, 0x56),
//	AFC_ODPRX_LSB			= PAGE_ADDR(PAGE_TMDSB, 0x57),
//	FIFO_CTL_DPRX_MIN		= PAGE_ADDR(PAGE_TMDSB, 0x58),
//	FIFO_CTL_DPRX_MAX		= PAGE_ADDR(PAGE_TMDSB, 0x59),
//	FIFO_CTL_DPRX_LSB		= PAGE_ADDR(PAGE_TMDSB, 0x5A),
//	FIFO_LATENCY_RD			= PAGE_ADDR(PAGE_TMDSB, 0x5B),
//	FIFO_CTL_COEFF_KP_LOW_RD	= PAGE_ADDR(PAGE_TMDSB, 0x5C),
//	FIFO_CTL_COEFF_ZETA_UNMUTE_RD	= PAGE_ADDR(PAGE_TMDSB, 0x5D),
//	FIFO_CTL_COEFF_ROUND_RD		= PAGE_ADDR(PAGE_TMDSB, 0x5E),
//	FIFO_CTL_COEFF_ROUND_WR		= PAGE_ADDR(PAGE_TMDSB, 0x5F),

	HMTP_T_RESET			= PAGE_ADDR(PAGE_TMDSB, 0x60),
	HMTP_T_ADDRESS_SETUP		= PAGE_ADDR(PAGE_TMDSB, 0x61),
	HMTP_T_ADDRESS_HOLD		= PAGE_ADDR(PAGE_TMDSB, 0x62),
	HMTP_T_READ_ENABLE		= PAGE_ADDR(PAGE_TMDSB, 0x63),
	HMTP_T_WRITE_ENABLE		= PAGE_ADDR(PAGE_TMDSB, 0x64),
	HMTP_T_INITIALIZATION		= PAGE_ADDR(PAGE_TMDSB, 0x65),
	HMTP_T_ERASE_PRG_PROGRESS	= PAGE_ADDR(PAGE_TMDSB, 0x66),
	HMTP_T_DISCHARGE		= PAGE_ADDR(PAGE_TMDSB, 0x67),
	HDCP_SRAM_REGS			= PAGE_ADDR(PAGE_TMDSB, 0x68),
	HDCP_DMA_CONF			= PAGE_ADDR(PAGE_TMDSB, 0x69),
	HMTP_ECC_REGISTERS		= PAGE_ADDR(PAGE_TMDSB, 0x6A),
	HMTP_ERR_ADDR			= PAGE_ADDR(PAGE_TMDSB, 0x6B),
	HDCP_MTP_TEST			= PAGE_ADDR(PAGE_TMDSB, 0x6C),
	HMTP_PARAM			= PAGE_ADDR(PAGE_TMDSB, 0x6D),
	HDCP_DE_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0x70),
	HDCP_EP_FILT_CTRL		= PAGE_ADDR(PAGE_TMDSB, 0x71),
	HDCP_EP_REM_CTRL		= PAGE_ADDR(PAGE_TMDSB, 0x72),
	HDCP_EP_READ			= PAGE_ADDR(PAGE_TMDSB, 0x73),
	HDCP_PA_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0x74),
	HDCP_PA_READ			= PAGE_ADDR(PAGE_TMDSB, 0x75),
	HDCP_MISC			= PAGE_ADDR(PAGE_TMDSB, 0x76),
	HDMI_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0x77),
	HDMI_POL			= PAGE_ADDR(PAGE_TMDSB, 0x78),
	HDCP_MODE_RECOVERY		= PAGE_ADDR(PAGE_TMDSB, 0x79),
	HMTP_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0x7A),
	HMTP_ADDRESS			= PAGE_ADDR(PAGE_TMDSB, 0x7B),
	EMTP_T_RESET			= PAGE_ADDR(PAGE_TMDSB, 0x80),
	EMTP_T_ADDRESS_SETUP		= PAGE_ADDR(PAGE_TMDSB, 0x81),
	EMTP_T_ADDRESS_HOLD		= PAGE_ADDR(PAGE_TMDSB, 0x82),
	EMTP_T_READ_ENABLE		= PAGE_ADDR(PAGE_TMDSB, 0x83),
	EMTP_T_WRITE_ENABLE		= PAGE_ADDR(PAGE_TMDSB, 0x84),
	EMTP_T_INITIALIZATION		= PAGE_ADDR(PAGE_TMDSB, 0x85),
	EMTP_T_ERASE_PRG_PROG		= PAGE_ADDR(PAGE_TMDSB, 0x86),
	EMTP_T_DISCHARGE		= PAGE_ADDR(PAGE_TMDSB, 0x87),
	DDC_HIDDEN0_REGISTER		= PAGE_ADDR(PAGE_TMDSB, 0x90),
	DDC_HIDDEN1_REGISTER		= PAGE_ADDR(PAGE_TMDSB, 0x91),
	DDC_DMA_CONF			= PAGE_ADDR(PAGE_TMDSB, 0x92),
	EMTP_ECC_CONF			= PAGE_ADDR(PAGE_TMDSB, 0x93),
	EMTP_ERR_ADDR			= PAGE_ADDR(PAGE_TMDSB, 0x94),
	HDCP_ACK_TIMER			= PAGE_ADDR(PAGE_TMDSB, 0x96),
	HDCP_NOACK_TIMER		= PAGE_ADDR(PAGE_TMDSB, 0x97),
	EMTP_PARAM			= PAGE_ADDR(PAGE_TMDSB, 0x98),
	DDC_MTP_VANALOG			= PAGE_ADDR(PAGE_TMDSB, 0x99),
	DDC_MTP_TEST			= PAGE_ADDR(PAGE_TMDSB, 0x9A),
	DDC_MST_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0xA0),
	DDC_MST_CLK_DIV			= PAGE_ADDR(PAGE_TMDSB, 0xA1),
	DDC_MST_CLK_DIV_FOR_MST		= PAGE_ADDR(PAGE_TMDSB, 0xA2),
	DDC_LINK_SEL			= PAGE_ADDR(PAGE_TMDSB, 0xA3),
	DDC_STATUS			= PAGE_ADDR(PAGE_TMDSB, 0xA4),
	CLOCK_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0xA5),
	MONITOR_OFFSET_CH0_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC0),
	MONITOR_OFFSET_CH1_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC1),
	MONITOR_OFFSET_CH2_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC2),
	MONITOR_GAIN_CH0_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC3),
	MONITOR_GAIN_CH1_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC4),
	MONITOR_GAIN_CH2_AB		= PAGE_ADDR(PAGE_TMDSB, 0xC5),
	SUS_CTRL			= PAGE_ADDR(PAGE_TMDSB, 0xC6),
	SUS_CTRL2			= PAGE_ADDR(PAGE_TMDSB, 0xC7),
	RESET_REFTIM_MSB		= PAGE_ADDR(PAGE_TMDSB, 0xC8),
	RESET_REFTIM_LSB		= PAGE_ADDR(PAGE_TMDSB, 0xC9),
	TIMER_RT			= PAGE_ADDR(PAGE_TMDSB, 0xCA),
	TIMER_A_MSB			= PAGE_ADDR(PAGE_TMDSB, 0xCB),
	TIMER_B_MSB			= PAGE_ADDR(PAGE_TMDSB, 0xCC),
	TIMER_C_MSB			= PAGE_ADDR(PAGE_TMDSB, 0xCD),
	TIMER_ABC_LSB			= PAGE_ADDR(PAGE_TMDSB, 0xCE),
	TIMER_D				= PAGE_ADDR(PAGE_TMDSB, 0xCF),
	SUS_SET_CAL0			= PAGE_ADDR(PAGE_TMDSB, 0xD0),
	SUS_SET_CAL1			= PAGE_ADDR(PAGE_TMDSB, 0xD1),
	SUS_SET_CAL2			= PAGE_ADDR(PAGE_TMDSB, 0xD2),
	SUS_SET_CAL3			= PAGE_ADDR(PAGE_TMDSB, 0xD3),
	SUS_SET_CAL4			= PAGE_ADDR(PAGE_TMDSB, 0xD4),
	SUS_SET_CAL5			= PAGE_ADDR(PAGE_TMDSB, 0xD5),
	SUS_SET_CAL6			= PAGE_ADDR(PAGE_TMDSB, 0xD6),
	SUS_SET_CAL7			= PAGE_ADDR(PAGE_TMDSB, 0xD7),
	SUS_SET_CAL8			= PAGE_ADDR(PAGE_TMDSB, 0xD8),
	SUS_SET_HDMI0			= PAGE_ADDR(PAGE_TMDSB, 0xD9),
	SUS_SET_HDMI1			= PAGE_ADDR(PAGE_TMDSB, 0xDA),
	SUS_SET_HDMI2			= PAGE_ADDR(PAGE_TMDSB, 0xDB),
	SUS_SET_HDMI3			= PAGE_ADDR(PAGE_TMDSB, 0xDC),
	SUS_SET_HDMI4			= PAGE_ADDR(PAGE_TMDSB, 0xDD),
	SUS_SET_HDMI5			= PAGE_ADDR(PAGE_TMDSB, 0xDE),
	SUS_SET_HDMI6			= PAGE_ADDR(PAGE_TMDSB, 0xDF),
	SUS_SET_HDMI7			= PAGE_ADDR(PAGE_TMDSB, 0xE0),
	SUS_SET_RGB0			= PAGE_ADDR(PAGE_TMDSB, 0xE1),
	SUS_SET_RGB1			= PAGE_ADDR(PAGE_TMDSB, 0xE2),
	SUS_SET_RGB2			= PAGE_ADDR(PAGE_TMDSB, 0xE3),
	SUS_SET_RGB3			= PAGE_ADDR(PAGE_TMDSB, 0xE4),
	SUS_SET_RGB4			= PAGE_ADDR(PAGE_TMDSB, 0xE5),
	MAN_SUS_CAL_SEL			= PAGE_ADDR(PAGE_TMDSB, 0xE6),
	MAN_CAL_SET			= PAGE_ADDR(PAGE_TMDSB, 0xE7),
	MAN_SUS_HDMI_SEL		= PAGE_ADDR(PAGE_TMDSB, 0xE8),
	MAN_HDMI_SET			= PAGE_ADDR(PAGE_TMDSB, 0xE9),
	MAN_SUS_RGB_SEL			= PAGE_ADDR(PAGE_TMDSB, 0xEA),
	MAN_RGB_SET			= PAGE_ADDR(PAGE_TMDSB, 0xEB),
	TIMER_ENCODED			= PAGE_ADDR(PAGE_TMDSB, 0xEC),
	RATE_REFTIM_MSB			= PAGE_ADDR(PAGE_TMDSB, 0xED),
	RATE_REFTIM_LSB			= PAGE_ADDR(PAGE_TMDSB, 0xEE),
	SUS_CLOCK_GOOD			= PAGE_ADDR(PAGE_TMDSB, 0xEF),
	SUS_FREQ_DIGITAL_MSB		= PAGE_ADDR(PAGE_TMDSB, 0xF0),
	SUS_FREQ_DIGITAL_ISB		= PAGE_ADDR(PAGE_TMDSB, 0xF1),
	SUS_FREQ_DIGITAL_LSB		= PAGE_ADDR(PAGE_TMDSB, 0xF2),
	SUS_GAIN_LIM			= PAGE_ADDR(PAGE_TMDSB, 0xF3),

	SOFT_AFC_CTRL			= PAGE_ADDR(PAGE_14, 0x00),
	SOFT_AFC_LSB			= PAGE_ADDR(PAGE_14, 0x01),
	FIFO_LATENCY_CTRL		= PAGE_ADDR(PAGE_14, 0x02),
	FIFO_LATENCY_VALUE		= PAGE_ADDR(PAGE_14, 0x03),
	FIFO_CTRL_COEFF0		= PAGE_ADDR(PAGE_14, 0x04),
	FIFO_CTRL_COEFF1		= PAGE_ADDR(PAGE_14, 0x05),
	FIFO_CTRL_COEFF2		= PAGE_ADDR(PAGE_14, 0x06),
	AFC_ODPRX_MSB			= PAGE_ADDR(PAGE_14, 0x07),
	AFC_ODPRX_LSB			= PAGE_ADDR(PAGE_14, 0x08),
	DPRX_MIN			= PAGE_ADDR(PAGE_14, 0x09),
	DPRX_MAX			= PAGE_ADDR(PAGE_14, 0x0A),
	DPRX_LSB_MIN_MAX		= PAGE_ADDR(PAGE_14, 0x0B),
	FIFO_LATENCY_VALUE_RD		= PAGE_ADDR(PAGE_14, 0x0C),
	FIFO_CTRL_COEFF0_RD		= PAGE_ADDR(PAGE_14, 0x0D),
	FIFO_CTRL_COEFF1_RD		= PAGE_ADDR(PAGE_14, 0x0E),
	FIFO_CTRL_COEFF2_RD		= PAGE_ADDR(PAGE_14, 0x0F),
	AUDIO_PWR_CTRL			= PAGE_ADDR(PAGE_14, 0x10),
	AUDIO_CLOCK_MODE		= PAGE_ADDR(PAGE_14, 0x11),
	AUDIO_HSPLL_CTRL		= PAGE_ADDR(PAGE_14, 0x12),
	TEST_NCTS_CTRL			= PAGE_ADDR(PAGE_14, 0x15),
	TEST_CTS_CHECKED_MSB		= PAGE_ADDR(PAGE_14, 0x1A),
	TEST_CTS_CHECKED_ISB		= PAGE_ADDR(PAGE_14, 0x1B),
	TEST_CTS_CHECKED_LSB		= PAGE_ADDR(PAGE_14, 0x1C),
	TEST_N_CHECKED_MSB		= PAGE_ADDR(PAGE_14, 0x1D),
	TEST_N_CHECKED_ISB		= PAGE_ADDR(PAGE_14, 0x1E),
	TEST_N_CHECKED_LSB		= PAGE_ADDR(PAGE_14, 0x1F),
	TEST_NCTS_CHECKED_VALID		= PAGE_ADDR(PAGE_14, 0x20),
	TEST_FDET_QUOTIENT_MSB		= PAGE_ADDR(PAGE_14, 0x24),
	TEST_FDET_QUOTIENT_LSB		= PAGE_ADDR(PAGE_14, 0x25),
	TEST_AUDIO_FREQ			= PAGE_ADDR(PAGE_14, 0x26),
	TEST_Q_DIV_SYNC			= PAGE_ADDR(PAGE_14, 0x2C),
	TEST_R_DIV_SYNC_MSB		= PAGE_ADDR(PAGE_14, 0x2D),
	TEST_R_DIV_SYNC_NSB		= PAGE_ADDR(PAGE_14, 0x2E),
	TEST_R_DIV_SYNC_ISB		= PAGE_ADDR(PAGE_14, 0x2F),
	TEST_R_DIV_SYNC_LSB		= PAGE_ADDR(PAGE_14, 0x30),
	TEST_N_DIV_SYNC_MSB		= PAGE_ADDR(PAGE_14, 0x31),
	TEST_N_DIV_SYNC_NSB		= PAGE_ADDR(PAGE_14, 0x32),
	TEST_N_DIV_SYNC_ISB		= PAGE_ADDR(PAGE_14, 0x33),
	TEST_N_DIV_SYNC_LSB		= PAGE_ADDR(PAGE_14, 0x34),
	TEST_MODE			= PAGE_ADDR(PAGE_14, 0x37),
	NCTS_CHECKED_VALID_OUT		= PAGE_ADDR(PAGE_14, 0x3D),
	CTS_CHECKED_MSB_OUT		= PAGE_ADDR(PAGE_14, 0x3E),
	CTS_CHECKED_ISB_OUT		= PAGE_ADDR(PAGE_14, 0x3F),
	CTS_CHECKED_LSB_OUT		= PAGE_ADDR(PAGE_14, 0x40),
	N_CHECKED_MSB_OUT		= PAGE_ADDR(PAGE_14, 0x41),
	N_CHECKED_ISB_OUT		= PAGE_ADDR(PAGE_14, 0x42),
	N_CHECKED_LSB_OUT		= PAGE_ADDR(PAGE_14, 0x43),
	FDET_QUOTIENT_MSB_OUT		= PAGE_ADDR(PAGE_14, 0x47),
	FDET_QUOTIENT_LSB_OUT		= PAGE_ADDR(PAGE_14, 0x48),
	FDET_REMAIN_MSB_OUT		= PAGE_ADDR(PAGE_14, 0x4A),
	FDET_REMAIN_ISB_OUT		= PAGE_ADDR(PAGE_14, 0x4B),
	FDET_REMAIN_LSB_OUT		= PAGE_ADDR(PAGE_14, 0x4C),
	AUDIO_STATUS			= PAGE_ADDR(PAGE_14, 0x4D),
	Q_DIV_SYNC_OUT			= PAGE_ADDR(PAGE_14, 0x51),
	R_DIV_SYNC_MSB			= PAGE_ADDR(PAGE_14, 0x52),
	R_DIV_SYNC_NSB			= PAGE_ADDR(PAGE_14, 0x53),
	R_DIV_SYNC_ISB			= PAGE_ADDR(PAGE_14, 0x54),
	R_DIV_SYNC_LSB			= PAGE_ADDR(PAGE_14, 0x55),
	N_DIV_SYNC_MSB			= PAGE_ADDR(PAGE_14, 0x56),
	N_DIV_SYNC_NSB			= PAGE_ADDR(PAGE_14, 0x57),
	N_DIV_SYNC_ISB			= PAGE_ADDR(PAGE_14, 0x58),
	N_DIV_SYNC_LSB			= PAGE_ADDR(PAGE_14, 0x59),
	AUDIO_PLL_STATUS		= PAGE_ADDR(PAGE_14, 0x5A),
	CTS_MSB				= PAGE_ADDR(PAGE_14, 0x5F),
	CTS_ISB				= PAGE_ADDR(PAGE_14, 0x60),
	CTS_LSB				= PAGE_ADDR(PAGE_14, 0x61),
	N_MSB				= PAGE_ADDR(PAGE_14, 0x62),
	N_ISB				= PAGE_ADDR(PAGE_14, 0x63),
	N_LSB				= PAGE_ADDR(PAGE_14, 0x64),

	EDID_IN_BYTE0			= PAGE_ADDR(PAGE_EDIDA, 0x00),
	EDID_IN_CHECKSUM0		= PAGE_ADDR(PAGE_EDIDA, 0x7F),
	EDID_IN_VERSION			= PAGE_ADDR(PAGE_EDIDA, 0x80),
	EDID_ENABLE			= PAGE_ADDR(PAGE_EDIDA, 0x81),
	EDID_BLOCK_SELECT		= PAGE_ADDR(PAGE_EDIDA, 0x82),
	HPD_POWER			= PAGE_ADDR(PAGE_EDIDA, 0x84),
	HPD_AUTO_CTRL			= PAGE_ADDR(PAGE_EDIDA, 0x85),
	HPD_DURATION			= PAGE_ADDR(PAGE_EDIDA, 0x86),
	RX_HPD_HEAC			= PAGE_ADDR(PAGE_EDIDA, 0x87),
	EDID_BLOCK0_TEST1		= PAGE_ADDR(PAGE_EDIDA, 0x8D),
	EDID_BLOCK0_TEST2		= PAGE_ADDR(PAGE_EDIDA, 0x8E),
	EDID_BLOCK0_TEST3		= PAGE_ADDR(PAGE_EDIDA, 0x8F),

	EDID_IN_BYTE128			= PAGE_ADDR(PAGE_EDIDB, 0x00),
	EDID_IN_CHECKSUM1		= PAGE_ADDR(PAGE_EDIDB, 0x7F),
	EDID_IN_SPA_SUB			= PAGE_ADDR(PAGE_EDIDB, 0x80),
	EDID_IN_SPA_AB_A		= PAGE_ADDR(PAGE_EDIDB, 0x81),
	EDID_IN_SPA_CD_A		= PAGE_ADDR(PAGE_EDIDB, 0x82),
	EDID_IN_CHECKSUM_A		= PAGE_ADDR(PAGE_EDIDB, 0x83),
	EDID_IN_SPA_AB_B		= PAGE_ADDR(PAGE_EDIDB, 0x84),
	EDID_IN_SPA_CD_B		= PAGE_ADDR(PAGE_EDIDB, 0x85),
	EDID_IN_CHECKSUM_B		= PAGE_ADDR(PAGE_EDIDB, 0x86),
	EDID_BLOCK1_TEST1		= PAGE_ADDR(PAGE_EDIDB, 0x8D),
	EDID_BLOCK1_TEST2		= PAGE_ADDR(PAGE_EDIDB, 0x8E),
	EDID_BLOCK1_TEST3		= PAGE_ADDR(PAGE_EDIDB, 0x8F),

	RT_AUTO_CTRL			= PAGE_ADDR(PAGE_CMTP, 0x00),
	EQ_MAN_CTRL0			= PAGE_ADDR(PAGE_CMTP, 0x01),
	EQ_MAN_CTRL1			= PAGE_ADDR(PAGE_CMTP, 0x02),
	OUTPUT_CFG			= PAGE_ADDR(PAGE_CMTP, 0x03),
	MUTE_CTRL			= PAGE_ADDR(PAGE_CMTP, 0x04),
	SLAVE_ADDR			= PAGE_ADDR(PAGE_CMTP, 0x05),
	CMTP_REG6			= PAGE_ADDR(PAGE_CMTP, 0x06),
	CMTP_REG2F			= PAGE_ADDR(PAGE_CMTP, 0x2F),
	CMTP_RESET			= PAGE_ADDR(PAGE_CMTP, 0x33),
	CMTP_ADDRESS_SETUP		= PAGE_ADDR(PAGE_CMTP, 0x34),
	CMTP_ADDRESS_HOLD		= PAGE_ADDR(PAGE_CMTP, 0x35),
	CMTP_READ_ENABLE		= PAGE_ADDR(PAGE_CMTP, 0x36),
	CMTP_WRITE_ENABLE		= PAGE_ADDR(PAGE_CMTP, 0x37),
	CMTP_INITIALIZATION		= PAGE_ADDR(PAGE_CMTP, 0x38),
	CMTP_ERASE_PGM_PROGRESS 	= PAGE_ADDR(PAGE_CMTP, 0x39),
	CMTP_DISCHARGE			= PAGE_ADDR(PAGE_CMTP, 0x3A),
	CMTP_VANALOG			= PAGE_ADDR(PAGE_CMTP, 0x3B),
	CMTP_TEST			= PAGE_ADDR(PAGE_CMTP, 0x3C),
	CMTP_MEM_REGS			= PAGE_ADDR(PAGE_CMTP, 0x40),
	CMTP_DMA_CONF			= PAGE_ADDR(PAGE_CMTP, 0x41),
	CMTP_ECC_REGISTERS		= PAGE_ADDR(PAGE_CMTP, 0x42),
	CMTP_ERR_ADDR			= PAGE_ADDR(PAGE_CMTP, 0x43),
	CMTP_PARAM			= PAGE_ADDR(PAGE_CMTP, 0x44),

	MTP_SEED_INDEX			= PAGE_ADDR(PAGE_MTPA, 0x00),
	MTP_KEY_SPARE			= PAGE_ADDR(PAGE_MTPA, 0x01),
	MTP_KEY39_LSB			= PAGE_ADDR(PAGE_MTPA, 0x02),
	MTP_BKSV4			= PAGE_ADDR(PAGE_MTPA, 0x03),
	MTP_BKSV3			= PAGE_ADDR(PAGE_MTPA, 0x04),
	MTP_BKSV2			= PAGE_ADDR(PAGE_MTPA, 0x05),
	MTP_BKSV1			= PAGE_ADDR(PAGE_MTPA, 0x06),
	MTP_BKSV0			= PAGE_ADDR(PAGE_MTPA, 0x07),
	MTP_KEY0_MSB			= PAGE_ADDR(PAGE_MTPA, 0x08),
	MTP_KEY0_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x09),
	MTP_KEY0_LSB			= PAGE_ADDR(PAGE_MTPA, 0x0E),
	MTP_KEY1_MSB			= PAGE_ADDR(PAGE_MTPA, 0x0F),
	MTP_KEY1_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x10),
	MTP_KEY1_LSB			= PAGE_ADDR(PAGE_MTPA, 0x15),
	MTP_KEY2_MSB			= PAGE_ADDR(PAGE_MTPA, 0x16),
	MTP_KEY2_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x17),
	MTP_KEY2_LSB			= PAGE_ADDR(PAGE_MTPA, 0x1C),
	MTP_KEY3_MSB			= PAGE_ADDR(PAGE_MTPA, 0x1D),
	MTP_KEY3_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x1E),
	MTP_KEY3_LSB			= PAGE_ADDR(PAGE_MTPA, 0x23),
	MTP_KEY4_MSB			= PAGE_ADDR(PAGE_MTPA, 0x24),
	MTP_KEY4_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x25),
	MTP_KEY4_LSB			= PAGE_ADDR(PAGE_MTPA, 0x2A),
	MTP_KEY5_MSB			= PAGE_ADDR(PAGE_MTPA, 0x2B),
	MTP_KEY5_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x2C),
	MTP_KEY5_LSB			= PAGE_ADDR(PAGE_MTPA, 0x31),
	MTP_KEY6_MSB			= PAGE_ADDR(PAGE_MTPA, 0x32),
	MTP_KEY6_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x33),
	MTP_KEY6_LSB			= PAGE_ADDR(PAGE_MTPA, 0x38),
	MTP_KEY7_MSB			= PAGE_ADDR(PAGE_MTPA, 0x39),
	MTP_KEY7_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x3A),
	MTP_KEY7_LSB			= PAGE_ADDR(PAGE_MTPA, 0x3F),
	MTP_KEY8_MSB			= PAGE_ADDR(PAGE_MTPA, 0x40),
	MTP_KEY8_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x41),
	MTP_KEY8_LSB			= PAGE_ADDR(PAGE_MTPA, 0x46),
	MTP_KEY9_MSB			= PAGE_ADDR(PAGE_MTPA, 0x47),
	MTP_KEY9_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x48),
	MTP_KEY9_LSB			= PAGE_ADDR(PAGE_MTPA, 0x4D),
	MTP_KEY10_MSB			= PAGE_ADDR(PAGE_MTPA, 0x4E),
	MTP_KEY10_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x4F),
	MTP_KEY10_LSB			= PAGE_ADDR(PAGE_MTPA, 0x54),
	MTP_KEY11_MSB			= PAGE_ADDR(PAGE_MTPA, 0x55),
	MTP_KEY11_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x56),
	MTP_KEY11_LSB			= PAGE_ADDR(PAGE_MTPA, 0x5B),
	MTP_KEY12_MSB			= PAGE_ADDR(PAGE_MTPA, 0x5C),
	MTP_KEY12_ISB1			= PAGE_ADDR(PAGE_MTPA, 0x5D),
	MTP_KEY12_LSB			= PAGE_ADDR(PAGE_MTPB, 0x02),
	MTP_KEY13_MSB			= PAGE_ADDR(PAGE_MTPB, 0x03),
	MTP_KEY13_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x04),
	MTP_KEY13_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x05),
	MTP_KEY13_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x06),
	MTP_KEY13_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x07),
	MTP_KEY13_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x08),
	MTP_KEY13_LSB			= PAGE_ADDR(PAGE_MTPB, 0x09),
	MTP_KEY14_MSB			= PAGE_ADDR(PAGE_MTPB, 0x0A),
	MTP_KEY14_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x0B),
	MTP_KEY14_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x0C),
	MTP_KEY14_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x0D),
	MTP_KEY14_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x0E),
	MTP_KEY14_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x0F),
	MTP_KEY14_LSB			= PAGE_ADDR(PAGE_MTPB, 0x10),
	MTP_KEY15_MSB			= PAGE_ADDR(PAGE_MTPB, 0x11),
	MTP_KEY15_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x12),
	MTP_KEY15_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x13),
	MTP_KEY15_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x14),
	MTP_KEY15_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x15),
	MTP_KEY15_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x16),
	MTP_KEY15_LSB			= PAGE_ADDR(PAGE_MTPB, 0x17),
	MTP_KEY16_MSB			= PAGE_ADDR(PAGE_MTPB, 0x18),
	MTP_KEY16_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x19),
	MTP_KEY16_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x1A),
	MTP_KEY16_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x1B),
	MTP_KEY16_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x1C),
	MTP_KEY16_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x1D),
	MTP_KEY16_LSB			= PAGE_ADDR(PAGE_MTPB, 0x1E),
	MTP_KEY17_MSB			= PAGE_ADDR(PAGE_MTPB, 0x1F),
	MTP_KEY17_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x20),
	MTP_KEY17_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x21),
	MTP_KEY17_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x22),
	MTP_KEY17_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x23),
	MTP_KEY17_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x24),
	MTP_KEY17_LSB			= PAGE_ADDR(PAGE_MTPB, 0x25),
	MTP_KEY18_MSB			= PAGE_ADDR(PAGE_MTPB, 0x26),
	MTP_KEY18_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x27),
	MTP_KEY18_ISB2			= PAGE_ADDR(PAGE_MTPB, 0x28),
	MTP_KEY18_ISB3			= PAGE_ADDR(PAGE_MTPB, 0x29),
	MTP_KEY18_ISB4			= PAGE_ADDR(PAGE_MTPB, 0x2A),
	MTP_KEY18_ISB5			= PAGE_ADDR(PAGE_MTPB, 0x2B),
	MTP_KEY18_LSB			= PAGE_ADDR(PAGE_MTPB, 0x2C),
	MTP_KEY19_MSB			= PAGE_ADDR(PAGE_MTPB, 0x2D),
	MTP_KEY19_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x2E),
	MTP_KEY19_LSB			= PAGE_ADDR(PAGE_MTPB, 0x33),
	MTP_KEY20_MSB			= PAGE_ADDR(PAGE_MTPB, 0x34),
	MTP_KEY20_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x35),
	MTP_KEY20_LSB			= PAGE_ADDR(PAGE_MTPB, 0x3A),
	MTP_KEY21_MSB			= PAGE_ADDR(PAGE_MTPB, 0x3B),
	MTP_KEY21_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x3C),
	MTP_KEY21_LSB			= PAGE_ADDR(PAGE_MTPB, 0x41),
	MTP_KEY22_MSB			= PAGE_ADDR(PAGE_MTPB, 0x42),
	MTP_KEY22_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x43),
	MTP_KEY22_LSB			= PAGE_ADDR(PAGE_MTPB, 0x48),
	MTP_KEY23_MSB			= PAGE_ADDR(PAGE_MTPB, 0x49),
	MTP_KEY23_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x4A),
	MTP_KEY23_LSB			= PAGE_ADDR(PAGE_MTPB, 0x4F),
	MTP_KEY24_MSB			= PAGE_ADDR(PAGE_MTPB, 0x50),
	MTP_KEY24_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x51),
	MTP_KEY24_LSB			= PAGE_ADDR(PAGE_MTPB, 0x56),
	MTP_KEY25_MSB			= PAGE_ADDR(PAGE_MTPB, 0x57),
	MTP_KEY25_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x58),
	MTP_KEY25_LSB			= PAGE_ADDR(PAGE_MTPB, 0x5D),
	MTP_KEY26_MSB			= PAGE_ADDR(PAGE_MTPB, 0x5E),
	MTP_KEY26_ISB1			= PAGE_ADDR(PAGE_MTPB, 0x5F),
	MTP_KEY26_LSB			= PAGE_ADDR(PAGE_MTPC, 0x04),
	MTP_KEY27_MSB			= PAGE_ADDR(PAGE_MTPC, 0x05),
	MTP_KEY27_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x06),
	MTP_KEY27_ISB2			= PAGE_ADDR(PAGE_MTPC, 0x07),
	MTP_KEY27_ISB3			= PAGE_ADDR(PAGE_MTPC, 0x08),
	MTP_KEY27_ISB4			= PAGE_ADDR(PAGE_MTPC, 0x09),
	MTP_KEY27_ISB5			= PAGE_ADDR(PAGE_MTPC, 0x0A),
	MTP_KEY27_LSB			= PAGE_ADDR(PAGE_MTPC, 0x0B),
	MTP_KEY28_MSB			= PAGE_ADDR(PAGE_MTPC, 0x0C),
	MTP_KEY28_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x0D),
	MTP_KEY28_ISB2			= PAGE_ADDR(PAGE_MTPC, 0x0E),
	MTP_KEY28_ISB3			= PAGE_ADDR(PAGE_MTPC, 0x0F),
	MTP_KEY28_ISB4			= PAGE_ADDR(PAGE_MTPC, 0x10),
	MTP_KEY28_ISB5			= PAGE_ADDR(PAGE_MTPC, 0x11),
	MTP_KEY28_LSB			= PAGE_ADDR(PAGE_MTPC, 0x12),
	MTP_KEY29_MSB			= PAGE_ADDR(PAGE_MTPC, 0x13),
	MTP_KEY29_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x14),
	MTP_KEY29_ISB2			= PAGE_ADDR(PAGE_MTPC, 0x15),
	MTP_KEY29_ISB3			= PAGE_ADDR(PAGE_MTPC, 0x16),
	MTP_KEY29_ISB4			= PAGE_ADDR(PAGE_MTPC, 0x17),
	MTP_KEY29_ISB5			= PAGE_ADDR(PAGE_MTPC, 0x18),
	MTP_KEY29_LSB			= PAGE_ADDR(PAGE_MTPC, 0x19),
	MTP_KEY30_MSB			= PAGE_ADDR(PAGE_MTPC, 0x1A),
	MTP_KEY30_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x1B),
	MTP_KEY30_LSB			= PAGE_ADDR(PAGE_MTPC, 0x20),
	MTP_KEY31_MSB			= PAGE_ADDR(PAGE_MTPC, 0x21),
	MTP_KEY31_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x22),
	MTP_KEY31_LSB			= PAGE_ADDR(PAGE_MTPC, 0x27),
	MTP_KEY32_MSB			= PAGE_ADDR(PAGE_MTPC, 0x28),
	MTP_KEY32_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x29),
	MTP_KEY32_LSB			= PAGE_ADDR(PAGE_MTPC, 0x2E),
	MTP_KEY33_MSB			= PAGE_ADDR(PAGE_MTPC, 0x2F),
	MTP_KEY33_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x30),
	MTP_KEY33_LSB			= PAGE_ADDR(PAGE_MTPC, 0x35),
	MTP_KEY34_MSB			= PAGE_ADDR(PAGE_MTPC, 0x36),
	MTP_KEY34_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x37),
	MTP_KEY34_LSB			= PAGE_ADDR(PAGE_MTPC, 0x3C),
	MTP_KEY35_MSB			= PAGE_ADDR(PAGE_MTPC, 0x3D),
	MTP_KEY35_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x3E),
	MTP_KEY35_LSB			= PAGE_ADDR(PAGE_MTPC, 0x43),
	MTP_KEY36_MSB			= PAGE_ADDR(PAGE_MTPC, 0x44),
	MTP_KEY36_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x45),
	MTP_KEY36_LSB			= PAGE_ADDR(PAGE_MTPC, 0x4A),
	MTP_KEY37_MSB			= PAGE_ADDR(PAGE_MTPC, 0x4B),
	MTP_KEY37_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x4C),
	MTP_KEY37_LSB			= PAGE_ADDR(PAGE_MTPC, 0x51),
	MTP_KEY38_MSB			= PAGE_ADDR(PAGE_MTPC, 0x52),
	MTP_KEY38_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x53),
	MTP_KEY38_LSB			= PAGE_ADDR(PAGE_MTPC, 0x58),
	MTP_KEY39_MSB			= PAGE_ADDR(PAGE_MTPC, 0x59),
	MTP_KEY39_ISB1			= PAGE_ADDR(PAGE_MTPC, 0x5A),
	MTP_PRIVATE_AREA		= PAGE_ADDR(PAGE_MTPC, 0x5F),
	CURPAGE				= PAGE_ADDR(PAGE_INVALID, 0xFF),
};



enum cec_reg {
	APRCSR = 0x00,
	CER = 0x01,
	CVR = 0x02,
	CCR = 0x03,
	ACKH = 0x04,
	ACKL = 0x05,
	CCONR = 0x06,
	CDR0 = 0x07,
	CDR1 = 0x08,
	CDR2 = 0x09,
	CDR3 = 0x0A,
	CDR4 = 0x0B,
	CDR5 = 0x0C,
	CDR6 = 0x0D,
	CDR7 = 0x0E,
	CDR8 = 0x0F,
	CDR9 = 0x10,
	CDR10 = 0x11,
	CDR11 = 0x12,
	CDR12 = 0x13,
	CDR13 = 0x14,
	CDR14 = 0x15,
	CDR15 = 0x16,
	CDR16 = 0x17,
	CDR17 = 0x18,
	CDR18 = 0x19,
	I2C_HIGH_SPEED = 0xF0,
	XTAL_CTRL = 0xF1,
	RESET_CTRL = 0xF2,
	CFG_CLK_CTRL = 0xF3,
	PWR_CONTROL = 0xF4,
	OSC_DIVIDER = 0xF5,
	OSC_PERIOD_LSB = 0xF6,
	OSC_PERIOD_MSB = 0xF7,
	EN_OSC_PERIOD_LSB = 0xF8,
	EN_OSC_PERIOD_MSB = 0xF9,
	STATUS_RX_SENSE = 0xFA,
	INTERRUPT = 0xFC,
	ENABLE_INTERRUPT = 0xFD,
	EN_RX_SENSE = 0xFE,
	CONTROL = 0xFF,
};

enum info_type {
	INFOFRAME_TYPE_NONE = 0x00,
	INFOFRAME_TYPE_VENDOR = 0x81,
	INFOFRAME_TYPE_AVI = 0x82,
	INFOFRAME_TYPE_SPD = 0x83,
	INFOFRAME_TYPE_AUDIO = 0x84,
	INFOFRAME_TYPE_MPS = 0x85
};

struct tda1997x_info_any {
	enum info_type			type;				/**< Infoframe type */
	uint8_t				version;			/**< Infoframe version */
	uint8_t				len;				/**< Infoframe length */
	uint8_t				cksum;				/**< Infoframe checksum */
	uint8_t				data[27];			/**< Maximum data length for infoframes */
};

struct tda1997x_info_vs {
	enum info_type			type;				/**< Expected to be 0x81 */
	uint8_t				version;
	uint8_t		 		len;
	uint8_t				cksum;
	uint32_t			oui;
};

struct tda1997x_info_avi {
	enum info_type			type;				/**< Expected to be 0x82 */
	uint8_t				version;
	uint8_t				len;				/**< Expected to be 13 */
	uint8_t				cksum;
};

enum info_spd_src {
	INFOFRAME_SPD_UNKNOWN = 0x00,
	INFOFRAME_SPD_DIGSTB = 0x01,
	INFOFRAME_SPD_DVD = 0x02,
	INFOFRAME_SPD_DVHS = 0x03,
	INFOFRAME_SPD_HDDVR = 0x04,
	INFOFRAME_SPD_DVC = 0x05,
	INFOFRAME_SPD_DSC = 0x06,
	INFOFRAME_SPD_VIDEOCD = 0x07,
	INFOFRAME_SPD_GAME = 0x08,
	INFOFRAME_SPD_PC = 0x09,
	INFOFRAME_SPD_BLURAY = 0x0A,
	INFOFRAME_SPD_SACD = 0x0B,
	INFOFRAME_SPD_HDDVD = 0x0C,
	INFOFRAME_SPD_PMP = 0x0D
};

struct tda1997x_info_spd {
	enum info_type		type;		/**< Expected to be 0x83 */
	uint8_t			version;
	uint8_t			len;		/**< Expected to be 25 */
	uint8_t			cksum;
	uint8_t			vendor[8];	/**< Vendor name */
	uint8_t			desc[16];	/**< Product description */
	enum info_spd_src	src;		/**< Source information */
};


#define INFO_AUD_CODE_TYPE_MASK				(0xF0U)		/**< Code type */
#define INFO_AUD_CH_COUNT_MASK				(0x07U)		/**< Channel count */

#define INFO_AUD_SAMPLE_FREQ_MASK			(0x1CU)		/**< Sample frequency */
#define INFO_AUD_SAMPLE_SIZE_MASK			(0x03U)		/**< Sample size */

#define INFO_AUD_CODE_EXT_MASK				(0x1FU)

#define INFO_AUD_DM_INHIBIT				(1 << 7)	/**< Down-mix inhibit */
#define INFO_AUD_LVL_SHIFT_MASK				(0x78U)		/**< Level shift value */
#define INFO_AUD_LFE_PB_MASK				(0x03U)		/**< LFE playback level */

struct tda1997x_info_aud {
	enum info_type		type;		/**< Expected to be 0x84 */
	uint8_t			version;
	uint8_t			len;		/**< Expected to be 10 */
	uint8_t			cksum;
	uint8_t			code_chan;	/**< Code type and channel data */
	uint8_t			sample;		/**< Sample frequency and size */
	uint8_t			code_ext;	/**< Code type extension */
	uint8_t			chan_alloc;	/**< Channel allocation */
	uint8_t			lvl_shift;	/**< Level shift */
};

struct tda1997x_info_mps {
	enum info_type		type;		/**< Expected to be 0x85 */
	uint8_t			version;
	uint8_t			len;		/**< Expected to be 10 */
	uint8_t			cksum;
	uint32_t		rate;
	uint8_t			data[6];
};

union tda1997x_infoframe {
	struct tda1997x_info_any	any;		/**< Generic infoframe data */
	struct tda1997x_info_vs		vs;		/**< Vendor specific */
	struct tda1997x_info_avi	avi;		/**< Auxiliary video information */
	struct tda1997x_info_spd	spd;		/**< Source product description */
	struct tda1997x_info_aud	aud;		/**< Audio infoframe */
	struct tda1997x_info_mps	mps;		/**< MPEG source infoframe */
};

#define TDA1997X_SEED_TABLE_LEN				(10)

//#ifdef DEBUG
//static const char *audio_freq[] = {
//	"NO CHANGE",
//	"32k Hz",
//	"44.1 kHz",
//	"48 kHz",
//	"88.2 kHz",
//	"96 kHz",
//	"176 kHz",
//	"192 kHz"
//};
//#endif

static uint8_t vp_conf444[9] = {
	VP_CTRL_A_MSB,			/* [23:20] */
	VP_CTRL_A_ISB,			/* [19:16] */
	VP_CTRL_HIZ,			/* Not used */
	VP_CTRL_B_MSB,			/* [15:12] */
	VP_CTRL_B_ISB,			/* [11:8] */
	VP_CTRL_HIZ,			/* Not used */
	VP_CTRL_C_MSB,			/* [7:4] */
	VP_CTRL_C_ISB,			/* [3:0] */
	VP_CTRL_HIZ,			/* Not used */
};

static uint8_t vp_conf_mute[9] = {
	VP_CTRL_HIZ,				/* [23:20] */
	VP_CTRL_HIZ,				/* [19:16] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_HIZ,				/* [15:12] */
	VP_CTRL_HIZ,				/* [11:8] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_HIZ,				/* [7:4] */
	VP_CTRL_HIZ,				/* [3:0] */
	VP_CTRL_LOZ,				/* Not used */
};

static const uint8_t blank_rgb[6] = {
	0x00,
	0x40,
	0x00,
	0x40,
	0x00,
	0x40
};

static const uint8_t blank_yuv[6] = {
	0x00,
	0x40,
	0x02,
	0x00,
	0x02,
	0x00
};

static const int16_t color_conv444[COLOR_CONV_MATRIX_LENGTH] = {
	-256,	-2048,	-2048,			/* Input Offset*/
	4096,	-2860,	-1378,			/* Matrix:ITU-601 YCbCr limited range =>  RGB limited range */
	4096,	5615,	0,
	4096,	0,	7097,
	256,	256,	256			/* Output Offset*/
};

/* YUV709 -> RGB full */
static const int16_t yuv709_rgb_full[COLOR_CONV_MATRIX_LENGTH] = {
	 -256, -2048,  -2048,
	 4769, -2183,   -873,
	 4769,  7343,      0,
	 4769,     0,   8652,
	    0,     0,      0,
};

static const int16_t yuv601_rgb_full[COLOR_CONV_MATRIX_LENGTH] = {
	 -256, -2048,  -2048,
	 4769, -3330,  -1602,
	 4769,  6538,      0,
	 4769,     0,   8264,
	  256,   256,    256,
};

static const int16_t rgb_lim_rgb_full[COLOR_CONV_MATRIX_LENGTH] = {
	 -256,  -256,   -256,
	 4769,     0,      0,
	    0,  4769,      0,
	    0
	    ,     0,   4769,
	    0,     0,      0,
};

static const int16_t rgb_lim_itu601[COLOR_CONV_MATRIX_LENGTH] = {
	 -256,  -256,   -256,
	 2404,  1225,    467,
	-1754,  2095,   -341,
	-1388,  -707,   2095,
	  256,  2048,   2048,
};

static const int16_t rgb_lim_itu709[COLOR_CONV_MATRIX_LENGTH] = {
	 -256,  -256,   -256,
	 2918,   867,    295,
	-1894,  2087,   -190,
	-1607,  -477,   2087,
	  256,  2048,   2048,
};

static const int16_t rgb_full_itu601[COLOR_CONV_MATRIX_LENGTH] = {
	    0,     0,      0,
	 2065,  1052,    401,
	-1506,  1799,   -293,
	-1192,  -607,   1799,
	  256,  2048,   2048,
};

static const int16_t rgb_full_itu709[COLOR_CONV_MATRIX_LENGTH] = {
	    0,     0,      0,
	 2506,   745,    253,
	-1627,  1792,   -163,
	-1380,  -410,   1792,
	  256,  2048,   2048,
};


static const uint8_t clk_rate[6] = {
	0x00,
	0x57,
	0xE4,
	0x03,
	0x95,
	0xF8
};

const struct tda1997x_mtp_seed hdcp_seed_tab[TDA1997X_SEED_TABLE_LEN] = {
	{ 0xF0,	0x1234 },
	{ 0xF1,	0xDBE6 },
	{ 0xF2,	0xDBE6 },
	{ 0,	0x1234 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 }
};

static uint8_t ddc_config[8] = {
	0x19,						/* EDID_VERSION */
	0x41,						/* EDID_ENABLE */
	0x44,						/* EDID_BLOCK_SELECT */
	0x00,						/* empty */
	0x04,						/* HPD_POWER */
	0x18,						/* HPD_AUTO_CTRL */
	0x00,						/* HPD_DURATION */
	0x00						/* RX_HPD_HEAC */
};

static uint8_t rt_config[6] = {
	0x78,						/* RT_AUTO_CTRL */
	0x03,						/* EQ_MAN_CTRL0 */
	0x33,						/* EQ_MAN_CTRL1 */
	0xF0,						/* OUTPUT_CFG */
	0x00,						/* MUTE_CTRL */
	0x00						/* SLAVE_ADDR */
};

static uint16_t spa_edid[2] = {
	0x0100,
	0x0000,
};

/**
 * @brief	Write Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda1997x_write(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)CURPAGE, &page);
		if (err < 0) {
			printf("[ERROR] %s() %s %d - writing page %02x (%d)\n", __func__, __FILE__, __LINE__, page, err);
			return err;
		}

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)reg + i, data);
		if (err < 0) {
			printf("[ERROR] %s() %s %d\n", __func__, __FILE__, __LINE__);
			return err;
		}
	}

	return i;
}

/**
 * @brief	Read Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int tda1997x_read(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->i2c_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Read Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int read_reg(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t *data)
{
	return tda1997x_read(dev, reg, 1, data);;
}

/**
 * @brief	Write Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int write_reg(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda1997x_write(dev, reg, 1, &tmp);
}

/**
 * @brief	Register Mask Write
 * 		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int write_reg_mask(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return write_reg(dev, reg, reg_val);
}

/**
 * @brief	CEC Write Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_write(struct tda1997x_dev *dev, enum cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Read Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_read(struct tda1997x_dev *dev, enum cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Write Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	0 on success, non-zero error status otherwise
 */
static int cec_write_reg(struct tda1997x_dev *dev, enum cec_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda1997x_cec_write(dev, reg, 1, &tmp);
}

/**
 * @brief	CEC Read Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	0 on success, non-zero error status otherwise
 */
static int cec_read_reg(struct tda1997x_dev *dev, enum cec_reg reg, uint8_t *data)
{
	return tda1997x_cec_read(dev, reg, 1, data);;
}

/**
 * @brief	CEC Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	0 on success, non-zero error status otherwise
 */
static int cec_write_reg_mask(struct tda1997x_dev *dev, enum cec_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = cec_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return cec_write_reg(dev, reg, reg_val);
}

/**
 * @brief	Clear Interrupt Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register to clear
 * @param	val:	Pointer to data to write from register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_clear_irq(struct tda1997x_dev *dev, enum hdmi_reg reg, uint8_t *val)
{
	int err;
	uint8_t tmp;

	err = read_reg(dev, reg, &tmp);
	if (err < 0)
		return err;

	err = write_reg(dev, reg, tmp);
	if (err < 0)
		return err;

	*val = tmp;

	return 0;
}

/**
 * @brief	Software Reset
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	rst:	Reset (> 0) or enable (0)
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_soft_rst(struct tda1997x_dev *dev, uint8_t rst)
{
	return write_reg(dev, HDMI_SOFT_RST, rst);
}

/**
 * @brief	Infoframe Reset
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	info_rst:	Infoframe reset bitfield
 * @param	sus_en:		Start up sequence enabled
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_info_rst(struct tda1997x_dev *dev, uint8_t rst)
{
	int err;
	uint8_t reg_val;

	err = write_reg_mask(dev, HDMI_INFO_RST, rst, rst);
	if (err < 0)
		return err;

	err = write_reg_mask(dev, HDMI_INFO_RST, rst, 0);
	if (err < 0)
		return err;

	/* Clear interrupts if infoframes have been reset */
	if (rst & INFO_RST_INFOFRAME) {
		err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_MODE, &reg_val);
		if (err < 0)
			return err;
	}

	return 0;
}

/**
 * @brief	Enable Startup Sequence
 *
 * @param	dev:	TDA1997x device structure pointer
 * @param	en:		Enable (> 0) or disable (0)
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_sus_en(struct tda1997x_dev *dev, uint8_t en)
{
	if (en)
		return write_reg_mask(dev, RATE_CTRL, SUS_ENABLE, SUS_ENABLE);
	else
		return write_reg_mask(dev, RATE_CTRL, SUS_ENABLE, 0);
}

/**
 * @brief	Configure Video Port
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	vp_conf:	Pointer to array of video port control values
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_vp(struct tda1997x_dev *dev, uint8_t *vp_conf)
{
	return tda1997x_write(dev, VP35_32_CTRL, 9, vp_conf);
}

/**
 * @brief	Configure Colorspace Conversion
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	mtx:		Pointer to start of conversion matrix or NULL for bypass
 * @return 	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_conv(struct tda1997x_dev *dev, int16_t *mtx)
{
	int err;
	uint8_t i;
	uint8_t reg_val[30];

	/* Matrix bypass if called with NULL */
	if (mtx == NULL)
		return write_reg_mask(dev, VDP_CTRL, VDP_CTRL_MATRIX_BYPASS, VDP_CTRL_MATRIX_BYPASS);

	/* Turn off matrix bypass before setting the matrix coefficients */
	err = write_reg_mask(dev, VDP_CTRL, VDP_CTRL_MATRIX_BYPASS, 0);
	if (err < 0)
		return err;

	for (i = 0; i < 15; i++, mtx++) {
		reg_val[2 * i] = (uint8_t)((*mtx & 0xFF00) >> 8);	/* coeff MSB register */
		reg_val[(2 * i) + 1] = (uint8_t)(((uint16_t)(*mtx)) & 0x00FF);	/* coeff LSB register */
	}

	err = tda1997x_write(dev, MAT_OI1_MSB, 30, reg_val);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Configure Video Output Format
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error code otherwise
 */
int tda1997x_cfg_vid_out(struct tda1997x_dev *dev)
{
	int err;

	/* Bypass formatter (not needed in RGB444 with no blanking or timing ref) */
	err = write_reg_mask(dev, VDP_CTRL, VDP_CTRL_FORMATTER_BYPASS, 0);
	if (err < 0)
		return err;

	/* Configure color space conversion (bypass) */
	err = tda1997x_cfg_conv(dev, NULL);
	if (err < 0)
		return err;

	/* Set blanking codes */
	err = tda1997x_write(dev, BLK_GY_MSB, 6, (uint8_t *) blank_rgb);
	if (err < 0)
		return err;

	/* Configure pixel repeater */
	err = write_reg_mask(dev, PIX_REPEAT, PIX_REPEAT_UP_SEL_MASK, (uint8_t) PIX_REPEAT_UP_SEL_BYPASS); // PIX_REPEAT_UP_SEL_REPEATCHROMA);
	if (err < 0)
		return err;

	err = write_reg_mask(dev, PIX_REPEAT, PIX_REPEAT_PIX_REP_MASK, 0);
	if (err < 0)
		return err;

	/* Configure prefilter */
	err = tda1997x_cfg_prefilter(dev, FILTERS_CTRL_PREFILTER_OFF, FILTERS_CTRL_PREFILTER_OFF);
	if (err < 0)
		return err;

	/* Configure video output */
	err = write_reg_mask(dev,
			OF_CTRL,
			OF_CTRL_BLANKING_INSERT | OF_CTRL_TIMINGREF_INSERT | OF_CTRL_FORMAT_MASK,
			OF_CTRL_TIMINGREF_INSERT | (uint8_t) OF_CTRL_FORMAT_444);
	if (err < 0)
		return err;

	err = write_reg(dev, VHREF_CTRL, 0x16);
	if (err < 0)
		return err;

	/* Configure pixel clock generator and delay */
	err = write_reg_mask(dev, CLKOUT_CTRL, CLKOUT_CLK_DELAY_MASK, 0x30);
	if (err < 0)
		return err;

	/* Configure DE output signal */
	err = write_reg(dev, DE_FREF_SEL, 0x82);
	if (err < 0)
		return err;

	/* Configure HS output signal */
	err = write_reg(dev, HS_HREF_SEL, 0x82);
	if (err < 0)
		return err;

	/* Configure VS output signal */
	err = write_reg(dev, VS_VREF_SEL, 0x82);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Configure Prefilter
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	bu:		B/Cb channel prefilter configuration
 * @param	rv:		R/Cr channel prefilter configuration
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_prefilter(struct tda1997x_dev *dev, enum tda1997x_filters_ctrl_prefil bu, enum tda1997x_filters_ctrl_prefil rv)
{
	int err;
	uint8_t reg_val = ((uint8_t)bu << 2) | ((uint8_t)rv);

	/* Configure prefilter */
	err = write_reg(dev, FILTERS_CTRL, reg_val);
	if (err < 0)
		return err;

	if ((bu == FILTERS_CTRL_PREFILTER_OFF) && (rv == FILTERS_CTRL_PREFILTER_OFF))
		reg_val = VDP_CTRL_PREFILTER_BYPASS;
	else
		reg_val = 0;

	/* Set or clear prefilter bypass bit */
	err = write_reg_mask(dev, VDP_CTRL, VDP_CTRL_PREFILTER_BYPASS, reg_val);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Configure Audio Format
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_audio_fmt(struct tda1997x_dev *dev)
{
	int err;
	uint8_t reg_val;

	/**
	 * BEGIN: Configure Audio Formatter
	 */
	/* Configure audio path */
	err = write_reg(dev, AUDIO_PATH, 0x01);
	if (err < 0)
		return err;

	/* Configure audio layout */
	err = write_reg(dev, AUDIO_LAYOUT, AUDIO_LAYOUT_SP_FLAG);
	if (err < 0)
		return err;

	/* Configure FIFO latency */
	err = write_reg(dev, FIFO_LATENCY_VALUE, 0x80U);
	if (err < 0)
		return err;

	/**
	 * Configure FIFO control for audio
	 * @todo Determine the correct register setting for FIFO_LATENCY_CTRL
	 * that will eliminate glitches and interruptions in audio stream
	 */
	err = write_reg(dev, FIFO_LATENCY_CTRL, 0x03);
	if (err < 0)
		return err;

	/* Configure audio selection */
	err = write_reg(dev, AUDIO_SEL, 0x00); // AUDIO_SEL_TESTTONE
	if (err < 0)
		return err;

	/* Configure audio enable */
	err = write_reg(dev,
			AUDIO_OUT_ENABLE,
			AUDIO_OUT_ENABLE_ACLK |
			AUDIO_OUT_ENABLE_WS |
			AUDIO_OUT_ENABLE_AP0);
//			AUDIO_OUT_ENABLE_AP1 |
//			AUDIO_OUT_ENABLE_AP2 |
//			AUDIO_OUT_ENABLE_AP3);
	if (err < 0)
		return err;

	err = read_reg(dev, AUDIO_OUT_LOW_HIZ, &reg_val);
	if (err < 0)
		return err;

	if (0) {
		/* Set test mode */
		err = write_reg(dev, TEST_MODE, 0x03);
		if (err < 0)
			return err;

		err = write_reg(dev, TEST_AUDIO_FREQ, 0x0b);
		if (err < 0)
			return err;
	} else {
		err = write_reg(dev, TEST_MODE, 0x00);
		if (err < 0)
			return err;

		err = write_reg_mask(dev, TEST_NCTS_CTRL, 0x03, 0);
		if (err < 0)
			return err;
	}
	/**
	 * END: Configure Audio Formatter
	 */

	/**
	 * BEGIN: Configure Audio Clock Mode
	 */

	err = write_reg(dev, AUDIO_CLOCK_MODE, (uint8_t) AUDIO_CLOCK_MODE_128FS);
	if (err < 0)
		return err;
	/**
	 * END: Configure Audio Clock Mode
	 */

	return 0;
}


/**
 * @brief	Configure Audio Selection
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	mode:	Audio selection mode enumeration value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_audio_mode(struct tda1997x_dev *dev, enum tda1997x_audio_sel_mode mode)
{
	return write_reg_mask(dev, AUDIO_SEL, AUDIO_SEL_MODE_MASK, (uint8_t)mode);
}


/**
 * @brief	Get Audio Status
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	status:	Pointer to audio status to write value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_audio_flags(struct tda1997x_dev *dev, uint8_t *status)
{
	return read_reg(dev, AUDIO_FLAGS, status);
}


/**
 * @brief	Get Audio Frequency
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	freq:	Pointer to frequency to write value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_audio_freq(struct tda1997x_dev *dev, enum tda1997x_audio_freq *freq)
{
	int err;
	uint8_t reg_val;

	err = read_reg(dev, AUDIO_FREQ, &reg_val);
	if (err < 0)
		return err;

	*freq = (enum tda1997x_audio_freq)reg_val;

	return 0;
}


/**
 * @brief	Get Audio Channel Status
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_chan_status(struct tda1997x_dev *dev)
{
	int err;
	uint8_t reg_val[12];

	err = tda1997x_read(dev, CH_STAT_BYTE0, 12, reg_val);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Reset Audio FIFO
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_audio_fifo_rst(struct tda1997x_dev *dev)
{
	int err;

	err = write_reg_mask(dev, HDMI_INFO_RST, INFO_RST_AUDIO_FIFO_MASK, INFO_RST_AUDIO_FIFO_MASK);
	if (err < 0)
		return err;

	err = write_reg_mask(dev, HDMI_INFO_RST, INFO_RST_AUDIO_FIFO_MASK, 0);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Calculate EDID Block Checksum
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	cksum:	Pointer to data to write checksum value
 * @return	None
 */
static int tda1997x_edid_cksum(struct tda1997x_dev *dev, uint8_t *edid, uint8_t *cksum)
{
	uint8_t i;
	uint8_t tmp = 0;
	uint8_t *pedid = edid;

	if ((edid == NULL) || (cksum == NULL))
		return (-1);

	for (i = 0; i < 127; i++)
		tmp += *pedid++;

	/* Write 2's complement to the checksum */
	*cksum = (0xFFU - tmp) + 1;

	return 0;
}


/**
 * @brief	Configure EDID
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	edid:		Pointer to start of EDID block, expected to be 127 bytes
 * @param	edid_ext:	Pointer to start of EDID extension, expected to be 127 bytes
 * @return	0 on success, non-zero error status otherwise
 */
int
tda1997x_cfg_edid(struct tda1997x_dev *dev, uint8_t *edid, uint8_t *edid_ext)
{
	int err;
	uint8_t cksum;				/**< Checksum values for each EDID block and SPA */

	/* Check arguments */
	if ((dev == NULL) ||
		(edid == NULL) ||
		(edid_ext == NULL))
		return (-1);

	/* Required number of EDID extensions after EDID block */
	if (edid[126] != 1) {
		DEBUG_PRINT("invalid number of EDID extensions: %d", edid[126]);
		return (-3);
	}

	/* Calculate the checksum for EDID block 0 */
	err = tda1997x_edid_cksum(dev, edid, &cksum);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, EDID_IN_BYTE0, 127, edid);
	if (err < 0)
		return err;

	/* Write block 0 checksum byte */
	err = write_reg(dev, EDID_IN_CHECKSUM0, cksum);
	if (err < 0)
		return err;

	/* Calculate the checksum for EDID extension */
	err = tda1997x_edid_cksum(dev, edid_ext, &cksum);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, EDID_IN_BYTE128, 127, edid_ext);
	if (err < 0)
		return err;

	/* Write block 1 checksum byte */
	err = write_reg(dev, EDID_IN_CHECKSUM1, cksum);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Configure Source Physical Address
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	edid1:	Pointer to start of EDID extension block
 * @param	offset:	Offset of SPA within the EDID extension block
 * @param	spa:	Pointer to array of SPAs
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cfg_spa(struct tda1997x_dev *dev, uint8_t *edid1, uint8_t offset, uint16_t* spa)
{
	int err;
	uint8_t reg_val[7];
	uint8_t i, tmp = 0;

	if ((dev == NULL) ||
		(edid1 == NULL) ||
		(spa == NULL))
		return (-1);

	/* Build SPA offset and value registers */
	reg_val[0] = offset;
	reg_val[1] = (uint8_t)(spa[0] >> 8);
	reg_val[2] = (uint8_t)(spa[0] & 0xFFU);

	reg_val[4] = (uint8_t)(spa[1] >> 8);
	reg_val[5] = (uint8_t)(spa[1] & 0xFFU);

	/* First calculate the EDID block 1 checksum without the SPA bytes */
	for (i = 0; i < 127; i++)
		if ((i == offset) || (i == (offset + 1)))
			continue;
		else
			tmp += edid1[i];

	/* Add the checksums for the SPAs separately */
	reg_val[3] = tmp + (((spa[0] >> 8) + spa[0]) & 0xFFU);
	reg_val[6] = tmp + (((spa[1] >> 8) + spa[1]) & 0xFFU);

	/* Calculate 2's complement */
	reg_val[3] = (uint8_t)((0xFFU - reg_val[3]) + 1);
	reg_val[6] = (uint8_t)((0xFFU - reg_val[6]) + 1);

	err = tda1997x_write(dev, EDID_IN_SPA_SUB, 7, reg_val);
	if (err < 0)
		return err;

	return 0;
}





/**
 * @brief	Read Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_read_infoframe(struct tda1997x_dev *dev, enum hdmi_reg reg, union tda1997x_infoframe *info)
{
	int err;
	uint8_t head[4];
	uint8_t *data;

	if ((dev == NULL) || (info == NULL))
		return (-1);

	/* Read the infoframe header to determine the type and length */
	err = tda1997x_read(dev, reg, 4, head);
	if (err < 0)
		return err;

	/* Parse the header to determine */
	info->any.type = head[0];
	info->any.version = head[1];
	info->any.len = head[2];
	info->any.cksum = head[3];

	/* If invalid type, don't bother reading data */
	if ((info->any.type < INFOFRAME_TYPE_VENDOR) || (info->any.type > INFOFRAME_TYPE_MPS))
		return (0);

	if ((info->any.len > 0) && (info->any.len <= 27)) {
		data = info->any.data;
		err = tda1997x_read(dev, reg + 4, info->any.len, data);
		if (err < 0)
			return err;
	}

	return 0;
}


/**
 * @brief	Parse Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	info:	Pointer to infoframe union data
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_parse_infoframe(struct tda1997x_dev *dev, union tda1997x_infoframe *info)
{
	return 0;
}


/**
 * @brief	Parse Audio Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	info:	Pointer to audio infoframe structure
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_parse_aud_infoframe(struct tda1997x_dev *dev, struct tda1997x_info_aud *info)
{
	int err;

	/* Set the audio output based to match the infoframe */
	err = write_reg(dev, AUDIO_PATH, info->chan_alloc);
	if (err < 0)
		return err;

	/* Reset the audio FIFO */
	err = tda1997x_audio_fifo_rst(dev);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Print Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_print_infoframe(struct tda1997x_dev *dev)
{
	return 0;
}

/**
 * @brief	Get Timing Values
 * 		Sets an data memory block to the video timing register values
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	0 on success, non-zero error status otherwise
 */
int
tda1997x_get_timing(struct tda1997x_dev *dev, uint8_t *data)
{
	int ret;

	ret = tda1997x_read(dev, V_PER_MSB, 26, data);

	data += 26;

	ret = tda1997x_read(dev, PXCNT_PR_MSB, 48, data);
	if (ret < 0)
		return ret;

	return 0;
}

/**
 * @brief	Initialize TDA1997x HDMI Receiver
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	cfg:	TDA1997X configuration structure pointer to use for
 * 			initialization
 * @return	0 on success, non-zero error status otherwise
 */
int
tda1997x_init(struct tda1997x_dev *dev, struct tda1997x_cfg *cfg, uint8_t *edid_block, uint8_t *edid_ext)
{
	int err;
	uint8_t i, reg_val, mask;
	uint16_t hdcp_kds;			/**< HDCP key decryption seed */

	if ((dev == NULL) || (cfg == NULL))
		return -1;

	dev->cfg = cfg;				/* Attach configuration to receiver */
	dev->cfg->cur_page = PAGE_INVALID;	/* Force initial read/write to set page */

	/* Open the device and perform basic initialization */

	/* Apply WA to get correct I2C access to Rx HDMI*/
	err = write_reg(dev, MAN_SUS_HDMI_SEL, MAN_SUS_HDMI_DIS_HDCP | MAN_SUS_HDMI_RST_HDCP);
	if (err < 0)
		return err;

	err = write_reg(dev, MAN_SUS_HDMI_SEL, 0x00);
	if (err < 0)
		return err;

	err = write_reg(dev, VDP_CTRL, 0x1f);
	if (err < 0)
		return err;

//	/* Read and store CEC slave address */
//	err = read_reg(dev, SLAVE_ADDR, &reg_val);
//	if (err < 0)
//		return err;
//
//	/* Update CEC address if necessary */
//	if ((uint8_t)((reg_val >> 4) & 0x03) != (dev->cfg->cec_addr & 0x03)) {
//		err = write_reg_mask(dev, SLAVE_ADDR, 0x30, (uint8_t)((dev->cfg->cec_addr << 4) & 0x30));
//		if (err < 0)
//			return err;
//	}

	/* Disable HPD */
	err = write_reg(dev, HPD_AUTO_CTRL, HPD_AUTO_UNSEL);
	if (err < 0)
		return err;

	/* Wrap these consecutive register writes */
	err = write_reg(dev, SUS_SET_RGB2, 0x06);
	if (err < 0)
		return err;

	err = write_reg(dev, SUS_SET_RGB3, 0x06);
	if (err < 0)
		return err;

	err = write_reg(dev, RT_MAN_CTRL, 0x43);
	if (err < 0)
		return err;

	err = write_reg(dev, OF_CTRL, 0x40);
	if (err < 0)
		return err;

	/* Begin CEC */
	/* Enable sync measurement timing */
	err = cec_write_reg(dev, PWR_CONTROL, 0x04);
	if (err < 0)
		return err;

	/* Adjust CEC clock divider */
	err = cec_write_reg(dev, OSC_DIVIDER, 0x03);
	if (err < 0)
		return err;

	err = cec_write_reg(dev, EN_OSC_PERIOD_LSB, 0xA0);
	if (err < 0)
		return err;
	/* End CEC */

	err = write_reg(dev, TIMER_D, 0x54);
	if (err < 0)
		return err;
	/*
	 * Enable power switch - SRAM content is always valid
	 * (in case E-MTP is not or mis-programmed)
	 */
	err = cec_write_reg_mask(dev, CONTROL, 0x20, 0x20);
	if (err < 0)
		return err;

	usleep(1000 * 50);					/* Short delay to allow power to settle */

	/* Initialize top level interrupts */
	err = write_reg(dev,
			IRQ_MASK_TOP,
			IRQ_TOP_SUS |
			IRQ_TOP_RATE |
			IRQ_TOP_MODE |
			IRQ_TOP_INFO |
			IRQ_TOP_AUDIO |
			IRQ_TOP_HDCP);
	if (err < 0)
		return err;

	err = write_reg(dev, IRQ_MASK_SUS, IRQ_SUS_MTP | IRQ_SUS_FORMAT | IRQ_SUS_END);
	if (err < 0)
		return err;

	/* Enable rate stability change interrupts for input */
	err = write_reg(dev, IRQ_MASK_RATE, IRQ_RATE_RXDA);
	if (err < 0)
		return err;

	/* Enable interrupts for audio, SPD, and AVI infoframes */
	err = write_reg(dev, IRQ_MASK_INFO, IRQ_INFO_AUD | IRQ_INFO_SPD | IRQ_INFO_AVI);
	if (err < 0)
		return err;

	/* Enable audio interrupts */
	err = write_reg(dev,
			IRQ_MASK_AUDIO,
			IRQ_AUDIO_FIFO_ERROR |
			IRQ_AUDIO_FIFO_UNMUTE |
			IRQ_AUDIO_CHAN_STATUS |
			IRQ_AUDIO_MUTE |
			IRQ_AUDIO_FLAGS |
			IRQ_AUDIO_FREQ_CHANGE);
	if (err < 0)
		return err;

	/* Enable HDCP interrupts */
	err = write_reg(dev, IRQ_MASK_HDCP, IRQ_HDCP_STATE_C5);
	if (err < 0)
		return err;

	/* Enable mode interrupts */
	err = write_reg(dev, IRQ_MASK_MODE, IRQ_MODE_FLAGS);
	if (err < 0)
		return err;

	for (i = 0; i < 9; i++) {
		/* Clear pending top level interrupts */
		err = write_reg(dev, IRQ_FLG_CLR_TOP + i, 0xff);
		if (err < 0)
			return err;
	}

	/* Initialize TMDS */
	err = tda1997x_write(dev, CLK_MIN_RATE_MSB, 6, (uint8_t *) clk_rate);
	if (err < 0)
		return err;

	/* Deep color filter */
	err = write_reg(dev, DEEP_COLOR_CTRL, 0x31);
	if (err < 0)
		return err;

	/* Disable test pattern */
	err = write_reg(dev, SERVICE_MODE, 0x00);
	if (err < 0)
		return err;

	err = write_reg(dev, INFO_CTRL, 0xff);
	if (err < 0)
		return err;

	err = write_reg(dev, INFO_EXCEED, 0x03);
	if (err < 0)
		return err;

	/* No HDCP acknowledge when disabled, reset startup sequence */
	err = tda1997x_info_rst(dev, INFO_RST_NACK_HDCP);
	if (err < 0)
		return err;

	/* Reset startup sequence if indicated */
	err = tda1997x_sus_en(dev, 0);
	if (err < 0)
		return err;

	/* Mute video port on start */
	err = tda1997x_cfg_vp(dev, vp_conf_mute);
	if (err < 0)
		return err;

	/* MTP start read */
	/* Clear HDCP download MTP flag to start reading */
	err = write_reg_mask(dev, IRQ_FLG_CLR_HDCP, IRQ_HDCP_DLMTP, IRQ_HDCP_DLMTP);
	if (err < 0)
		return err;

	/* Download MTP into SRAM  */
	err = write_reg(dev, HMTP_CTRL, HMTP_CNTRL_DL_ALL);
	if (err < 0)
		return err;

	/* Check HDCP flag INT_FLG_CLR_HDCP_DLMTP */
	do {
		err = read_reg(dev, IRQ_FLG_CLR_HDCP, &reg_val);
		if (err < 0)
			return err;
	} while ((reg_val & IRQ_HDCP_DLMTP) != IRQ_HDCP_DLMTP);

	/* Get HDCP seed */
	err = read_reg(dev, MTP_SEED_INDEX, &reg_val);
	if (err < 0)
		return err;

	/* Search the seed table for the index value */
	for (i = 0; i < TDA1997X_SEED_TABLE_LEN; i++) {
		if ((hdcp_seed_tab[i].seed == 0) && (hdcp_seed_tab[i].lookup == 0))
			break;

		if (hdcp_seed_tab[i].lookup == (uint16_t)reg_val) {
			/* Store the encryption key seed */
			hdcp_kds = hdcp_seed_tab[i].seed;
			break;
		}
	}

	/* Disable HDCP */
	err = write_reg(dev, HDCP_CTRL, HDCP_CTRL_DECRYPTKEY_ON);
	if (err < 0)
		return err;

	/* Write key decryption seed MSB */
	err = write_reg(dev, HDCP_KDS_MSB, (uint8_t)(hdcp_kds >> 8));
	if (err < 0)
		return err;

	/* Write key decryption seed LSB */
	err = write_reg(dev, HDCP_KDS_LSB, (uint8_t)(hdcp_kds & 0xFF));
	if (err < 0)
		return err;

	/* Set the HDCP DDC address */
	err = write_reg(dev, HDCP_DDC_ADDR, TDA1997X_HDCP_DDC_ADDR);
	if (err < 0)
		return err;

	/* Clear HDCP interrupt status bits that may have been raised during this process */
	err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_HDCP, &reg_val);
	if (err < 0)
		return err;

	/* THE DEVICE IS INITIALIZED AT THIS POINT */

	/* Set HPD low */
	err = write_reg_mask(dev, HPD_POWER, HPD_POWER_BYPASS_MASK, 0);
	if (err < 0)
		return err;

	/* Set HPD low */
	err = write_reg_mask(dev, HPD_MAN_CTRL, HPD_MAN_GAIN_MASK, 0);
	if (err < 0)
		return err;

	err = write_reg(dev, HDCP_BCAPS, HDCP_BCAPS_DEFAULT | HDCP_BCAPS_FAST_REAUTH);
	if (err < 0)
		return err;

	/* Configure HDMI */
	err = write_reg_mask(dev,
			HDMI_CTRL,
			HDMI_CTRL_HDCP_MASK | HDMI_CTRL_MUTE_MASK,
			(uint8_t) HDMI_CTRL_MUTE_OFF | (uint8_t) HDMI_CTRL_HDCP_AUTO);
	if (err < 0)
		return err;

	/* EDID Nack OFF */
	err = write_reg_mask(dev, EDID_ENABLE, 0x83, 0x83);
	if (err < 0)
		return err;

	/**
	 * @todo HDCP configuration and activation
	 */
	/* 1. Enable HDCP NACK */
	err = write_reg_mask(dev, HDMI_INFO_RST, INFO_RST_NACK_HDCP, INFO_RST_NACK_HDCP);
	if (err < 0)
		return err;

	/* 2. Disable HDCP */

	/* 3. Set private key index */

	usleep(1000 * 20);

	/* 4. Disable HDCP NACK */
	err = write_reg_mask(dev, HDMI_INFO_RST, INFO_RST_NACK_HDCP, 0);
	if (err < 0)
		return err;

	/* 5. Configure HDCP error protection */

	/* Reset SUS to force format detection */
	err = tda1997x_sus_en(dev, 0);
	if (err < 0)
		return err;

	err = tda1997x_sus_en(dev, SUS_ENABLE);
	if (err < 0)
		return err;

	err = write_reg_mask(dev, HPD_AUTO_CTRL, HPD_AUTO_OTHER, HPD_AUTO_OTHER);
	if (err < 0)
		return err;

	err = tda1997x_cfg_edid(dev, edid_block, edid_ext);
	if (err < 0)
		return err;

	err = tda1997x_cfg_spa(dev, &edid_block[128], 8, spa_edid);
	if (err < 0)
		return err;

	/* Load EDID configuration data */
	err = tda1997x_write(dev, EDID_IN_VERSION, 8, ddc_config);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, RT_AUTO_CTRL, 6, rt_config);
	if (err < 0)
		return err;

	err = write_reg_mask(dev, HPD_POWER, HPD_POWER_BYPASS_MASK, 0x04);
	if (err < 0)
		return err;

	err = write_reg(dev, INPUT_SEL, 0x00);
	if (err < 0)
		return err;

//	/* Configure HDCP without resetting SUS */
//	err = tda1997x_info_rst(dev, INFO_RST_NACK_HDCP, SUS_ENABLE);
//	if (err < 0)
//		return err;

	/* Enable HDCP Nack */

	/* Disable HDCP */

	/* Index the private key */

	/* Encrypted, enable HDCP */

	/* Enable HDCP acknowledge when HDCP is enabled */

	/* Configure HDCP error protection */
	mask = INPUT_SEL_VDPR_FMT_MASK | INPUT_SEL_HDMIOUT;
	err = write_reg_mask(dev, INPUT_SEL, mask, INPUT_SEL_FORMAT_RESET);
	if (err < 0)
		return err;

	/* Mute output */
	mask = OF_CTRL_OUTPUT_ACTIVE | OF_CTRL_VIDEO_HIZ;
	err = write_reg_mask(dev, OF_CTRL, mask, OF_CTRL_VIDEO_HIZ);
	if (err < 0)
		return err;

	/**
	 * @todo Configure video output with structure data
	 */
	err = tda1997x_cfg_vid_out(dev);
	if (err < 0)
		return err;

	/* Define video port */
	err = tda1997x_cfg_vp(dev, vp_conf444);
	if (err < 0)
		return err;

	/* Unmute output */
	err = write_reg_mask(dev, OF_CTRL, OF_CTRL_OUTPUT_ACTIVE | OF_CTRL_VIDEO_HIZ, OF_CTRL_OUTPUT_ACTIVE);
	if (err < 0)
		return err;

	/**
	 *  Configure audio
	 * @todo Pass audio configuration data to tda1997x_cfg_audio_fmt
	 */
	err = tda1997x_cfg_audio_fmt(dev);
	if (err < 0)
		return err;

	/* Reset infoframes */
	err = tda1997x_info_rst(dev, INFO_RST_AI);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_INFOFRAME);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_AUDIO);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_GAMUT);
	if (err < 0)
		return err;

	err = tda1997x_sus_en(dev, SUS_ENABLE);
	if (err < 0)
		return err;

	err = read_reg(dev, HDMI_FLAGS, &reg_val);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Startup Sequence Interrupt Handler
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_sus_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t i, status;

	if (flags & IRQ_SUS_STATE) {
		/* SUS state changed */
	}

	if (flags & IRQ_SUS_INPUT) {
		/* Selected input changed */
	}

	if (flags & IRQ_SUS_ACTIVITY) {
		/* Activity of selected input changed */
	}

	if (flags & IRQ_SUS_END) {

		/* Reset the audio FIFO */
		err = tda1997x_audio_fifo_rst(dev);
		if (err < 0)
			return err;

		err = read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			err = read_reg(dev, GAIN_OVR_EN, &status);
			if (err < 0)
				return err;

			/* Gain mode manual */
			if (status == 0x01U) {

				/* Set the gain mode to automatic */
				err = write_reg(dev, GAIN_OVR_EN, 0x00);
				if (err < 0)
					return err;

				/* Reset the startup sequence */
				err = tda1997x_sus_en(dev, 0);
				if (err < 0)
					return err;

				usleep(1000 * 5);

				err = tda1997x_sus_en(dev, SUS_ENABLE);
				if (err < 0)
					return err;
			} else {
				/* Gain mode is already set to automatic. Read gains */
				for (i = 0; i < 3; i++) {
					err = read_reg(dev, GAIN_CH0 + i, &status);
					if (err < 0)
						return err;
				}
			}
		}

		/* Detect the resolution */

		/* Set the resolution to detected input */

		/* Colorspace conversion */
		err =  tda1997x_cfg_conv(dev, (int16_t *) color_conv444);
		if (err < 0)
			return err;

		/* Set blanking codes */
		err = tda1997x_write(dev, BLK_GY_MSB, 6, (uint8_t *) blank_rgb);
		if (err < 0)
			return err;

		/* The state of the HDMI is now LOCKED */
	}

	if (flags & IRQ_SUS_RT_PULSE) {
	}

	if (flags & IRQ_SUS_MTP) {
	}

	if (flags & IRQ_SUS_FORMAT) {

		/* Ignore format interrupts during MTP process */
		if (!(flags & IRQ_SUS_MTP)) {

			err = read_reg(dev, SUS_STATUS, &status);
			if (err < 0)
				return err;

			if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE)
				flags &= ~(IRQ_SUS_FORMAT);

			/* Detect the resolution */

			/* Set the resolution to detected input */

			/* Colorspace conversion */
			err =  tda1997x_cfg_conv(dev, (int16_t *) color_conv444);
			if (err < 0)
				return err;

			/* Set blanking codes */
			err = tda1997x_write(dev, BLK_GY_MSB, 6, (uint8_t *) blank_rgb);
			if (err < 0)
			return err;

			/* The state of the HDMI is now LOCKED */
		}
	}

	return 0;
}


/**
 * @brief	Parse Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_infoframe_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t i;
	uint8_t reg_val;
	enum hdmi_reg reg = VS_IF_HDMI_UPDATE;
	union tda1997x_infoframe info;

	for (i = 0; i < NIRQ_SOURCE_FLAGS; i++) {
		/* Check if interrupt flag is set */
		if (flags & (1 << i)) {

			/* Check the update register */
			err = read_reg(dev, reg, &reg_val);
			if (err < 0)
				return err;

			/* Read the infoframe if updated (start from infoframe type register) */
//			if (reg_val) {
				err = tda1997x_read_infoframe(dev, reg + 1, &info);
				if (err < 0)
					return err;

//				err = tda1997x_parse_infoframe(dev, &info);
//				if (err < 0)
//					return err;
//			}
		}

		reg += 32;				/* Go to next infoframe update register */
	}

	return 0;
}


/**
 * @brief	Audio Interrupt Handler
 *
 * @param	dev:	TDA19997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_audio_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t status;
	enum tda1997x_audio_freq freq;

	if (flags & IRQ_AUDIO_FIFO_ERROR) {

		err = read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		/* Last state reached */
		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			/* Reset the audio FIFO */
//			err = tda1997x_audio_fifo_rst(dev);
//			if (err < 0)
//				return err;
		}
	}

	if (flags & IRQ_AUDIO_FIFO_UNMUTE) {
		/* Audio FIFO unmuted */
	}

	if ((flags & IRQ_AUDIO_CHAN_STATUS) &&
			!(flags & (IRQ_AUDIO_FIFO_ERROR | IRQ_AUDIO_MUTE))) {

		err = read_reg(dev, AUDIO_STATUS, &status);
		if (err < 0)
			return err;

		/* Read channel status */
		err = tda1997x_get_chan_status(dev);
		if (err < 0)
			return err;
	}

	if (flags & IRQ_AUDIO_MUTE) {

		err = read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		/* Last state reached */
		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			/* Reset the audio FIFO */
//			err = tda1997x_audio_fifo_rst(dev);
//			if (err < 0)
//				return err;
		}
	}

	if (flags & IRQ_AUDIO_FLAGS) {
		/* Get the audio flags */
		err = tda1997x_get_audio_flags(dev, &status);
		if (err < 0)
			return err;
	}

	if (flags & IRQ_AUDIO_FREQ_CHANGE) {

		/* Get the audio frequency */
		err = tda1997x_get_audio_freq(dev, &freq);
		if (err < 0)
			return err;

		if (freq != AUDIO_FREQ_HEADER) {
		}
	}

	return 0;
}


/**
 * @brief	AFE Interrupt Handler
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error otherwise
 */
int tda1997x_afe_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	return 0;
}


/**
 * @brief	Handle TDA1997x Interrupt
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return 0 on success, non-zero error status otherwise
 */
int tda1997x_handle_irq(struct tda1997x_dev *dev)
{
	int err;
	uint8_t irq_flags_top, reg_val;
	uint8_t status;

	do {
		/* Read top level flags */
		err = read_reg(dev, IRQ_FLG_CLR_TOP, &irq_flags_top);
		if (err < 0)
			return err;

		/* Start-up sequence source handling */
		if (irq_flags_top & IRQ_TOP_SUS) {
			/* Read the SUS interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_SUS, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_sus_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		if (irq_flags_top & IRQ_TOP_RATE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_RATE, &reg_val);
			if (err < 0)
				return err;

			if (reg_val & IRQ_RATE_RXDA) {
				/* Read interrupt status registers */
				err = read_reg(dev, CLK_A_STATUS, &status);
				if (err < 0)
					return err;

				err = read_reg(dev, CLK_B_STATUS, &status);
				if (err < 0)
					return err;

				err = read_reg(dev, SUS_STATUS, &status);
				if (err < 0)
					return err;
			}
		}

		if (irq_flags_top & IRQ_TOP_MODE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_MODE, &reg_val);
			if (err < 0)
				return err;

			if (reg_val & IRQ_MODE_FLAGS) {
				err = read_reg(dev, HDMI_FLAGS, &status);
				if (err < 0)
					return err;

//				if (status & (HDMI_FLAGS_AUD_FIFO_OVR | HDMI_FLAGS_AUD_FIFO_LOW)) {
//					err = tda1997x_audio_fifo_rst(dev);
//					if (err < 0)
//						return err;
//				}
			}
		}

		/* Infoframe interrupt source handling */
		if (irq_flags_top & IRQ_TOP_INFO) {
			/* Read the infoframe interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_INFO, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_infoframe_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		/* Audio interrupt source handling */
		if (irq_flags_top & IRQ_TOP_AUDIO) {
			/* Read the audio interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_AUDIO, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_audio_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		/* AFE interrupt source handling */
		if (irq_flags_top & IRQ_TOP_AFE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_AFE, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_afe_irq(dev, reg_val);
			if (err < 0)
				return err;
		}
	} while (irq_flags_top != 0);

	return 0;
}


/**
 * @brief
 */
int tda1997x_interrupt(struct tda1997x_dev *dev, struct tda1997x_irq_source *tab)
{
	int err;
	uint8_t i, j;
	uint8_t irq_top_flags = 0;
	uint8_t flags;
	struct tda1997x_irq_source *src = tab;			/* Point to start of table */
	struct tda1997x_irq_event *evt;

	/* Vector the interrupt from the top level */
	for (i = 0; i < NIRQ_TOP_FLAGS; i++, src++) {
		evt = src->events;					/* Point to start of event list */

		if (irq_top_flags & (1 << i)) {
			/* Clear the interrupt source in the FLG_CLR register */
			err = tda1997x_clear_irq(dev, src->clr_reg, &flags);
			if (err < 0)
				return err;

			for (j = 0; j < NIRQ_SOURCE_FLAGS; j++, evt++) {
				if ((flags & (1 << j)) && evt->en)
					if (evt->handler != NULL)
						evt->handler(dev, flags);
			}
		}
	}

	return 0;
}
/**
 * @}
 */

/*
 * END OF FILE [tda1997x.c]
 */
